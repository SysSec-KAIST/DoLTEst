/*
 * Copyright 2013-2019 Software Radio Systems Limited
 *
 * This file is part of srsLTE.
 *
 * srsLTE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsLTE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#ifndef SRSASN1_RRC_H
#define SRSASN1_RRC_H

#include "asn1_utils.h"
#include <cstdio>
#include <stdarg.h>

namespace asn1 {
namespace rrc {

/*******************************************************************************
/*                        Functions for external logging
/******************************************************************************/

static log_handler_t log_handler;
static void*         callback_ctx = NULL;

inline void rrc_log_register_handler(void* ctx, log_handler_t handler)
{
  log_handler  = handler;
  callback_ctx = ctx;
}

inline void rrc_log_print(srsasn_logger_level_t log_level, const char* format, ...)
{
  va_list args;
  va_start(args, format);
  vlog_print(log_handler, callback_ctx, log_level, format, args);
  va_end(args);
}

inline void log_invalid_access_choice_id(uint32_t val, uint32_t choice_id)
{
  rrc_log_print(LOG_LEVEL_ERROR, "The access choice id is invalid (%d!=%d)\n", val, choice_id);
}

inline void assert_choice_type(uint32_t val, uint32_t choice_id)
{
  if (val != choice_id) {
    log_invalid_access_choice_id(val, choice_id);
  }
}

inline void
assert_choice_type(const std::string& access_type, const std::string& current_type, const std::string& choice_type)
{
  if (access_type != current_type) {
    rrc_log_print(LOG_LEVEL_ERROR,
                  "Invalid field access for choice type \"%s\" (\"%s\"!=\"%s\")\n",
                  choice_type.c_str(),
                  access_type.c_str(),
                  current_type.c_str());
  }
}

inline const char* convert_enum_idx(const char* array[], uint32_t nof_types, uint32_t enum_val, const char* enum_type)
{
  if (enum_val >= nof_types) {
    if (enum_val == nof_types) {
      rrc_log_print(LOG_LEVEL_ERROR, "The enum of type %s was not initialized.\n", enum_type);
    } else {
      rrc_log_print(LOG_LEVEL_ERROR, "The enum value=%d of type %s is not valid.\n", enum_val, enum_type);
    }
    return "";
  }
  return array[enum_val];
}

template <class ItemType>
ItemType convert_enum_idx(ItemType* array, uint32_t nof_types, uint32_t enum_val, const char* enum_type)
{
  if (enum_val >= nof_types) {
    if (enum_val == nof_types) {
      rrc_log_print(LOG_LEVEL_ERROR, "The enum of type %s was not initialized.\n", enum_type);
    } else {
      rrc_log_print(
          LOG_LEVEL_ERROR, "The provided enum value=%d of type %s cannot be converted.\n", enum_val, enum_type);
    }
    return 0;
  }
  return array[enum_val];
}

/*******************************************************************************
/*                             Constant Definitions
/******************************************************************************/

#define ASN1_RRC_MAX_ACCESS_CAT_MINUS1_R15 63
#define ASN1_RRC_MAX_ACDC_CAT_R13 16
#define ASN1_RRC_MAX_AVAIL_NARROW_BANDS_R13 16
#define ASN1_RRC_MAX_BAND_COMB_R10 128
#define ASN1_RRC_MAX_BAND_COMB_R11 256
#define ASN1_RRC_MAX_BAND_COMB_R13 384
#define ASN1_RRC_MAX_BANDS 64
#define ASN1_RRC_MAX_BANDS_NR_R15 1024
#define ASN1_RRC_MAX_BW_CLASS_R10 16
#define ASN1_RRC_MAX_BW_COMB_SET_R10 32
#define ASN1_RRC_MAX_BARR_INFO_SET_R15 8
#define ASN1_RRC_MAX_BT_ID_REPORT_R15 32
#define ASN1_RRC_MAX_BT_NAME_R15 4
#define ASN1_RRC_MAX_CBR_LEVEL_R14 16
#define ASN1_RRC_MAX_CBR_LEVEL_MINUS1_R14 15
#define ASN1_RRC_MAX_CBR_REPORT_R14 72
#define ASN1_RRC_MAX_CDMA_BAND_CLASS 32
#define ASN1_RRC_MAX_CE_LEVEL_R13 4
#define ASN1_RRC_MAX_CELL_BLACK 16
#define ASN1_RRC_MAX_CELL_HISTORY_R12 16
#define ASN1_RRC_MAX_CELL_INFO_GERAN_R9 32
#define ASN1_RRC_MAX_CELL_INFO_UTRA_R9 16
#define ASN1_RRC_MAX_CELL_MEAS_IDLE_R15 8
#define ASN1_RRC_MAX_COMB_IDC_R11 128
#define ASN1_RRC_MAX_CSI_IM_R11 3
#define ASN1_RRC_MAX_CSI_IM_R12 4
#define ASN1_RRC_MIN_CSI_IM_R13 5
#define ASN1_RRC_MAX_CSI_IM_R13 24
#define ASN1_RRC_MAX_CSI_IM_V1310 20
#define ASN1_RRC_MAX_CSI_PROC_R11 4
#define ASN1_RRC_MAX_CSI_RS_NZP_R11 3
#define ASN1_RRC_MIN_CSI_RS_NZP_R13 4
#define ASN1_RRC_MAX_CSI_RS_NZP_R13 24
#define ASN1_RRC_MAX_CSI_RS_NZP_V1310 21
#define ASN1_RRC_MAX_CSI_RS_ZP_R11 4
#define ASN1_RRC_MAX_CQI_PROC_EXT_R11 3
#define ASN1_RRC_MAX_FREQ_UTRA_TDD_R10 6
#define ASN1_RRC_MAX_CELL_INTER 16
#define ASN1_RRC_MAX_CELL_INTRA 16
#define ASN1_RRC_MAX_CELL_LIST_GERAN 3
#define ASN1_RRC_MAX_CELL_MEAS 32
#define ASN1_RRC_MAX_CELL_REPORT 8
#define ASN1_RRC_MAX_CELL_SFTD 3
#define ASN1_RRC_MAX_CFG_SPS_R14 8
#define ASN1_RRC_MAX_CFG_SPS_R15 6
#define ASN1_RRC_MAX_CSI_RS_MEAS_R12 96
#define ASN1_RRC_MAX_DRB 11
#define ASN1_RRC_MAX_DRB_EXT_R15 4
#define ASN1_RRC_MAX_DRB_R15 15
#define ASN1_RRC_MAX_DS_DUR_R12 5
#define ASN1_RRC_MAX_DS_ZTP_CSI_RS_R12 5
#define ASN1_RRC_MAX_EARFCN 65535
#define ASN1_RRC_MAX_EARFCN_PLUS1 65536
#define ASN1_RRC_MAX_EARFCN2 262143
#define ASN1_RRC_MAX_EPDCCH_SET_R11 2
#define ASN1_RRC_MAX_FBI 64
#define ASN1_RRC_MAX_FBI_NR_R15 1024
#define ASN1_RRC_MAX_FBI_PLUS1 65
#define ASN1_RRC_MAX_FBI2 256
#define ASN1_RRC_MAX_FEATURE_SETS_R15 256
#define ASN1_RRC_MAX_PER_CC_FEATURE_SETS_R15 32
#define ASN1_RRC_MAX_FREQ 8
#define ASN1_RRC_MAX_FREQ_IDC_R11 32
#define ASN1_RRC_MAX_FREQ_IDLE_R15 8
#define ASN1_RRC_MAX_FREQ_MBMS_R11 5
#define ASN1_RRC_MAX_FREQ_NR_R15 5
#define ASN1_RRC_MAX_FREQ_V2X_R14 8
#define ASN1_RRC_MAX_FREQ_V2X_MINUS1_R14 7
#define ASN1_RRC_MAX_GERAN_SI 10
#define ASN1_RRC_MAX_GNFG 16
#define ASN1_RRC_MAX_IDLE_MEAS_CARRIERS_R15 3
#define ASN1_RRC_MAX_LCG_R13 4
#define ASN1_RRC_MAX_LOG_MEAS_REPORT_R10 520
#define ASN1_RRC_MAX_MBSFN_ALLOCS 8
#define ASN1_RRC_MAX_MBSFN_AREA 8
#define ASN1_RRC_MAX_MBSFN_AREA_MINUS1 7
#define ASN1_RRC_MAX_MBMS_SERVICE_LIST_PER_UE_R13 15
#define ASN1_RRC_MAX_MEAS_ID 32
#define ASN1_RRC_MAX_MEAS_ID_PLUS1 33
#define ASN1_RRC_MAX_MEAS_ID_R12 64
#define ASN1_RRC_MAX_MULTI_BANDS 8
#define ASN1_RRC_MAX_MULTI_BANDS_NR_R15 32
#define ASN1_RRC_MAX_NS_PMAX_R10 8
#define ASN1_RRC_MAX_NAICS_ENTRIES_R12 8
#define ASN1_RRC_MAX_NEIGH_CELL_R12 8
#define ASN1_RRC_MAX_NEIGH_CELL_SCPTM_R13 8
#define ASN1_RRC_MAX_NROF_S_NSSAI_R15 8
#define ASN1_RRC_MAX_OBJ_ID 32
#define ASN1_RRC_MAX_OBJ_ID_PLUS1_R13 33
#define ASN1_RRC_MAX_OBJ_ID_R13 64
#define ASN1_RRC_MAX_P_A_PER_NEIGH_CELL_R12 3
#define ASN1_RRC_MAX_PAGE_REC 16
#define ASN1_RRC_MAX_PCI_RANGE_R9 4
#define ASN1_RRC_MAX_PLMN_R11 6
#define ASN1_RRC_MAX_PLMN_MINUS1_R14 5
#define ASN1_RRC_MAX_PLMN_R15 8
#define ASN1_RRC_MAX_PLMN_NR_R15 12
#define ASN1_RRC_MAX_PN_OFFSET 511
#define ASN1_RRC_MAX_PMCH_PER_MBSFN 15
#define ASN1_RRC_MAX_PSSCH_TX_CFG_R14 16
#define ASN1_RRC_MAX_QUANT_SETS_NR_R15 2
#define ASN1_RRC_MAX_QCI_R13 6
#define ASN1_RRC_MAX_RAT_CAPABILITIES 8
#define ASN1_RRC_MAX_RE_MAP_QCL_R11 4
#define ASN1_RRC_MAX_REPORT_CFG_ID 32
#define ASN1_RRC_MAX_RESERV_PERIOD_R14 16
#define ASN1_RRC_MAX_RS_IDX_R15 64
#define ASN1_RRC_MAX_RS_IDX_MINUS1_R15 63
#define ASN1_RRC_MAX_RS_IDX_CELL_QUAL_R15 16
#define ASN1_RRC_MAX_RS_IDX_REPORT_R15 32
#define ASN1_RRC_MAX_RSTD_FREQ_R10 3
#define ASN1_RRC_MAX_SAI_MBMS_R11 64
#define ASN1_RRC_MAX_SCELL_R10 4
#define ASN1_RRC_MAX_SCELL_R13 31
#define ASN1_RRC_MAX_SCELL_GROUPS_R15 4
#define ASN1_RRC_MAX_SC_MTCH_R13 1023
#define ASN1_RRC_MAX_SC_MTCH_BR_R14 128
#define ASN1_RRC_MAX_SL_COMM_RX_POOL_NFREQ_R13 32
#define ASN1_RRC_MAX_SL_COMM_RX_POOL_PRECONF_V1310 12
#define ASN1_RRC_MAX_SL_TX_POOL_R12_PLUS1_R13 5
#define ASN1_RRC_MAX_SL_TX_POOL_V1310 4
#define ASN1_RRC_MAX_SL_TX_POOL_R13 8
#define ASN1_RRC_MAX_SL_COMM_TX_POOL_PRECONF_V1310 7
#define ASN1_RRC_MAX_SL_DEST_R12 16
#define ASN1_RRC_MAX_SL_DISC_CELLS_R13 16
#define ASN1_RRC_MAX_SL_DISC_PWR_CLASS_R12 3
#define ASN1_RRC_MAX_SL_DISC_RX_POOL_PRECONF_R13 16
#define ASN1_RRC_MAX_SL_DISC_SYS_INFO_REPORT_FREQ_R13 8
#define ASN1_RRC_MAX_SL_DISC_TX_POOL_PRECONF_R13 4
#define ASN1_RRC_MAX_SL_GP_R13 8
#define ASN1_RRC_MAX_SL_POOL_TO_MEASURE_R14 72
#define ASN1_RRC_MAX_SL_PRIO_R13 8
#define ASN1_RRC_MAX_SL_RX_POOL_R12 16
#define ASN1_RRC_MAX_SL_RELIABILITY_R15 8
#define ASN1_RRC_MAX_SL_SYNC_CFG_R12 16
#define ASN1_RRC_MAX_SL_TF_IDX_PAIR_R12 64
#define ASN1_RRC_MAX_SL_TX_POOL_R12 4
#define ASN1_RRC_MAX_SL_V2X_RX_POOL_R14 16
#define ASN1_RRC_MAX_SL_V2X_RX_POOL_PRECONF_R14 16
#define ASN1_RRC_MAX_SL_V2X_TX_POOL_R14 8
#define ASN1_RRC_MAX_SL_V2X_TX_POOL_PRECONF_R14 8
#define ASN1_RRC_MAX_SL_V2X_SYNC_CFG_R14 16
#define ASN1_RRC_MAX_SL_V2X_CBR_CFG_R14 4
#define ASN1_RRC_MAX_SL_V2X_CBR_CFG_MINUS1_R14 3
#define ASN1_RRC_MAX_SL_V2X_TX_CFG_R14 64
#define ASN1_RRC_MAX_SL_V2X_TX_CFG_MINUS1_R14 63
#define ASN1_RRC_MAX_SL_V2X_CBR_CFG2_R14 8
#define ASN1_RRC_MAX_SL_V2X_CBR_CFG2_MINUS1_R14 7
#define ASN1_RRC_MAX_SL_V2X_TX_CFG2_R14 128
#define ASN1_RRC_MAX_SL_V2X_TX_CFG2_MINUS1_R14 127
#define ASN1_RRC_MAX_STAG_R11 3
#define ASN1_RRC_MAX_SERV_CELL_R10 5
#define ASN1_RRC_MAX_SERV_CELL_R13 32
#define ASN1_RRC_MAX_SERV_CELL_NR_R15 16
#define ASN1_RRC_MAX_SERVICE_COUNT 16
#define ASN1_RRC_MAX_SERVICE_COUNT_MINUS1 15
#define ASN1_RRC_MAX_SESSION_PER_PMCH 29
#define ASN1_RRC_MAX_SESSION_PER_PMCH_MINUS1 28
#define ASN1_RRC_MAX_SIB 32
#define ASN1_RRC_MAX_SIB_MINUS1 31
#define ASN1_RRC_MAX_SI_MSG 32
#define ASN1_RRC_MAX_SIMUL_BANDS_R10 64
#define ASN1_RRC_MAX_SF_PATTERN_IDC_R11 8
#define ASN1_RRC_MAX_TRAFFIC_PATTERN_R14 8
#define ASN1_RRC_MAX_UTRA_FDD_CARRIER 16
#define ASN1_RRC_MAX_UTRA_TDD_CARRIER 16
#define ASN1_RRC_MAX_WAY_POINT_R15 20
#define ASN1_RRC_MAX_WLAN_ID_R12 16
#define ASN1_RRC_MAX_WLAN_BANDS_R13 8
#define ASN1_RRC_MAX_WLAN_ID_R13 32
#define ASN1_RRC_MAX_WLAN_CHS_R13 16
#define ASN1_RRC_MAX_WLAN_CARRIER_INFO_R13 8
#define ASN1_RRC_MAX_WLAN_ID_REPORT_R14 32
#define ASN1_RRC_MAX_WLAN_NAME_R15 4
#define ASN1_RRC_MAX_LOG_MEAS_R10 4060
#define ASN1_RRC_MAX_REESTAB_INFO 32
#define ASN1_RRC_MAX_NPRACH_RES_NB_R13 3
#define ASN1_RRC_MAX_NON_ANCHOR_CARRIERS_NB_R14 15
#define ASN1_RRC_MAX_DRB_NB_R13 2
#define ASN1_RRC_MAX_NEIGH_CELL_SCPTM_NB_R14 8
#define ASN1_RRC_MAX_NS_PMAX_NB_R13 4
#define ASN1_RRC_MAX_SC_MTCH_NB_R14 64
#define ASN1_RRC_MAX_SI_MSG_NB_R13 8

/*******************************************************************************
/*                              Struct Definitions
/******************************************************************************/

// PHICH-Config ::= SEQUENCE
struct phich_cfg_s {
  struct phich_dur_opts {
    enum options { normal, extended, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<phich_dur_opts> phich_dur_e_;
  struct phich_res_opts {
    enum options { one_sixth, half, one, two, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<phich_res_opts> phich_res_e_;

  // member variables
  phich_dur_e_ phich_dur;
  phich_res_e_ phich_res;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MasterInformationBlock ::= SEQUENCE
struct mib_s {
  struct dl_bw_opts {
    enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<dl_bw_opts> dl_bw_e_;

  // member variables
  dl_bw_e_           dl_bw;
  phich_cfg_s        phich_cfg;
  fixed_bitstring<8> sys_frame_num;
  uint8_t            sched_info_sib1_br_r13    = 0;
  bool               sys_info_unchanged_br_r15 = false;
  fixed_bitstring<4> spare;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BCCH-BCH-MessageType ::= MasterInformationBlock
typedef mib_s bcch_bch_msg_type_s;

// BCCH-BCH-Message ::= SEQUENCE
struct bcch_bch_msg_s {
  // member variables
  bcch_bch_msg_type_s msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MasterInformationBlock-MBMS-r14 ::= SEQUENCE
struct mib_mbms_r14_s {
  struct dl_bw_mbms_r14_opts {
    enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<dl_bw_mbms_r14_opts> dl_bw_mbms_r14_e_;

  // member variables
  dl_bw_mbms_r14_e_   dl_bw_mbms_r14;
  fixed_bitstring<6>  sys_frame_num_r14;
  uint8_t             add_non_mbsfn_sfs_r14 = 0;
  fixed_bitstring<13> spare;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BCCH-BCH-MessageType-MBMS-r14 ::= MasterInformationBlock-MBMS-r14
typedef mib_mbms_r14_s bcch_bch_msg_type_mbms_r14_s;

// BCCH-BCH-Message-MBMS ::= SEQUENCE
struct bcch_bch_msg_mbms_s {
  // member variables
  bcch_bch_msg_type_mbms_r14_s msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNSS-ID-r15 ::= SEQUENCE
struct gnss_id_r15_s {
  struct gnss_id_r15_opts {
    enum options { gps, sbas, qzss, galileo, glonass, bds, /*...*/ nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<gnss_id_r15_opts, true> gnss_id_r15_e_;

  // member variables
  bool           ext = false;
  gnss_id_r15_e_ gnss_id_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MCC ::= SEQUENCE (SIZE (3)) OF INTEGER
typedef fixed_array<uint8_t, 3> mcc_l;

// MNC ::= SEQUENCE (SIZE (2..3)) OF INTEGER
typedef bounded_array<uint8_t, 3> mnc_l;

// SBAS-ID-r15 ::= SEQUENCE
struct sbas_id_r15_s {
  struct sbas_id_r15_opts {
    enum options { waas, egnos, msas, gagan, /*...*/ nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<sbas_id_r15_opts, true> sbas_id_r15_e_;

  // member variables
  bool           ext = false;
  sbas_id_r15_e_ sbas_id_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-Identity ::= SEQUENCE
struct plmn_id_s {
  // member variables
  bool  mcc_present = false;
  mcc_l mcc;
  mnc_l mnc;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosSIB-Type-r15 ::= SEQUENCE
struct pos_sib_type_r15_s {
  struct pos_sib_type_r15_opts {
    enum options {
      pos_sib_type1_minus1,
      pos_sib_type1_minus2,
      pos_sib_type1_minus3,
      pos_sib_type1_minus4,
      pos_sib_type1_minus5,
      pos_sib_type1_minus6,
      pos_sib_type1_minus7,
      pos_sib_type2_minus1,
      pos_sib_type2_minus2,
      pos_sib_type2_minus3,
      pos_sib_type2_minus4,
      pos_sib_type2_minus5,
      pos_sib_type2_minus6,
      pos_sib_type2_minus7,
      pos_sib_type2_minus8,
      pos_sib_type2_minus9,
      pos_sib_type2_minus10,
      pos_sib_type2_minus11,
      pos_sib_type2_minus12,
      pos_sib_type2_minus13,
      pos_sib_type2_minus14,
      pos_sib_type2_minus15,
      pos_sib_type2_minus16,
      pos_sib_type2_minus17,
      pos_sib_type2_minus18,
      pos_sib_type2_minus19,
      pos_sib_type3_minus1,
      // ...
      nulltype
    } value;

    std::string to_string() const;
  };
  typedef enumerated<pos_sib_type_r15_opts, true> pos_sib_type_r15_e_;

  // member variables
  bool                ext                   = false;
  bool                encrypted_r15_present = false;
  bool                gnss_id_r15_present   = false;
  bool                sbas_id_r15_present   = false;
  gnss_id_r15_s       gnss_id_r15;
  sbas_id_r15_s       sbas_id_r15;
  pos_sib_type_r15_e_ pos_sib_type_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityInfo-r15 ::= SEQUENCE
struct plmn_id_info_r15_s {
  struct plmn_id_minus5_gc_r15_c_ {
    struct types_opts {
      enum options { plmn_id_r15, plmn_idx_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    plmn_id_minus5_gc_r15_c_() = default;
    plmn_id_minus5_gc_r15_c_(const plmn_id_minus5_gc_r15_c_& other);
    plmn_id_minus5_gc_r15_c_& operator=(const plmn_id_minus5_gc_r15_c_& other);
    ~plmn_id_minus5_gc_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    plmn_id_s& plmn_id_r15()
    {
      assert_choice_type("plmn-Identity-r15", type_.to_string(), "plmn-Identity-5GC-r15");
      return c.get<plmn_id_s>();
    }
    uint8_t& plmn_idx_r15()
    {
      assert_choice_type("plmn-Index-r15", type_.to_string(), "plmn-Identity-5GC-r15");
      return c.get<uint8_t>();
    }
    const plmn_id_s& plmn_id_r15() const
    {
      assert_choice_type("plmn-Identity-r15", type_.to_string(), "plmn-Identity-5GC-r15");
      return c.get<plmn_id_s>();
    }
    const uint8_t& plmn_idx_r15() const
    {
      assert_choice_type("plmn-Index-r15", type_.to_string(), "plmn-Identity-5GC-r15");
      return c.get<uint8_t>();
    }
    plmn_id_s& set_plmn_id_r15()
    {
      set(types::plmn_id_r15);
      return c.get<plmn_id_s>();
    }
    uint8_t& set_plmn_idx_r15()
    {
      set(types::plmn_idx_r15);
      return c.get<uint8_t>();
    }

  private:
    types                              type_;
    choice_buffer_t<sizeof(plmn_id_s)> c;

    void destroy_();
  };
  struct cell_reserved_for_oper_r15_opts {
    enum options { reserved, not_reserved, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<cell_reserved_for_oper_r15_opts> cell_reserved_for_oper_r15_e_;
  struct cell_reserved_for_oper_crs_r15_opts {
    enum options { reserved, not_reserved, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<cell_reserved_for_oper_crs_r15_opts> cell_reserved_for_oper_crs_r15_e_;

  // member variables
  plmn_id_minus5_gc_r15_c_          plmn_id_minus5_gc_r15;
  cell_reserved_for_oper_r15_e_     cell_reserved_for_oper_r15;
  cell_reserved_for_oper_crs_r15_e_ cell_reserved_for_oper_crs_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosSIB-MappingInfo-r15 ::= SEQUENCE (SIZE (1..maxSIB)) OF PosSIB-Type-r15
typedef dyn_array<pos_sib_type_r15_s> pos_sib_map_info_r15_l;

// CellIdentity-5GC-r15 ::= CHOICE
struct cell_id_minus5_gc_r15_c {
  struct types_opts {
    enum options { cell_id_r15, cell_id_idx_r15, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  cell_id_minus5_gc_r15_c() = default;
  cell_id_minus5_gc_r15_c(const cell_id_minus5_gc_r15_c& other);
  cell_id_minus5_gc_r15_c& operator=(const cell_id_minus5_gc_r15_c& other);
  ~cell_id_minus5_gc_r15_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<28>& cell_id_r15()
  {
    assert_choice_type("cellIdentity-r15", type_.to_string(), "CellIdentity-5GC-r15");
    return c.get<fixed_bitstring<28> >();
  }
  uint8_t& cell_id_idx_r15()
  {
    assert_choice_type("cellId-Index-r15", type_.to_string(), "CellIdentity-5GC-r15");
    return c.get<uint8_t>();
  }
  const fixed_bitstring<28>& cell_id_r15() const
  {
    assert_choice_type("cellIdentity-r15", type_.to_string(), "CellIdentity-5GC-r15");
    return c.get<fixed_bitstring<28> >();
  }
  const uint8_t& cell_id_idx_r15() const
  {
    assert_choice_type("cellId-Index-r15", type_.to_string(), "CellIdentity-5GC-r15");
    return c.get<uint8_t>();
  }
  fixed_bitstring<28>& set_cell_id_r15()
  {
    set(types::cell_id_r15);
    return c.get<fixed_bitstring<28> >();
  }
  uint8_t& set_cell_id_idx_r15()
  {
    set(types::cell_id_idx_r15);
    return c.get<uint8_t>();
  }

private:
  types                                        type_;
  choice_buffer_t<sizeof(fixed_bitstring<28>)> c;

  void destroy_();
};

// PLMN-IdentityInfo-v1530 ::= SEQUENCE
struct plmn_id_info_v1530_s {
  struct cell_reserved_for_oper_crs_r15_opts {
    enum options { reserved, not_reserved, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<cell_reserved_for_oper_crs_r15_opts> cell_reserved_for_oper_crs_r15_e_;

  // member variables
  cell_reserved_for_oper_crs_r15_e_ cell_reserved_for_oper_crs_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityList-r15 ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF PLMN-IdentityInfo-r15
typedef dyn_array<plmn_id_info_r15_s> plmn_id_list_r15_l;

// PosSchedulingInfo-r15 ::= SEQUENCE
struct pos_sched_info_r15_s {
  struct pos_si_periodicity_r15_opts {
    enum options { rf8, rf16, rf32, rf64, rf128, rf256, rf512, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<pos_si_periodicity_r15_opts> pos_si_periodicity_r15_e_;

  // member variables
  pos_si_periodicity_r15_e_ pos_si_periodicity_r15;
  pos_sib_map_info_r15_l    pos_sib_map_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellAccessRelatedInfo-5GC-r15 ::= SEQUENCE
struct cell_access_related_info_minus5_gc_r15_s {
  // member variables
  bool                    ran_area_code_r15_present = false;
  plmn_id_list_r15_l      plmn_id_list_r15;
  uint8_t                 ran_area_code_r15 = 0;
  fixed_bitstring<24>     tac_minus5_gc_r15;
  cell_id_minus5_gc_r15_c cell_id_minus5_gc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellSelectionInfoCE-v1530 ::= SEQUENCE
struct cell_sel_info_ce_v1530_s {
  struct pwr_class14dbm_offset_r15_opts {
    enum options { db_minus6, db_minus3, db3, db6, db9, db12, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<pwr_class14dbm_offset_r15_opts> pwr_class14dbm_offset_r15_e_;

  // member variables
  pwr_class14dbm_offset_r15_e_ pwr_class14dbm_offset_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MCS-PSSCH-Range-r15 ::= SEQUENCE
struct mcs_pssch_range_r15_s {
  // member variables
  uint8_t min_mcs_pssch_r15 = 0;
  uint8_t max_mcs_pssch_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityInfo ::= SEQUENCE
struct plmn_id_info_s {
  struct cell_reserved_for_oper_opts {
    enum options { reserved, not_reserved, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<cell_reserved_for_oper_opts> cell_reserved_for_oper_e_;

  // member variables
  plmn_id_s                 plmn_id;
  cell_reserved_for_oper_e_ cell_reserved_for_oper;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityList-v1530 ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF PLMN-IdentityInfo-v1530
typedef dyn_array<plmn_id_info_v1530_s> plmn_id_list_v1530_l;

// PosSchedulingInfoList-r15 ::= SEQUENCE (SIZE (1..maxSI-Message)) OF PosSchedulingInfo-r15
typedef dyn_array<pos_sched_info_r15_s> pos_sched_info_list_r15_l;

// SL-PriorityList-r13 ::= SEQUENCE (SIZE (1..maxSL-Prio-r13)) OF INTEGER
typedef bounded_array<uint8_t, 8> sl_prio_list_r13_l;

// SL-TxPower-r14 ::= CHOICE
struct sl_tx_pwr_r14_c {
  struct types_opts {
    enum options { minusinfinity_r14, tx_pwr_r14, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sl_tx_pwr_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  int8_t& tx_pwr_r14()
  {
    assert_choice_type("txPower-r14", type_.to_string(), "SL-TxPower-r14");
    return c;
  }
  const int8_t& tx_pwr_r14() const
  {
    assert_choice_type("txPower-r14", type_.to_string(), "SL-TxPower-r14");
    return c;
  }
  int8_t& set_tx_pwr_r14()
  {
    set(types::tx_pwr_r14);
    return c;
  }

private:
  types  type_;
  int8_t c;
};

// Alpha-r12 ::= ENUMERATED
struct alpha_r12_opts {
  enum options { al0, al04, al05, al06, al07, al08, al09, al1, nulltype } value;
  typedef float number_type;

  std::string to_string() const;
  float       to_number() const;
  std::string to_number_string() const;
};
typedef enumerated<alpha_r12_opts> alpha_r12_e;

// PLMN-IdentityList ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF PLMN-IdentityInfo
typedef dyn_array<plmn_id_info_s> plmn_id_list_l;

// SL-MinT2Value-r15 ::= SEQUENCE
struct sl_min_t2_value_r15_s {
  // member variables
  sl_prio_list_r13_l prio_list_r15;
  uint8_t            min_t2_value_r15 = 10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PPPP-TxConfigIndex-r14 ::= SEQUENCE
struct sl_pppp_tx_cfg_idx_r14_s {
  typedef bounded_array<uint8_t, 16> tx_cfg_idx_list_r14_l_;

  // member variables
  uint8_t                prio_thres_r14         = 1;
  uint8_t                default_tx_cfg_idx_r14 = 0;
  uint8_t                cbr_cfg_idx_r14        = 0;
  tx_cfg_idx_list_r14_l_ tx_cfg_idx_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PPPP-TxConfigIndex-v1530 ::= SEQUENCE
struct sl_pppp_tx_cfg_idx_v1530_s {
  typedef dyn_array<mcs_pssch_range_r15_s> mcs_pssch_range_list_r15_l_;

  // member variables
  bool                        mcs_pssch_range_list_r15_present = false;
  mcs_pssch_range_list_r15_l_ mcs_pssch_range_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PSSCH-TxParameters-r14 ::= SEQUENCE
struct sl_pssch_tx_params_r14_s {
  struct allowed_retx_num_pssch_r14_opts {
    enum options { n0, n1, both, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<allowed_retx_num_pssch_r14_opts> allowed_retx_num_pssch_r14_e_;

  // member variables
  bool                          max_tx_pwr_r14_present   = false;
  uint8_t                       min_mcs_pssch_r14        = 0;
  uint8_t                       max_mcs_pssch_r14        = 0;
  uint8_t                       min_sub_ch_num_pssch_r14 = 1;
  uint8_t                       max_subch_num_pssch_r14  = 1;
  allowed_retx_num_pssch_r14_e_ allowed_retx_num_pssch_r14;
  sl_tx_pwr_r14_c               max_tx_pwr_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PSSCH-TxParameters-v1530 ::= SEQUENCE
struct sl_pssch_tx_params_v1530_s {
  // member variables
  uint8_t min_mcs_pssch_r15 = 0;
  uint8_t max_mcs_pssch_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-RestrictResourceReservationPeriod-r14 ::= ENUMERATED
struct sl_restrict_res_reserv_period_r14_opts {
  enum options {
    v0dot2,
    v0dot5,
    v1,
    v2,
    v3,
    v4,
    v5,
    v6,
    v7,
    v8,
    v9,
    v10,
    spare4,
    spare3,
    spare2,
    spare1,
    nulltype
  } value;
  typedef float number_type;

  std::string to_string() const;
  float       to_number() const;
  std::string to_number_string() const;
};
typedef enumerated<sl_restrict_res_reserv_period_r14_opts> sl_restrict_res_reserv_period_r14_e;

// SL-TypeTxSync-r14 ::= ENUMERATED
struct sl_type_tx_sync_r14_opts {
  enum options { gnss, enb, ue, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<sl_type_tx_sync_r14_opts> sl_type_tx_sync_r14_e;

// SystemInformationBlockType1-v1530-IEs ::= SEQUENCE
struct sib_type1_v1530_ies_s {
  struct crs_intf_mitig_cfg_r15_c_ {
    struct crs_intf_mitig_num_prbs_r15_opts {
      enum options { n6, n24, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<crs_intf_mitig_num_prbs_r15_opts> crs_intf_mitig_num_prbs_r15_e_;
    struct types_opts {
      enum options { crs_intf_mitig_enabled_minus15, crs_intf_mitig_num_prbs_r15, nulltype } value;
      typedef int8_t number_type;

      std::string to_string() const;
      int8_t      to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crs_intf_mitig_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    crs_intf_mitig_num_prbs_r15_e_& crs_intf_mitig_num_prbs_r15()
    {
      assert_choice_type("crs-IntfMitigNumPRBs-r15", type_.to_string(), "crs-IntfMitigConfig-r15");
      return c;
    }
    const crs_intf_mitig_num_prbs_r15_e_& crs_intf_mitig_num_prbs_r15() const
    {
      assert_choice_type("crs-IntfMitigNumPRBs-r15", type_.to_string(), "crs-IntfMitigConfig-r15");
      return c;
    }
    crs_intf_mitig_num_prbs_r15_e_& set_crs_intf_mitig_num_prbs_r15()
    {
      set(types::crs_intf_mitig_num_prbs_r15);
      return c;
    }

  private:
    types                          type_;
    crs_intf_mitig_num_prbs_r15_e_ c;
  };
  struct cell_barred_crs_r15_opts {
    enum options { barred, not_barred, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<cell_barred_crs_r15_opts> cell_barred_crs_r15_e_;
  struct cell_access_related_info_minus5_gc_r15_s_ {
    struct cell_barred_minus5_gc_r15_opts {
      enum options { barred, not_barred, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<cell_barred_minus5_gc_r15_opts> cell_barred_minus5_gc_r15_e_;
    struct cell_barred_minus5_gc_crs_r15_opts {
      enum options { barred, not_barred, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<cell_barred_minus5_gc_crs_r15_opts>      cell_barred_minus5_gc_crs_r15_e_;
    typedef dyn_array<cell_access_related_info_minus5_gc_r15_s> cell_access_related_info_list_minus5_gc_r15_l_;

    // member variables
    cell_barred_minus5_gc_r15_e_                   cell_barred_minus5_gc_r15;
    cell_barred_minus5_gc_crs_r15_e_               cell_barred_minus5_gc_crs_r15;
    cell_access_related_info_list_minus5_gc_r15_l_ cell_access_related_info_list_minus5_gc_r15;
  };

  // member variables
  bool                                      hsdn_cell_r15_present                          = false;
  bool                                      cell_sel_info_ce_v1530_present                 = false;
  bool                                      crs_intf_mitig_cfg_r15_present                 = false;
  bool                                      plmn_id_list_v1530_present                     = false;
  bool                                      pos_sched_info_list_r15_present                = false;
  bool                                      cell_access_related_info_minus5_gc_r15_present = false;
  bool                                      ims_emergency_support5_gc_r15_present          = false;
  bool                                      e_call_over_ims_support5_gc_r15_present        = false;
  bool                                      non_crit_ext_present                           = false;
  cell_sel_info_ce_v1530_s                  cell_sel_info_ce_v1530;
  crs_intf_mitig_cfg_r15_c_                 crs_intf_mitig_cfg_r15;
  cell_barred_crs_r15_e_                    cell_barred_crs_r15;
  plmn_id_list_v1530_l                      plmn_id_list_v1530;
  pos_sched_info_list_r15_l                 pos_sched_info_list_r15;
  cell_access_related_info_minus5_gc_r15_s_ cell_access_related_info_minus5_gc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TDD-Config-v1450 ::= SEQUENCE
struct tdd_cfg_v1450_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellAccessRelatedInfo-r14 ::= SEQUENCE
struct cell_access_related_info_r14_s {
  // member variables
  plmn_id_list_l      plmn_id_list_r14;
  fixed_bitstring<16> tac_r14;
  fixed_bitstring<28> cell_id_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellSelectionInfoCE1-v1360 ::= SEQUENCE
struct cell_sel_info_ce1_v1360_s {
  // member variables
  int8_t delta_rx_lev_min_ce1_v1360 = -8;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NS-PmaxValue-v10l0 ::= SEQUENCE
struct ns_pmax_value_v10l0_s {
  // member variables
  bool     add_spec_emission_v10l0_present = false;
  uint16_t add_spec_emission_v10l0         = 33;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CBR-PPPP-TxConfigList-r14 ::= SEQUENCE (SIZE (1..8)) OF SL-PPPP-TxConfigIndex-r14
typedef dyn_array<sl_pppp_tx_cfg_idx_r14_s> sl_cbr_pppp_tx_cfg_list_r14_l;

// SL-CBR-PPPP-TxConfigList-v1530 ::= SEQUENCE (SIZE (1..8)) OF SL-PPPP-TxConfigIndex-v1530
typedef dyn_array<sl_pppp_tx_cfg_idx_v1530_s> sl_cbr_pppp_tx_cfg_list_v1530_l;

// SL-CP-Len-r12 ::= ENUMERATED
struct sl_cp_len_r12_opts {
  enum options { normal, extended, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<sl_cp_len_r12_opts> sl_cp_len_r12_e;

// SL-MinT2ValueList-r15 ::= SEQUENCE (SIZE (1..maxSL-Prio-r13)) OF SL-MinT2Value-r15
typedef dyn_array<sl_min_t2_value_r15_s> sl_min_t2_value_list_r15_l;

// SL-OffsetIndicator-r12 ::= CHOICE
struct sl_offset_ind_r12_c {
  struct types_opts {
    enum options { small_r12, large_r12, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sl_offset_ind_r12_c() = default;
  sl_offset_ind_r12_c(const sl_offset_ind_r12_c& other);
  sl_offset_ind_r12_c& operator=(const sl_offset_ind_r12_c& other);
  ~sl_offset_ind_r12_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& small_r12()
  {
    assert_choice_type("small-r12", type_.to_string(), "SL-OffsetIndicator-r12");
    return c.get<uint16_t>();
  }
  uint16_t& large_r12()
  {
    assert_choice_type("large-r12", type_.to_string(), "SL-OffsetIndicator-r12");
    return c.get<uint16_t>();
  }
  const uint16_t& small_r12() const
  {
    assert_choice_type("small-r12", type_.to_string(), "SL-OffsetIndicator-r12");
    return c.get<uint16_t>();
  }
  const uint16_t& large_r12() const
  {
    assert_choice_type("large-r12", type_.to_string(), "SL-OffsetIndicator-r12");
    return c.get<uint16_t>();
  }
  uint16_t& set_small_r12()
  {
    set(types::small_r12);
    return c.get<uint16_t>();
  }
  uint16_t& set_large_r12()
  {
    set(types::large_r12);
    return c.get<uint16_t>();
  }

private:
  types              type_;
  choice_buffer_t<8> c;

  void destroy_();
};

// SL-P2X-ResourceSelectionConfig-r14 ::= SEQUENCE
struct sl_p2_x_res_sel_cfg_r14_s {
  // member variables
  bool partial_sensing_r14_present = false;
  bool random_sel_r14_present      = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PSSCH-TxConfig-r14 ::= SEQUENCE
struct sl_pssch_tx_cfg_r14_s {
  struct thres_ue_speed_r14_opts {
    enum options { kmph60, kmph80, kmph100, kmph120, kmph140, kmph160, kmph180, kmph200, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<thres_ue_speed_r14_opts> thres_ue_speed_r14_e_;

  // member variables
  bool                     ext                      = false;
  bool                     type_tx_sync_r14_present = false;
  sl_type_tx_sync_r14_e    type_tx_sync_r14;
  thres_ue_speed_r14_e_    thres_ue_speed_r14;
  sl_pssch_tx_params_r14_s params_above_thres_r14;
  sl_pssch_tx_params_r14_s params_below_thres_r14;
  // ...
  // group 0
  bool                                 params_above_thres_v1530_present = false;
  bool                                 params_below_thres_v1530_present = false;
  copy_ptr<sl_pssch_tx_params_v1530_s> params_above_thres_v1530;
  copy_ptr<sl_pssch_tx_params_v1530_s> params_below_thres_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-RestrictResourceReservationPeriodList-r14 ::= SEQUENCE (SIZE (1..maxReservationPeriod-r14)) OF
// SL-RestrictResourceReservationPeriod-r14
typedef bounded_array<sl_restrict_res_reserv_period_r14_e, 16> sl_restrict_res_reserv_period_list_r14_l;

// SL-SyncAllowed-r14 ::= SEQUENCE
struct sl_sync_allowed_r14_s {
  // member variables
  bool gnss_sync_r14_present = false;
  bool enb_sync_r14_present  = false;
  bool ue_sync_r14_present   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-TxParameters-r12 ::= SEQUENCE
struct sl_tx_params_r12_s {
  // member variables
  alpha_r12_e alpha_r12;
  int8_t      p0_r12 = -126;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SubframeBitmapSL-r12 ::= CHOICE
struct sf_bitmap_sl_r12_c {
  struct types_opts {
    enum options { bs4_r12, bs8_r12, bs12_r12, bs16_r12, bs30_r12, bs40_r12, bs42_r12, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sf_bitmap_sl_r12_c() = default;
  sf_bitmap_sl_r12_c(const sf_bitmap_sl_r12_c& other);
  sf_bitmap_sl_r12_c& operator=(const sf_bitmap_sl_r12_c& other);
  ~sf_bitmap_sl_r12_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<4>& bs4_r12()
  {
    assert_choice_type("bs4-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<4> >();
  }
  fixed_bitstring<8>& bs8_r12()
  {
    assert_choice_type("bs8-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<8> >();
  }
  fixed_bitstring<12>& bs12_r12()
  {
    assert_choice_type("bs12-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<12> >();
  }
  fixed_bitstring<16>& bs16_r12()
  {
    assert_choice_type("bs16-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<16> >();
  }
  fixed_bitstring<30>& bs30_r12()
  {
    assert_choice_type("bs30-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<30> >();
  }
  fixed_bitstring<40>& bs40_r12()
  {
    assert_choice_type("bs40-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<40> >();
  }
  fixed_bitstring<42>& bs42_r12()
  {
    assert_choice_type("bs42-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<42> >();
  }
  const fixed_bitstring<4>& bs4_r12() const
  {
    assert_choice_type("bs4-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<4> >();
  }
  const fixed_bitstring<8>& bs8_r12() const
  {
    assert_choice_type("bs8-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<8> >();
  }
  const fixed_bitstring<12>& bs12_r12() const
  {
    assert_choice_type("bs12-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<12> >();
  }
  const fixed_bitstring<16>& bs16_r12() const
  {
    assert_choice_type("bs16-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<16> >();
  }
  const fixed_bitstring<30>& bs30_r12() const
  {
    assert_choice_type("bs30-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<30> >();
  }
  const fixed_bitstring<40>& bs40_r12() const
  {
    assert_choice_type("bs40-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<40> >();
  }
  const fixed_bitstring<42>& bs42_r12() const
  {
    assert_choice_type("bs42-r12", type_.to_string(), "SubframeBitmapSL-r12");
    return c.get<fixed_bitstring<42> >();
  }
  fixed_bitstring<4>& set_bs4_r12()
  {
    set(types::bs4_r12);
    return c.get<fixed_bitstring<4> >();
  }
  fixed_bitstring<8>& set_bs8_r12()
  {
    set(types::bs8_r12);
    return c.get<fixed_bitstring<8> >();
  }
  fixed_bitstring<12>& set_bs12_r12()
  {
    set(types::bs12_r12);
    return c.get<fixed_bitstring<12> >();
  }
  fixed_bitstring<16>& set_bs16_r12()
  {
    set(types::bs16_r12);
    return c.get<fixed_bitstring<16> >();
  }
  fixed_bitstring<30>& set_bs30_r12()
  {
    set(types::bs30_r12);
    return c.get<fixed_bitstring<30> >();
  }
  fixed_bitstring<40>& set_bs40_r12()
  {
    set(types::bs40_r12);
    return c.get<fixed_bitstring<40> >();
  }
  fixed_bitstring<42>& set_bs42_r12()
  {
    set(types::bs42_r12);
    return c.get<fixed_bitstring<42> >();
  }

private:
  types                                        type_;
  choice_buffer_t<sizeof(fixed_bitstring<42>)> c;

  void destroy_();
};

// SubframeBitmapSL-r14 ::= CHOICE
struct sf_bitmap_sl_r14_c {
  struct types_opts {
    enum options { bs10_r14, bs16_r14, bs20_r14, bs30_r14, bs40_r14, bs50_r14, bs60_r14, bs100_r14, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sf_bitmap_sl_r14_c() = default;
  sf_bitmap_sl_r14_c(const sf_bitmap_sl_r14_c& other);
  sf_bitmap_sl_r14_c& operator=(const sf_bitmap_sl_r14_c& other);
  ~sf_bitmap_sl_r14_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<10>& bs10_r14()
  {
    assert_choice_type("bs10-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<10> >();
  }
  fixed_bitstring<16>& bs16_r14()
  {
    assert_choice_type("bs16-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<16> >();
  }
  fixed_bitstring<20>& bs20_r14()
  {
    assert_choice_type("bs20-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<20> >();
  }
  fixed_bitstring<30>& bs30_r14()
  {
    assert_choice_type("bs30-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<30> >();
  }
  fixed_bitstring<40>& bs40_r14()
  {
    assert_choice_type("bs40-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<40> >();
  }
  fixed_bitstring<50>& bs50_r14()
  {
    assert_choice_type("bs50-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<50> >();
  }
  fixed_bitstring<60>& bs60_r14()
  {
    assert_choice_type("bs60-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<60> >();
  }
  fixed_bitstring<100>& bs100_r14()
  {
    assert_choice_type("bs100-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<100> >();
  }
  const fixed_bitstring<10>& bs10_r14() const
  {
    assert_choice_type("bs10-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<10> >();
  }
  const fixed_bitstring<16>& bs16_r14() const
  {
    assert_choice_type("bs16-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<16> >();
  }
  const fixed_bitstring<20>& bs20_r14() const
  {
    assert_choice_type("bs20-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<20> >();
  }
  const fixed_bitstring<30>& bs30_r14() const
  {
    assert_choice_type("bs30-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<30> >();
  }
  const fixed_bitstring<40>& bs40_r14() const
  {
    assert_choice_type("bs40-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<40> >();
  }
  const fixed_bitstring<50>& bs50_r14() const
  {
    assert_choice_type("bs50-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<50> >();
  }
  const fixed_bitstring<60>& bs60_r14() const
  {
    assert_choice_type("bs60-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<60> >();
  }
  const fixed_bitstring<100>& bs100_r14() const
  {
    assert_choice_type("bs100-r14", type_.to_string(), "SubframeBitmapSL-r14");
    return c.get<fixed_bitstring<100> >();
  }
  fixed_bitstring<10>& set_bs10_r14()
  {
    set(types::bs10_r14);
    return c.get<fixed_bitstring<10> >();
  }
  fixed_bitstring<16>& set_bs16_r14()
  {
    set(types::bs16_r14);
    return c.get<fixed_bitstring<16> >();
  }
  fixed_bitstring<20>& set_bs20_r14()
  {
    set(types::bs20_r14);
    return c.get<fixed_bitstring<20> >();
  }
  fixed_bitstring<30>& set_bs30_r14()
  {
    set(types::bs30_r14);
    return c.get<fixed_bitstring<30> >();
  }
  fixed_bitstring<40>& set_bs40_r14()
  {
    set(types::bs40_r14);
    return c.get<fixed_bitstring<40> >();
  }
  fixed_bitstring<50>& set_bs50_r14()
  {
    set(types::bs50_r14);
    return c.get<fixed_bitstring<50> >();
  }
  fixed_bitstring<60>& set_bs60_r14()
  {
    set(types::bs60_r14);
    return c.get<fixed_bitstring<60> >();
  }
  fixed_bitstring<100>& set_bs100_r14()
  {
    set(types::bs100_r14);
    return c.get<fixed_bitstring<100> >();
  }

private:
  types                                         type_;
  choice_buffer_t<sizeof(fixed_bitstring<100>)> c;

  void destroy_();
};

// SystemInformationBlockType1-v1450-IEs ::= SEQUENCE
struct sib_type1_v1450_ies_s {
  // member variables
  bool                  tdd_cfg_v1450_present = false;
  bool                  non_crit_ext_present  = false;
  tdd_cfg_v1450_s       tdd_cfg_v1450;
  sib_type1_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TDD-Config ::= SEQUENCE
struct tdd_cfg_s {
  struct sf_assign_opts {
    enum options { sa0, sa1, sa2, sa3, sa4, sa5, sa6, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sf_assign_opts> sf_assign_e_;
  struct special_sf_patterns_opts {
    enum options { ssp0, ssp1, ssp2, ssp3, ssp4, ssp5, ssp6, ssp7, ssp8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<special_sf_patterns_opts> special_sf_patterns_e_;

  // member variables
  sf_assign_e_           sf_assign;
  special_sf_patterns_e_ special_sf_patterns;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TDD-Config-v1430 ::= SEQUENCE
struct tdd_cfg_v1430_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandclassCDMA2000 ::= ENUMERATED
struct bandclass_cdma2000_opts {
  enum options {
    bc0,
    bc1,
    bc2,
    bc3,
    bc4,
    bc5,
    bc6,
    bc7,
    bc8,
    bc9,
    bc10,
    bc11,
    bc12,
    bc13,
    bc14,
    bc15,
    bc16,
    bc17,
    bc18_v9a0,
    bc19_v9a0,
    bc20_v9a0,
    bc21_v9a0,
    spare10,
    spare9,
    spare8,
    spare7,
    spare6,
    spare5,
    spare4,
    spare3,
    spare2,
    spare1,
    // ...
    nulltype
  } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<bandclass_cdma2000_opts, true> bandclass_cdma2000_e;

// InterFreqCarrierFreqInfo-v1360 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v1360_s {
  // member variables
  bool                      cell_sel_info_ce1_v1360_present = false;
  cell_sel_info_ce1_v1360_s cell_sel_info_ce1_v1360;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NS-PmaxList-v10l0 ::= SEQUENCE (SIZE (1..maxNS-Pmax-r10)) OF NS-PmaxValue-v10l0
typedef dyn_array<ns_pmax_value_v10l0_s> ns_pmax_list_v10l0_l;

// NS-PmaxValue-r10 ::= SEQUENCE
struct ns_pmax_value_r10_s {
  // member variables
  bool    add_pmax_r10_present = false;
  int8_t  add_pmax_r10         = -30;
  uint8_t add_spec_emission    = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhysCellIdList-r13 ::= SEQUENCE (SIZE (1.. maxSL-DiscCells-r13)) OF INTEGER
typedef bounded_array<uint16_t, 16> pci_list_r13_l;

// SL-CommResourcePoolV2X-r14 ::= SEQUENCE
struct sl_comm_res_pool_v2x_r14_s {
  struct size_subch_r14_opts {
    enum options {
      n4,
      n5,
      n6,
      n8,
      n9,
      n10,
      n12,
      n15,
      n16,
      n18,
      n20,
      n25,
      n30,
      n48,
      n50,
      n72,
      n75,
      n96,
      n100,
      spare13,
      spare12,
      spare11,
      spare10,
      spare9,
      spare8,
      spare7,
      spare6,
      spare5,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<size_subch_r14_opts> size_subch_r14_e_;
  struct num_subch_r14_opts {
    enum options { n1, n3, n5, n8, n10, n15, n20, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<num_subch_r14_opts> num_subch_r14_e_;
  struct rx_params_ncell_r14_s_ {
    // member variables
    bool      tdd_cfg_r14_present = false;
    tdd_cfg_s tdd_cfg_r14;
    uint8_t   sync_cfg_idx_r14 = 0;
  };

  // member variables
  bool                                     ext                                    = false;
  bool                                     sl_offset_ind_r14_present              = false;
  bool                                     start_rb_pscch_pool_r14_present        = false;
  bool                                     rx_params_ncell_r14_present            = false;
  bool                                     data_tx_params_r14_present             = false;
  bool                                     zone_id_r14_present                    = false;
  bool                                     thresh_s_rssi_cbr_r14_present          = false;
  bool                                     pool_report_id_r14_present             = false;
  bool                                     cbr_pssch_tx_cfg_list_r14_present      = false;
  bool                                     res_sel_cfg_p2_x_r14_present           = false;
  bool                                     sync_allowed_r14_present               = false;
  bool                                     restrict_res_reserv_period_r14_present = false;
  sl_offset_ind_r12_c                      sl_offset_ind_r14;
  sf_bitmap_sl_r14_c                       sl_sf_r14;
  bool                                     adjacency_pscch_pssch_r14 = false;
  size_subch_r14_e_                        size_subch_r14;
  num_subch_r14_e_                         num_subch_r14;
  uint8_t                                  start_rb_subch_r14      = 0;
  uint8_t                                  start_rb_pscch_pool_r14 = 0;
  rx_params_ncell_r14_s_                   rx_params_ncell_r14;
  sl_tx_params_r12_s                       data_tx_params_r14;
  uint8_t                                  zone_id_r14           = 0;
  uint8_t                                  thresh_s_rssi_cbr_r14 = 0;
  uint8_t                                  pool_report_id_r14    = 1;
  sl_cbr_pppp_tx_cfg_list_r14_l            cbr_pssch_tx_cfg_list_r14;
  sl_p2_x_res_sel_cfg_r14_s                res_sel_cfg_p2_x_r14;
  sl_sync_allowed_r14_s                    sync_allowed_r14;
  sl_restrict_res_reserv_period_list_r14_l restrict_res_reserv_period_r14;
  // ...
  // group 0
  bool                                      sl_min_t2_value_list_r15_present    = false;
  bool                                      cbr_pssch_tx_cfg_list_v1530_present = false;
  copy_ptr<sl_min_t2_value_list_r15_l>      sl_min_t2_value_list_r15;
  copy_ptr<sl_cbr_pppp_tx_cfg_list_v1530_l> cbr_pssch_tx_cfg_list_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PSSCH-TxConfigList-r14 ::= SEQUENCE (SIZE (1..maxPSSCH-TxConfig-r14)) OF SL-PSSCH-TxConfig-r14
typedef dyn_array<sl_pssch_tx_cfg_r14_s> sl_pssch_tx_cfg_list_r14_l;

// SL-PoolSelectionConfig-r12 ::= SEQUENCE
struct sl_pool_sel_cfg_r12_s {
  // member variables
  uint8_t thresh_low_r12  = 0;
  uint8_t thresh_high_r12 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-SyncConfigNFreq-r13 ::= SEQUENCE
struct sl_sync_cfg_nfreq_r13_s {
  struct async_params_r13_s_ {
    // member variables
    sl_cp_len_r12_e sync_cp_len_r13;
    uint8_t         sync_offset_ind_r13 = 0;
    uint8_t         slssid_r13          = 0;
  };
  struct tx_params_r13_s_ {
    // member variables
    bool                sync_info_reserved_r13_present = false;
    bool                sync_tx_periodic_r13_present   = false;
    sl_tx_params_r12_s  sync_tx_params_r13;
    uint8_t             sync_tx_thresh_ic_r13 = 0;
    fixed_bitstring<19> sync_info_reserved_r13;
  };
  struct rx_params_r13_s_ {
    struct disc_sync_win_r13_opts {
      enum options { w1, w2, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<disc_sync_win_r13_opts> disc_sync_win_r13_e_;

    // member variables
    disc_sync_win_r13_e_ disc_sync_win_r13;
  };

  // member variables
  bool                ext                      = false;
  bool                async_params_r13_present = false;
  bool                tx_params_r13_present    = false;
  bool                rx_params_r13_present    = false;
  async_params_r13_s_ async_params_r13;
  tx_params_r13_s_    tx_params_r13;
  rx_params_r13_s_    rx_params_r13;
  // ...
  // group 0
  bool    sync_offset_ind_v1430_present = false;
  bool    gnss_sync_r14_present         = false;
  uint8_t sync_offset_ind_v1430         = 40;
  // group 1
  bool    sync_offset_ind2_r14_present = false;
  bool    sync_offset_ind3_r14_present = false;
  uint8_t sync_offset_ind2_r14         = 0;
  uint8_t sync_offset_ind3_r14         = 0;
  // group 2
  bool slss_tx_disabled_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-TF-ResourceConfig-r12 ::= SEQUENCE
struct sl_tf_res_cfg_r12_s {
  // member variables
  uint8_t             prb_num_r12   = 1;
  uint8_t             prb_start_r12 = 0;
  uint8_t             prb_end_r12   = 0;
  sl_offset_ind_r12_c offset_ind_r12;
  sf_bitmap_sl_r12_c  sf_bitmap_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-ThresPSSCH-RSRP-List-r14 ::= SEQUENCE (SIZE (64)) OF INTEGER
typedef fixed_array<uint8_t, 64> sl_thres_pssch_rsrp_list_r14_l;

// SystemInformationBlockType1-v1430-IEs ::= SEQUENCE
struct sib_type1_v1430_ies_s {
  typedef dyn_array<cell_access_related_info_r14_s> cell_access_related_info_list_r14_l_;

  // member variables
  bool                                 e_call_over_ims_support_r14_present       = false;
  bool                                 tdd_cfg_v1430_present                     = false;
  bool                                 cell_access_related_info_list_r14_present = false;
  bool                                 non_crit_ext_present                      = false;
  tdd_cfg_v1430_s                      tdd_cfg_v1430;
  cell_access_related_info_list_r14_l_ cell_access_related_info_list_r14;
  sib_type1_v1450_ies_s                non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TDD-Config-v1130 ::= SEQUENCE
struct tdd_cfg_v1130_s {
  struct special_sf_patterns_v1130_opts {
    enum options { ssp7, ssp9, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<special_sf_patterns_v1130_opts> special_sf_patterns_v1130_e_;

  // member variables
  special_sf_patterns_v1130_e_ special_sf_patterns_v1130;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandClassInfoCDMA2000 ::= SEQUENCE
struct band_class_info_cdma2000_s {
  // member variables
  bool                 ext                     = false;
  bool                 cell_resel_prio_present = false;
  bandclass_cdma2000_e band_class;
  uint8_t              cell_resel_prio = 0;
  uint8_t              thresh_x_high   = 0;
  uint8_t              thresh_x_low    = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellSelectionInfoCE1-r13 ::= SEQUENCE
struct cell_sel_info_ce1_r13_s {
  // member variables
  bool   q_qual_min_rsrq_ce1_r13_present = false;
  int8_t q_rx_lev_min_ce1_r13            = -70;
  int8_t q_qual_min_rsrq_ce1_r13         = -34;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqList-v13a0 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v1360
typedef dyn_array<inter_freq_carrier_freq_info_v1360_s> inter_freq_carrier_freq_list_v13a0_l;

// MultiBandInfoList-v10l0 ::= SEQUENCE (SIZE (1..maxMultiBands)) OF NS-PmaxList-v10l0
typedef dyn_array<ns_pmax_list_v10l0_l> multi_band_info_list_v10l0_l;

// NS-PmaxList-r10 ::= SEQUENCE (SIZE (1..maxNS-Pmax-r10)) OF NS-PmaxValue-r10
typedef dyn_array<ns_pmax_value_r10_s> ns_pmax_list_r10_l;

// NeighCellsPerBandclassCDMA2000-r11 ::= SEQUENCE
struct neigh_cells_per_bandclass_cdma2000_r11_s {
  typedef dyn_array<uint16_t> pci_list_r11_l_;

  // member variables
  uint16_t        arfcn = 0;
  pci_list_r11_l_ pci_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhysCellIdListCDMA2000 ::= SEQUENCE (SIZE (1..16)) OF INTEGER
typedef bounded_array<uint16_t, 16> pci_list_cdma2000_l;

// PhysCellIdListCDMA2000-v920 ::= SEQUENCE (SIZE (0..24)) OF INTEGER
typedef bounded_array<uint16_t, 24> pci_list_cdma2000_v920_l;

// SL-CommRxPoolListV2X-r14 ::= SEQUENCE (SIZE (1..maxSL-V2X-RxPool-r14)) OF SL-CommResourcePoolV2X-r14
typedef dyn_array<sl_comm_res_pool_v2x_r14_s> sl_comm_rx_pool_list_v2x_r14_l;

// SL-CommTxPoolListV2X-r14 ::= SEQUENCE (SIZE (1..maxSL-V2X-TxPool-r14)) OF SL-CommResourcePoolV2X-r14
typedef dyn_array<sl_comm_res_pool_v2x_r14_s> sl_comm_tx_pool_list_v2x_r14_l;

// SL-CommTxPoolSensingConfig-r14 ::= SEQUENCE
struct sl_comm_tx_pool_sensing_cfg_r14_s {
  struct prob_res_keep_r14_opts {
    enum options { v0, v0dot2, v0dot4, v0dot6, v0dot8, spare3, spare2, spare1, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<prob_res_keep_r14_opts> prob_res_keep_r14_e_;
  struct p2x_sensing_cfg_r14_s_ {
    // member variables
    uint8_t             min_num_candidate_sf_r14 = 1;
    fixed_bitstring<10> gap_candidate_sensing_r14;
  };
  struct sl_reselect_after_r14_opts {
    enum options {
      n1,
      n2,
      n3,
      n4,
      n5,
      n6,
      n7,
      n8,
      n9,
      spare7,
      spare6,
      spare5,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sl_reselect_after_r14_opts> sl_reselect_after_r14_e_;

  // member variables
  bool                                     restrict_res_reserv_period_r14_present = false;
  bool                                     p2x_sensing_cfg_r14_present            = false;
  bool                                     sl_reselect_after_r14_present          = false;
  sl_pssch_tx_cfg_list_r14_l               pssch_tx_cfg_list_r14;
  copy_ptr<sl_thres_pssch_rsrp_list_r14_l> thres_pssch_rsrp_list_r14;
  sl_restrict_res_reserv_period_list_r14_l restrict_res_reserv_period_r14;
  prob_res_keep_r14_e_                     prob_res_keep_r14;
  p2x_sensing_cfg_r14_s_                   p2x_sensing_cfg_r14;
  sl_reselect_after_r14_e_                 sl_reselect_after_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct setup_opts {
  enum options { release, setup, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<setup_opts> setup_e;

// SL-DiscResourcePool-r12 ::= SEQUENCE
struct sl_disc_res_pool_r12_s {
  struct disc_period_r12_opts {
    enum options { rf32, rf64, rf128, rf256, rf512, rf1024, rf16_v1310, spare, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<disc_period_r12_opts> disc_period_r12_e_;
  struct tx_params_r12_s_ {
    struct ue_sel_res_cfg_r12_s_ {
      struct pool_sel_r12_c_ {
        struct types_opts {
          enum options { rsrp_based_r12, random_r12, nulltype } value;

          std::string to_string() const;
        };
        typedef enumerated<types_opts> types;

        // choice methods
        pool_sel_r12_c_() = default;
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        sl_pool_sel_cfg_r12_s& rsrp_based_r12()
        {
          assert_choice_type("rsrpBased-r12", type_.to_string(), "poolSelection-r12");
          return c;
        }
        const sl_pool_sel_cfg_r12_s& rsrp_based_r12() const
        {
          assert_choice_type("rsrpBased-r12", type_.to_string(), "poolSelection-r12");
          return c;
        }
        sl_pool_sel_cfg_r12_s& set_rsrp_based_r12()
        {
          set(types::rsrp_based_r12);
          return c;
        }

      private:
        types                 type_;
        sl_pool_sel_cfg_r12_s c;
      };
      struct tx_probability_r12_opts {
        enum options { p25, p50, p75, p100, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<tx_probability_r12_opts> tx_probability_r12_e_;

      // member variables
      pool_sel_r12_c_       pool_sel_r12;
      tx_probability_r12_e_ tx_probability_r12;
    };

    // member variables
    bool                  ue_sel_res_cfg_r12_present = false;
    sl_tx_params_r12_s    tx_params_general_r12;
    ue_sel_res_cfg_r12_s_ ue_sel_res_cfg_r12;
  };
  struct rx_params_r12_s_ {
    // member variables
    bool      tdd_cfg_r12_present = false;
    tdd_cfg_s tdd_cfg_r12;
    uint8_t   sync_cfg_idx_r12 = 0;
  };
  struct disc_period_v1310_c_ {
    struct setup_opts {
      enum options { rf4, rf6, rf7, rf8, rf12, rf14, rf24, rf28, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<setup_opts> setup_e_;
    typedef setup_e                types;

    // choice methods
    disc_period_v1310_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_e_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discPeriod-v1310");
      return c;
    }
    const setup_e_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discPeriod-v1310");
      return c;
    }
    setup_e_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_e_ c;
  };
  struct rx_params_add_neigh_freq_r13_c_ {
    struct setup_s_ {
      // member variables
      pci_list_r13_l pci_r13;
    };
    typedef setup_e types;

    // choice methods
    rx_params_add_neigh_freq_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "rxParamsAddNeighFreq-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "rxParamsAddNeighFreq-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct tx_params_add_neigh_freq_r13_c_ {
    struct setup_s_ {
      struct freq_info_s_ {
        struct ul_bw_opts {
          enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<ul_bw_opts> ul_bw_e_;

        // member variables
        bool     ul_carrier_freq_present = false;
        bool     ul_bw_present           = false;
        uint16_t ul_carrier_freq         = 0;
        ul_bw_e_ ul_bw;
        uint8_t  add_spec_emission = 1;
      };

      // member variables
      bool            p_max_present            = false;
      bool            tdd_cfg_r13_present      = false;
      bool            tdd_cfg_v1130_present    = false;
      bool            sync_cfg_idx_r13_present = false;
      pci_list_r13_l  pci_r13;
      int8_t          p_max = -30;
      tdd_cfg_s       tdd_cfg_r13;
      tdd_cfg_v1130_s tdd_cfg_v1130;
      freq_info_s_    freq_info;
      int8_t          ref_sig_pwr      = -60;
      uint8_t         sync_cfg_idx_r13 = 0;
    };
    typedef setup_e types;

    // choice methods
    tx_params_add_neigh_freq_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "txParamsAddNeighFreq-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "txParamsAddNeighFreq-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct tx_params_add_neigh_freq_v1370_c_ {
    struct setup_s_ {
      struct freq_info_v1370_s_ {
        // member variables
        uint16_t add_spec_emission_v1370 = 33;
      };

      // member variables
      freq_info_v1370_s_ freq_info_v1370;
    };
    typedef setup_e types;

    // choice methods
    tx_params_add_neigh_freq_v1370_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "txParamsAddNeighFreq-v1370");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "txParamsAddNeighFreq-v1370");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                ext                   = false;
  bool                tx_params_r12_present = false;
  bool                rx_params_r12_present = false;
  sl_cp_len_r12_e     cp_len_r12;
  disc_period_r12_e_  disc_period_r12;
  uint8_t             num_retx_r12   = 0;
  uint8_t             num_repeat_r12 = 1;
  sl_tf_res_cfg_r12_s tf_res_cfg_r12;
  tx_params_r12_s_    tx_params_r12;
  rx_params_r12_s_    rx_params_r12;
  // ...
  // group 0
  bool                                      disc_period_v1310_present            = false;
  bool                                      rx_params_add_neigh_freq_r13_present = false;
  bool                                      tx_params_add_neigh_freq_r13_present = false;
  copy_ptr<disc_period_v1310_c_>            disc_period_v1310;
  copy_ptr<rx_params_add_neigh_freq_r13_c_> rx_params_add_neigh_freq_r13;
  copy_ptr<tx_params_add_neigh_freq_r13_c_> tx_params_add_neigh_freq_r13;
  // group 1
  bool                                        tx_params_add_neigh_freq_v1370_present = false;
  copy_ptr<tx_params_add_neigh_freq_v1370_c_> tx_params_add_neigh_freq_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-SyncConfigListNFreqV2X-r14 ::= SEQUENCE (SIZE (1..maxSL-V2X-SyncConfig-r14)) OF SL-SyncConfigNFreq-r13
typedef dyn_array<sl_sync_cfg_nfreq_r13_s> sl_sync_cfg_list_nfreq_v2x_r14_l;

// SL-ZoneConfig-r14 ::= SEQUENCE
struct sl_zone_cfg_r14_s {
  struct zone_len_r14_opts {
    enum options { m5, m10, m20, m50, m100, m200, m500, spare1, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<zone_len_r14_opts> zone_len_r14_e_;
  struct zone_width_r14_opts {
    enum options { m5, m10, m20, m50, m100, m200, m500, spare1, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<zone_width_r14_opts> zone_width_r14_e_;

  // member variables
  zone_len_r14_e_   zone_len_r14;
  zone_width_r14_e_ zone_width_r14;
  uint8_t           zone_id_longi_mod_r14 = 1;
  uint8_t           zone_id_lati_mod_r14  = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v1360-IEs ::= SEQUENCE
struct sib_type1_v1360_ies_s {
  // member variables
  bool                      cell_sel_info_ce1_v1360_present = false;
  bool                      non_crit_ext_present            = false;
  cell_sel_info_ce1_v1360_s cell_sel_info_ce1_v1360;
  sib_type1_v1430_ies_s     non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandClassListCDMA2000 ::= SEQUENCE (SIZE (1..maxCDMA-BandClass)) OF BandClassInfoCDMA2000
typedef dyn_array<band_class_info_cdma2000_s> band_class_list_cdma2000_l;

// InterFreqCarrierFreqInfo-v10l0 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v10l0_s {
  // member variables
  bool                         freq_band_info_v10l0_present       = false;
  bool                         multi_band_info_list_v10l0_present = false;
  ns_pmax_list_v10l0_l         freq_band_info_v10l0;
  multi_band_info_list_v10l0_l multi_band_info_list_v10l0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MultiBandInfo-v9e0 ::= SEQUENCE
struct multi_band_info_v9e0_s {
  // member variables
  bool     freq_band_ind_v9e0_present = false;
  uint16_t freq_band_ind_v9e0         = 65;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MultiBandInfoList-v10j0 ::= SEQUENCE (SIZE (1..maxMultiBands)) OF NS-PmaxList-r10
typedef dyn_array<ns_pmax_list_r10_l> multi_band_info_list_v10j0_l;

// NeighCellCDMA2000-r11 ::= SEQUENCE
struct neigh_cell_cdma2000_r11_s {
  typedef dyn_array<neigh_cells_per_bandclass_cdma2000_r11_s> neigh_freq_info_list_r11_l_;

  // member variables
  bandclass_cdma2000_e        band_class;
  neigh_freq_info_list_r11_l_ neigh_freq_info_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighCellsPerBandclassCDMA2000 ::= SEQUENCE
struct neigh_cells_per_bandclass_cdma2000_s {
  // member variables
  uint16_t            arfcn = 0;
  pci_list_cdma2000_l pci_list;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighCellsPerBandclassCDMA2000-v920 ::= SEQUENCE
struct neigh_cells_per_bandclass_cdma2000_v920_s {
  // member variables
  pci_list_cdma2000_v920_l pci_list_v920;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhysCellIdRange ::= SEQUENCE
struct pci_range_s {
  struct range_opts {
    enum options {
      n4,
      n8,
      n12,
      n16,
      n24,
      n32,
      n48,
      n64,
      n84,
      n96,
      n128,
      n168,
      n252,
      n504,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<range_opts> range_e_;

  // member variables
  bool     range_present = false;
  uint16_t start         = 0;
  range_e_ range;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Q-OffsetRange ::= ENUMERATED
struct q_offset_range_opts {
  enum options {
    db_minus24,
    db_minus22,
    db_minus20,
    db_minus18,
    db_minus16,
    db_minus14,
    db_minus12,
    db_minus10,
    db_minus8,
    db_minus6,
    db_minus5,
    db_minus4,
    db_minus3,
    db_minus2,
    db_minus1,
    db0,
    db1,
    db2,
    db3,
    db4,
    db5,
    db6,
    db8,
    db10,
    db12,
    db14,
    db16,
    db18,
    db20,
    db22,
    db24,
    nulltype
  } value;
  typedef int8_t number_type;

  std::string to_string() const;
  int8_t      to_number() const;
};
typedef enumerated<q_offset_range_opts> q_offset_range_e;

// RedistributionNeighCell-r13 ::= SEQUENCE
struct redist_neigh_cell_r13_s {
  // member variables
  uint16_t pci_r13                = 0;
  uint8_t  redist_factor_cell_r13 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscTxPoolList-r12 ::= SEQUENCE (SIZE (1..maxSL-TxPool-r12)) OF SL-DiscResourcePool-r12
typedef dyn_array<sl_disc_res_pool_r12_s> sl_disc_tx_pool_list_r12_l;

// SL-DiscTxPowerInfo-r12 ::= SEQUENCE
struct sl_disc_tx_pwr_info_r12_s {
  // member variables
  bool   ext                 = false;
  int8_t disc_max_tx_pwr_r12 = -30;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-FreqSelectionConfig-r15 ::= SEQUENCE
struct sl_v2x_freq_sel_cfg_r15_s {
  // member variables
  bool               thresh_cbr_freq_resel_r15_present   = false;
  bool               thresh_cbr_freq_keeping_r15_present = false;
  sl_prio_list_r13_l prio_list_r15;
  uint8_t            thresh_cbr_freq_resel_r15   = 0;
  uint8_t            thresh_cbr_freq_keeping_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-InterFreqUE-Config-r14 ::= SEQUENCE
struct sl_v2x_inter_freq_ue_cfg_r14_s {
  // member variables
  bool                              ext                                      = false;
  bool                              pci_list_r14_present                     = false;
  bool                              type_tx_sync_r14_present                 = false;
  bool                              v2x_sync_cfg_r14_present                 = false;
  bool                              v2x_comm_rx_pool_r14_present             = false;
  bool                              v2x_comm_tx_pool_normal_r14_present      = false;
  bool                              p2x_comm_tx_pool_normal_r14_present      = false;
  bool                              v2x_comm_tx_pool_exceptional_r14_present = false;
  bool                              v2x_res_sel_cfg_r14_present              = false;
  bool                              zone_cfg_r14_present                     = false;
  bool                              offset_dfn_r14_present                   = false;
  pci_list_r13_l                    pci_list_r14;
  sl_type_tx_sync_r14_e             type_tx_sync_r14;
  sl_sync_cfg_list_nfreq_v2x_r14_l  v2x_sync_cfg_r14;
  sl_comm_rx_pool_list_v2x_r14_l    v2x_comm_rx_pool_r14;
  sl_comm_tx_pool_list_v2x_r14_l    v2x_comm_tx_pool_normal_r14;
  sl_comm_tx_pool_list_v2x_r14_l    p2x_comm_tx_pool_normal_r14;
  sl_comm_res_pool_v2x_r14_s        v2x_comm_tx_pool_exceptional_r14;
  sl_comm_tx_pool_sensing_cfg_r14_s v2x_res_sel_cfg_r14;
  sl_zone_cfg_r14_s                 zone_cfg_r14;
  uint16_t                          offset_dfn_r14 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SchedulingInfo-BR-r13 ::= SEQUENCE
struct sched_info_br_r13_s {
  struct si_tbs_r13_opts {
    enum options { b152, b208, b256, b328, b408, b504, b600, b712, b808, b936, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<si_tbs_r13_opts> si_tbs_r13_e_;

  // member variables
  uint8_t       si_nb_r13 = 1;
  si_tbs_r13_e_ si_tbs_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecondaryPreRegistrationZoneIdListHRPD ::= SEQUENCE (SIZE (1..2)) OF INTEGER
typedef bounded_array<uint8_t, 2> secondary_pre_regist_zone_id_list_hrpd_l;

// SpeedStateScaleFactors ::= SEQUENCE
struct speed_state_scale_factors_s {
  struct sf_medium_opts {
    enum options { o_dot25, o_dot5, o_dot75, l_dot0, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<sf_medium_opts> sf_medium_e_;
  struct sf_high_opts {
    enum options { o_dot25, o_dot5, o_dot75, l_dot0, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<sf_high_opts> sf_high_e_;

  // member variables
  sf_medium_e_ sf_medium;
  sf_high_e_   sf_high;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v1350-IEs ::= SEQUENCE
struct sib_type1_v1350_ies_s {
  // member variables
  bool                    cell_sel_info_ce1_r13_present = false;
  bool                    non_crit_ext_present          = false;
  cell_sel_info_ce1_r13_s cell_sel_info_ce1_r13;
  sib_type1_v1360_ies_s   non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType5-v13a0-IEs ::= SEQUENCE
struct sib_type5_v13a0_ies_s {
  // member variables
  bool                                 late_non_crit_ext_present                  = false;
  bool                                 inter_freq_carrier_freq_list_v13a0_present = false;
  bool                                 non_crit_ext_present                       = false;
  dyn_octstring                        late_non_crit_ext;
  inter_freq_carrier_freq_list_v13a0_l inter_freq_carrier_freq_list_v13a0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AC-BarringConfig1XRTT-r9 ::= SEQUENCE
struct ac_barr_cfg1_xrtt_r9_s {
  // member variables
  uint8_t ac_barr0to9_r9 = 0;
  uint8_t ac_barr10_r9   = 0;
  uint8_t ac_barr11_r9   = 0;
  uint8_t ac_barr12_r9   = 0;
  uint8_t ac_barr13_r9   = 0;
  uint8_t ac_barr14_r9   = 0;
  uint8_t ac_barr15_r9   = 0;
  uint8_t ac_barr_msg_r9 = 0;
  uint8_t ac_barr_reg_r9 = 0;
  uint8_t ac_barr_emg_r9 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AllowedMeasBandwidth ::= ENUMERATED
struct allowed_meas_bw_opts {
  enum options { mbw6, mbw15, mbw25, mbw50, mbw75, mbw100, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<allowed_meas_bw_opts> allowed_meas_bw_e;

// BandIndicatorGERAN ::= ENUMERATED
struct band_ind_geran_opts {
  enum options { dcs1800, pcs1900, nulltype } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<band_ind_geran_opts> band_ind_geran_e;

// BarringPerACDC-Category-r13 ::= SEQUENCE
struct barr_per_acdc_category_r13_s {
  struct acdc_barr_cfg_r13_s_ {
    struct ac_barr_factor_r13_opts {
      enum options { p00, p05, p10, p15, p20, p25, p30, p40, p50, p60, p70, p75, p80, p85, p90, p95, nulltype } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<ac_barr_factor_r13_opts> ac_barr_factor_r13_e_;
    struct ac_barr_time_r13_opts {
      enum options { s4, s8, s16, s32, s64, s128, s256, s512, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<ac_barr_time_r13_opts> ac_barr_time_r13_e_;

    // member variables
    ac_barr_factor_r13_e_ ac_barr_factor_r13;
    ac_barr_time_r13_e_   ac_barr_time_r13;
  };

  // member variables
  bool                 acdc_barr_cfg_r13_present = false;
  uint8_t              acdc_category_r13         = 1;
  acdc_barr_cfg_r13_s_ acdc_barr_cfg_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSFB-RegistrationParam1XRTT ::= SEQUENCE
struct csfb_regist_param1_xrtt_s {
  // member variables
  fixed_bitstring<15> sid;
  fixed_bitstring<16> nid;
  bool                multiple_sid    = false;
  bool                multiple_nid    = false;
  bool                home_reg        = false;
  bool                foreign_sid_reg = false;
  bool                foreign_nid_reg = false;
  bool                param_reg       = false;
  bool                pwr_up_reg      = false;
  fixed_bitstring<7>  regist_period;
  fixed_bitstring<12> regist_zone;
  fixed_bitstring<3>  total_zone;
  fixed_bitstring<3>  zone_timer;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSFB-RegistrationParam1XRTT-v920 ::= SEQUENCE
struct csfb_regist_param1_xrtt_v920_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellList-r15 ::= SEQUENCE (SIZE (1.. maxCellMeasIdle-r15)) OF PhysCellIdRange
typedef dyn_array<pci_range_s> cell_list_r15_l;

// CellReselectionParametersCDMA2000-r11 ::= SEQUENCE
struct cell_resel_params_cdma2000_r11_s {
  typedef dyn_array<neigh_cell_cdma2000_r11_s> neigh_cell_list_r11_l_;

  // member variables
  bool                        t_resel_cdma2000_sf_present = false;
  band_class_list_cdma2000_l  band_class_list;
  neigh_cell_list_r11_l_      neigh_cell_list_r11;
  uint8_t                     t_resel_cdma2000 = 0;
  speed_state_scale_factors_s t_resel_cdma2000_sf;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellSelectionInfoCE-r13 ::= SEQUENCE
struct cell_sel_info_ce_r13_s {
  // member variables
  bool   q_qual_min_rsrq_ce_r13_present = false;
  int8_t q_rx_lev_min_ce_r13            = -70;
  int8_t q_qual_min_rsrq_ce_r13         = -34;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellSelectionInfoNFreq-r13 ::= SEQUENCE
struct cell_sel_info_nfreq_r13_s {
  struct q_hyst_r13_opts {
    enum options {
      db0,
      db1,
      db2,
      db3,
      db4,
      db5,
      db6,
      db8,
      db10,
      db12,
      db14,
      db16,
      db18,
      db20,
      db22,
      db24,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<q_hyst_r13_opts> q_hyst_r13_e_;

  // member variables
  bool          q_rx_lev_min_offset_present = false;
  int8_t        q_rx_lev_min_r13            = -70;
  uint8_t       q_rx_lev_min_offset         = 1;
  q_hyst_r13_e_ q_hyst_r13;
  int8_t        q_rx_lev_min_resel_r13 = -70;
  uint8_t       t_resel_eutra_r13      = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ExplicitListOfARFCNs ::= SEQUENCE (SIZE (0..31)) OF INTEGER
typedef bounded_array<uint16_t, 31> explicit_list_of_arfcns_l;

// InterFreqCarrierFreqInfo-v10j0 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v10j0_s {
  // member variables
  bool                         freq_band_info_r10_present         = false;
  bool                         multi_band_info_list_v10j0_present = false;
  ns_pmax_list_r10_l           freq_band_info_r10;
  multi_band_info_list_v10j0_l multi_band_info_list_v10j0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqNeighCellInfo ::= SEQUENCE
struct inter_freq_neigh_cell_info_s {
  // member variables
  uint16_t         pci = 0;
  q_offset_range_e q_offset_cell;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MultiBandInfoList-v9e0 ::= SEQUENCE (SIZE (1..maxMultiBands)) OF MultiBandInfo-v9e0
typedef dyn_array<multi_band_info_v9e0_s> multi_band_info_list_v9e0_l;

// NS-PmaxValueNR-r15 ::= SEQUENCE
struct ns_pmax_value_nr_r15_s {
  // member variables
  bool    add_pmax_nr_r15_present  = false;
  int8_t  add_pmax_nr_r15          = -30;
  uint8_t add_spec_emission_nr_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighCellsPerBandclassListCDMA2000 ::= SEQUENCE (SIZE (1..16)) OF NeighCellsPerBandclassCDMA2000
typedef dyn_array<neigh_cells_per_bandclass_cdma2000_s> neigh_cells_per_bandclass_list_cdma2000_l;

// NeighCellsPerBandclassListCDMA2000-v920 ::= SEQUENCE (SIZE (1..16)) OF NeighCellsPerBandclassCDMA2000-v920
typedef dyn_array<neigh_cells_per_bandclass_cdma2000_v920_s> neigh_cells_per_bandclass_list_cdma2000_v920_l;

// PLMN-IdentityInfo2-r12 ::= CHOICE
struct plmn_id_info2_r12_c {
  struct types_opts {
    enum options { plmn_idx_r12, plmn_id_r12, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  plmn_id_info2_r12_c() = default;
  plmn_id_info2_r12_c(const plmn_id_info2_r12_c& other);
  plmn_id_info2_r12_c& operator=(const plmn_id_info2_r12_c& other);
  ~plmn_id_info2_r12_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& plmn_idx_r12()
  {
    assert_choice_type("plmn-Index-r12", type_.to_string(), "PLMN-IdentityInfo2-r12");
    return c.get<uint8_t>();
  }
  plmn_id_s& plmn_id_r12()
  {
    assert_choice_type("plmnIdentity-r12", type_.to_string(), "PLMN-IdentityInfo2-r12");
    return c.get<plmn_id_s>();
  }
  const uint8_t& plmn_idx_r12() const
  {
    assert_choice_type("plmn-Index-r12", type_.to_string(), "PLMN-IdentityInfo2-r12");
    return c.get<uint8_t>();
  }
  const plmn_id_s& plmn_id_r12() const
  {
    assert_choice_type("plmnIdentity-r12", type_.to_string(), "PLMN-IdentityInfo2-r12");
    return c.get<plmn_id_s>();
  }
  uint8_t& set_plmn_idx_r12()
  {
    set(types::plmn_idx_r12);
    return c.get<uint8_t>();
  }
  plmn_id_s& set_plmn_id_r12()
  {
    set(types::plmn_id_r12);
    return c.get<plmn_id_s>();
  }

private:
  types                              type_;
  choice_buffer_t<sizeof(plmn_id_s)> c;

  void destroy_();
};

// PRACH-ParametersCE-r13 ::= SEQUENCE
struct prach_params_ce_r13_s {
  struct prach_start_sf_r13_opts {
    enum options { sf2, sf4, sf8, sf16, sf32, sf64, sf128, sf256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<prach_start_sf_r13_opts> prach_start_sf_r13_e_;
  struct max_num_preamb_attempt_ce_r13_opts {
    enum options { n3, n4, n5, n6, n7, n8, n10, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<max_num_preamb_attempt_ce_r13_opts> max_num_preamb_attempt_ce_r13_e_;
  struct num_repeat_per_preamb_attempt_r13_opts {
    enum options { n1, n2, n4, n8, n16, n32, n64, n128, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<num_repeat_per_preamb_attempt_r13_opts> num_repeat_per_preamb_attempt_r13_e_;
  typedef bounded_array<uint8_t, 2>                          mpdcch_nbs_to_monitor_r13_l_;
  struct mpdcch_num_repeat_ra_r13_opts {
    enum options { r1, r2, r4, r8, r16, r32, r64, r128, r256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<mpdcch_num_repeat_ra_r13_opts> mpdcch_num_repeat_ra_r13_e_;
  struct prach_hop_cfg_r13_opts {
    enum options { on, off, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<prach_hop_cfg_r13_opts> prach_hop_cfg_r13_e_;

  // member variables
  bool                                 prach_start_sf_r13_present            = false;
  bool                                 max_num_preamb_attempt_ce_r13_present = false;
  uint8_t                              prach_cfg_idx_r13                     = 0;
  uint8_t                              prach_freq_offset_r13                 = 0;
  prach_start_sf_r13_e_                prach_start_sf_r13;
  max_num_preamb_attempt_ce_r13_e_     max_num_preamb_attempt_ce_r13;
  num_repeat_per_preamb_attempt_r13_e_ num_repeat_per_preamb_attempt_r13;
  mpdcch_nbs_to_monitor_r13_l_         mpdcch_nbs_to_monitor_r13;
  mpdcch_num_repeat_ra_r13_e_          mpdcch_num_repeat_ra_r13;
  prach_hop_cfg_r13_e_                 prach_hop_cfg_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PreRegistrationInfoHRPD ::= SEQUENCE
struct pre_regist_info_hrpd_s {
  // member variables
  bool                                     pre_regist_zone_id_present                = false;
  bool                                     secondary_pre_regist_zone_id_list_present = false;
  bool                                     pre_regist_allowed                        = false;
  uint8_t                                  pre_regist_zone_id                        = 0;
  secondary_pre_regist_zone_id_list_hrpd_l secondary_pre_regist_zone_id_list;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RACH-CE-LevelInfo-r13 ::= SEQUENCE
struct rach_ce_level_info_r13_s {
  struct preamb_map_info_r13_s_ {
    // member variables
    uint8_t first_preamb_r13 = 0;
    uint8_t last_preamb_r13  = 0;
  };
  struct ra_resp_win_size_r13_opts {
    enum options { sf20, sf50, sf80, sf120, sf180, sf240, sf320, sf400, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<ra_resp_win_size_r13_opts> ra_resp_win_size_r13_e_;
  struct mac_contention_resolution_timer_r13_opts {
    enum options { sf80, sf100, sf120, sf160, sf200, sf240, sf480, sf960, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<mac_contention_resolution_timer_r13_opts> mac_contention_resolution_timer_r13_e_;
  struct rar_hop_cfg_r13_opts {
    enum options { on, off, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<rar_hop_cfg_r13_opts> rar_hop_cfg_r13_e_;
  struct edt_params_r15_s_ {
    struct edt_tbs_r15_opts {
      enum options { b328, b408, b504, b600, b712, b808, b936, b1000or456, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<edt_tbs_r15_opts> edt_tbs_r15_e_;
    struct mac_contention_resolution_timer_r15_opts {
      enum options { sf240, sf480, sf960, sf1920, sf3840, sf5760, sf7680, sf10240, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<mac_contention_resolution_timer_r15_opts> mac_contention_resolution_timer_r15_e_;

    // member variables
    bool                                   mac_contention_resolution_timer_r15_present = false;
    uint8_t                                edt_last_preamb_r15                         = 0;
    bool                                   edt_small_tbs_enabled_r15                   = false;
    edt_tbs_r15_e_                         edt_tbs_r15;
    mac_contention_resolution_timer_r15_e_ mac_contention_resolution_timer_r15;
  };

  // member variables
  bool                                   ext = false;
  preamb_map_info_r13_s_                 preamb_map_info_r13;
  ra_resp_win_size_r13_e_                ra_resp_win_size_r13;
  mac_contention_resolution_timer_r13_e_ mac_contention_resolution_timer_r13;
  rar_hop_cfg_r13_e_                     rar_hop_cfg_r13;
  // ...
  // group 0
  bool                        edt_params_r15_present = false;
  copy_ptr<edt_params_r15_s_> edt_params_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RedistributionNeighCellList-r13 ::= SEQUENCE (SIZE (1..maxCellInter)) OF RedistributionNeighCell-r13
typedef dyn_array<redist_neigh_cell_r13_s> redist_neigh_cell_list_r13_l;

// SL-AllowedCarrierFreqList-r15 ::= SEQUENCE
struct sl_allowed_carrier_freq_list_r15_s {
  typedef bounded_array<uint32_t, 8> allowed_carrier_freq_set1_l_;
  typedef bounded_array<uint32_t, 8> allowed_carrier_freq_set2_l_;

  // member variables
  allowed_carrier_freq_set1_l_ allowed_carrier_freq_set1;
  allowed_carrier_freq_set2_l_ allowed_carrier_freq_set2;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DestinationInfoList-r12 ::= SEQUENCE (SIZE (1..maxSL-Dest-r12)) OF BIT STRING
typedef bounded_array<fixed_bitstring<24>, 16> sl_dest_info_list_r12_l;

// SL-DiscRxPoolList-r12 ::= SEQUENCE (SIZE (1..maxSL-RxPool-r12)) OF SL-DiscResourcePool-r12
typedef dyn_array<sl_disc_res_pool_r12_s> sl_disc_rx_pool_list_r12_l;

// SL-DiscTxPowerInfoList-r12 ::= SEQUENCE (SIZE (maxSL-DiscPowerClass-r12)) OF SL-DiscTxPowerInfo-r12
typedef fixed_array<sl_disc_tx_pwr_info_r12_s, 3> sl_disc_tx_pwr_info_list_r12_l;

// SL-DiscTxResourcesInterFreq-r13 ::= CHOICE
struct sl_disc_tx_res_inter_freq_r13_c {
  struct types_opts {
    enum options {
      acquire_si_from_carrier_r13,
      disc_tx_pool_common_r13,
      request_ded_r13,
      no_tx_on_carrier_r13,
      nulltype
    } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sl_disc_tx_res_inter_freq_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  sl_disc_tx_pool_list_r12_l& disc_tx_pool_common_r13()
  {
    assert_choice_type("discTxPoolCommon-r13", type_.to_string(), "SL-DiscTxResourcesInterFreq-r13");
    return c;
  }
  const sl_disc_tx_pool_list_r12_l& disc_tx_pool_common_r13() const
  {
    assert_choice_type("discTxPoolCommon-r13", type_.to_string(), "SL-DiscTxResourcesInterFreq-r13");
    return c;
  }
  sl_disc_tx_pool_list_r12_l& set_disc_tx_pool_common_r13()
  {
    set(types::disc_tx_pool_common_r13);
    return c;
  }

private:
  types                      type_;
  sl_disc_tx_pool_list_r12_l c;
};

// SL-SyncConfigListNFreq-r13 ::= SEQUENCE (SIZE (1..maxSL-SyncConfig-r12)) OF SL-SyncConfigNFreq-r13
typedef dyn_array<sl_sync_cfg_nfreq_r13_s> sl_sync_cfg_list_nfreq_r13_l;

// SL-V2X-FreqSelectionConfigList-r15 ::= SEQUENCE (SIZE (1..8)) OF SL-V2X-FreqSelectionConfig-r15
typedef dyn_array<sl_v2x_freq_sel_cfg_r15_s> sl_v2x_freq_sel_cfg_list_r15_l;

// SL-V2X-UE-ConfigList-r14 ::= SEQUENCE (SIZE (1.. maxCellIntra)) OF SL-V2X-InterFreqUE-Config-r14
typedef dyn_array<sl_v2x_inter_freq_ue_cfg_r14_s> sl_v2x_ue_cfg_list_r14_l;

// SchedulingInfoList-BR-r13 ::= SEQUENCE (SIZE (1..maxSI-Message)) OF SchedulingInfo-BR-r13
typedef dyn_array<sched_info_br_r13_s> sched_info_list_br_r13_l;

// SystemInfoValueTagList-r13 ::= SEQUENCE (SIZE (1..maxSI-Message)) OF INTEGER
typedef bounded_array<uint8_t, 32> sys_info_value_tag_list_r13_l;

// SystemInformationBlockType1-v1320-IEs ::= SEQUENCE
struct sib_type1_v1320_ies_s {
  struct freq_hop_params_dl_r13_s_ {
    struct mpdcch_pdsch_hop_nb_r13_opts {
      enum options { nb2, nb4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<mpdcch_pdsch_hop_nb_r13_opts> mpdcch_pdsch_hop_nb_r13_e_;
    struct interv_dl_hop_cfg_common_mode_a_r13_c_ {
      struct interv_fdd_r13_opts {
        enum options { int1, int2, int4, int8, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<interv_fdd_r13_opts> interv_fdd_r13_e_;
      struct interv_tdd_r13_opts {
        enum options { int1, int5, int10, int20, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<interv_tdd_r13_opts> interv_tdd_r13_e_;
      struct types_opts {
        enum options { interv_fdd_r13, interv_tdd_r13, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      interv_dl_hop_cfg_common_mode_a_r13_c_() = default;
      interv_dl_hop_cfg_common_mode_a_r13_c_(const interv_dl_hop_cfg_common_mode_a_r13_c_& other);
      interv_dl_hop_cfg_common_mode_a_r13_c_& operator=(const interv_dl_hop_cfg_common_mode_a_r13_c_& other);
      ~interv_dl_hop_cfg_common_mode_a_r13_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      interv_fdd_r13_e_& interv_fdd_r13()
      {
        assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeA-r13");
        return c.get<interv_fdd_r13_e_>();
      }
      interv_tdd_r13_e_& interv_tdd_r13()
      {
        assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeA-r13");
        return c.get<interv_tdd_r13_e_>();
      }
      const interv_fdd_r13_e_& interv_fdd_r13() const
      {
        assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeA-r13");
        return c.get<interv_fdd_r13_e_>();
      }
      const interv_tdd_r13_e_& interv_tdd_r13() const
      {
        assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeA-r13");
        return c.get<interv_tdd_r13_e_>();
      }
      interv_fdd_r13_e_& set_interv_fdd_r13()
      {
        set(types::interv_fdd_r13);
        return c.get<interv_fdd_r13_e_>();
      }
      interv_tdd_r13_e_& set_interv_tdd_r13()
      {
        set(types::interv_tdd_r13);
        return c.get<interv_tdd_r13_e_>();
      }

    private:
      types                                                                       type_;
      choice_buffer_t<MAX2(sizeof(interv_fdd_r13_e_), sizeof(interv_tdd_r13_e_))> c;

      void destroy_();
    };
    struct interv_dl_hop_cfg_common_mode_b_r13_c_ {
      struct interv_fdd_r13_opts {
        enum options { int2, int4, int8, int16, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<interv_fdd_r13_opts> interv_fdd_r13_e_;
      struct interv_tdd_r13_opts {
        enum options { int5, int10, int20, int40, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<interv_tdd_r13_opts> interv_tdd_r13_e_;
      struct types_opts {
        enum options { interv_fdd_r13, interv_tdd_r13, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      interv_dl_hop_cfg_common_mode_b_r13_c_() = default;
      interv_dl_hop_cfg_common_mode_b_r13_c_(const interv_dl_hop_cfg_common_mode_b_r13_c_& other);
      interv_dl_hop_cfg_common_mode_b_r13_c_& operator=(const interv_dl_hop_cfg_common_mode_b_r13_c_& other);
      ~interv_dl_hop_cfg_common_mode_b_r13_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      interv_fdd_r13_e_& interv_fdd_r13()
      {
        assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeB-r13");
        return c.get<interv_fdd_r13_e_>();
      }
      interv_tdd_r13_e_& interv_tdd_r13()
      {
        assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeB-r13");
        return c.get<interv_tdd_r13_e_>();
      }
      const interv_fdd_r13_e_& interv_fdd_r13() const
      {
        assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeB-r13");
        return c.get<interv_fdd_r13_e_>();
      }
      const interv_tdd_r13_e_& interv_tdd_r13() const
      {
        assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-DLHoppingConfigCommonModeB-r13");
        return c.get<interv_tdd_r13_e_>();
      }
      interv_fdd_r13_e_& set_interv_fdd_r13()
      {
        set(types::interv_fdd_r13);
        return c.get<interv_fdd_r13_e_>();
      }
      interv_tdd_r13_e_& set_interv_tdd_r13()
      {
        set(types::interv_tdd_r13);
        return c.get<interv_tdd_r13_e_>();
      }

    private:
      types                                                                       type_;
      choice_buffer_t<MAX2(sizeof(interv_fdd_r13_e_), sizeof(interv_tdd_r13_e_))> c;

      void destroy_();
    };

    // member variables
    bool                                   mpdcch_pdsch_hop_nb_r13_present             = false;
    bool                                   interv_dl_hop_cfg_common_mode_a_r13_present = false;
    bool                                   interv_dl_hop_cfg_common_mode_b_r13_present = false;
    bool                                   mpdcch_pdsch_hop_offset_r13_present         = false;
    mpdcch_pdsch_hop_nb_r13_e_             mpdcch_pdsch_hop_nb_r13;
    interv_dl_hop_cfg_common_mode_a_r13_c_ interv_dl_hop_cfg_common_mode_a_r13;
    interv_dl_hop_cfg_common_mode_b_r13_c_ interv_dl_hop_cfg_common_mode_b_r13;
    uint8_t                                mpdcch_pdsch_hop_offset_r13 = 1;
  };

  // member variables
  bool                      freq_hop_params_dl_r13_present = false;
  bool                      non_crit_ext_present           = false;
  freq_hop_params_dl_r13_s_ freq_hop_params_dl_r13;
  sib_type1_v1350_ies_s     non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType2-v10m0-IEs ::= SEQUENCE
struct sib_type2_v10m0_ies_s {
  struct freq_info_v10l0_s_ {
    // member variables
    uint16_t add_spec_emission_v10l0 = 33;
  };
  typedef bounded_array<uint16_t, 8> multi_band_info_list_v10l0_l_;

  // member variables
  bool                          freq_info_v10l0_present            = false;
  bool                          multi_band_info_list_v10l0_present = false;
  bool                          non_crit_ext_present               = false;
  freq_info_v10l0_s_            freq_info_v10l0;
  multi_band_info_list_v10l0_l_ multi_band_info_list_v10l0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType5-v10l0-IEs ::= SEQUENCE
struct sib_type5_v10l0_ies_s {
  typedef dyn_array<inter_freq_carrier_freq_info_v10l0_s> inter_freq_carrier_freq_list_v10l0_l_;

  // member variables
  bool                                  inter_freq_carrier_freq_list_v10l0_present = false;
  bool                                  non_crit_ext_present                       = false;
  inter_freq_carrier_freq_list_v10l0_l_ inter_freq_carrier_freq_list_v10l0;
  sib_type5_v13a0_ies_s                 non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemTimeInfoCDMA2000 ::= SEQUENCE
struct sys_time_info_cdma2000_s {
  struct cdma_sys_time_c_ {
    struct types_opts {
      enum options { sync_sys_time, async_sys_time, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    cdma_sys_time_c_() = default;
    cdma_sys_time_c_(const cdma_sys_time_c_& other);
    cdma_sys_time_c_& operator=(const cdma_sys_time_c_& other);
    ~cdma_sys_time_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<39>& sync_sys_time()
    {
      assert_choice_type("synchronousSystemTime", type_.to_string(), "cdma-SystemTime");
      return c.get<fixed_bitstring<39> >();
    }
    fixed_bitstring<49>& async_sys_time()
    {
      assert_choice_type("asynchronousSystemTime", type_.to_string(), "cdma-SystemTime");
      return c.get<fixed_bitstring<49> >();
    }
    const fixed_bitstring<39>& sync_sys_time() const
    {
      assert_choice_type("synchronousSystemTime", type_.to_string(), "cdma-SystemTime");
      return c.get<fixed_bitstring<39> >();
    }
    const fixed_bitstring<49>& async_sys_time() const
    {
      assert_choice_type("asynchronousSystemTime", type_.to_string(), "cdma-SystemTime");
      return c.get<fixed_bitstring<49> >();
    }
    fixed_bitstring<39>& set_sync_sys_time()
    {
      set(types::sync_sys_time);
      return c.get<fixed_bitstring<39> >();
    }
    fixed_bitstring<49>& set_async_sys_time()
    {
      set(types::async_sys_time);
      return c.get<fixed_bitstring<49> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<49>)> c;

    void destroy_();
  };

  // member variables
  bool             cdma_eutra_synchronisation = false;
  cdma_sys_time_c_ cdma_sys_time;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UAC-BarringPerCat-r15 ::= SEQUENCE
struct uac_barr_per_cat_r15_s {
  // member variables
  uint8_t access_category_r15       = 1;
  uint8_t uac_barr_info_set_idx_r15 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AC-BarringConfig ::= SEQUENCE
struct ac_barr_cfg_s {
  struct ac_barr_factor_opts {
    enum options { p00, p05, p10, p15, p20, p25, p30, p40, p50, p60, p70, p75, p80, p85, p90, p95, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<ac_barr_factor_opts> ac_barr_factor_e_;
  struct ac_barr_time_opts {
    enum options { s4, s8, s16, s32, s64, s128, s256, s512, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<ac_barr_time_opts> ac_barr_time_e_;

  // member variables
  ac_barr_factor_e_  ac_barr_factor;
  ac_barr_time_e_    ac_barr_time;
  fixed_bitstring<5> ac_barr_for_special_ac;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BarringPerACDC-CategoryList-r13 ::= SEQUENCE (SIZE (1..maxACDC-Cat-r13)) OF BarringPerACDC-Category-r13
typedef dyn_array<barr_per_acdc_category_r13_s> barr_per_acdc_category_list_r13_l;

// CarrierFreqsGERAN ::= SEQUENCE
struct carrier_freqs_geran_s {
  struct following_arfcns_c_ {
    struct equally_spaced_arfcns_s_ {
      // member variables
      uint8_t arfcn_spacing        = 1;
      uint8_t nof_following_arfcns = 0;
    };
    struct types_opts {
      enum options { explicit_list_of_arfcns, equally_spaced_arfcns, variable_bit_map_of_arfcns, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    following_arfcns_c_() = default;
    following_arfcns_c_(const following_arfcns_c_& other);
    following_arfcns_c_& operator=(const following_arfcns_c_& other);
    ~following_arfcns_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    explicit_list_of_arfcns_l& explicit_list_of_arfcns()
    {
      assert_choice_type("explicitListOfARFCNs", type_.to_string(), "followingARFCNs");
      return c.get<explicit_list_of_arfcns_l>();
    }
    equally_spaced_arfcns_s_& equally_spaced_arfcns()
    {
      assert_choice_type("equallySpacedARFCNs", type_.to_string(), "followingARFCNs");
      return c.get<equally_spaced_arfcns_s_>();
    }
    dyn_octstring& variable_bit_map_of_arfcns()
    {
      assert_choice_type("variableBitMapOfARFCNs", type_.to_string(), "followingARFCNs");
      return c.get<dyn_octstring>();
    }
    const explicit_list_of_arfcns_l& explicit_list_of_arfcns() const
    {
      assert_choice_type("explicitListOfARFCNs", type_.to_string(), "followingARFCNs");
      return c.get<explicit_list_of_arfcns_l>();
    }
    const equally_spaced_arfcns_s_& equally_spaced_arfcns() const
    {
      assert_choice_type("equallySpacedARFCNs", type_.to_string(), "followingARFCNs");
      return c.get<equally_spaced_arfcns_s_>();
    }
    const dyn_octstring& variable_bit_map_of_arfcns() const
    {
      assert_choice_type("variableBitMapOfARFCNs", type_.to_string(), "followingARFCNs");
      return c.get<dyn_octstring>();
    }
    explicit_list_of_arfcns_l& set_explicit_list_of_arfcns()
    {
      set(types::explicit_list_of_arfcns);
      return c.get<explicit_list_of_arfcns_l>();
    }
    equally_spaced_arfcns_s_& set_equally_spaced_arfcns()
    {
      set(types::equally_spaced_arfcns);
      return c.get<equally_spaced_arfcns_s_>();
    }
    dyn_octstring& set_variable_bit_map_of_arfcns()
    {
      set(types::variable_bit_map_of_arfcns);
      return c.get<dyn_octstring>();
    }

  private:
    types type_;
    choice_buffer_t<MAX4(sizeof(dyn_octstring), sizeof(equally_spaced_arfcns_s_), sizeof(explicit_list_of_arfcns_l), 0)>
        c;

    void destroy_();
  };

  // member variables
  uint16_t            start_arfcn = 0;
  band_ind_geran_e    band_ind;
  following_arfcns_c_ following_arfcns;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellReselectionSubPriority-r13 ::= ENUMERATED
struct cell_resel_sub_prio_r13_opts {
  enum options { o_dot2, o_dot4, o_dot6, o_dot8, nulltype } value;
  typedef float number_type;

  std::string to_string() const;
  float       to_number() const;
  std::string to_number_string() const;
};
typedef enumerated<cell_resel_sub_prio_r13_opts> cell_resel_sub_prio_r13_e;

// CellSelectionInfo-v1250 ::= SEQUENCE
struct cell_sel_info_v1250_s {
  // member variables
  int8_t q_qual_min_rsrq_on_all_symbols_r12 = -34;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DeltaFList-PUCCH ::= SEQUENCE
struct delta_flist_pucch_s {
  struct delta_f_pucch_format1_opts {
    enum options { delta_f_minus2, delta_f0, delta_f2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_f_pucch_format1_opts> delta_f_pucch_format1_e_;
  struct delta_f_pucch_format1b_opts {
    enum options { delta_f1, delta_f3, delta_f5, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format1b_opts> delta_f_pucch_format1b_e_;
  struct delta_f_pucch_format2_opts {
    enum options { delta_f_minus2, delta_f0, delta_f1, delta_f2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_f_pucch_format2_opts> delta_f_pucch_format2_e_;
  struct delta_f_pucch_format2a_opts {
    enum options { delta_f_minus2, delta_f0, delta_f2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_f_pucch_format2a_opts> delta_f_pucch_format2a_e_;
  struct delta_f_pucch_format2b_opts {
    enum options { delta_f_minus2, delta_f0, delta_f2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_f_pucch_format2b_opts> delta_f_pucch_format2b_e_;

  // member variables
  delta_f_pucch_format1_e_  delta_f_pucch_format1;
  delta_f_pucch_format1b_e_ delta_f_pucch_format1b;
  delta_f_pucch_format2_e_  delta_f_pucch_format2;
  delta_f_pucch_format2a_e_ delta_f_pucch_format2a;
  delta_f_pucch_format2b_e_ delta_f_pucch_format2b;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EDT-PRACH-ParametersCE-r15 ::= SEQUENCE
struct edt_prach_params_ce_r15_s {
  struct edt_prach_params_ce_r15_s_ {
    struct prach_start_sf_r15_opts {
      enum options { sf2, sf4, sf8, sf16, sf32, sf64, sf128, sf256, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<prach_start_sf_r15_opts> prach_start_sf_r15_e_;
    typedef bounded_array<uint8_t, 2>           mpdcch_nbs_to_monitor_r15_l_;

    // member variables
    bool                         prach_start_sf_r15_present = false;
    uint8_t                      prach_cfg_idx_r15          = 0;
    uint8_t                      prach_freq_offset_r15      = 0;
    prach_start_sf_r15_e_        prach_start_sf_r15;
    mpdcch_nbs_to_monitor_r15_l_ mpdcch_nbs_to_monitor_r15;
  };

  // member variables
  bool                       edt_prach_params_ce_r15_present = false;
  edt_prach_params_ce_r15_s_ edt_prach_params_ce_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FilterCoefficient ::= ENUMERATED
struct filt_coef_opts {
  enum options {
    fc0,
    fc1,
    fc2,
    fc3,
    fc4,
    fc5,
    fc6,
    fc7,
    fc8,
    fc9,
    fc11,
    fc13,
    fc15,
    fc17,
    fc19,
    spare1,
    /*...*/ nulltype
  } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<filt_coef_opts, true> filt_coef_e;

// InterFreqBlackCellList ::= SEQUENCE (SIZE (1..maxCellBlack)) OF PhysCellIdRange
typedef dyn_array<pci_range_s> inter_freq_black_cell_list_l;

// InterFreqCarrierFreqInfo-v9e0 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v9e0_s {
  // member variables
  bool                        dl_carrier_freq_v9e0_present      = false;
  bool                        multi_band_info_list_v9e0_present = false;
  uint32_t                    dl_carrier_freq_v9e0              = 65536;
  multi_band_info_list_v9e0_l multi_band_info_list_v9e0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqNeighCellList ::= SEQUENCE (SIZE (1..maxCellInter)) OF InterFreqNeighCellInfo
typedef dyn_array<inter_freq_neigh_cell_info_s> inter_freq_neigh_cell_list_l;

// InterFreqNeighHSDN-CellList-r15 ::= SEQUENCE (SIZE (1..maxCellInter)) OF PhysCellIdRange
typedef dyn_array<pci_range_s> inter_freq_neigh_hsdn_cell_list_r15_l;

// MBMS-SAI-List-r11 ::= SEQUENCE (SIZE (1..maxSAI-MBMS-r11)) OF INTEGER
typedef dyn_array<uint16_t> mbms_sai_list_r11_l;

// MTC-SSB-NR-r15 ::= SEQUENCE
struct mtc_ssb_nr_r15_s {
  struct periodicity_and_offset_r15_c_ {
    struct types_opts {
      enum options { sf5_r15, sf10_r15, sf20_r15, sf40_r15, sf80_r15, sf160_r15, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    periodicity_and_offset_r15_c_() = default;
    periodicity_and_offset_r15_c_(const periodicity_and_offset_r15_c_& other);
    periodicity_and_offset_r15_c_& operator=(const periodicity_and_offset_r15_c_& other);
    ~periodicity_and_offset_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& sf5_r15()
    {
      assert_choice_type("sf5-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    uint8_t& sf10_r15()
    {
      assert_choice_type("sf10-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    uint8_t& sf20_r15()
    {
      assert_choice_type("sf20-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    uint8_t& sf40_r15()
    {
      assert_choice_type("sf40-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    uint8_t& sf80_r15()
    {
      assert_choice_type("sf80-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    uint8_t& sf160_r15()
    {
      assert_choice_type("sf160-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    const uint8_t& sf5_r15() const
    {
      assert_choice_type("sf5-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    const uint8_t& sf10_r15() const
    {
      assert_choice_type("sf10-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    const uint8_t& sf20_r15() const
    {
      assert_choice_type("sf20-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    const uint8_t& sf40_r15() const
    {
      assert_choice_type("sf40-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    const uint8_t& sf80_r15() const
    {
      assert_choice_type("sf80-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    const uint8_t& sf160_r15() const
    {
      assert_choice_type("sf160-r15", type_.to_string(), "periodicityAndOffset-r15");
      return c.get<uint8_t>();
    }
    uint8_t& set_sf5_r15()
    {
      set(types::sf5_r15);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf10_r15()
    {
      set(types::sf10_r15);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf20_r15()
    {
      set(types::sf20_r15);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf40_r15()
    {
      set(types::sf40_r15);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf80_r15()
    {
      set(types::sf80_r15);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf160_r15()
    {
      set(types::sf160_r15);
      return c.get<uint8_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };
  struct ssb_dur_r15_opts {
    enum options { sf1, sf2, sf3, sf4, sf5, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ssb_dur_r15_opts> ssb_dur_r15_e_;

  // member variables
  periodicity_and_offset_r15_c_ periodicity_and_offset_r15;
  ssb_dur_r15_e_                ssb_dur_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasIdleCarrierEUTRA-r15 ::= SEQUENCE
struct meas_idle_carrier_eutra_r15_s {
  struct report_quantities_opts {
    enum options { rsrp, rsrq, both, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<report_quantities_opts> report_quantities_e_;
  struct quality_thres_r15_s_ {
    // member variables
    bool    idle_rsrp_thres_r15_present = false;
    bool    idle_rsrq_thres_r15_present = false;
    uint8_t idle_rsrp_thres_r15         = 0;
    int8_t  idle_rsrq_thres_r15         = -30;
  };

  // member variables
  bool                 ext                        = false;
  bool                 validity_area_r15_present  = false;
  bool                 meas_cell_list_r15_present = false;
  bool                 quality_thres_r15_present  = false;
  uint32_t             carrier_freq_r15           = 0;
  allowed_meas_bw_e    allowed_meas_bw_r15;
  cell_list_r15_l      validity_area_r15;
  cell_list_r15_l      meas_cell_list_r15;
  report_quantities_e_ report_quantities;
  quality_thres_r15_s_ quality_thres_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MultiBandInfoList ::= SEQUENCE (SIZE (1..maxMultiBands)) OF INTEGER
typedef bounded_array<uint8_t, 8> multi_band_info_list_l;

// MultiBandInfoList-r11 ::= SEQUENCE (SIZE (1..maxMultiBands)) OF INTEGER
typedef bounded_array<uint16_t, 8> multi_band_info_list_r11_l;

// MultiFrequencyBandListNR-r15 ::= SEQUENCE (SIZE (1.. maxMultiBandsNR-r15)) OF INTEGER
typedef bounded_array<uint16_t, 32> multi_freq_band_list_nr_r15_l;

// N1PUCCH-AN-InfoList-r13 ::= SEQUENCE (SIZE(1..maxCE-Level-r13)) OF INTEGER
typedef bounded_array<uint16_t, 4> n1_pucch_an_info_list_r13_l;

// NS-PmaxListNR-r15 ::= SEQUENCE (SIZE (1..8)) OF NS-PmaxValueNR-r15
typedef dyn_array<ns_pmax_value_nr_r15_s> ns_pmax_list_nr_r15_l;

// NeighCellCDMA2000 ::= SEQUENCE
struct neigh_cell_cdma2000_s {
  // member variables
  bandclass_cdma2000_e                      band_class;
  neigh_cells_per_bandclass_list_cdma2000_l neigh_cells_per_freq_list;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighCellCDMA2000-v920 ::= SEQUENCE
struct neigh_cell_cdma2000_v920_s {
  // member variables
  neigh_cells_per_bandclass_list_cdma2000_v920_l neigh_cells_per_freq_list_v920;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityList4-r12 ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF PLMN-IdentityInfo2-r12
typedef dyn_array<plmn_id_info2_r12_c> plmn_id_list4_r12_l;

// PRACH-ConfigInfo ::= SEQUENCE
struct prach_cfg_info_s {
  // member variables
  uint8_t prach_cfg_idx             = 0;
  bool    high_speed_flag           = false;
  uint8_t zero_correlation_zone_cfg = 0;
  uint8_t prach_freq_offset         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRACH-ParametersListCE-r13 ::= SEQUENCE (SIZE(1..maxCE-Level-r13)) OF PRACH-ParametersCE-r13
typedef dyn_array<prach_params_ce_r13_s> prach_params_list_ce_r13_l;

// ParametersCDMA2000-r11 ::= SEQUENCE
struct params_cdma2000_r11_s {
  struct sys_time_info_r11_c_ {
    struct types_opts {
      enum options { explicit_value, default_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sys_time_info_r11_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sys_time_info_cdma2000_s& explicit_value()
    {
      assert_choice_type("explicitValue", type_.to_string(), "systemTimeInfo-r11");
      return c;
    }
    const sys_time_info_cdma2000_s& explicit_value() const
    {
      assert_choice_type("explicitValue", type_.to_string(), "systemTimeInfo-r11");
      return c;
    }
    sys_time_info_cdma2000_s& set_explicit_value()
    {
      set(types::explicit_value);
      return c;
    }

  private:
    types                    type_;
    sys_time_info_cdma2000_s c;
  };
  struct params_hrpd_r11_s_ {
    // member variables
    bool                             cell_resel_params_hrpd_r11_present = false;
    pre_regist_info_hrpd_s           pre_regist_info_hrpd_r11;
    cell_resel_params_cdma2000_r11_s cell_resel_params_hrpd_r11;
  };
  struct params1_xrtt_r11_s_ {
    // member variables
    bool                             csfb_regist_param1_xrtt_r11_present      = false;
    bool                             csfb_regist_param1_xrtt_ext_r11_present  = false;
    bool                             long_code_state1_xrtt_r11_present        = false;
    bool                             cell_resel_params1_xrtt_r11_present      = false;
    bool                             ac_barr_cfg1_xrtt_r11_present            = false;
    bool                             csfb_support_for_dual_rx_ues_r11_present = false;
    bool                             csfb_dual_rx_tx_support_r11_present      = false;
    csfb_regist_param1_xrtt_s        csfb_regist_param1_xrtt_r11;
    csfb_regist_param1_xrtt_v920_s   csfb_regist_param1_xrtt_ext_r11;
    fixed_bitstring<42>              long_code_state1_xrtt_r11;
    cell_resel_params_cdma2000_r11_s cell_resel_params1_xrtt_r11;
    ac_barr_cfg1_xrtt_r9_s           ac_barr_cfg1_xrtt_r11;
    bool                             csfb_support_for_dual_rx_ues_r11 = false;
  };

  // member variables
  bool                 ext                       = false;
  bool                 sys_time_info_r11_present = false;
  bool                 params_hrpd_r11_present   = false;
  bool                 params1_xrtt_r11_present  = false;
  sys_time_info_r11_c_ sys_time_info_r11;
  uint8_t              search_win_size_r11 = 0;
  params_hrpd_r11_s_   params_hrpd_r11;
  params1_xrtt_r11_s_  params1_xrtt_r11;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PowerRampingParameters ::= SEQUENCE
struct pwr_ramp_params_s {
  struct pwr_ramp_step_opts {
    enum options { db0, db2, db4, db6, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pwr_ramp_step_opts> pwr_ramp_step_e_;
  struct preamb_init_rx_target_pwr_opts {
    enum options {
      dbm_minus120,
      dbm_minus118,
      dbm_minus116,
      dbm_minus114,
      dbm_minus112,
      dbm_minus110,
      dbm_minus108,
      dbm_minus106,
      dbm_minus104,
      dbm_minus102,
      dbm_minus100,
      dbm_minus98,
      dbm_minus96,
      dbm_minus94,
      dbm_minus92,
      dbm_minus90,
      nulltype
    } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<preamb_init_rx_target_pwr_opts> preamb_init_rx_target_pwr_e_;

  // member variables
  pwr_ramp_step_e_             pwr_ramp_step;
  preamb_init_rx_target_pwr_e_ preamb_init_rx_target_pwr;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PreambleTransMax ::= ENUMERATED
struct preamb_trans_max_opts {
  enum options { n3, n4, n5, n6, n7, n8, n10, n20, n50, n100, n200, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<preamb_trans_max_opts> preamb_trans_max_e;

// RACH-CE-LevelInfoList-r13 ::= SEQUENCE (SIZE (1..maxCE-Level-r13)) OF RACH-CE-LevelInfo-r13
typedef dyn_array<rach_ce_level_info_r13_s> rach_ce_level_info_list_r13_l;

// RSRP-ThresholdsPrachInfoList-r13 ::= SEQUENCE (SIZE(1..3)) OF INTEGER
typedef bounded_array<uint8_t, 3> rsrp_thress_prach_info_list_r13_l;

// RedistributionInterFreqInfo-r13 ::= SEQUENCE
struct redist_inter_freq_info_r13_s {
  // member variables
  bool                         redist_factor_freq_r13_present     = false;
  bool                         redist_neigh_cell_list_r13_present = false;
  uint8_t                      redist_factor_freq_r13             = 1;
  redist_neigh_cell_list_r13_l redist_neigh_cell_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CBR-Levels-Config-r14 ::= SEQUENCE (SIZE (1..maxCBR-Level-r14)) OF INTEGER
typedef bounded_array<uint8_t, 16> sl_cbr_levels_cfg_r14_l;

// SL-CBR-PSSCH-TxConfig-r14 ::= SEQUENCE
struct sl_cbr_pssch_tx_cfg_r14_s {
  // member variables
  uint16_t                 cr_limit_r14 = 0;
  sl_pssch_tx_params_r14_s tx_params_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscConfigOtherInterFreq-r13 ::= SEQUENCE
struct sl_disc_cfg_other_inter_freq_r13_s {
  // member variables
  bool                           tx_pwr_info_r13_present        = false;
  bool                           ref_carrier_common_r13_present = false;
  bool                           disc_sync_cfg_r13_present      = false;
  bool                           disc_cell_sel_info_r13_present = false;
  sl_disc_tx_pwr_info_list_r12_l tx_pwr_info_r13;
  sl_sync_cfg_list_nfreq_r13_l   disc_sync_cfg_r13;
  cell_sel_info_nfreq_r13_s      disc_cell_sel_info_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-HoppingConfigComm-r12 ::= SEQUENCE
struct sl_hop_cfg_comm_r12_s {
  struct num_subbands_r12_opts {
    enum options { ns1, ns2, ns4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<num_subbands_r12_opts> num_subbands_r12_e_;

  // member variables
  uint16_t            hop_param_r12 = 0;
  num_subbands_r12_e_ num_subbands_r12;
  uint8_t             rb_offset_r12 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-InterFreqInfoV2X-r14 ::= SEQUENCE
struct sl_inter_freq_info_v2x_r14_s {
  struct sl_bw_r14_opts {
    enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sl_bw_r14_opts> sl_bw_r14_e_;
  struct add_spec_emission_v2x_r14_c_ {
    struct types_opts {
      enum options { add_spec_emission_r14, add_spec_emission_v1440, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    add_spec_emission_v2x_r14_c_() = default;
    add_spec_emission_v2x_r14_c_(const add_spec_emission_v2x_r14_c_& other);
    add_spec_emission_v2x_r14_c_& operator=(const add_spec_emission_v2x_r14_c_& other);
    ~add_spec_emission_v2x_r14_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& add_spec_emission_r14()
    {
      assert_choice_type("additionalSpectrumEmission-r14", type_.to_string(), "additionalSpectrumEmissionV2X-r14");
      return c.get<uint8_t>();
    }
    uint16_t& add_spec_emission_v1440()
    {
      assert_choice_type("additionalSpectrumEmission-v1440", type_.to_string(), "additionalSpectrumEmissionV2X-r14");
      return c.get<uint16_t>();
    }
    const uint8_t& add_spec_emission_r14() const
    {
      assert_choice_type("additionalSpectrumEmission-r14", type_.to_string(), "additionalSpectrumEmissionV2X-r14");
      return c.get<uint8_t>();
    }
    const uint16_t& add_spec_emission_v1440() const
    {
      assert_choice_type("additionalSpectrumEmission-v1440", type_.to_string(), "additionalSpectrumEmissionV2X-r14");
      return c.get<uint16_t>();
    }
    uint8_t& set_add_spec_emission_r14()
    {
      set(types::add_spec_emission_r14);
      return c.get<uint8_t>();
    }
    uint16_t& set_add_spec_emission_v1440()
    {
      set(types::add_spec_emission_v1440);
      return c.get<uint16_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool                       ext                         = false;
  bool                       plmn_id_list_r14_present    = false;
  bool                       sl_max_tx_pwr_r14_present   = false;
  bool                       sl_bw_r14_present           = false;
  bool                       v2x_sched_pool_r14_present  = false;
  bool                       v2x_ue_cfg_list_r14_present = false;
  plmn_id_list_l             plmn_id_list_r14;
  uint32_t                   v2x_comm_carrier_freq_r14 = 0;
  int8_t                     sl_max_tx_pwr_r14         = -30;
  sl_bw_r14_e_               sl_bw_r14;
  sl_comm_res_pool_v2x_r14_s v2x_sched_pool_r14;
  sl_v2x_ue_cfg_list_r14_l   v2x_ue_cfg_list_r14;
  // ...
  // group 0
  bool                                   add_spec_emission_v2x_r14_present = false;
  copy_ptr<add_spec_emission_v2x_r14_c_> add_spec_emission_v2x_r14;
  // group 1
  bool                                     v2x_freq_sel_cfg_list_r15_present = false;
  copy_ptr<sl_v2x_freq_sel_cfg_list_r15_l> v2x_freq_sel_cfg_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PPPR-Dest-CarrierFreq ::= SEQUENCE
struct sl_pppr_dest_carrier_freq_s {
  // member variables
  bool                               dest_info_list_r15_present            = false;
  bool                               allowed_carrier_freq_list_r15_present = false;
  sl_dest_info_list_r12_l            dest_info_list_r15;
  sl_allowed_carrier_freq_list_r15_s allowed_carrier_freq_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PeriodComm-r12 ::= ENUMERATED
struct sl_period_comm_r12_opts {
  enum options {
    sf40,
    sf60,
    sf70,
    sf80,
    sf120,
    sf140,
    sf160,
    sf240,
    sf280,
    sf320,
    spare6,
    spare5,
    spare4,
    spare3,
    spare2,
    spare,
    nulltype
  } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<sl_period_comm_r12_opts> sl_period_comm_r12_e;

// SL-ResourcesInterFreq-r13 ::= SEQUENCE
struct sl_res_inter_freq_r13_s {
  // member variables
  bool                            disc_rx_res_inter_freq_r13_present = false;
  bool                            disc_tx_res_inter_freq_r13_present = false;
  sl_disc_rx_pool_list_r12_l      disc_rx_res_inter_freq_r13;
  sl_disc_tx_res_inter_freq_r13_c disc_tx_res_inter_freq_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-SyncConfig-r12 ::= SEQUENCE
struct sl_sync_cfg_r12_s {
  struct tx_params_r12_s_ {
    // member variables
    bool                sync_info_reserved_r12_present = false;
    sl_tx_params_r12_s  sync_tx_params_r12;
    uint8_t             sync_tx_thresh_ic_r12 = 0;
    fixed_bitstring<19> sync_info_reserved_r12;
  };
  struct rx_params_ncell_r12_s_ {
    struct disc_sync_win_r12_opts {
      enum options { w1, w2, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<disc_sync_win_r12_opts> disc_sync_win_r12_e_;

    // member variables
    uint16_t             pci_r12 = 0;
    disc_sync_win_r12_e_ disc_sync_win_r12;
  };

  // member variables
  bool                   ext                         = false;
  bool                   tx_params_r12_present       = false;
  bool                   rx_params_ncell_r12_present = false;
  sl_cp_len_r12_e        sync_cp_len_r12;
  uint8_t                sync_offset_ind_r12 = 0;
  uint8_t                slssid_r12          = 0;
  tx_params_r12_s_       tx_params_r12;
  rx_params_ncell_r12_s_ rx_params_ncell_r12;
  // ...
  // group 0
  bool sync_tx_periodic_r13_present = false;
  // group 1
  bool    sync_offset_ind_v1430_present = false;
  bool    gnss_sync_r14_present         = false;
  uint8_t sync_offset_ind_v1430         = 40;
  // group 2
  bool    sync_offset_ind2_r14_present = false;
  bool    sync_offset_ind3_r14_present = false;
  uint8_t sync_offset_ind2_r14         = 0;
  uint8_t sync_offset_ind3_r14         = 0;
  // group 3
  bool slss_tx_disabled_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SS-RSSI-Measurement-r15 ::= SEQUENCE
struct ss_rssi_meas_r15_s {
  // member variables
  dyn_bitstring meas_slots_r15;
  uint8_t       end_symbol_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v10l0-IEs ::= SEQUENCE
struct sib_type1_v10l0_ies_s {
  // member variables
  bool                         freq_band_info_v10l0_present       = false;
  bool                         multi_band_info_list_v10l0_present = false;
  bool                         non_crit_ext_present               = false;
  ns_pmax_list_v10l0_l         freq_band_info_v10l0;
  multi_band_info_list_v10l0_l multi_band_info_list_v10l0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v1310-IEs ::= SEQUENCE
struct sib_type1_v1310_ies_s {
  struct bw_reduced_access_related_info_r13_s_ {
    struct si_win_len_br_r13_opts {
      enum options { ms20, ms40, ms60, ms80, ms120, ms160, ms200, spare, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<si_win_len_br_r13_opts> si_win_len_br_r13_e_;
    struct si_repeat_pattern_r13_opts {
      enum options { every_rf, every2nd_rf, every4th_rf, every8th_rf, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<si_repeat_pattern_r13_opts> si_repeat_pattern_r13_e_;
    struct fdd_dl_or_tdd_sf_bitmap_br_r13_c_ {
      struct types_opts {
        enum options { sf_pattern10_r13, sf_pattern40_r13, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      fdd_dl_or_tdd_sf_bitmap_br_r13_c_() = default;
      fdd_dl_or_tdd_sf_bitmap_br_r13_c_(const fdd_dl_or_tdd_sf_bitmap_br_r13_c_& other);
      fdd_dl_or_tdd_sf_bitmap_br_r13_c_& operator=(const fdd_dl_or_tdd_sf_bitmap_br_r13_c_& other);
      ~fdd_dl_or_tdd_sf_bitmap_br_r13_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      fixed_bitstring<10>& sf_pattern10_r13()
      {
        assert_choice_type("subframePattern10-r13", type_.to_string(), "fdd-DownlinkOrTddSubframeBitmapBR-r13");
        return c.get<fixed_bitstring<10> >();
      }
      fixed_bitstring<40>& sf_pattern40_r13()
      {
        assert_choice_type("subframePattern40-r13", type_.to_string(), "fdd-DownlinkOrTddSubframeBitmapBR-r13");
        return c.get<fixed_bitstring<40> >();
      }
      const fixed_bitstring<10>& sf_pattern10_r13() const
      {
        assert_choice_type("subframePattern10-r13", type_.to_string(), "fdd-DownlinkOrTddSubframeBitmapBR-r13");
        return c.get<fixed_bitstring<10> >();
      }
      const fixed_bitstring<40>& sf_pattern40_r13() const
      {
        assert_choice_type("subframePattern40-r13", type_.to_string(), "fdd-DownlinkOrTddSubframeBitmapBR-r13");
        return c.get<fixed_bitstring<40> >();
      }
      fixed_bitstring<10>& set_sf_pattern10_r13()
      {
        set(types::sf_pattern10_r13);
        return c.get<fixed_bitstring<10> >();
      }
      fixed_bitstring<40>& set_sf_pattern40_r13()
      {
        set(types::sf_pattern40_r13);
        return c.get<fixed_bitstring<40> >();
      }

    private:
      types                                        type_;
      choice_buffer_t<sizeof(fixed_bitstring<40>)> c;

      void destroy_();
    };
    struct si_hop_cfg_common_r13_opts {
      enum options { on, off, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<si_hop_cfg_common_r13_opts> si_hop_cfg_common_r13_e_;

    // member variables
    bool                              sched_info_list_br_r13_present         = false;
    bool                              fdd_dl_or_tdd_sf_bitmap_br_r13_present = false;
    bool                              fdd_ul_sf_bitmap_br_r13_present        = false;
    bool                              si_validity_time_r13_present           = false;
    bool                              sys_info_value_tag_list_r13_present    = false;
    si_win_len_br_r13_e_              si_win_len_br_r13;
    si_repeat_pattern_r13_e_          si_repeat_pattern_r13;
    sched_info_list_br_r13_l          sched_info_list_br_r13;
    fdd_dl_or_tdd_sf_bitmap_br_r13_c_ fdd_dl_or_tdd_sf_bitmap_br_r13;
    fixed_bitstring<10>               fdd_ul_sf_bitmap_br_r13;
    uint8_t                           start_symbol_br_r13 = 1;
    si_hop_cfg_common_r13_e_          si_hop_cfg_common_r13;
    sys_info_value_tag_list_r13_l     sys_info_value_tag_list_r13;
  };

  // member variables
  bool                                  hyper_sfn_r13_present                      = false;
  bool                                  e_drx_allowed_r13_present                  = false;
  bool                                  cell_sel_info_ce_r13_present               = false;
  bool                                  bw_reduced_access_related_info_r13_present = false;
  bool                                  non_crit_ext_present                       = false;
  fixed_bitstring<10>                   hyper_sfn_r13;
  cell_sel_info_ce_r13_s                cell_sel_info_ce_r13;
  bw_reduced_access_related_info_r13_s_ bw_reduced_access_related_info_r13;
  sib_type1_v1320_ies_s                 non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType2-v9i0-IEs ::= SEQUENCE
struct sib_type2_v9i0_ies_s {
  // member variables
  bool          non_crit_ext_present = false;
  bool          dummy_present        = false;
  dyn_octstring non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType5-v10j0-IEs ::= SEQUENCE
struct sib_type5_v10j0_ies_s {
  typedef dyn_array<inter_freq_carrier_freq_info_v10j0_s> inter_freq_carrier_freq_list_v10j0_l_;

  // member variables
  bool                                  inter_freq_carrier_freq_list_v10j0_present = false;
  bool                                  non_crit_ext_present                       = false;
  inter_freq_carrier_freq_list_v10j0_l_ inter_freq_carrier_freq_list_v10j0;
  sib_type5_v10l0_ies_s                 non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ThresholdListNR-r15 ::= SEQUENCE
struct thres_list_nr_r15_s {
  // member variables
  bool    nr_rsrp_r15_present = false;
  bool    nr_rsrq_r15_present = false;
  bool    nr_sinr_r15_present = false;
  uint8_t nr_rsrp_r15         = 0;
  uint8_t nr_rsrq_r15         = 0;
  uint8_t nr_sinr_r15         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UAC-BarringPerCatList-r15 ::= SEQUENCE (SIZE (1..maxAccessCat-1-r15)) OF UAC-BarringPerCat-r15
typedef dyn_array<uac_barr_per_cat_r15_s> uac_barr_per_cat_list_r15_l;

// UDT-Restricting-r13 ::= SEQUENCE
struct udt_restricting_r13_s {
  struct udt_restricting_time_r13_opts {
    enum options { s4, s8, s16, s32, s64, s128, s256, s512, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<udt_restricting_time_r13_opts> udt_restricting_time_r13_e_;

  // member variables
  bool                        udt_restricting_r13_present      = false;
  bool                        udt_restricting_time_r13_present = false;
  udt_restricting_time_r13_e_ udt_restricting_time_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-ReferenceSignalsPUSCH ::= SEQUENCE
struct ul_ref_sigs_pusch_s {
  // member variables
  bool    group_hop_enabled  = false;
  uint8_t group_assign_pusch = 0;
  bool    seq_hop_enabled    = false;
  uint8_t cyclic_shift       = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-Identifiers-r12 ::= SEQUENCE
struct wlan_ids_r12_s {
  // member variables
  bool               ext                = false;
  bool               ssid_r12_present   = false;
  bool               bssid_r12_present  = false;
  bool               hessid_r12_present = false;
  dyn_octstring      ssid_r12;
  fixed_octstring<6> bssid_r12;
  fixed_octstring<6> hessid_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-backhaulRate-r12 ::= ENUMERATED
struct wlan_backhaul_rate_r12_opts {
  enum options {
    r0,
    r4,
    r8,
    r16,
    r32,
    r64,
    r128,
    r256,
    r512,
    r1024,
    r2048,
    r4096,
    r8192,
    r16384,
    r32768,
    r65536,
    r131072,
    r262144,
    r524288,
    r1048576,
    r2097152,
    r4194304,
    r8388608,
    r16777216,
    r33554432,
    r67108864,
    r134217728,
    r268435456,
    r536870912,
    r1073741824,
    r2147483648,
    r4294967296,
    nulltype
  } value;
  typedef uint64_t number_type;

  std::string to_string() const;
  uint64_t    to_number() const;
};
typedef enumerated<wlan_backhaul_rate_r12_opts> wlan_backhaul_rate_r12_e;

// AC-BarringPerPLMN-r12 ::= SEQUENCE
struct ac_barr_per_plmn_r12_s {
  struct ac_barr_info_r12_s_ {
    // member variables
    bool          ac_barr_for_mo_sig_r12_present  = false;
    bool          ac_barr_for_mo_data_r12_present = false;
    bool          ac_barr_for_emergency_r12       = false;
    ac_barr_cfg_s ac_barr_for_mo_sig_r12;
    ac_barr_cfg_s ac_barr_for_mo_data_r12;
  };

  // member variables
  bool                ac_barr_info_r12_present                 = false;
  bool                ac_barr_skip_for_mmtel_voice_r12_present = false;
  bool                ac_barr_skip_for_mmtel_video_r12_present = false;
  bool                ac_barr_skip_for_sms_r12_present         = false;
  bool                ac_barr_for_csfb_r12_present             = false;
  bool                ssac_barr_for_mmtel_voice_r12_present    = false;
  bool                ssac_barr_for_mmtel_video_r12_present    = false;
  uint8_t             plmn_id_idx_r12                          = 1;
  ac_barr_info_r12_s_ ac_barr_info_r12;
  ac_barr_cfg_s       ac_barr_for_csfb_r12;
  ac_barr_cfg_s       ssac_barr_for_mmtel_voice_r12;
  ac_barr_cfg_s       ssac_barr_for_mmtel_video_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ACDC-BarringPerPLMN-r13 ::= SEQUENCE
struct acdc_barr_per_plmn_r13_s {
  // member variables
  uint8_t                           plmn_id_idx_r13         = 1;
  bool                              acdc_only_for_hplmn_r13 = false;
  barr_per_acdc_category_list_r13_l barr_per_acdc_category_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BCCH-Config ::= SEQUENCE
struct bcch_cfg_s {
  struct mod_period_coeff_opts {
    enum options { n2, n4, n8, n16, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<mod_period_coeff_opts> mod_period_coeff_e_;

  // member variables
  mod_period_coeff_e_ mod_period_coeff;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BCCH-Config-v1310 ::= SEQUENCE
struct bcch_cfg_v1310_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CIOT-OptimisationPLMN-r13 ::= SEQUENCE
struct ciot_optim_plmn_r13_s {
  // member variables
  bool up_cio_t_eps_optim_r13_present         = false;
  bool cp_cio_t_eps_optim_r13_present         = false;
  bool attach_without_pdn_connect_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqInfoUTRA-FDD-v8h0 ::= SEQUENCE
struct carrier_freq_info_utra_fdd_v8h0_s {
  typedef bounded_array<uint8_t, 8> multi_band_info_list_l_;

  // member variables
  bool                    multi_band_info_list_present = false;
  multi_band_info_list_l_ multi_band_info_list;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqNR-r15 ::= SEQUENCE
struct carrier_freq_nr_r15_s {
  struct subcarrier_spacing_ssb_r15_opts {
    enum options { k_hz15, k_hz30, k_hz120, k_hz240, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<subcarrier_spacing_ssb_r15_opts> subcarrier_spacing_ssb_r15_e_;
  struct thresh_x_q_r15_s_ {
    // member variables
    uint8_t thresh_x_high_q_r15 = 0;
    uint8_t thresh_x_low_q_r15  = 0;
  };

  // member variables
  bool                          ext                                  = false;
  bool                          multi_band_info_list_r15_present     = false;
  bool                          multi_band_info_list_sul_r15_present = false;
  bool                          meas_timing_cfg_r15_present          = false;
  bool                          ss_rssi_meas_r15_present             = false;
  bool                          cell_resel_prio_r15_present          = false;
  bool                          cell_resel_sub_prio_r15_present      = false;
  bool                          thresh_x_q_r15_present               = false;
  bool                          q_rx_lev_min_sul_r15_present         = false;
  bool                          ns_pmax_list_nr_r15_present          = false;
  bool                          q_qual_min_r15_present               = false;
  bool                          max_rs_idx_cell_qual_r15_present     = false;
  bool                          thresh_rs_idx_r15_present            = false;
  uint32_t                      carrier_freq_r15                     = 0;
  multi_freq_band_list_nr_r15_l multi_band_info_list_r15;
  multi_freq_band_list_nr_r15_l multi_band_info_list_sul_r15;
  mtc_ssb_nr_r15_s              meas_timing_cfg_r15;
  subcarrier_spacing_ssb_r15_e_ subcarrier_spacing_ssb_r15;
  ss_rssi_meas_r15_s            ss_rssi_meas_r15;
  uint8_t                       cell_resel_prio_r15 = 0;
  cell_resel_sub_prio_r13_e     cell_resel_sub_prio_r15;
  uint8_t                       thresh_x_high_r15 = 0;
  uint8_t                       thresh_x_low_r15  = 0;
  thresh_x_q_r15_s_             thresh_x_q_r15;
  int8_t                        q_rx_lev_min_r15     = -70;
  int8_t                        q_rx_lev_min_sul_r15 = -70;
  int8_t                        p_max_nr_r15         = -30;
  ns_pmax_list_nr_r15_l         ns_pmax_list_nr_r15;
  int8_t                        q_qual_min_r15               = -34;
  bool                          derive_ssb_idx_from_cell_r15 = false;
  uint8_t                       max_rs_idx_cell_qual_r15     = 1;
  thres_list_nr_r15_s           thresh_rs_idx_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqUTRA-FDD ::= SEQUENCE
struct carrier_freq_utra_fdd_s {
  struct thresh_x_q_r9_s_ {
    // member variables
    uint8_t thresh_x_high_q_r9 = 0;
    uint8_t thresh_x_low_q_r9  = 0;
  };

  // member variables
  bool     ext                     = false;
  bool     cell_resel_prio_present = false;
  uint16_t carrier_freq            = 0;
  uint8_t  cell_resel_prio         = 0;
  uint8_t  thresh_x_high           = 0;
  uint8_t  thresh_x_low            = 0;
  int8_t   q_rx_lev_min            = -60;
  int8_t   p_max_utra              = -50;
  int8_t   q_qual_min              = -24;
  // ...
  // group 0
  bool                       thresh_x_q_r9_present = false;
  copy_ptr<thresh_x_q_r9_s_> thresh_x_q_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqUTRA-FDD-Ext-r12 ::= SEQUENCE
struct carrier_freq_utra_fdd_ext_r12_s {
  struct thresh_x_q_r12_s_ {
    // member variables
    uint8_t thresh_x_high_q_r12 = 0;
    uint8_t thresh_x_low_q_r12  = 0;
  };
  typedef bounded_array<uint8_t, 8> multi_band_info_list_r12_l_;

  // member variables
  bool                        ext                                  = false;
  bool                        cell_resel_prio_r12_present          = false;
  bool                        thresh_x_q_r12_present               = false;
  bool                        multi_band_info_list_r12_present     = false;
  bool                        reduced_meas_performance_r12_present = false;
  uint16_t                    carrier_freq_r12                     = 0;
  uint8_t                     cell_resel_prio_r12                  = 0;
  uint8_t                     thresh_x_high_r12                    = 0;
  uint8_t                     thresh_x_low_r12                     = 0;
  int8_t                      q_rx_lev_min_r12                     = -60;
  int8_t                      p_max_utra_r12                       = -50;
  int8_t                      q_qual_min_r12                       = -24;
  thresh_x_q_r12_s_           thresh_x_q_r12;
  multi_band_info_list_r12_l_ multi_band_info_list_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqUTRA-TDD ::= SEQUENCE
struct carrier_freq_utra_tdd_s {
  // member variables
  bool     ext                     = false;
  bool     cell_resel_prio_present = false;
  uint16_t carrier_freq            = 0;
  uint8_t  cell_resel_prio         = 0;
  uint8_t  thresh_x_high           = 0;
  uint8_t  thresh_x_low            = 0;
  int8_t   q_rx_lev_min            = -60;
  int8_t   p_max_utra              = -50;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqUTRA-TDD-r12 ::= SEQUENCE
struct carrier_freq_utra_tdd_r12_s {
  // member variables
  bool     ext                                  = false;
  bool     cell_resel_prio_r12_present          = false;
  bool     reduced_meas_performance_r12_present = false;
  uint16_t carrier_freq_r12                     = 0;
  uint8_t  cell_resel_prio_r12                  = 0;
  uint8_t  thresh_x_high_r12                    = 0;
  uint8_t  thresh_x_low_r12                     = 0;
  int8_t   q_rx_lev_min_r12                     = -60;
  int8_t   p_max_utra_r12                       = -50;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqsInfoGERAN ::= SEQUENCE
struct carrier_freqs_info_geran_s {
  struct common_info_s_ {
    // member variables
    bool               cell_resel_prio_present = false;
    bool               p_max_geran_present     = false;
    uint8_t            cell_resel_prio         = 0;
    fixed_bitstring<8> ncc_permitted;
    uint8_t            q_rx_lev_min  = 0;
    uint8_t            p_max_geran   = 0;
    uint8_t            thresh_x_high = 0;
    uint8_t            thresh_x_low  = 0;
  };

  // member variables
  bool                  ext = false;
  carrier_freqs_geran_s carrier_freqs;
  common_info_s_        common_info;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellSelectionInfo-v1130 ::= SEQUENCE
struct cell_sel_info_v1130_s {
  // member variables
  int8_t q_qual_min_wb_r11 = -34;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EAB-Config-r11 ::= SEQUENCE
struct eab_cfg_r11_s {
  struct eab_category_r11_opts {
    enum options { a, b, c, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<eab_category_r11_opts> eab_category_r11_e_;

  // member variables
  eab_category_r11_e_ eab_category_r11;
  fixed_bitstring<10> eab_barr_bitmap_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EUTRA-CarrierList-r15 ::= SEQUENCE (SIZE (1..maxFreqIdle-r15)) OF MeasIdleCarrierEUTRA-r15
typedef dyn_array<meas_idle_carrier_eutra_r15_s> eutra_carrier_list_r15_l;

// FreqHoppingParameters-r13 ::= SEQUENCE
struct freq_hop_params_r13_s {
  struct dummy_opts {
    enum options { nb2, nb4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<dummy_opts> dummy_e_;
  struct dummy2_c_ {
    struct interv_fdd_r13_opts {
      enum options { int1, int2, int4, int8, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_fdd_r13_opts> interv_fdd_r13_e_;
    struct interv_tdd_r13_opts {
      enum options { int1, int5, int10, int20, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_tdd_r13_opts> interv_tdd_r13_e_;
    struct types_opts {
      enum options { interv_fdd_r13, interv_tdd_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    dummy2_c_() = default;
    dummy2_c_(const dummy2_c_& other);
    dummy2_c_& operator=(const dummy2_c_& other);
    ~dummy2_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    interv_fdd_r13_e_& interv_fdd_r13()
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "dummy2");
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& interv_tdd_r13()
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "dummy2");
      return c.get<interv_tdd_r13_e_>();
    }
    const interv_fdd_r13_e_& interv_fdd_r13() const
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "dummy2");
      return c.get<interv_fdd_r13_e_>();
    }
    const interv_tdd_r13_e_& interv_tdd_r13() const
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "dummy2");
      return c.get<interv_tdd_r13_e_>();
    }
    interv_fdd_r13_e_& set_interv_fdd_r13()
    {
      set(types::interv_fdd_r13);
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& set_interv_tdd_r13()
    {
      set(types::interv_tdd_r13);
      return c.get<interv_tdd_r13_e_>();
    }

  private:
    types                                                                       type_;
    choice_buffer_t<MAX2(sizeof(interv_fdd_r13_e_), sizeof(interv_tdd_r13_e_))> c;

    void destroy_();
  };
  struct dummy3_c_ {
    struct interv_fdd_r13_opts {
      enum options { int2, int4, int8, int16, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_fdd_r13_opts> interv_fdd_r13_e_;
    struct interv_tdd_r13_opts {
      enum options { int5, int10, int20, int40, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_tdd_r13_opts> interv_tdd_r13_e_;
    struct types_opts {
      enum options { interv_fdd_r13, interv_tdd_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    dummy3_c_() = default;
    dummy3_c_(const dummy3_c_& other);
    dummy3_c_& operator=(const dummy3_c_& other);
    ~dummy3_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    interv_fdd_r13_e_& interv_fdd_r13()
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "dummy3");
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& interv_tdd_r13()
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "dummy3");
      return c.get<interv_tdd_r13_e_>();
    }
    const interv_fdd_r13_e_& interv_fdd_r13() const
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "dummy3");
      return c.get<interv_fdd_r13_e_>();
    }
    const interv_tdd_r13_e_& interv_tdd_r13() const
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "dummy3");
      return c.get<interv_tdd_r13_e_>();
    }
    interv_fdd_r13_e_& set_interv_fdd_r13()
    {
      set(types::interv_fdd_r13);
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& set_interv_tdd_r13()
    {
      set(types::interv_tdd_r13);
      return c.get<interv_tdd_r13_e_>();
    }

  private:
    types                                                                       type_;
    choice_buffer_t<MAX2(sizeof(interv_fdd_r13_e_), sizeof(interv_tdd_r13_e_))> c;

    void destroy_();
  };
  struct interv_ul_hop_cfg_common_mode_a_r13_c_ {
    struct interv_fdd_r13_opts {
      enum options { int1, int2, int4, int8, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_fdd_r13_opts> interv_fdd_r13_e_;
    struct interv_tdd_r13_opts {
      enum options { int1, int5, int10, int20, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_tdd_r13_opts> interv_tdd_r13_e_;
    struct types_opts {
      enum options { interv_fdd_r13, interv_tdd_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    interv_ul_hop_cfg_common_mode_a_r13_c_() = default;
    interv_ul_hop_cfg_common_mode_a_r13_c_(const interv_ul_hop_cfg_common_mode_a_r13_c_& other);
    interv_ul_hop_cfg_common_mode_a_r13_c_& operator=(const interv_ul_hop_cfg_common_mode_a_r13_c_& other);
    ~interv_ul_hop_cfg_common_mode_a_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    interv_fdd_r13_e_& interv_fdd_r13()
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeA-r13");
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& interv_tdd_r13()
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeA-r13");
      return c.get<interv_tdd_r13_e_>();
    }
    const interv_fdd_r13_e_& interv_fdd_r13() const
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeA-r13");
      return c.get<interv_fdd_r13_e_>();
    }
    const interv_tdd_r13_e_& interv_tdd_r13() const
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeA-r13");
      return c.get<interv_tdd_r13_e_>();
    }
    interv_fdd_r13_e_& set_interv_fdd_r13()
    {
      set(types::interv_fdd_r13);
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& set_interv_tdd_r13()
    {
      set(types::interv_tdd_r13);
      return c.get<interv_tdd_r13_e_>();
    }

  private:
    types                                                                       type_;
    choice_buffer_t<MAX2(sizeof(interv_fdd_r13_e_), sizeof(interv_tdd_r13_e_))> c;

    void destroy_();
  };
  struct interv_ul_hop_cfg_common_mode_b_r13_c_ {
    struct interv_fdd_r13_opts {
      enum options { int2, int4, int8, int16, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_fdd_r13_opts> interv_fdd_r13_e_;
    struct interv_tdd_r13_opts {
      enum options { int5, int10, int20, int40, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<interv_tdd_r13_opts> interv_tdd_r13_e_;
    struct types_opts {
      enum options { interv_fdd_r13, interv_tdd_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    interv_ul_hop_cfg_common_mode_b_r13_c_() = default;
    interv_ul_hop_cfg_common_mode_b_r13_c_(const interv_ul_hop_cfg_common_mode_b_r13_c_& other);
    interv_ul_hop_cfg_common_mode_b_r13_c_& operator=(const interv_ul_hop_cfg_common_mode_b_r13_c_& other);
    ~interv_ul_hop_cfg_common_mode_b_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    interv_fdd_r13_e_& interv_fdd_r13()
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeB-r13");
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& interv_tdd_r13()
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeB-r13");
      return c.get<interv_tdd_r13_e_>();
    }
    const interv_fdd_r13_e_& interv_fdd_r13() const
    {
      assert_choice_type("interval-FDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeB-r13");
      return c.get<interv_fdd_r13_e_>();
    }
    const interv_tdd_r13_e_& interv_tdd_r13() const
    {
      assert_choice_type("interval-TDD-r13", type_.to_string(), "interval-ULHoppingConfigCommonModeB-r13");
      return c.get<interv_tdd_r13_e_>();
    }
    interv_fdd_r13_e_& set_interv_fdd_r13()
    {
      set(types::interv_fdd_r13);
      return c.get<interv_fdd_r13_e_>();
    }
    interv_tdd_r13_e_& set_interv_tdd_r13()
    {
      set(types::interv_tdd_r13);
      return c.get<interv_tdd_r13_e_>();
    }

  private:
    types                                                                       type_;
    choice_buffer_t<MAX2(sizeof(interv_fdd_r13_e_), sizeof(interv_tdd_r13_e_))> c;

    void destroy_();
  };

  // member variables
  bool                                   dummy_present                               = false;
  bool                                   dummy2_present                              = false;
  bool                                   dummy3_present                              = false;
  bool                                   interv_ul_hop_cfg_common_mode_a_r13_present = false;
  bool                                   interv_ul_hop_cfg_common_mode_b_r13_present = false;
  bool                                   dummy4_present                              = false;
  dummy_e_                               dummy;
  dummy2_c_                              dummy2;
  dummy3_c_                              dummy3;
  interv_ul_hop_cfg_common_mode_a_r13_c_ interv_ul_hop_cfg_common_mode_a_r13;
  interv_ul_hop_cfg_common_mode_b_r13_c_ interv_ul_hop_cfg_common_mode_b_r13;
  uint8_t                                dummy4 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HighSpeedConfig-r14 ::= SEQUENCE
struct high_speed_cfg_r14_s {
  // member variables
  bool high_speed_enhanced_meas_flag_r14_present  = false;
  bool high_speed_enhanced_demod_flag_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HighSpeedConfig-v1530 ::= SEQUENCE
struct high_speed_cfg_v1530_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqInfo ::= SEQUENCE
struct inter_freq_carrier_freq_info_s {
  struct thresh_x_q_r9_s_ {
    // member variables
    uint8_t thresh_x_high_q_r9 = 0;
    uint8_t thresh_x_low_q_r9  = 0;
  };

  // member variables
  bool                         ext                                = false;
  bool                         p_max_present                      = false;
  bool                         t_resel_eutra_sf_present           = false;
  bool                         cell_resel_prio_present            = false;
  bool                         q_offset_freq_present              = false;
  bool                         inter_freq_neigh_cell_list_present = false;
  bool                         inter_freq_black_cell_list_present = false;
  uint16_t                     dl_carrier_freq                    = 0;
  int8_t                       q_rx_lev_min                       = -70;
  int8_t                       p_max                              = -30;
  uint8_t                      t_resel_eutra                      = 0;
  speed_state_scale_factors_s  t_resel_eutra_sf;
  uint8_t                      thresh_x_high = 0;
  uint8_t                      thresh_x_low  = 0;
  allowed_meas_bw_e            allowed_meas_bw;
  bool                         presence_ant_port1 = false;
  uint8_t                      cell_resel_prio    = 0;
  fixed_bitstring<2>           neigh_cell_cfg;
  q_offset_range_e             q_offset_freq;
  inter_freq_neigh_cell_list_l inter_freq_neigh_cell_list;
  inter_freq_black_cell_list_l inter_freq_black_cell_list;
  // ...
  // group 0
  bool                       q_qual_min_r9_present = false;
  bool                       thresh_x_q_r9_present = false;
  int8_t                     q_qual_min_r9         = -34;
  copy_ptr<thresh_x_q_r9_s_> thresh_x_q_r9;
  // group 1
  bool   q_qual_min_wb_r11_present = false;
  int8_t q_qual_min_wb_r11         = -34;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqInfo-r12 ::= SEQUENCE
struct inter_freq_carrier_freq_info_r12_s {
  struct thresh_x_q_r12_s_ {
    // member variables
    uint8_t thresh_x_high_q_r12 = 0;
    uint8_t thresh_x_low_q_r12  = 0;
  };

  // member variables
  bool                         ext                                        = false;
  bool                         p_max_r12_present                          = false;
  bool                         t_resel_eutra_sf_r12_present               = false;
  bool                         cell_resel_prio_r12_present                = false;
  bool                         q_offset_freq_r12_present                  = false;
  bool                         inter_freq_neigh_cell_list_r12_present     = false;
  bool                         inter_freq_black_cell_list_r12_present     = false;
  bool                         q_qual_min_r12_present                     = false;
  bool                         thresh_x_q_r12_present                     = false;
  bool                         q_qual_min_wb_r12_present                  = false;
  bool                         multi_band_info_list_r12_present           = false;
  bool                         reduced_meas_performance_r12_present       = false;
  bool                         q_qual_min_rsrq_on_all_symbols_r12_present = false;
  uint32_t                     dl_carrier_freq_r12                        = 0;
  int8_t                       q_rx_lev_min_r12                           = -70;
  int8_t                       p_max_r12                                  = -30;
  uint8_t                      t_resel_eutra_r12                          = 0;
  speed_state_scale_factors_s  t_resel_eutra_sf_r12;
  uint8_t                      thresh_x_high_r12 = 0;
  uint8_t                      thresh_x_low_r12  = 0;
  allowed_meas_bw_e            allowed_meas_bw_r12;
  bool                         presence_ant_port1_r12 = false;
  uint8_t                      cell_resel_prio_r12    = 0;
  fixed_bitstring<2>           neigh_cell_cfg_r12;
  q_offset_range_e             q_offset_freq_r12;
  inter_freq_neigh_cell_list_l inter_freq_neigh_cell_list_r12;
  inter_freq_black_cell_list_l inter_freq_black_cell_list_r12;
  int8_t                       q_qual_min_r12 = -34;
  thresh_x_q_r12_s_            thresh_x_q_r12;
  int8_t                       q_qual_min_wb_r12 = -34;
  multi_band_info_list_r11_l   multi_band_info_list_r12;
  int8_t                       q_qual_min_rsrq_on_all_symbols_r12 = -34;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqInfo-v1250 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v1250_s {
  // member variables
  bool   reduced_meas_performance_r12_present       = false;
  bool   q_qual_min_rsrq_on_all_symbols_r12_present = false;
  int8_t q_qual_min_rsrq_on_all_symbols_r12         = -34;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqInfo-v1310 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v1310_s {
  // member variables
  bool                         cell_resel_sub_prio_r13_present    = false;
  bool                         redist_inter_freq_info_r13_present = false;
  bool                         cell_sel_info_ce_r13_present       = false;
  bool                         t_resel_eutra_ce_r13_present       = false;
  cell_resel_sub_prio_r13_e    cell_resel_sub_prio_r13;
  redist_inter_freq_info_r13_s redist_inter_freq_info_r13;
  cell_sel_info_ce_r13_s       cell_sel_info_ce_r13;
  uint8_t                      t_resel_eutra_ce_r13 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqInfo-v1350 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v1350_s {
  // member variables
  bool                    cell_sel_info_ce1_r13_present = false;
  cell_sel_info_ce1_r13_s cell_sel_info_ce1_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqInfo-v1530 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v1530_s {
  // member variables
  bool                                  inter_freq_neigh_hsdn_cell_list_r15_present = false;
  bool                                  cell_sel_info_ce_v1530_present              = false;
  bool                                  hsdn_ind_r15                                = false;
  inter_freq_neigh_hsdn_cell_list_r15_l inter_freq_neigh_hsdn_cell_list_r15;
  cell_sel_info_ce_v1530_s              cell_sel_info_ce_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqInfo-v8h0 ::= SEQUENCE
struct inter_freq_carrier_freq_info_v8h0_s {
  // member variables
  bool                   multi_band_info_list_present = false;
  multi_band_info_list_l multi_band_info_list;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IntraFreqNeighCellInfo ::= SEQUENCE
struct intra_freq_neigh_cell_info_s {
  // member variables
  bool             ext = false;
  uint16_t         pci = 0;
  q_offset_range_e q_offset_cell;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-CarrierType-r14 ::= SEQUENCE
struct mbms_carrier_type_r14_s {
  struct carrier_type_r14_opts {
    enum options { mbms, fembms_mixed, fembms_ded, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<carrier_type_r14_opts> carrier_type_r14_e_;

  // member variables
  bool                frame_offset_r14_present = false;
  carrier_type_r14_e_ carrier_type_r14;
  uint8_t             frame_offset_r14 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-SAI-InterFreq-r11 ::= SEQUENCE
struct mbms_sai_inter_freq_r11_s {
  // member variables
  uint32_t            dl_carrier_freq_r11 = 0;
  mbms_sai_list_r11_l mbms_sai_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-SAI-InterFreq-v1140 ::= SEQUENCE
struct mbms_sai_inter_freq_v1140_s {
  // member variables
  bool                       multi_band_info_list_r11_present = false;
  multi_band_info_list_r11_l multi_band_info_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSFN-AreaInfo-r9 ::= SEQUENCE
struct mbsfn_area_info_r9_s {
  struct non_mbsfn_region_len_opts {
    enum options { s1, s2, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<non_mbsfn_region_len_opts> non_mbsfn_region_len_e_;
  struct mcch_cfg_r9_s_ {
    struct mcch_repeat_period_r9_opts {
      enum options { rf32, rf64, rf128, rf256, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<mcch_repeat_period_r9_opts> mcch_repeat_period_r9_e_;
    struct mcch_mod_period_r9_opts {
      enum options { rf512, rf1024, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<mcch_mod_period_r9_opts> mcch_mod_period_r9_e_;
    struct sig_mcs_r9_opts {
      enum options { n2, n7, n13, n19, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<sig_mcs_r9_opts> sig_mcs_r9_e_;

    // member variables
    mcch_repeat_period_r9_e_ mcch_repeat_period_r9;
    uint8_t                  mcch_offset_r9 = 0;
    mcch_mod_period_r9_e_    mcch_mod_period_r9;
    fixed_bitstring<6>       sf_alloc_info_r9;
    sig_mcs_r9_e_            sig_mcs_r9;
  };
  struct mcch_cfg_r14_s_ {
    struct mcch_repeat_period_v1430_opts {
      enum options { rf1, rf2, rf4, rf8, rf16, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<mcch_repeat_period_v1430_opts> mcch_repeat_period_v1430_e_;
    struct mcch_mod_period_v1430_opts {
      enum options { rf1, rf2, rf4, rf8, rf16, rf32, rf64, rf128, rf256, spare7, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<mcch_mod_period_v1430_opts> mcch_mod_period_v1430_e_;

    // member variables
    bool                        mcch_repeat_period_v1430_present = false;
    bool                        mcch_mod_period_v1430_present    = false;
    mcch_repeat_period_v1430_e_ mcch_repeat_period_v1430;
    mcch_mod_period_v1430_e_    mcch_mod_period_v1430;
  };
  struct subcarrier_spacing_mbms_r14_opts {
    enum options { khz_minus7dot5, khz_minus1dot25, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<subcarrier_spacing_mbms_r14_opts> subcarrier_spacing_mbms_r14_e_;

  // member variables
  bool                    ext              = false;
  uint8_t                 mbsfn_area_id_r9 = 0;
  non_mbsfn_region_len_e_ non_mbsfn_region_len;
  uint8_t                 notif_ind_r9 = 0;
  mcch_cfg_r9_s_          mcch_cfg_r9;
  // ...
  // group 0
  bool                           mcch_cfg_r14_present                = false;
  bool                           subcarrier_spacing_mbms_r14_present = false;
  copy_ptr<mcch_cfg_r14_s_>      mcch_cfg_r14;
  subcarrier_spacing_mbms_r14_e_ subcarrier_spacing_mbms_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSFN-SubframeConfig ::= SEQUENCE
struct mbsfn_sf_cfg_s {
  struct radioframe_alloc_period_opts {
    enum options { n1, n2, n4, n8, n16, n32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<radioframe_alloc_period_opts> radioframe_alloc_period_e_;
  struct sf_alloc_c_ {
    struct types_opts {
      enum options { one_frame, four_frames, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sf_alloc_c_() = default;
    sf_alloc_c_(const sf_alloc_c_& other);
    sf_alloc_c_& operator=(const sf_alloc_c_& other);
    ~sf_alloc_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<6>& one_frame()
    {
      assert_choice_type("oneFrame", type_.to_string(), "subframeAllocation");
      return c.get<fixed_bitstring<6> >();
    }
    fixed_bitstring<24>& four_frames()
    {
      assert_choice_type("fourFrames", type_.to_string(), "subframeAllocation");
      return c.get<fixed_bitstring<24> >();
    }
    const fixed_bitstring<6>& one_frame() const
    {
      assert_choice_type("oneFrame", type_.to_string(), "subframeAllocation");
      return c.get<fixed_bitstring<6> >();
    }
    const fixed_bitstring<24>& four_frames() const
    {
      assert_choice_type("fourFrames", type_.to_string(), "subframeAllocation");
      return c.get<fixed_bitstring<24> >();
    }
    fixed_bitstring<6>& set_one_frame()
    {
      set(types::one_frame);
      return c.get<fixed_bitstring<6> >();
    }
    fixed_bitstring<24>& set_four_frames()
    {
      set(types::four_frames);
      return c.get<fixed_bitstring<24> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<24>)> c;

    void destroy_();
  };

  // member variables
  radioframe_alloc_period_e_ radioframe_alloc_period;
  uint8_t                    radioframe_alloc_offset = 0;
  sf_alloc_c_                sf_alloc;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSFN-SubframeConfig-v1430 ::= SEQUENCE
struct mbsfn_sf_cfg_v1430_s {
  struct sf_alloc_v1430_c_ {
    struct types_opts {
      enum options { one_frame_v1430, four_frames_v1430, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sf_alloc_v1430_c_() = default;
    sf_alloc_v1430_c_(const sf_alloc_v1430_c_& other);
    sf_alloc_v1430_c_& operator=(const sf_alloc_v1430_c_& other);
    ~sf_alloc_v1430_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<2>& one_frame_v1430()
    {
      assert_choice_type("oneFrame-v1430", type_.to_string(), "subframeAllocation-v1430");
      return c.get<fixed_bitstring<2> >();
    }
    fixed_bitstring<8>& four_frames_v1430()
    {
      assert_choice_type("fourFrames-v1430", type_.to_string(), "subframeAllocation-v1430");
      return c.get<fixed_bitstring<8> >();
    }
    const fixed_bitstring<2>& one_frame_v1430() const
    {
      assert_choice_type("oneFrame-v1430", type_.to_string(), "subframeAllocation-v1430");
      return c.get<fixed_bitstring<2> >();
    }
    const fixed_bitstring<8>& four_frames_v1430() const
    {
      assert_choice_type("fourFrames-v1430", type_.to_string(), "subframeAllocation-v1430");
      return c.get<fixed_bitstring<8> >();
    }
    fixed_bitstring<2>& set_one_frame_v1430()
    {
      set(types::one_frame_v1430);
      return c.get<fixed_bitstring<2> >();
    }
    fixed_bitstring<8>& set_four_frames_v1430()
    {
      set(types::four_frames_v1430);
      return c.get<fixed_bitstring<8> >();
    }

  private:
    types                                       type_;
    choice_buffer_t<sizeof(fixed_bitstring<8>)> c;

    void destroy_();
  };

  // member variables
  sf_alloc_v1430_c_ sf_alloc_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighCellListCDMA2000 ::= SEQUENCE (SIZE (1..16)) OF NeighCellCDMA2000
typedef dyn_array<neigh_cell_cdma2000_s> neigh_cell_list_cdma2000_l;

// NeighCellListCDMA2000-v920 ::= SEQUENCE (SIZE (1..16)) OF NeighCellCDMA2000-v920
typedef dyn_array<neigh_cell_cdma2000_v920_s> neigh_cell_list_cdma2000_v920_l;

// PCCH-Config ::= SEQUENCE
struct pcch_cfg_s {
  struct default_paging_cycle_opts {
    enum options { rf32, rf64, rf128, rf256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<default_paging_cycle_opts> default_paging_cycle_e_;
  struct nb_opts {
    enum options {
      four_t,
      two_t,
      one_t,
      half_t,
      quarter_t,
      one_eighth_t,
      one_sixteenth_t,
      one_thirty_second_t,
      nulltype
    } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<nb_opts> nb_e_;

  // member variables
  default_paging_cycle_e_ default_paging_cycle;
  nb_e_                   nb;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PCCH-Config-v1310 ::= SEQUENCE
struct pcch_cfg_v1310_s {
  struct mpdcch_num_repeat_paging_r13_opts {
    enum options { r1, r2, r4, r8, r16, r32, r64, r128, r256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<mpdcch_num_repeat_paging_r13_opts> mpdcch_num_repeat_paging_r13_e_;
  struct nb_v1310_opts {
    enum options { one64th_t, one128th_t, one256th_t, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<nb_v1310_opts> nb_v1310_e_;

  // member variables
  bool                            nb_v1310_present        = false;
  uint8_t                         paging_narrow_bands_r13 = 1;
  mpdcch_num_repeat_paging_r13_e_ mpdcch_num_repeat_paging_r13;
  nb_v1310_e_                     nb_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigCommon ::= SEQUENCE
struct pdsch_cfg_common_s {
  // member variables
  int8_t  ref_sig_pwr = -60;
  uint8_t p_b         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigCommon-v1310 ::= SEQUENCE
struct pdsch_cfg_common_v1310_s {
  struct pdsch_max_num_repeat_cemode_a_r13_opts {
    enum options { r16, r32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pdsch_max_num_repeat_cemode_a_r13_opts> pdsch_max_num_repeat_cemode_a_r13_e_;
  struct pdsch_max_num_repeat_cemode_b_r13_opts {
    enum options { r192, r256, r384, r512, r768, r1024, r1536, r2048, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<pdsch_max_num_repeat_cemode_b_r13_opts> pdsch_max_num_repeat_cemode_b_r13_e_;

  // member variables
  bool                                 pdsch_max_num_repeat_cemode_a_r13_present = false;
  bool                                 pdsch_max_num_repeat_cemode_b_r13_present = false;
  pdsch_max_num_repeat_cemode_a_r13_e_ pdsch_max_num_repeat_cemode_a_r13;
  pdsch_max_num_repeat_cemode_b_r13_e_ pdsch_max_num_repeat_cemode_b_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-Info-r15 ::= SEQUENCE
struct plmn_info_r15_s {
  // member variables
  bool upper_layer_ind_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRACH-Config-v1430 ::= SEQUENCE
struct prach_cfg_v1430_s {
  // member variables
  uint16_t root_seq_idx_high_speed_r14              = 0;
  uint8_t  zero_correlation_zone_cfg_high_speed_r14 = 0;
  uint8_t  prach_cfg_idx_high_speed_r14             = 0;
  uint8_t  prach_freq_offset_high_speed_r14         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRACH-ConfigSIB ::= SEQUENCE
struct prach_cfg_sib_s {
  // member variables
  uint16_t         root_seq_idx = 0;
  prach_cfg_info_s prach_cfg_info;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRACH-ConfigSIB-v1310 ::= SEQUENCE
struct prach_cfg_sib_v1310_s {
  struct mpdcch_start_sf_css_ra_r13_c_ {
    struct fdd_r13_opts {
      enum options { v1, v1dot5, v2, v2dot5, v4, v5, v8, v10, nulltype } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<fdd_r13_opts> fdd_r13_e_;
    struct tdd_r13_opts {
      enum options { v1, v2, v4, v5, v8, v10, v20, spare, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tdd_r13_opts> tdd_r13_e_;
    struct types_opts {
      enum options { fdd_r13, tdd_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    mpdcch_start_sf_css_ra_r13_c_() = default;
    mpdcch_start_sf_css_ra_r13_c_(const mpdcch_start_sf_css_ra_r13_c_& other);
    mpdcch_start_sf_css_ra_r13_c_& operator=(const mpdcch_start_sf_css_ra_r13_c_& other);
    ~mpdcch_start_sf_css_ra_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fdd_r13_e_& fdd_r13()
    {
      assert_choice_type("fdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<fdd_r13_e_>();
    }
    tdd_r13_e_& tdd_r13()
    {
      assert_choice_type("tdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<tdd_r13_e_>();
    }
    const fdd_r13_e_& fdd_r13() const
    {
      assert_choice_type("fdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<fdd_r13_e_>();
    }
    const tdd_r13_e_& tdd_r13() const
    {
      assert_choice_type("tdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<tdd_r13_e_>();
    }
    fdd_r13_e_& set_fdd_r13()
    {
      set(types::fdd_r13);
      return c.get<fdd_r13_e_>();
    }
    tdd_r13_e_& set_tdd_r13()
    {
      set(types::tdd_r13);
      return c.get<tdd_r13_e_>();
    }

  private:
    types                                                         type_;
    choice_buffer_t<MAX2(sizeof(fdd_r13_e_), sizeof(tdd_r13_e_))> c;

    void destroy_();
  };

  // member variables
  bool                              mpdcch_start_sf_css_ra_r13_present = false;
  bool                              prach_hop_offset_r13_present       = false;
  rsrp_thress_prach_info_list_r13_l rsrp_thress_prach_info_list_r13;
  mpdcch_start_sf_css_ra_r13_c_     mpdcch_start_sf_css_ra_r13;
  uint8_t                           prach_hop_offset_r13 = 0;
  prach_params_list_ce_r13_l        prach_params_list_ce_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRACH-ConfigSIB-v1530 ::= SEQUENCE
struct prach_cfg_sib_v1530_s {
  typedef dyn_array<edt_prach_params_ce_r15_s> edt_prach_params_list_ce_r15_l_;

  // member variables
  edt_prach_params_list_ce_r15_l_ edt_prach_params_list_ce_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigCommon ::= SEQUENCE
struct pucch_cfg_common_s {
  struct delta_pucch_shift_opts {
    enum options { ds1, ds2, ds3, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_pucch_shift_opts> delta_pucch_shift_e_;

  // member variables
  delta_pucch_shift_e_ delta_pucch_shift;
  uint8_t              n_rb_cqi    = 0;
  uint8_t              n_cs_an     = 0;
  uint16_t             n1_pucch_an = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigCommon-v1310 ::= SEQUENCE
struct pucch_cfg_common_v1310_s {
  struct pucch_num_repeat_ce_msg4_level0_r13_opts {
    enum options { n1, n2, n4, n8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pucch_num_repeat_ce_msg4_level0_r13_opts> pucch_num_repeat_ce_msg4_level0_r13_e_;
  struct pucch_num_repeat_ce_msg4_level1_r13_opts {
    enum options { n1, n2, n4, n8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pucch_num_repeat_ce_msg4_level1_r13_opts> pucch_num_repeat_ce_msg4_level1_r13_e_;
  struct pucch_num_repeat_ce_msg4_level2_r13_opts {
    enum options { n4, n8, n16, n32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pucch_num_repeat_ce_msg4_level2_r13_opts> pucch_num_repeat_ce_msg4_level2_r13_e_;
  struct pucch_num_repeat_ce_msg4_level3_r13_opts {
    enum options { n4, n8, n16, n32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pucch_num_repeat_ce_msg4_level3_r13_opts> pucch_num_repeat_ce_msg4_level3_r13_e_;

  // member variables
  bool                                   n1_pucch_an_info_list_r13_present           = false;
  bool                                   pucch_num_repeat_ce_msg4_level0_r13_present = false;
  bool                                   pucch_num_repeat_ce_msg4_level1_r13_present = false;
  bool                                   pucch_num_repeat_ce_msg4_level2_r13_present = false;
  bool                                   pucch_num_repeat_ce_msg4_level3_r13_present = false;
  n1_pucch_an_info_list_r13_l            n1_pucch_an_info_list_r13;
  pucch_num_repeat_ce_msg4_level0_r13_e_ pucch_num_repeat_ce_msg4_level0_r13;
  pucch_num_repeat_ce_msg4_level1_r13_e_ pucch_num_repeat_ce_msg4_level1_r13;
  pucch_num_repeat_ce_msg4_level2_r13_e_ pucch_num_repeat_ce_msg4_level2_r13;
  pucch_num_repeat_ce_msg4_level3_r13_e_ pucch_num_repeat_ce_msg4_level3_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigCommon-v1430 ::= SEQUENCE
struct pucch_cfg_common_v1430_s {
  struct pucch_num_repeat_ce_msg4_level3_r14_opts {
    enum options { n64, n128, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pucch_num_repeat_ce_msg4_level3_r14_opts> pucch_num_repeat_ce_msg4_level3_r14_e_;

  // member variables
  bool                                   pucch_num_repeat_ce_msg4_level3_r14_present = false;
  pucch_num_repeat_ce_msg4_level3_r14_e_ pucch_num_repeat_ce_msg4_level3_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigCommon ::= SEQUENCE
struct pusch_cfg_common_s {
  struct pusch_cfg_basic_s_ {
    struct hop_mode_opts {
      enum options { inter_sub_frame, intra_and_inter_sub_frame, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<hop_mode_opts> hop_mode_e_;

    // member variables
    uint8_t     n_sb = 1;
    hop_mode_e_ hop_mode;
    uint8_t     pusch_hop_offset = 0;
    bool        enable64_qam     = false;
  };

  // member variables
  pusch_cfg_basic_s_  pusch_cfg_basic;
  ul_ref_sigs_pusch_s ul_ref_sigs_pusch;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigCommon-v1270 ::= SEQUENCE
struct pusch_cfg_common_v1270_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigCommon-v1310 ::= SEQUENCE
struct pusch_cfg_common_v1310_s {
  struct pusch_max_num_repeat_cemode_a_r13_opts {
    enum options { r8, r16, r32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pusch_max_num_repeat_cemode_a_r13_opts> pusch_max_num_repeat_cemode_a_r13_e_;
  struct pusch_max_num_repeat_cemode_b_r13_opts {
    enum options { r192, r256, r384, r512, r768, r1024, r1536, r2048, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<pusch_max_num_repeat_cemode_b_r13_opts> pusch_max_num_repeat_cemode_b_r13_e_;

  // member variables
  bool                                 pusch_max_num_repeat_cemode_a_r13_present = false;
  bool                                 pusch_max_num_repeat_cemode_b_r13_present = false;
  bool                                 pusch_hop_offset_v1310_present            = false;
  pusch_max_num_repeat_cemode_a_r13_e_ pusch_max_num_repeat_cemode_a_r13;
  pusch_max_num_repeat_cemode_b_r13_e_ pusch_max_num_repeat_cemode_b_r13;
  uint8_t                              pusch_hop_offset_v1310 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RACH-ConfigCommon ::= SEQUENCE
struct rach_cfg_common_s {
  struct preamb_info_s_ {
    struct nof_ra_preambs_opts {
      enum options { n4, n8, n12, n16, n20, n24, n28, n32, n36, n40, n44, n48, n52, n56, n60, n64, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<nof_ra_preambs_opts> nof_ra_preambs_e_;
    struct preambs_group_a_cfg_s_ {
      struct size_of_ra_preambs_group_a_opts {
        enum options { n4, n8, n12, n16, n20, n24, n28, n32, n36, n40, n44, n48, n52, n56, n60, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<size_of_ra_preambs_group_a_opts> size_of_ra_preambs_group_a_e_;
      struct msg_size_group_a_opts {
        enum options { b56, b144, b208, b256, nulltype } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<msg_size_group_a_opts> msg_size_group_a_e_;
      struct msg_pwr_offset_group_b_opts {
        enum options { minusinfinity, db0, db5, db8, db10, db12, db15, db18, nulltype } value;
        typedef int8_t number_type;

        std::string to_string() const;
        int8_t      to_number() const;
      };
      typedef enumerated<msg_pwr_offset_group_b_opts> msg_pwr_offset_group_b_e_;

      // member variables
      bool                          ext = false;
      size_of_ra_preambs_group_a_e_ size_of_ra_preambs_group_a;
      msg_size_group_a_e_           msg_size_group_a;
      msg_pwr_offset_group_b_e_     msg_pwr_offset_group_b;
      // ...
    };

    // member variables
    bool                   preambs_group_a_cfg_present = false;
    nof_ra_preambs_e_      nof_ra_preambs;
    preambs_group_a_cfg_s_ preambs_group_a_cfg;
  };
  struct ra_supervision_info_s_ {
    struct ra_resp_win_size_opts {
      enum options { sf2, sf3, sf4, sf5, sf6, sf7, sf8, sf10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<ra_resp_win_size_opts> ra_resp_win_size_e_;
    struct mac_contention_resolution_timer_opts {
      enum options { sf8, sf16, sf24, sf32, sf40, sf48, sf56, sf64, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<mac_contention_resolution_timer_opts> mac_contention_resolution_timer_e_;

    // member variables
    preamb_trans_max_e                 preamb_trans_max;
    ra_resp_win_size_e_                ra_resp_win_size;
    mac_contention_resolution_timer_e_ mac_contention_resolution_timer;
  };

  // member variables
  bool                   ext = false;
  preamb_info_s_         preamb_info;
  pwr_ramp_params_s      pwr_ramp_params;
  ra_supervision_info_s_ ra_supervision_info;
  uint8_t                max_harq_msg3_tx = 1;
  // ...
  // group 0
  bool                                    preamb_trans_max_ce_r13_present     = false;
  bool                                    rach_ce_level_info_list_r13_present = false;
  preamb_trans_max_e                      preamb_trans_max_ce_r13;
  copy_ptr<rach_ce_level_info_list_r13_l> rach_ce_level_info_list_r13;
  // group 1
  bool edt_small_tbs_subset_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RACH-ConfigCommon-v1250 ::= SEQUENCE
struct rach_cfg_common_v1250_s {
  struct tx_fail_params_r12_s_ {
    struct conn_est_fail_count_r12_opts {
      enum options { n1, n2, n3, n4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<conn_est_fail_count_r12_opts> conn_est_fail_count_r12_e_;
    struct conn_est_fail_offset_validity_r12_opts {
      enum options { s30, s60, s120, s240, s300, s420, s600, s900, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<conn_est_fail_offset_validity_r12_opts> conn_est_fail_offset_validity_r12_e_;

    // member variables
    bool                                 conn_est_fail_offset_r12_present = false;
    conn_est_fail_count_r12_e_           conn_est_fail_count_r12;
    conn_est_fail_offset_validity_r12_e_ conn_est_fail_offset_validity_r12;
    uint8_t                              conn_est_fail_offset_r12 = 0;
  };

  // member variables
  tx_fail_params_r12_s_ tx_fail_params_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RSS-Config-r15 ::= SEQUENCE
struct rss_cfg_r15_s {
  struct dur_r15_opts {
    enum options { sf8, sf16, sf32, sf40, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<dur_r15_opts> dur_r15_e_;
  struct periodicity_r15_opts {
    enum options { ms160, ms320, ms640, ms1280, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<periodicity_r15_opts> periodicity_r15_e_;
  struct pwr_boost_r15_opts {
    enum options { db0, db3, db4dot8, db6, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<pwr_boost_r15_opts> pwr_boost_r15_e_;

  // member variables
  dur_r15_e_         dur_r15;
  uint8_t            freq_location_r15 = 0;
  periodicity_r15_e_ periodicity_r15;
  pwr_boost_r15_e_   pwr_boost_r15;
  uint8_t            time_offset_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReferenceTime-r15 ::= SEQUENCE
struct ref_time_r15_s {
  // member variables
  uint32_t ref_days_r15                  = 0;
  uint32_t ref_seconds_r15               = 0;
  uint16_t ref_milli_seconds_r15         = 0;
  uint16_t ref_quarter_micro_seconds_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReselectionInfoRelay-r13 ::= SEQUENCE
struct resel_info_relay_r13_s {
  struct min_hyst_r13_opts {
    enum options { db0, db3, db6, db9, db12, dbinf, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<min_hyst_r13_opts> min_hyst_r13_e_;

  // member variables
  bool            min_hyst_r13_present = false;
  int8_t          q_rx_lev_min_r13     = -70;
  filt_coef_e     filt_coef_r13;
  min_hyst_r13_e_ min_hyst_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SIB-Type ::= ENUMERATED
struct sib_type_opts {
  enum options {
    sib_type3,
    sib_type4,
    sib_type5,
    sib_type6,
    sib_type7,
    sib_type8,
    sib_type9,
    sib_type10,
    sib_type11,
    sib_type12_v920,
    sib_type13_v920,
    sib_type14_v1130,
    sib_type15_v1130,
    sib_type16_v1130,
    sib_type17_v1250,
    sib_type18_v1250,
    // ...
    sib_type19_v1250,
    sib_type20_v1310,
    sib_type21_v1430,
    sib_type24_v1530,
    sib_type25_v1530,
    sib_type26_v1530,
    nulltype
  } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<sib_type_opts, true, 6> sib_type_e;

// SIB8-PerPLMN-r11 ::= SEQUENCE
struct sib8_per_plmn_r11_s {
  struct params_cdma2000_r11_c_ {
    struct types_opts {
      enum options { explicit_value, default_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    params_cdma2000_r11_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    params_cdma2000_r11_s& explicit_value()
    {
      assert_choice_type("explicitValue", type_.to_string(), "parametersCDMA2000-r11");
      return c;
    }
    const params_cdma2000_r11_s& explicit_value() const
    {
      assert_choice_type("explicitValue", type_.to_string(), "parametersCDMA2000-r11");
      return c;
    }
    params_cdma2000_r11_s& set_explicit_value()
    {
      set(types::explicit_value);
      return c;
    }

  private:
    types                 type_;
    params_cdma2000_r11_s c;
  };

  // member variables
  uint8_t                plmn_id_r11 = 1;
  params_cdma2000_r11_c_ params_cdma2000_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-AnchorCarrierFreqList-V2X-r14 ::= SEQUENCE (SIZE (1..maxFreqV2X-r14)) OF INTEGER
typedef bounded_array<uint32_t, 8> sl_anchor_carrier_freq_list_v2x_r14_l;

// SL-CBR-CommonTxConfigList-r14 ::= SEQUENCE
struct sl_cbr_common_tx_cfg_list_r14_s {
  typedef dyn_array<sl_cbr_levels_cfg_r14_l>   cbr_range_common_cfg_list_r14_l_;
  typedef dyn_array<sl_cbr_pssch_tx_cfg_r14_s> sl_cbr_pssch_tx_cfg_list_r14_l_;

  // member variables
  cbr_range_common_cfg_list_r14_l_ cbr_range_common_cfg_list_r14;
  sl_cbr_pssch_tx_cfg_list_r14_l_  sl_cbr_pssch_tx_cfg_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CarrierFreqInfo-r12 ::= SEQUENCE
struct sl_carrier_freq_info_r12_s {
  // member variables
  bool                plmn_id_list_r12_present = false;
  uint32_t            carrier_freq_r12         = 0;
  plmn_id_list4_r12_l plmn_id_list_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CarrierFreqInfo-v1310 ::= SEQUENCE
struct sl_carrier_freq_info_v1310_s {
  // member variables
  bool                               ext                         = false;
  bool                               disc_res_non_ps_r13_present = false;
  bool                               disc_res_ps_r13_present     = false;
  bool                               disc_cfg_other_r13_present  = false;
  sl_res_inter_freq_r13_s            disc_res_non_ps_r13;
  sl_res_inter_freq_r13_s            disc_res_ps_r13;
  sl_disc_cfg_other_inter_freq_r13_s disc_cfg_other_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CommResourcePool-r12 ::= SEQUENCE
struct sl_comm_res_pool_r12_s {
  struct ue_sel_res_cfg_r12_s_ {
    // member variables
    bool                trpt_subset_r12_present = false;
    sl_tf_res_cfg_r12_s data_tf_res_cfg_r12;
    dyn_bitstring       trpt_subset_r12;
  };
  struct rx_params_ncell_r12_s_ {
    // member variables
    bool      tdd_cfg_r12_present = false;
    tdd_cfg_s tdd_cfg_r12;
    uint8_t   sync_cfg_idx_r12 = 0;
  };
  struct tx_params_r12_s_ {
    // member variables
    sl_tx_params_r12_s sc_tx_params_r12;
    sl_tx_params_r12_s data_tx_params_r12;
  };

  // member variables
  bool                   ext                         = false;
  bool                   ue_sel_res_cfg_r12_present  = false;
  bool                   rx_params_ncell_r12_present = false;
  bool                   tx_params_r12_present       = false;
  sl_cp_len_r12_e        sc_cp_len_r12;
  sl_period_comm_r12_e   sc_period_r12;
  sl_tf_res_cfg_r12_s    sc_tf_res_cfg_r12;
  sl_cp_len_r12_e        data_cp_len_r12;
  sl_hop_cfg_comm_r12_s  data_hop_cfg_r12;
  ue_sel_res_cfg_r12_s_  ue_sel_res_cfg_r12;
  rx_params_ncell_r12_s_ rx_params_ncell_r12;
  tx_params_r12_s_       tx_params_r12;
  // ...
  // group 0
  bool                         prio_list_r13_present = false;
  copy_ptr<sl_prio_list_r13_l> prio_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-InterFreqInfoListV2X-r14 ::= SEQUENCE (SIZE (0..maxFreqV2X-1-r14)) OF SL-InterFreqInfoV2X-r14
typedef dyn_array<sl_inter_freq_info_v2x_r14_s> sl_inter_freq_info_list_v2x_r14_l;

// SL-PPPP-TxConfigIndex-r15 ::= SEQUENCE
struct sl_pppp_tx_cfg_idx_r15_s {
  typedef bounded_array<uint8_t, 16>       tx_cfg_idx_list_r15_l_;
  typedef dyn_array<mcs_pssch_range_r15_s> mcs_pssch_range_list_r15_l_;

  // member variables
  uint8_t                     prio_thres_r15         = 1;
  uint8_t                     default_tx_cfg_idx_r15 = 0;
  uint8_t                     cbr_cfg_idx_r15        = 0;
  tx_cfg_idx_list_r15_l_      tx_cfg_idx_list_r15;
  mcs_pssch_range_list_r15_l_ mcs_pssch_range_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PPPR-Dest-CarrierFreqList-r15 ::= SEQUENCE (SIZE (1..maxSL-Dest-r12)) OF SL-PPPR-Dest-CarrierFreq
typedef dyn_array<sl_pppr_dest_carrier_freq_s> sl_pppr_dest_carrier_freq_list_r15_l;

// SL-SyncConfigListV2X-r14 ::= SEQUENCE (SIZE (1.. maxSL-V2X-SyncConfig-r14)) OF SL-SyncConfig-r12
typedef dyn_array<sl_sync_cfg_r12_s> sl_sync_cfg_list_v2x_r14_l;

// SoundingRS-UL-ConfigCommon ::= CHOICE
struct srs_ul_cfg_common_c {
  struct setup_s_ {
    struct srs_bw_cfg_opts {
      enum options { bw0, bw1, bw2, bw3, bw4, bw5, bw6, bw7, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_bw_cfg_opts> srs_bw_cfg_e_;
    struct srs_sf_cfg_opts {
      enum options {
        sc0,
        sc1,
        sc2,
        sc3,
        sc4,
        sc5,
        sc6,
        sc7,
        sc8,
        sc9,
        sc10,
        sc11,
        sc12,
        sc13,
        sc14,
        sc15,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_sf_cfg_opts> srs_sf_cfg_e_;

    // member variables
    bool          srs_max_up_pts_present = false;
    srs_bw_cfg_e_ srs_bw_cfg;
    srs_sf_cfg_e_ srs_sf_cfg;
    bool          ack_nack_srs_simul_tx = false;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_common_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigCommon");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigCommon");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SystemInformationBlockType1-v10j0-IEs ::= SEQUENCE
struct sib_type1_v10j0_ies_s {
  // member variables
  bool                         freq_band_info_r10_present         = false;
  bool                         multi_band_info_list_v10j0_present = false;
  bool                         non_crit_ext_present               = false;
  ns_pmax_list_r10_l           freq_band_info_r10;
  multi_band_info_list_v10j0_l multi_band_info_list_v10j0;
  sib_type1_v10l0_ies_s        non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v1250-IEs ::= SEQUENCE
struct sib_type1_v1250_ies_s {
  struct cell_access_related_info_v1250_s_ {
    // member variables
    bool category0_allowed_r12_present = false;
  };

  // member variables
  bool                              cell_sel_info_v1250_present    = false;
  bool                              freq_band_ind_prio_r12_present = false;
  bool                              non_crit_ext_present           = false;
  cell_access_related_info_v1250_s_ cell_access_related_info_v1250;
  cell_sel_info_v1250_s             cell_sel_info_v1250;
  sib_type1_v1310_ies_s             non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType2-v9e0-IEs ::= SEQUENCE
struct sib_type2_v9e0_ies_s {
  // member variables
  bool                 ul_carrier_freq_v9e0_present = false;
  bool                 non_crit_ext_present         = false;
  uint32_t             ul_carrier_freq_v9e0         = 65536;
  sib_type2_v9i0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType3-v10l0-IEs ::= SEQUENCE
struct sib_type3_v10l0_ies_s {
  // member variables
  bool                         freq_band_info_v10l0_present       = false;
  bool                         multi_band_info_list_v10l0_present = false;
  bool                         non_crit_ext_present               = false;
  ns_pmax_list_v10l0_l         freq_band_info_v10l0;
  multi_band_info_list_v10l0_l multi_band_info_list_v10l0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType5-v9e0-IEs ::= SEQUENCE
struct sib_type5_v9e0_ies_s {
  typedef dyn_array<inter_freq_carrier_freq_info_v9e0_s> inter_freq_carrier_freq_list_v9e0_l_;

  // member variables
  bool                                 inter_freq_carrier_freq_list_v9e0_present = false;
  bool                                 non_crit_ext_present                      = false;
  inter_freq_carrier_freq_list_v9e0_l_ inter_freq_carrier_freq_list_v9e0;
  sib_type5_v10j0_ies_s                non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UAC-BarringInfoSet-r15 ::= SEQUENCE
struct uac_barr_info_set_r15_s {
  struct uac_barr_factor_r15_opts {
    enum options { p00, p05, p10, p15, p20, p25, p30, p40, p50, p60, p70, p75, p80, p85, p90, p95, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<uac_barr_factor_r15_opts> uac_barr_factor_r15_e_;
  struct uac_barr_time_r15_opts {
    enum options { s4, s8, s16, s32, s64, s128, s256, s512, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<uac_barr_time_r15_opts> uac_barr_time_r15_e_;

  // member variables
  uac_barr_factor_r15_e_ uac_barr_factor_r15;
  uac_barr_time_r15_e_   uac_barr_time_r15;
  fixed_bitstring<7>     uac_barr_for_access_id_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UAC-BarringPerPLMN-r15 ::= SEQUENCE
struct uac_barr_per_plmn_r15_s {
  struct uac_ac_barr_list_type_r15_c_ {
    typedef fixed_array<uint8_t, 63> uac_implicit_ac_barr_list_r15_l_;
    struct types_opts {
      enum options { uac_implicit_ac_barr_list_r15, uac_explicit_ac_barr_list_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    uac_ac_barr_list_type_r15_c_() = default;
    uac_ac_barr_list_type_r15_c_(const uac_ac_barr_list_type_r15_c_& other);
    uac_ac_barr_list_type_r15_c_& operator=(const uac_ac_barr_list_type_r15_c_& other);
    ~uac_ac_barr_list_type_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uac_implicit_ac_barr_list_r15_l_& uac_implicit_ac_barr_list_r15()
    {
      assert_choice_type("uac-ImplicitAC-BarringList-r15", type_.to_string(), "uac-AC-BarringListType-r15");
      return c.get<uac_implicit_ac_barr_list_r15_l_>();
    }
    uac_barr_per_cat_list_r15_l& uac_explicit_ac_barr_list_r15()
    {
      assert_choice_type("uac-ExplicitAC-BarringList-r15", type_.to_string(), "uac-AC-BarringListType-r15");
      return c.get<uac_barr_per_cat_list_r15_l>();
    }
    const uac_implicit_ac_barr_list_r15_l_& uac_implicit_ac_barr_list_r15() const
    {
      assert_choice_type("uac-ImplicitAC-BarringList-r15", type_.to_string(), "uac-AC-BarringListType-r15");
      return c.get<uac_implicit_ac_barr_list_r15_l_>();
    }
    const uac_barr_per_cat_list_r15_l& uac_explicit_ac_barr_list_r15() const
    {
      assert_choice_type("uac-ExplicitAC-BarringList-r15", type_.to_string(), "uac-AC-BarringListType-r15");
      return c.get<uac_barr_per_cat_list_r15_l>();
    }
    uac_implicit_ac_barr_list_r15_l_& set_uac_implicit_ac_barr_list_r15()
    {
      set(types::uac_implicit_ac_barr_list_r15);
      return c.get<uac_implicit_ac_barr_list_r15_l_>();
    }
    uac_barr_per_cat_list_r15_l& set_uac_explicit_ac_barr_list_r15()
    {
      set(types::uac_explicit_ac_barr_list_r15);
      return c.get<uac_barr_per_cat_list_r15_l>();
    }

  private:
    types                                                                                                type_;
    choice_buffer_t<MAX2(sizeof(uac_barr_per_cat_list_r15_l), sizeof(uac_implicit_ac_barr_list_r15_l_))> c;

    void destroy_();
  };

  // member variables
  bool                         uac_ac_barr_list_type_r15_present = false;
  uint8_t                      plmn_id_idx_r15                   = 1;
  uac_ac_barr_list_type_r15_c_ uac_ac_barr_list_type_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UDT-RestrictingPerPLMN-r13 ::= SEQUENCE
struct udt_restricting_per_plmn_r13_s {
  // member variables
  bool                  udt_restricting_r13_present = false;
  uint8_t               plmn_id_idx_r13             = 1;
  udt_restricting_r13_s udt_restricting_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-CyclicPrefixLength ::= ENUMERATED
struct ul_cp_len_opts {
  enum options { len1, len2, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<ul_cp_len_opts> ul_cp_len_e;

// UplinkPowerControlCommon ::= SEQUENCE
struct ul_pwr_ctrl_common_s {
  // member variables
  int8_t              p0_nominal_pusch = -126;
  alpha_r12_e         alpha;
  int8_t              p0_nominal_pucch = -127;
  delta_flist_pucch_s delta_flist_pucch;
  int8_t              delta_preamb_msg3 = -1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommon-v1020 ::= SEQUENCE
struct ul_pwr_ctrl_common_v1020_s {
  struct delta_f_pucch_format3_r10_opts {
    enum options {
      delta_f_minus1,
      delta_f0,
      delta_f1,
      delta_f2,
      delta_f3,
      delta_f4,
      delta_f5,
      delta_f6,
      nulltype
    } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_f_pucch_format3_r10_opts> delta_f_pucch_format3_r10_e_;
  struct delta_f_pucch_format1b_cs_r10_opts {
    enum options { delta_f1, delta_f2, spare2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format1b_cs_r10_opts> delta_f_pucch_format1b_cs_r10_e_;

  // member variables
  delta_f_pucch_format3_r10_e_     delta_f_pucch_format3_r10;
  delta_f_pucch_format1b_cs_r10_e_ delta_f_pucch_format1b_cs_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-Id-List-r12 ::= SEQUENCE (SIZE (1..maxWLAN-Id-r12)) OF WLAN-Identifiers-r12
typedef dyn_array<wlan_ids_r12_s> wlan_id_list_r12_l;

// WLAN-OffloadConfig-r12 ::= SEQUENCE
struct wlan_offload_cfg_r12_s {
  struct thres_rsrp_r12_s_ {
    // member variables
    uint8_t thres_rsrp_low_r12  = 0;
    uint8_t thres_rsrp_high_r12 = 0;
  };
  struct thres_rsrq_r12_s_ {
    // member variables
    uint8_t thres_rsrq_low_r12  = 0;
    uint8_t thres_rsrq_high_r12 = 0;
  };
  struct thres_rsrq_on_all_symbols_with_wb_r12_s_ {
    // member variables
    uint8_t thres_rsrq_on_all_symbols_with_wb_low_r12  = 0;
    uint8_t thres_rsrq_on_all_symbols_with_wb_high_r12 = 0;
  };
  struct thres_rsrq_on_all_symbols_r12_s_ {
    // member variables
    uint8_t thres_rsrq_on_all_symbols_low_r12  = 0;
    uint8_t thres_rsrq_on_all_symbols_high_r12 = 0;
  };
  struct thres_rsrq_wb_r12_s_ {
    // member variables
    uint8_t thres_rsrq_wb_low_r12  = 0;
    uint8_t thres_rsrq_wb_high_r12 = 0;
  };
  struct thres_ch_utilization_r12_s_ {
    // member variables
    uint8_t thres_ch_utilization_low_r12  = 0;
    uint8_t thres_ch_utilization_high_r12 = 0;
  };
  struct thres_backhaul_bw_r12_s_ {
    // member variables
    wlan_backhaul_rate_r12_e thres_backhaul_dl_bw_low_r12;
    wlan_backhaul_rate_r12_e thres_backhaul_dl_bw_high_r12;
    wlan_backhaul_rate_r12_e thres_backhaul_ul_bw_low_r12;
    wlan_backhaul_rate_r12_e thres_backhaul_ul_bw_high_r12;
  };
  struct thres_wlan_rssi_r12_s_ {
    // member variables
    uint8_t thres_wlan_rssi_low_r12  = 0;
    uint8_t thres_wlan_rssi_high_r12 = 0;
  };

  // member variables
  bool                                     ext                                           = false;
  bool                                     thres_rsrp_r12_present                        = false;
  bool                                     thres_rsrq_r12_present                        = false;
  bool                                     thres_rsrq_on_all_symbols_with_wb_r12_present = false;
  bool                                     thres_rsrq_on_all_symbols_r12_present         = false;
  bool                                     thres_rsrq_wb_r12_present                     = false;
  bool                                     thres_ch_utilization_r12_present              = false;
  bool                                     thres_backhaul_bw_r12_present                 = false;
  bool                                     thres_wlan_rssi_r12_present                   = false;
  bool                                     offload_pref_ind_r12_present                  = false;
  bool                                     t_steering_wlan_r12_present                   = false;
  thres_rsrp_r12_s_                        thres_rsrp_r12;
  thres_rsrq_r12_s_                        thres_rsrq_r12;
  thres_rsrq_on_all_symbols_with_wb_r12_s_ thres_rsrq_on_all_symbols_with_wb_r12;
  thres_rsrq_on_all_symbols_r12_s_         thres_rsrq_on_all_symbols_r12;
  thres_rsrq_wb_r12_s_                     thres_rsrq_wb_r12;
  thres_ch_utilization_r12_s_              thres_ch_utilization_r12;
  thres_backhaul_bw_r12_s_                 thres_backhaul_bw_r12;
  thres_wlan_rssi_r12_s_                   thres_wlan_rssi_r12;
  fixed_bitstring<16>                      offload_pref_ind_r12;
  uint8_t                                  t_steering_wlan_r12 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WUS-Config-r15 ::= SEQUENCE
struct wus_cfg_r15_s {
  struct max_dur_factor_r15_opts {
    enum options { one32th, one16th, one8th, one4th, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<max_dur_factor_r15_opts> max_dur_factor_r15_e_;
  struct num_pos_r15_opts {
    enum options { n1, n2, n4, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<num_pos_r15_opts> num_pos_r15_e_;
  struct freq_location_r15_opts {
    enum options { n0, n2, n4, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<freq_location_r15_opts> freq_location_r15_e_;
  struct time_offset_drx_r15_opts {
    enum options { ms40, ms80, ms160, ms240, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<time_offset_drx_r15_opts> time_offset_drx_r15_e_;
  struct time_offset_e_drx_short_r15_opts {
    enum options { ms40, ms80, ms160, ms240, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<time_offset_e_drx_short_r15_opts> time_offset_e_drx_short_r15_e_;
  struct time_offset_e_drx_long_r15_opts {
    enum options { ms1000, ms2000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<time_offset_e_drx_long_r15_opts> time_offset_e_drx_long_r15_e_;

  // member variables
  bool                           num_pos_r15_present                = false;
  bool                           time_offset_e_drx_long_r15_present = false;
  max_dur_factor_r15_e_          max_dur_factor_r15;
  num_pos_r15_e_                 num_pos_r15;
  freq_location_r15_e_           freq_location_r15;
  time_offset_drx_r15_e_         time_offset_drx_r15;
  time_offset_e_drx_short_r15_e_ time_offset_e_drx_short_r15;
  time_offset_e_drx_long_r15_e_  time_offset_e_drx_long_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AC-BarringPerPLMN-List-r12 ::= SEQUENCE (SIZE (1.. maxPLMN-r11)) OF AC-BarringPerPLMN-r12
typedef dyn_array<ac_barr_per_plmn_r12_s> ac_barr_per_plmn_list_r12_l;

// ACDC-BarringForCommon-r13 ::= SEQUENCE
struct acdc_barr_for_common_r13_s {
  // member variables
  bool                              acdc_hplm_nonly_r13 = false;
  barr_per_acdc_category_list_r13_l barr_per_acdc_category_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ACDC-BarringPerPLMN-List-r13 ::= SEQUENCE (SIZE (1.. maxPLMN-r11)) OF ACDC-BarringPerPLMN-r13
typedef dyn_array<acdc_barr_per_plmn_r13_s> acdc_barr_per_plmn_list_r13_l;

// CIOT-EPS-OptimisationInfo-r13 ::= SEQUENCE (SIZE (1.. maxPLMN-r11)) OF CIOT-OptimisationPLMN-r13
typedef dyn_array<ciot_optim_plmn_r13_s> ciot_eps_optim_info_r13_l;

// CarrierFreqInfoUTRA-v1250 ::= SEQUENCE
struct carrier_freq_info_utra_v1250_s {
  // member variables
  bool reduced_meas_performance_r12_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqListNR-r15 ::= SEQUENCE (SIZE (1..maxFreq)) OF CarrierFreqNR-r15
typedef dyn_array<carrier_freq_nr_r15_s> carrier_freq_list_nr_r15_l;

// CarrierFreqListUTRA-FDD ::= SEQUENCE (SIZE (1..maxUTRA-FDD-Carrier)) OF CarrierFreqUTRA-FDD
typedef dyn_array<carrier_freq_utra_fdd_s> carrier_freq_list_utra_fdd_l;

// CarrierFreqListUTRA-FDD-Ext-r12 ::= SEQUENCE (SIZE (1..maxUTRA-FDD-Carrier)) OF CarrierFreqUTRA-FDD-Ext-r12
typedef dyn_array<carrier_freq_utra_fdd_ext_r12_s> carrier_freq_list_utra_fdd_ext_r12_l;

// CarrierFreqListUTRA-TDD ::= SEQUENCE (SIZE (1..maxUTRA-TDD-Carrier)) OF CarrierFreqUTRA-TDD
typedef dyn_array<carrier_freq_utra_tdd_s> carrier_freq_list_utra_tdd_l;

// CarrierFreqListUTRA-TDD-Ext-r12 ::= SEQUENCE (SIZE (1..maxUTRA-TDD-Carrier)) OF CarrierFreqUTRA-TDD-r12
typedef dyn_array<carrier_freq_utra_tdd_r12_s> carrier_freq_list_utra_tdd_ext_r12_l;

// CarrierFreqsInfoListGERAN ::= SEQUENCE (SIZE (1..maxGNFG)) OF CarrierFreqsInfoGERAN
typedef dyn_array<carrier_freqs_info_geran_s> carrier_freqs_info_list_geran_l;

// CellReselectionInfoCommon-v1460 ::= SEQUENCE
struct cell_resel_info_common_v1460_s {
  struct s_search_delta_p_r14_opts {
    enum options { db6, db9, db12, db15, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<s_search_delta_p_r14_opts> s_search_delta_p_r14_e_;

  // member variables
  s_search_delta_p_r14_e_ s_search_delta_p_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellReselectionInfoHSDN-r15 ::= SEQUENCE
struct cell_resel_info_hsdn_r15_s {
  // member variables
  uint8_t cell_equivalent_size_r15 = 2;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellReselectionParametersCDMA2000 ::= SEQUENCE
struct cell_resel_params_cdma2000_s {
  // member variables
  bool                        t_resel_cdma2000_sf_present = false;
  band_class_list_cdma2000_l  band_class_list;
  neigh_cell_list_cdma2000_l  neigh_cell_list;
  uint8_t                     t_resel_cdma2000 = 0;
  speed_state_scale_factors_s t_resel_cdma2000_sf;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellReselectionParametersCDMA2000-v920 ::= SEQUENCE
struct cell_resel_params_cdma2000_v920_s {
  // member variables
  neigh_cell_list_cdma2000_v920_l neigh_cell_list_v920;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellReselectionServingFreqInfo-v1310 ::= SEQUENCE
struct cell_resel_serving_freq_info_v1310_s {
  // member variables
  cell_resel_sub_prio_r13_e cell_resel_sub_prio_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellSelectionInfo-v920 ::= SEQUENCE
struct cell_sel_info_v920_s {
  // member variables
  bool    q_qual_min_offset_r9_present = false;
  int8_t  q_qual_min_r9                = -34;
  uint8_t q_qual_min_offset_r9         = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EAB-ConfigPLMN-r11 ::= SEQUENCE
struct eab_cfg_plmn_r11_s {
  // member variables
  bool          eab_cfg_r11_present = false;
  eab_cfg_r11_s eab_cfg_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqCarrierFreqList ::= SEQUENCE (SIZE (1..maxFreq)) OF InterFreqCarrierFreqInfo
typedef dyn_array<inter_freq_carrier_freq_info_s> inter_freq_carrier_freq_list_l;

// InterFreqCarrierFreqList-v1250 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v1250
typedef dyn_array<inter_freq_carrier_freq_info_v1250_s> inter_freq_carrier_freq_list_v1250_l;

// InterFreqCarrierFreqList-v1310 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v1310
typedef dyn_array<inter_freq_carrier_freq_info_v1310_s> inter_freq_carrier_freq_list_v1310_l;

// InterFreqCarrierFreqList-v1350 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v1350
typedef dyn_array<inter_freq_carrier_freq_info_v1350_s> inter_freq_carrier_freq_list_v1350_l;

// InterFreqCarrierFreqList-v1530 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v1530
typedef dyn_array<inter_freq_carrier_freq_info_v1530_s> inter_freq_carrier_freq_list_v1530_l;

// InterFreqCarrierFreqListExt-r12 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-r12
typedef dyn_array<inter_freq_carrier_freq_info_r12_s> inter_freq_carrier_freq_list_ext_r12_l;

// InterFreqCarrierFreqListExt-v1280 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v10j0
typedef dyn_array<inter_freq_carrier_freq_info_v10j0_s> inter_freq_carrier_freq_list_ext_v1280_l;

// InterFreqCarrierFreqListExt-v1310 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v1310
typedef dyn_array<inter_freq_carrier_freq_info_v1310_s> inter_freq_carrier_freq_list_ext_v1310_l;

// InterFreqCarrierFreqListExt-v1350 ::= SEQUENCE (SIZE (1.. maxFreq)) OF InterFreqCarrierFreqInfo-v1350
typedef dyn_array<inter_freq_carrier_freq_info_v1350_s> inter_freq_carrier_freq_list_ext_v1350_l;

// InterFreqCarrierFreqListExt-v1360 ::= SEQUENCE (SIZE (1..maxFreq)) OF InterFreqCarrierFreqInfo-v1360
typedef dyn_array<inter_freq_carrier_freq_info_v1360_s> inter_freq_carrier_freq_list_ext_v1360_l;

// InterFreqCarrierFreqListExt-v1530 ::= SEQUENCE (SIZE (1..maxFreq)) OF InterFreqCarrierFreqInfo-v1530
typedef dyn_array<inter_freq_carrier_freq_info_v1530_s> inter_freq_carrier_freq_list_ext_v1530_l;

// IntraFreqBlackCellList ::= SEQUENCE (SIZE (1..maxCellBlack)) OF PhysCellIdRange
typedef dyn_array<pci_range_s> intra_freq_black_cell_list_l;

// IntraFreqNeighCellList ::= SEQUENCE (SIZE (1..maxCellIntra)) OF IntraFreqNeighCellInfo
typedef dyn_array<intra_freq_neigh_cell_info_s> intra_freq_neigh_cell_list_l;

// IntraFreqNeighHSDN-CellList-r15 ::= SEQUENCE (SIZE (1..maxCellIntra)) OF PhysCellIdRange
typedef dyn_array<pci_range_s> intra_freq_neigh_hsdn_cell_list_r15_l;

// MBMS-InterFreqCarrierTypeList-r14 ::= SEQUENCE (SIZE (1..maxFreq)) OF MBMS-CarrierType-r14
typedef dyn_array<mbms_carrier_type_r14_s> mbms_inter_freq_carrier_type_list_r14_l;

// MBMS-NotificationConfig-r9 ::= SEQUENCE
struct mbms_notif_cfg_r9_s {
  struct notif_repeat_coeff_r9_opts {
    enum options { n2, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<notif_repeat_coeff_r9_opts> notif_repeat_coeff_r9_e_;

  // member variables
  notif_repeat_coeff_r9_e_ notif_repeat_coeff_r9;
  uint8_t                  notif_offset_r9 = 0;
  uint8_t                  notif_sf_idx_r9 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-NotificationConfig-v1430 ::= SEQUENCE
struct mbms_notif_cfg_v1430_s {
  // member variables
  uint8_t notif_sf_idx_v1430 = 7;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-SAI-InterFreqList-r11 ::= SEQUENCE (SIZE (1..maxFreq)) OF MBMS-SAI-InterFreq-r11
typedef dyn_array<mbms_sai_inter_freq_r11_s> mbms_sai_inter_freq_list_r11_l;

// MBMS-SAI-InterFreqList-v1140 ::= SEQUENCE (SIZE (1..maxFreq)) OF MBMS-SAI-InterFreq-v1140
typedef dyn_array<mbms_sai_inter_freq_v1140_s> mbms_sai_inter_freq_list_v1140_l;

// MBSFN-AreaInfoList-r9 ::= SEQUENCE (SIZE(1..maxMBSFN-Area)) OF MBSFN-AreaInfo-r9
typedef dyn_array<mbsfn_area_info_r9_s> mbsfn_area_info_list_r9_l;

// MBSFN-SubframeConfigList ::= SEQUENCE (SIZE (1..maxMBSFN-Allocations)) OF MBSFN-SubframeConfig
typedef dyn_array<mbsfn_sf_cfg_s> mbsfn_sf_cfg_list_l;

// MBSFN-SubframeConfigList-v1430 ::= SEQUENCE (SIZE (1..maxMBSFN-Allocations)) OF MBSFN-SubframeConfig-v1430
typedef dyn_array<mbsfn_sf_cfg_v1430_s> mbsfn_sf_cfg_list_v1430_l;

// MeasIdleConfigSIB-r15 ::= SEQUENCE
struct meas_idle_cfg_sib_r15_s {
  // member variables
  bool                     ext = false;
  eutra_carrier_list_r15_l meas_idle_carrier_list_eutra_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityStateParameters ::= SEQUENCE
struct mob_state_params_s {
  struct t_eval_opts {
    enum options { s30, s60, s120, s180, s240, spare3, spare2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<t_eval_opts> t_eval_e_;
  struct t_hyst_normal_opts {
    enum options { s30, s60, s120, s180, s240, spare3, spare2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<t_hyst_normal_opts> t_hyst_normal_e_;

  // member variables
  t_eval_e_        t_eval;
  t_hyst_normal_e_ t_hyst_normal;
  uint8_t          n_cell_change_medium = 1;
  uint8_t          n_cell_change_high   = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-InfoList-r15 ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF PLMN-Info-r15
typedef dyn_array<plmn_info_r15_s> plmn_info_list_r15_l;

// RadioResourceConfigCommonSIB ::= SEQUENCE
struct rr_cfg_common_sib_s {
  // member variables
  bool                 ext = false;
  rach_cfg_common_s    rach_cfg_common;
  bcch_cfg_s           bcch_cfg;
  pcch_cfg_s           pcch_cfg;
  prach_cfg_sib_s      prach_cfg;
  pdsch_cfg_common_s   pdsch_cfg_common;
  pusch_cfg_common_s   pusch_cfg_common;
  pucch_cfg_common_s   pucch_cfg_common;
  srs_ul_cfg_common_c  srs_ul_cfg_common;
  ul_pwr_ctrl_common_s ul_pwr_ctrl_common;
  ul_cp_len_e          ul_cp_len;
  // ...
  // group 0
  bool                                 ul_pwr_ctrl_common_v1020_present = false;
  copy_ptr<ul_pwr_ctrl_common_v1020_s> ul_pwr_ctrl_common_v1020;
  // group 1
  bool                              rach_cfg_common_v1250_present = false;
  copy_ptr<rach_cfg_common_v1250_s> rach_cfg_common_v1250;
  // group 2
  bool                               pusch_cfg_common_v1270_present = false;
  copy_ptr<pusch_cfg_common_v1270_s> pusch_cfg_common_v1270;
  // group 3
  bool                               bcch_cfg_v1310_present         = false;
  bool                               pcch_cfg_v1310_present         = false;
  bool                               freq_hop_params_r13_present    = false;
  bool                               pdsch_cfg_common_v1310_present = false;
  bool                               pusch_cfg_common_v1310_present = false;
  bool                               prach_cfg_common_v1310_present = false;
  bool                               pucch_cfg_common_v1310_present = false;
  copy_ptr<bcch_cfg_v1310_s>         bcch_cfg_v1310;
  copy_ptr<pcch_cfg_v1310_s>         pcch_cfg_v1310;
  copy_ptr<freq_hop_params_r13_s>    freq_hop_params_r13;
  copy_ptr<pdsch_cfg_common_v1310_s> pdsch_cfg_common_v1310;
  copy_ptr<pusch_cfg_common_v1310_s> pusch_cfg_common_v1310;
  copy_ptr<prach_cfg_sib_v1310_s>    prach_cfg_common_v1310;
  copy_ptr<pucch_cfg_common_v1310_s> pucch_cfg_common_v1310;
  // group 4
  bool                               high_speed_cfg_r14_present     = false;
  bool                               prach_cfg_v1430_present        = false;
  bool                               pucch_cfg_common_v1430_present = false;
  copy_ptr<high_speed_cfg_r14_s>     high_speed_cfg_r14;
  copy_ptr<prach_cfg_v1430_s>        prach_cfg_v1430;
  copy_ptr<pucch_cfg_common_v1430_s> pucch_cfg_common_v1430;
  // group 5
  bool                             prach_cfg_v1530_present      = false;
  bool                             ce_rss_cfg_r15_present       = false;
  bool                             wus_cfg_r15_present          = false;
  bool                             high_speed_cfg_v1530_present = false;
  copy_ptr<prach_cfg_sib_v1530_s>  prach_cfg_v1530;
  copy_ptr<rss_cfg_r15_s>          ce_rss_cfg_r15;
  copy_ptr<wus_cfg_r15_s>          wus_cfg_r15;
  copy_ptr<high_speed_cfg_v1530_s> high_speed_cfg_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RedistributionServingInfo-r13 ::= SEQUENCE
struct redist_serving_info_r13_s {
  struct t360_r13_opts {
    enum options { min4, min8, min16, min32, infinity, spare3, spare2, spare1, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<t360_r13_opts> t360_r13_e_;

  // member variables
  bool        redist_factor_cell_r13_present     = false;
  bool        redistr_on_paging_only_r13_present = false;
  uint8_t     redist_factor_serving_r13          = 0;
  t360_r13_e_ t360_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SC-MCCH-SchedulingInfo-r14 ::= SEQUENCE
struct sc_mcch_sched_info_r14_s {
  struct on_dur_timer_scptm_r14_opts {
    enum options { psf10, psf20, psf100, psf300, psf500, psf1000, psf1200, psf1600, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<on_dur_timer_scptm_r14_opts> on_dur_timer_scptm_r14_e_;
  struct drx_inactivity_timer_scptm_r14_opts {
    enum options {
      psf0,
      psf1,
      psf2,
      psf4,
      psf8,
      psf16,
      psf32,
      psf64,
      psf128,
      psf256,
      ps512,
      psf1024,
      psf2048,
      psf4096,
      psf8192,
      psf16384,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<drx_inactivity_timer_scptm_r14_opts> drx_inactivity_timer_scptm_r14_e_;
  struct sched_period_start_offset_scptm_r14_c_ {
    struct types_opts {
      enum options {
        sf10,
        sf20,
        sf32,
        sf40,
        sf64,
        sf80,
        sf128,
        sf160,
        sf256,
        sf320,
        sf512,
        sf640,
        sf1024,
        sf2048,
        sf4096,
        sf8192,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sched_period_start_offset_scptm_r14_c_() = default;
    sched_period_start_offset_scptm_r14_c_(const sched_period_start_offset_scptm_r14_c_& other);
    sched_period_start_offset_scptm_r14_c_& operator=(const sched_period_start_offset_scptm_r14_c_& other);
    ~sched_period_start_offset_scptm_r14_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& sf10()
    {
      assert_choice_type("sf10", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf20()
    {
      assert_choice_type("sf20", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf32()
    {
      assert_choice_type("sf32", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf40()
    {
      assert_choice_type("sf40", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf64()
    {
      assert_choice_type("sf64", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf80()
    {
      assert_choice_type("sf80", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf128()
    {
      assert_choice_type("sf128", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf160()
    {
      assert_choice_type("sf160", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf256()
    {
      assert_choice_type("sf256", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint16_t& sf320()
    {
      assert_choice_type("sf320", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf512()
    {
      assert_choice_type("sf512", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf640()
    {
      assert_choice_type("sf640", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf1024()
    {
      assert_choice_type("sf1024", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf2048()
    {
      assert_choice_type("sf2048", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf4096()
    {
      assert_choice_type("sf4096", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf8192()
    {
      assert_choice_type("sf8192", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint8_t& sf10() const
    {
      assert_choice_type("sf10", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf20() const
    {
      assert_choice_type("sf20", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf32() const
    {
      assert_choice_type("sf32", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf40() const
    {
      assert_choice_type("sf40", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf64() const
    {
      assert_choice_type("sf64", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf80() const
    {
      assert_choice_type("sf80", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf128() const
    {
      assert_choice_type("sf128", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf160() const
    {
      assert_choice_type("sf160", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf256() const
    {
      assert_choice_type("sf256", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint16_t& sf320() const
    {
      assert_choice_type("sf320", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf512() const
    {
      assert_choice_type("sf512", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf640() const
    {
      assert_choice_type("sf640", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf1024() const
    {
      assert_choice_type("sf1024", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf2048() const
    {
      assert_choice_type("sf2048", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf4096() const
    {
      assert_choice_type("sf4096", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf8192() const
    {
      assert_choice_type("sf8192", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint8_t& set_sf10()
    {
      set(types::sf10);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf20()
    {
      set(types::sf20);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf32()
    {
      set(types::sf32);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf40()
    {
      set(types::sf40);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf64()
    {
      set(types::sf64);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf80()
    {
      set(types::sf80);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf128()
    {
      set(types::sf128);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf160()
    {
      set(types::sf160);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf256()
    {
      set(types::sf256);
      return c.get<uint8_t>();
    }
    uint16_t& set_sf320()
    {
      set(types::sf320);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf512()
    {
      set(types::sf512);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf640()
    {
      set(types::sf640);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf1024()
    {
      set(types::sf1024);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf2048()
    {
      set(types::sf2048);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf4096()
    {
      set(types::sf4096);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf8192()
    {
      set(types::sf8192);
      return c.get<uint16_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool                                   ext = false;
  on_dur_timer_scptm_r14_e_              on_dur_timer_scptm_r14;
  drx_inactivity_timer_scptm_r14_e_      drx_inactivity_timer_scptm_r14;
  sched_period_start_offset_scptm_r14_c_ sched_period_start_offset_scptm_r14;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SIB-MappingInfo ::= SEQUENCE (SIZE (0..maxSIB-1)) OF SIB-Type
typedef bounded_array<sib_type_e, 31> sib_map_info_l;

// SIB8-PerPLMN-List-r11 ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF SIB8-PerPLMN-r11
typedef dyn_array<sib8_per_plmn_r11_s> sib8_per_plmn_list_r11_l;

// SL-CBR-PPPP-TxConfigList-r15 ::= SEQUENCE (SIZE (1..8)) OF SL-PPPP-TxConfigIndex-r15
typedef dyn_array<sl_pppp_tx_cfg_idx_r15_s> sl_cbr_pppp_tx_cfg_list_r15_l;

// SL-CarrierFreqInfoList-r12 ::= SEQUENCE (SIZE (1..maxFreq)) OF SL-CarrierFreqInfo-r12
typedef dyn_array<sl_carrier_freq_info_r12_s> sl_carrier_freq_info_list_r12_l;

// SL-CarrierFreqInfoList-v1310 ::= SEQUENCE (SIZE (1..maxFreq)) OF SL-CarrierFreqInfo-v1310
typedef dyn_array<sl_carrier_freq_info_v1310_s> sl_carrier_freq_info_list_v1310_l;

// SL-CommRxPoolList-r12 ::= SEQUENCE (SIZE (1..maxSL-RxPool-r12)) OF SL-CommResourcePool-r12
typedef dyn_array<sl_comm_res_pool_r12_s> sl_comm_rx_pool_list_r12_l;

// SL-CommTxPoolList-r12 ::= SEQUENCE (SIZE (1..maxSL-TxPool-r12)) OF SL-CommResourcePool-r12
typedef dyn_array<sl_comm_res_pool_r12_s> sl_comm_tx_pool_list_r12_l;

// SL-CommTxPoolListExt-r13 ::= SEQUENCE (SIZE (1..maxSL-TxPool-v1310)) OF SL-CommResourcePool-r12
typedef dyn_array<sl_comm_res_pool_r12_s> sl_comm_tx_pool_list_ext_r13_l;

// SL-DiscConfigRelayUE-r13 ::= SEQUENCE
struct sl_disc_cfg_relay_ue_r13_s {
  struct hyst_max_r13_opts {
    enum options { db0, db3, db6, db9, db12, dbinf, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<hyst_max_r13_opts> hyst_max_r13_e_;
  struct hyst_min_r13_opts {
    enum options { db0, db3, db6, db9, db12, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<hyst_min_r13_opts> hyst_min_r13_e_;

  // member variables
  bool            thresh_high_r13_present = false;
  bool            thresh_low_r13_present  = false;
  bool            hyst_max_r13_present    = false;
  bool            hyst_min_r13_present    = false;
  uint8_t         thresh_high_r13         = 0;
  uint8_t         thresh_low_r13          = 0;
  hyst_max_r13_e_ hyst_max_r13;
  hyst_min_r13_e_ hyst_min_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscConfigRemoteUE-r13 ::= SEQUENCE
struct sl_disc_cfg_remote_ue_r13_s {
  struct hyst_max_r13_opts {
    enum options { db0, db3, db6, db9, db12, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<hyst_max_r13_opts> hyst_max_r13_e_;

  // member variables
  bool                   thresh_high_r13_present = false;
  bool                   hyst_max_r13_present    = false;
  uint8_t                thresh_high_r13         = 0;
  hyst_max_r13_e_        hyst_max_r13;
  resel_info_relay_r13_s resel_info_ic_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-SyncConfigList-r12 ::= SEQUENCE (SIZE (1..maxSL-SyncConfig-r12)) OF SL-SyncConfig-r12
typedef dyn_array<sl_sync_cfg_r12_s> sl_sync_cfg_list_r12_l;

// SL-V2X-ConfigCommon-r14 ::= SEQUENCE
struct sl_v2x_cfg_common_r14_s {
  // member variables
  bool                                  v2x_comm_rx_pool_r14_present               = false;
  bool                                  v2x_comm_tx_pool_normal_common_r14_present = false;
  bool                                  p2x_comm_tx_pool_normal_common_r14_present = false;
  bool                                  v2x_comm_tx_pool_exceptional_r14_present   = false;
  bool                                  v2x_sync_cfg_r14_present                   = false;
  bool                                  v2x_inter_freq_info_list_r14_present       = false;
  bool                                  v2x_res_sel_cfg_r14_present                = false;
  bool                                  zone_cfg_r14_present                       = false;
  bool                                  type_tx_sync_r14_present                   = false;
  bool                                  thres_sl_tx_prioritization_r14_present     = false;
  bool                                  anchor_carrier_freq_list_r14_present       = false;
  bool                                  offset_dfn_r14_present                     = false;
  bool                                  cbr_common_tx_cfg_list_r14_present         = false;
  sl_comm_rx_pool_list_v2x_r14_l        v2x_comm_rx_pool_r14;
  sl_comm_tx_pool_list_v2x_r14_l        v2x_comm_tx_pool_normal_common_r14;
  sl_comm_tx_pool_list_v2x_r14_l        p2x_comm_tx_pool_normal_common_r14;
  sl_comm_res_pool_v2x_r14_s            v2x_comm_tx_pool_exceptional_r14;
  sl_sync_cfg_list_v2x_r14_l            v2x_sync_cfg_r14;
  sl_inter_freq_info_list_v2x_r14_l     v2x_inter_freq_info_list_r14;
  sl_comm_tx_pool_sensing_cfg_r14_s     v2x_res_sel_cfg_r14;
  sl_zone_cfg_r14_s                     zone_cfg_r14;
  sl_type_tx_sync_r14_e                 type_tx_sync_r14;
  uint8_t                               thres_sl_tx_prioritization_r14 = 1;
  sl_anchor_carrier_freq_list_v2x_r14_l anchor_carrier_freq_list_r14;
  uint16_t                              offset_dfn_r14 = 0;
  sl_cbr_common_tx_cfg_list_r14_s       cbr_common_tx_cfg_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-PacketDuplicationConfig-r15 ::= SEQUENCE
struct sl_v2x_packet_dupl_cfg_r15_s {
  // member variables
  bool                                 ext                                  = false;
  bool                                 allowed_carrier_freq_cfg_r15_present = false;
  uint8_t                              thresh_sl_reliability_r15            = 1;
  sl_pppr_dest_carrier_freq_list_r15_l allowed_carrier_freq_cfg_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-SyncFreqList-r15 ::= SEQUENCE (SIZE (1..maxFreqV2X-r14)) OF INTEGER
typedef bounded_array<uint32_t, 8> sl_v2x_sync_freq_list_r15_l;

// SystemInformationBlockType1-v1130-IEs ::= SEQUENCE
struct sib_type1_v1130_ies_s {
  // member variables
  bool                  tdd_cfg_v1130_present       = false;
  bool                  cell_sel_info_v1130_present = false;
  bool                  non_crit_ext_present        = false;
  tdd_cfg_v1130_s       tdd_cfg_v1130;
  cell_sel_info_v1130_s cell_sel_info_v1130;
  sib_type1_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v9e0-IEs ::= SEQUENCE
struct sib_type1_v9e0_ies_s {
  // member variables
  bool                        freq_band_ind_v9e0_present        = false;
  bool                        multi_band_info_list_v9e0_present = false;
  bool                        non_crit_ext_present              = false;
  uint16_t                    freq_band_ind_v9e0                = 65;
  multi_band_info_list_v9e0_l multi_band_info_list_v9e0;
  sib_type1_v10j0_ies_s       non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType2-v8h0-IEs ::= SEQUENCE
struct sib_type2_v8h0_ies_s {
  typedef bounded_array<uint8_t, 8> multi_band_info_list_l_;

  // member variables
  bool                    multi_band_info_list_present = false;
  bool                    non_crit_ext_present         = false;
  multi_band_info_list_l_ multi_band_info_list;
  sib_type2_v9e0_ies_s    non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType3-v10j0-IEs ::= SEQUENCE
struct sib_type3_v10j0_ies_s {
  // member variables
  bool                         freq_band_info_r10_present         = false;
  bool                         multi_band_info_list_v10j0_present = false;
  bool                         non_crit_ext_present               = false;
  ns_pmax_list_r10_l           freq_band_info_r10;
  multi_band_info_list_v10j0_l multi_band_info_list_v10j0;
  sib_type3_v10l0_ies_s        non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType5-v8h0-IEs ::= SEQUENCE
struct sib_type5_v8h0_ies_s {
  typedef dyn_array<inter_freq_carrier_freq_info_v8h0_s> inter_freq_carrier_freq_list_v8h0_l_;

  // member variables
  bool                                 inter_freq_carrier_freq_list_v8h0_present = false;
  bool                                 non_crit_ext_present                      = false;
  inter_freq_carrier_freq_list_v8h0_l_ inter_freq_carrier_freq_list_v8h0;
  sib_type5_v9e0_ies_s                 non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType6-v8h0-IEs ::= SEQUENCE
struct sib_type6_v8h0_ies_s {
  typedef dyn_array<carrier_freq_info_utra_fdd_v8h0_s> carrier_freq_list_utra_fdd_v8h0_l_;

  // member variables
  bool                               carrier_freq_list_utra_fdd_v8h0_present = false;
  bool                               non_crit_ext_present                    = false;
  carrier_freq_list_utra_fdd_v8h0_l_ carrier_freq_list_utra_fdd_v8h0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TimeAlignmentTimer ::= ENUMERATED
struct time_align_timer_opts {
  enum options { sf500, sf750, sf1280, sf1920, sf2560, sf5120, sf10240, infinity, nulltype } value;
  typedef int16_t number_type;

  std::string to_string() const;
  int16_t     to_number() const;
};
typedef enumerated<time_align_timer_opts> time_align_timer_e;

// TimeReferenceInfo-r15 ::= SEQUENCE
struct time_ref_info_r15_s {
  // member variables
  bool           uncertainty_r15_present    = false;
  bool           time_info_type_r15_present = false;
  bool           ref_sfn_r15_present        = false;
  ref_time_r15_s time_r15;
  uint8_t        uncertainty_r15 = 0;
  uint16_t       ref_sfn_r15     = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UAC-AC1-SelectAssistInfo-r15 ::= ENUMERATED
struct uac_ac1_select_assist_info_r15_opts {
  enum options { a, b, c, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<uac_ac1_select_assist_info_r15_opts> uac_ac1_select_assist_info_r15_e;

// UAC-BarringInfoSetList-r15 ::= SEQUENCE (SIZE (1..maxBarringInfoSet-r15)) OF UAC-BarringInfoSet-r15
typedef dyn_array<uac_barr_info_set_r15_s> uac_barr_info_set_list_r15_l;

// UAC-BarringPerPLMN-List-r15 ::= SEQUENCE (SIZE (1.. maxPLMN-r11)) OF UAC-BarringPerPLMN-r15
typedef dyn_array<uac_barr_per_plmn_r15_s> uac_barr_per_plmn_list_r15_l;

// UDT-RestrictingPerPLMN-List-r13 ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF UDT-RestrictingPerPLMN-r13
typedef dyn_array<udt_restricting_per_plmn_r13_s> udt_restricting_per_plmn_list_r13_l;

// UE-TimersAndConstants ::= SEQUENCE
struct ue_timers_and_consts_s {
  struct t300_opts {
    enum options { ms100, ms200, ms300, ms400, ms600, ms1000, ms1500, ms2000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t300_opts> t300_e_;
  struct t301_opts {
    enum options { ms100, ms200, ms300, ms400, ms600, ms1000, ms1500, ms2000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t301_opts> t301_e_;
  struct t310_opts {
    enum options { ms0, ms50, ms100, ms200, ms500, ms1000, ms2000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t310_opts> t310_e_;
  struct n310_opts {
    enum options { n1, n2, n3, n4, n6, n8, n10, n20, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<n310_opts> n310_e_;
  struct t311_opts {
    enum options { ms1000, ms3000, ms5000, ms10000, ms15000, ms20000, ms30000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t311_opts> t311_e_;
  struct n311_opts {
    enum options { n1, n2, n3, n4, n5, n6, n8, n10, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<n311_opts> n311_e_;
  struct t300_v1310_opts {
    enum options { ms2500, ms3000, ms3500, ms4000, ms5000, ms6000, ms8000, ms10000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t300_v1310_opts> t300_v1310_e_;
  struct t301_v1310_opts {
    enum options { ms2500, ms3000, ms3500, ms4000, ms5000, ms6000, ms8000, ms10000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t301_v1310_opts> t301_v1310_e_;
  struct t310_v1330_opts {
    enum options { ms4000, ms6000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t310_v1330_opts> t310_v1330_e_;
  struct t300_r15_opts {
    enum options { ms4000, ms6000, ms8000, ms10000, ms15000, ms25000, ms40000, ms60000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t300_r15_opts> t300_r15_e_;

  // member variables
  bool    ext = false;
  t300_e_ t300;
  t301_e_ t301;
  t310_e_ t310;
  n310_e_ n310;
  t311_e_ t311;
  n311_e_ n311;
  // ...
  // group 0
  bool          t300_v1310_present = false;
  bool          t301_v1310_present = false;
  t300_v1310_e_ t300_v1310;
  t301_v1310_e_ t301_v1310;
  // group 1
  bool          t310_v1330_present = false;
  t310_v1330_e_ t310_v1330;
  // group 2
  bool        t300_r15_present = false;
  t300_r15_e_ t300_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-OffloadInfoPerPLMN-r12 ::= SEQUENCE
struct wlan_offload_info_per_plmn_r12_s {
  // member variables
  bool                   ext                                 = false;
  bool                   wlan_offload_cfg_common_r12_present = false;
  bool                   wlan_id_list_r12_present            = false;
  wlan_offload_cfg_r12_s wlan_offload_cfg_common_r12;
  wlan_id_list_r12_l     wlan_id_list_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SchedulingInfo ::= SEQUENCE
struct sched_info_s {
  struct si_periodicity_opts {
    enum options { rf8, rf16, rf32, rf64, rf128, rf256, rf512, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<si_periodicity_opts> si_periodicity_e_;

  // member variables
  si_periodicity_e_ si_periodicity;
  sib_map_info_l    sib_map_info;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformation-v8a0-IEs ::= SEQUENCE
struct sys_info_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockPos-r15 ::= SEQUENCE
struct sib_pos_r15_s {
  // member variables
  bool          ext                       = false;
  bool          late_non_crit_ext_present = false;
  dyn_octstring assist_data_sib_elem_r15;
  dyn_octstring late_non_crit_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v8h0-IEs ::= SEQUENCE
struct sib_type1_v8h0_ies_s {
  // member variables
  bool                   multi_band_info_list_present = false;
  bool                   non_crit_ext_present         = false;
  multi_band_info_list_l multi_band_info_list;
  sib_type1_v9e0_ies_s   non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v920-IEs ::= SEQUENCE
struct sib_type1_v920_ies_s {
  // member variables
  bool                  ims_emergency_support_r9_present = false;
  bool                  cell_sel_info_v920_present       = false;
  bool                  non_crit_ext_present             = false;
  cell_sel_info_v920_s  cell_sel_info_v920;
  sib_type1_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType10 ::= SEQUENCE
struct sib_type10_s {
  // member variables
  bool                ext           = false;
  bool                dummy_present = false;
  fixed_bitstring<16> msg_id;
  fixed_bitstring<16> serial_num;
  fixed_octstring<2>  warning_type;
  fixed_octstring<50> dummy;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType11 ::= SEQUENCE
struct sib_type11_s {
  struct warning_msg_segment_type_opts {
    enum options { not_last_segment, last_segment, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<warning_msg_segment_type_opts> warning_msg_segment_type_e_;

  // member variables
  bool                        ext                        = false;
  bool                        data_coding_scheme_present = false;
  fixed_bitstring<16>         msg_id;
  fixed_bitstring<16>         serial_num;
  warning_msg_segment_type_e_ warning_msg_segment_type;
  uint8_t                     warning_msg_segment_num = 0;
  dyn_octstring               warning_msg_segment;
  fixed_octstring<1>          data_coding_scheme;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType12-r9 ::= SEQUENCE
struct sib_type12_r9_s {
  struct warning_msg_segment_type_r9_opts {
    enum options { not_last_segment, last_segment, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<warning_msg_segment_type_r9_opts> warning_msg_segment_type_r9_e_;

  // member variables
  bool                           ext                           = false;
  bool                           data_coding_scheme_r9_present = false;
  bool                           late_non_crit_ext_present     = false;
  fixed_bitstring<16>            msg_id_r9;
  fixed_bitstring<16>            serial_num_r9;
  warning_msg_segment_type_r9_e_ warning_msg_segment_type_r9;
  uint8_t                        warning_msg_segment_num_r9 = 0;
  dyn_octstring                  warning_msg_segment_r9;
  fixed_octstring<1>             data_coding_scheme_r9;
  dyn_octstring                  late_non_crit_ext;
  // ...
  // group 0
  bool          warning_area_coordinates_segment_r15_present = false;
  dyn_octstring warning_area_coordinates_segment_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType13-r9 ::= SEQUENCE
struct sib_type13_r9_s {
  // member variables
  bool                      ext                       = false;
  bool                      late_non_crit_ext_present = false;
  mbsfn_area_info_list_r9_l mbsfn_area_info_list_r9;
  mbms_notif_cfg_r9_s       notif_cfg_r9;
  dyn_octstring             late_non_crit_ext;
  // ...
  // group 0
  bool                             notif_cfg_v1430_present = false;
  copy_ptr<mbms_notif_cfg_v1430_s> notif_cfg_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType14-r11 ::= SEQUENCE
struct sib_type14_r11_s {
  struct eab_param_r11_c_ {
    typedef dyn_array<eab_cfg_plmn_r11_s> eab_per_plmn_list_r11_l_;
    struct types_opts {
      enum options { eab_common_r11, eab_per_plmn_list_r11, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    eab_param_r11_c_() = default;
    eab_param_r11_c_(const eab_param_r11_c_& other);
    eab_param_r11_c_& operator=(const eab_param_r11_c_& other);
    ~eab_param_r11_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    eab_cfg_r11_s& eab_common_r11()
    {
      assert_choice_type("eab-Common-r11", type_.to_string(), "eab-Param-r11");
      return c.get<eab_cfg_r11_s>();
    }
    eab_per_plmn_list_r11_l_& eab_per_plmn_list_r11()
    {
      assert_choice_type("eab-PerPLMN-List-r11", type_.to_string(), "eab-Param-r11");
      return c.get<eab_per_plmn_list_r11_l_>();
    }
    const eab_cfg_r11_s& eab_common_r11() const
    {
      assert_choice_type("eab-Common-r11", type_.to_string(), "eab-Param-r11");
      return c.get<eab_cfg_r11_s>();
    }
    const eab_per_plmn_list_r11_l_& eab_per_plmn_list_r11() const
    {
      assert_choice_type("eab-PerPLMN-List-r11", type_.to_string(), "eab-Param-r11");
      return c.get<eab_per_plmn_list_r11_l_>();
    }
    eab_cfg_r11_s& set_eab_common_r11()
    {
      set(types::eab_common_r11);
      return c.get<eab_cfg_r11_s>();
    }
    eab_per_plmn_list_r11_l_& set_eab_per_plmn_list_r11()
    {
      set(types::eab_per_plmn_list_r11);
      return c.get<eab_per_plmn_list_r11_l_>();
    }

  private:
    types                                                                          type_;
    choice_buffer_t<MAX2(sizeof(eab_cfg_r11_s), sizeof(eab_per_plmn_list_r11_l_))> c;

    void destroy_();
  };
  struct eab_per_rsrp_r15_opts {
    enum options { thresh0, thresh1, thresh2, thresh3, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<eab_per_rsrp_r15_opts> eab_per_rsrp_r15_e_;

  // member variables
  bool             ext                       = false;
  bool             eab_param_r11_present     = false;
  bool             late_non_crit_ext_present = false;
  eab_param_r11_c_ eab_param_r11;
  dyn_octstring    late_non_crit_ext;
  // ...
  // group 0
  bool                eab_per_rsrp_r15_present = false;
  eab_per_rsrp_r15_e_ eab_per_rsrp_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType15-r11 ::= SEQUENCE
struct sib_type15_r11_s {
  // member variables
  bool                           ext                                  = false;
  bool                           mbms_sai_intra_freq_r11_present      = false;
  bool                           mbms_sai_inter_freq_list_r11_present = false;
  bool                           late_non_crit_ext_present            = false;
  mbms_sai_list_r11_l            mbms_sai_intra_freq_r11;
  mbms_sai_inter_freq_list_r11_l mbms_sai_inter_freq_list_r11;
  dyn_octstring                  late_non_crit_ext;
  // ...
  // group 0
  bool                                       mbms_sai_inter_freq_list_v1140_present = false;
  copy_ptr<mbms_sai_inter_freq_list_v1140_l> mbms_sai_inter_freq_list_v1140;
  // group 1
  bool                                              mbms_intra_freq_carrier_type_r14_present      = false;
  bool                                              mbms_inter_freq_carrier_type_list_r14_present = false;
  copy_ptr<mbms_carrier_type_r14_s>                 mbms_intra_freq_carrier_type_r14;
  copy_ptr<mbms_inter_freq_carrier_type_list_r14_l> mbms_inter_freq_carrier_type_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType16-r11 ::= SEQUENCE
struct sib_type16_r11_s {
  struct time_info_r11_s_ {
    // member variables
    bool               day_light_saving_time_r11_present = false;
    bool               leap_seconds_r11_present          = false;
    bool               local_time_offset_r11_present     = false;
    uint64_t           time_info_utc_r11                 = 0;
    fixed_bitstring<2> day_light_saving_time_r11;
    int16_t            leap_seconds_r11      = -127;
    int8_t             local_time_offset_r11 = -63;
  };

  // member variables
  bool             ext                       = false;
  bool             time_info_r11_present     = false;
  bool             late_non_crit_ext_present = false;
  time_info_r11_s_ time_info_r11;
  dyn_octstring    late_non_crit_ext;
  // ...
  // group 0
  bool                          time_ref_info_r15_present = false;
  copy_ptr<time_ref_info_r15_s> time_ref_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType17-r12 ::= SEQUENCE
struct sib_type17_r12_s {
  typedef dyn_array<wlan_offload_info_per_plmn_r12_s> wlan_offload_info_per_plmn_list_r12_l_;

  // member variables
  bool                                   ext                                         = false;
  bool                                   wlan_offload_info_per_plmn_list_r12_present = false;
  bool                                   late_non_crit_ext_present                   = false;
  wlan_offload_info_per_plmn_list_r12_l_ wlan_offload_info_per_plmn_list_r12;
  dyn_octstring                          late_non_crit_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType18-r12 ::= SEQUENCE
struct sib_type18_r12_s {
  struct comm_cfg_r12_s_ {
    // member variables
    bool                       comm_tx_pool_normal_common_r12_present = false;
    bool                       comm_tx_pool_exceptional_r12_present   = false;
    bool                       comm_sync_cfg_r12_present              = false;
    sl_comm_rx_pool_list_r12_l comm_rx_pool_r12;
    sl_comm_tx_pool_list_r12_l comm_tx_pool_normal_common_r12;
    sl_comm_tx_pool_list_r12_l comm_tx_pool_exceptional_r12;
    sl_sync_cfg_list_r12_l     comm_sync_cfg_r12;
  };

  // member variables
  bool            ext                       = false;
  bool            comm_cfg_r12_present      = false;
  bool            late_non_crit_ext_present = false;
  comm_cfg_r12_s_ comm_cfg_r12;
  dyn_octstring   late_non_crit_ext;
  // ...
  // group 0
  bool                                     comm_tx_pool_normal_common_ext_r13_present = false;
  bool                                     comm_tx_res_uc_req_allowed_r13_present     = false;
  bool                                     comm_tx_allow_relay_common_r13_present     = false;
  copy_ptr<sl_comm_tx_pool_list_ext_r13_l> comm_tx_pool_normal_common_ext_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType19-r12 ::= SEQUENCE
struct sib_type19_r12_s {
  struct disc_cfg_r12_s_ {
    // member variables
    bool                           disc_tx_pool_common_r12_present = false;
    bool                           disc_tx_pwr_info_r12_present    = false;
    bool                           disc_sync_cfg_r12_present       = false;
    sl_disc_rx_pool_list_r12_l     disc_rx_pool_r12;
    sl_disc_tx_pool_list_r12_l     disc_tx_pool_common_r12;
    sl_disc_tx_pwr_info_list_r12_l disc_tx_pwr_info_r12;
    sl_sync_cfg_list_r12_l         disc_sync_cfg_r12;
  };
  struct disc_cfg_v1310_s_ {
    // member variables
    bool                              disc_inter_freq_list_v1310_present  = false;
    bool                              gap_requests_allowed_common_present = false;
    sl_carrier_freq_info_list_v1310_l disc_inter_freq_list_v1310;
  };
  struct disc_cfg_relay_r13_s_ {
    // member variables
    sl_disc_cfg_relay_ue_r13_s  relay_ue_cfg_r13;
    sl_disc_cfg_remote_ue_r13_s remote_ue_cfg_r13;
  };
  struct disc_cfg_ps_minus13_s_ {
    // member variables
    bool                       disc_tx_pool_ps_common_r13_present = false;
    sl_disc_rx_pool_list_r12_l disc_rx_pool_ps_r13;
    sl_disc_tx_pool_list_r12_l disc_tx_pool_ps_common_r13;
  };

  // member variables
  bool                            ext                              = false;
  bool                            disc_cfg_r12_present             = false;
  bool                            disc_inter_freq_list_r12_present = false;
  bool                            late_non_crit_ext_present        = false;
  disc_cfg_r12_s_                 disc_cfg_r12;
  sl_carrier_freq_info_list_r12_l disc_inter_freq_list_r12;
  dyn_octstring                   late_non_crit_ext;
  // ...
  // group 0
  bool                             disc_cfg_v1310_present      = false;
  bool                             disc_cfg_relay_r13_present  = false;
  bool                             disc_cfg_ps_minus13_present = false;
  copy_ptr<disc_cfg_v1310_s_>      disc_cfg_v1310;
  copy_ptr<disc_cfg_relay_r13_s_>  disc_cfg_relay_r13;
  copy_ptr<disc_cfg_ps_minus13_s_> disc_cfg_ps_minus13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType2 ::= SEQUENCE
struct sib_type2_s {
  struct ac_barr_info_s_ {
    // member variables
    bool          ac_barr_for_mo_sig_present  = false;
    bool          ac_barr_for_mo_data_present = false;
    bool          ac_barr_for_emergency       = false;
    ac_barr_cfg_s ac_barr_for_mo_sig;
    ac_barr_cfg_s ac_barr_for_mo_data;
  };
  struct freq_info_s_ {
    struct ul_bw_opts {
      enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<ul_bw_opts> ul_bw_e_;

    // member variables
    bool     ul_carrier_freq_present = false;
    bool     ul_bw_present           = false;
    uint16_t ul_carrier_freq         = 0;
    ul_bw_e_ ul_bw;
    uint8_t  add_spec_emission = 1;
  };

  // member variables
  bool                   ext                       = false;
  bool                   ac_barr_info_present      = false;
  bool                   mbsfn_sf_cfg_list_present = false;
  ac_barr_info_s_        ac_barr_info;
  rr_cfg_common_sib_s    rr_cfg_common;
  ue_timers_and_consts_s ue_timers_and_consts;
  freq_info_s_           freq_info;
  mbsfn_sf_cfg_list_l    mbsfn_sf_cfg_list;
  time_align_timer_e     time_align_timer_common;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;
  // group 0
  bool                    ssac_barr_for_mmtel_voice_r9_present = false;
  bool                    ssac_barr_for_mmtel_video_r9_present = false;
  copy_ptr<ac_barr_cfg_s> ssac_barr_for_mmtel_voice_r9;
  copy_ptr<ac_barr_cfg_s> ssac_barr_for_mmtel_video_r9;
  // group 1
  bool                    ac_barr_for_csfb_r10_present = false;
  copy_ptr<ac_barr_cfg_s> ac_barr_for_csfb_r10;
  // group 2
  bool                                  ac_barr_skip_for_mmtel_voice_r12_present = false;
  bool                                  ac_barr_skip_for_mmtel_video_r12_present = false;
  bool                                  ac_barr_skip_for_sms_r12_present         = false;
  bool                                  ac_barr_per_plmn_list_r12_present        = false;
  copy_ptr<ac_barr_per_plmn_list_r12_l> ac_barr_per_plmn_list_r12;
  // group 3
  bool voice_service_cause_ind_r12_present = false;
  // group 4
  bool                                    acdc_barr_for_common_r13_present    = false;
  bool                                    acdc_barr_per_plmn_list_r13_present = false;
  copy_ptr<acdc_barr_for_common_r13_s>    acdc_barr_for_common_r13;
  copy_ptr<acdc_barr_per_plmn_list_r13_l> acdc_barr_per_plmn_list_r13;
  // group 5
  bool                                          udt_restricting_for_common_r13_present    = false;
  bool                                          udt_restricting_per_plmn_list_r13_present = false;
  bool                                          c_io_t_eps_optim_info_r13_present         = false;
  bool                                          use_full_resume_id_r13_present            = false;
  copy_ptr<udt_restricting_r13_s>               udt_restricting_for_common_r13;
  copy_ptr<udt_restricting_per_plmn_list_r13_l> udt_restricting_per_plmn_list_r13;
  copy_ptr<ciot_eps_optim_info_r13_l>           c_io_t_eps_optim_info_r13;
  // group 6
  bool unicast_freq_hop_ind_r13_present = false;
  // group 7
  bool                                mbsfn_sf_cfg_list_v1430_present     = false;
  bool                                video_service_cause_ind_r14_present = false;
  copy_ptr<mbsfn_sf_cfg_list_v1430_l> mbsfn_sf_cfg_list_v1430;
  // group 8
  bool                           plmn_info_list_r15_present = false;
  copy_ptr<plmn_info_list_r15_l> plmn_info_list_r15;
  // group 9
  bool cp_edt_r15_present                     = false;
  bool up_edt_r15_present                     = false;
  bool idle_mode_meass_r15_present            = false;
  bool reduced_cp_latency_enabled_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType20-r13 ::= SEQUENCE
struct sib_type20_r13_s {
  struct sc_mcch_repeat_period_r13_opts {
    enum options { rf2, rf4, rf8, rf16, rf32, rf64, rf128, rf256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<sc_mcch_repeat_period_r13_opts> sc_mcch_repeat_period_r13_e_;
  struct sc_mcch_mod_period_r13_opts {
    enum options {
      rf2,
      rf4,
      rf8,
      rf16,
      rf32,
      rf64,
      rf128,
      rf256,
      rf512,
      rf1024,
      r2048,
      rf4096,
      rf8192,
      rf16384,
      rf32768,
      rf65536,
      nulltype
    } value;
    typedef uint32_t number_type;

    std::string to_string() const;
    uint32_t    to_number() const;
  };
  typedef enumerated<sc_mcch_mod_period_r13_opts> sc_mcch_mod_period_r13_e_;
  struct br_bcch_cfg_r14_s_ {
    struct mpdcch_num_repeat_sc_mcch_r14_opts {
      enum options { r1, r2, r4, r8, r16, r32, r64, r128, r256, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<mpdcch_num_repeat_sc_mcch_r14_opts> mpdcch_num_repeat_sc_mcch_r14_e_;
    struct mpdcch_start_sf_sc_mcch_r14_c_ {
      struct fdd_r14_opts {
        enum options { v1, v1dot5, v2, v2dot5, v4, v5, v8, v10, nulltype } value;
        typedef float number_type;

        std::string to_string() const;
        float       to_number() const;
        std::string to_number_string() const;
      };
      typedef enumerated<fdd_r14_opts> fdd_r14_e_;
      struct tdd_r14_opts {
        enum options { v1, v2, v4, v5, v8, v10, v20, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<tdd_r14_opts> tdd_r14_e_;
      struct types_opts {
        enum options { fdd_r14, tdd_r14, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      mpdcch_start_sf_sc_mcch_r14_c_() = default;
      mpdcch_start_sf_sc_mcch_r14_c_(const mpdcch_start_sf_sc_mcch_r14_c_& other);
      mpdcch_start_sf_sc_mcch_r14_c_& operator=(const mpdcch_start_sf_sc_mcch_r14_c_& other);
      ~mpdcch_start_sf_sc_mcch_r14_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      fdd_r14_e_& fdd_r14()
      {
        assert_choice_type("fdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MCCH-r14");
        return c.get<fdd_r14_e_>();
      }
      tdd_r14_e_& tdd_r14()
      {
        assert_choice_type("tdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MCCH-r14");
        return c.get<tdd_r14_e_>();
      }
      const fdd_r14_e_& fdd_r14() const
      {
        assert_choice_type("fdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MCCH-r14");
        return c.get<fdd_r14_e_>();
      }
      const tdd_r14_e_& tdd_r14() const
      {
        assert_choice_type("tdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MCCH-r14");
        return c.get<tdd_r14_e_>();
      }
      fdd_r14_e_& set_fdd_r14()
      {
        set(types::fdd_r14);
        return c.get<fdd_r14_e_>();
      }
      tdd_r14_e_& set_tdd_r14()
      {
        set(types::tdd_r14);
        return c.get<tdd_r14_e_>();
      }

    private:
      types                                                         type_;
      choice_buffer_t<MAX2(sizeof(fdd_r14_e_), sizeof(tdd_r14_e_))> c;

      void destroy_();
    };
    struct mpdcch_pdsch_hop_cfg_sc_mcch_r14_opts {
      enum options { off, ce_mode_a, ce_mode_b, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<mpdcch_pdsch_hop_cfg_sc_mcch_r14_opts> mpdcch_pdsch_hop_cfg_sc_mcch_r14_e_;
    struct sc_mcch_repeat_period_br_r14_opts {
      enum options { rf32, rf128, rf512, rf1024, rf2048, rf4096, rf8192, rf16384, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<sc_mcch_repeat_period_br_r14_opts> sc_mcch_repeat_period_br_r14_e_;
    struct sc_mcch_mod_period_br_r14_opts {
      enum options {
        rf32,
        rf128,
        rf256,
        rf512,
        rf1024,
        rf2048,
        rf4096,
        rf8192,
        rf16384,
        rf32768,
        rf65536,
        rf131072,
        rf262144,
        rf524288,
        rf1048576,
        nulltype
      } value;
      typedef uint32_t number_type;

      std::string to_string() const;
      uint32_t    to_number() const;
    };
    typedef enumerated<sc_mcch_mod_period_br_r14_opts> sc_mcch_mod_period_br_r14_e_;

    // member variables
    uint8_t                             mpdcch_nb_sc_mcch_r14 = 1;
    mpdcch_num_repeat_sc_mcch_r14_e_    mpdcch_num_repeat_sc_mcch_r14;
    mpdcch_start_sf_sc_mcch_r14_c_      mpdcch_start_sf_sc_mcch_r14;
    mpdcch_pdsch_hop_cfg_sc_mcch_r14_e_ mpdcch_pdsch_hop_cfg_sc_mcch_r14;
    uint32_t                            sc_mcch_carrier_freq_r14 = 0;
    uint8_t                             sc_mcch_offset_br_r14    = 0;
    sc_mcch_repeat_period_br_r14_e_     sc_mcch_repeat_period_br_r14;
    sc_mcch_mod_period_br_r14_e_        sc_mcch_mod_period_br_r14;
  };
  struct pdsch_max_num_repeat_cemode_a_sc_mtch_r14_opts {
    enum options { r16, r32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pdsch_max_num_repeat_cemode_a_sc_mtch_r14_opts> pdsch_max_num_repeat_cemode_a_sc_mtch_r14_e_;
  struct pdsch_max_num_repeat_cemode_b_sc_mtch_r14_opts {
    enum options { r192, r256, r384, r512, r768, r1024, r1536, r2048, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<pdsch_max_num_repeat_cemode_b_sc_mtch_r14_opts> pdsch_max_num_repeat_cemode_b_sc_mtch_r14_e_;

  // member variables
  bool                         ext                       = false;
  bool                         sc_mcch_dur_r13_present   = false;
  bool                         late_non_crit_ext_present = false;
  sc_mcch_repeat_period_r13_e_ sc_mcch_repeat_period_r13;
  uint8_t                      sc_mcch_offset_r13   = 0;
  uint8_t                      sc_mcch_first_sf_r13 = 0;
  uint8_t                      sc_mcch_dur_r13      = 2;
  sc_mcch_mod_period_r13_e_    sc_mcch_mod_period_r13;
  dyn_octstring                late_non_crit_ext;
  // ...
  // group 0
  bool                                         br_bcch_cfg_r14_present                           = false;
  bool                                         sc_mcch_sched_info_r14_present                    = false;
  bool                                         pdsch_max_num_repeat_cemode_a_sc_mtch_r14_present = false;
  bool                                         pdsch_max_num_repeat_cemode_b_sc_mtch_r14_present = false;
  copy_ptr<br_bcch_cfg_r14_s_>                 br_bcch_cfg_r14;
  copy_ptr<sc_mcch_sched_info_r14_s>           sc_mcch_sched_info_r14;
  pdsch_max_num_repeat_cemode_a_sc_mtch_r14_e_ pdsch_max_num_repeat_cemode_a_sc_mtch_r14;
  pdsch_max_num_repeat_cemode_b_sc_mtch_r14_e_ pdsch_max_num_repeat_cemode_b_sc_mtch_r14;
  // group 1
  bool sc_mcch_repeat_period_v1470_present = false;
  bool sc_mcch_mod_period_v1470_present    = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType21-r14 ::= SEQUENCE
struct sib_type21_r14_s {
  // member variables
  bool                    ext                           = false;
  bool                    sl_v2x_cfg_common_r14_present = false;
  bool                    late_non_crit_ext_present     = false;
  sl_v2x_cfg_common_r14_s sl_v2x_cfg_common_r14;
  dyn_octstring           late_non_crit_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType24-r15 ::= SEQUENCE
struct sib_type24_r15_s {
  // member variables
  bool                        ext                              = false;
  bool                        carrier_freq_list_nr_r15_present = false;
  bool                        t_resel_nr_sf_r15_present        = false;
  bool                        late_non_crit_ext_present        = false;
  carrier_freq_list_nr_r15_l  carrier_freq_list_nr_r15;
  uint8_t                     t_resel_nr_r15 = 0;
  speed_state_scale_factors_s t_resel_nr_sf_r15;
  dyn_octstring               late_non_crit_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType25-r15 ::= SEQUENCE
struct sib_type25_r15_s {
  struct uac_ac1_select_assist_info_r15_c_ {
    typedef bounded_array<uac_ac1_select_assist_info_r15_e, 6> individual_plmn_list_r15_l_;
    struct types_opts {
      enum options { plmn_common_r15, individual_plmn_list_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    uac_ac1_select_assist_info_r15_c_() = default;
    uac_ac1_select_assist_info_r15_c_(const uac_ac1_select_assist_info_r15_c_& other);
    uac_ac1_select_assist_info_r15_c_& operator=(const uac_ac1_select_assist_info_r15_c_& other);
    ~uac_ac1_select_assist_info_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uac_ac1_select_assist_info_r15_e& plmn_common_r15()
    {
      assert_choice_type("plmnCommon-r15", type_.to_string(), "uac-AC1-SelectAssistInfo-r15");
      return c.get<uac_ac1_select_assist_info_r15_e>();
    }
    individual_plmn_list_r15_l_& individual_plmn_list_r15()
    {
      assert_choice_type("individualPLMNList-r15", type_.to_string(), "uac-AC1-SelectAssistInfo-r15");
      return c.get<individual_plmn_list_r15_l_>();
    }
    const uac_ac1_select_assist_info_r15_e& plmn_common_r15() const
    {
      assert_choice_type("plmnCommon-r15", type_.to_string(), "uac-AC1-SelectAssistInfo-r15");
      return c.get<uac_ac1_select_assist_info_r15_e>();
    }
    const individual_plmn_list_r15_l_& individual_plmn_list_r15() const
    {
      assert_choice_type("individualPLMNList-r15", type_.to_string(), "uac-AC1-SelectAssistInfo-r15");
      return c.get<individual_plmn_list_r15_l_>();
    }
    uac_ac1_select_assist_info_r15_e& set_plmn_common_r15()
    {
      set(types::plmn_common_r15);
      return c.get<uac_ac1_select_assist_info_r15_e>();
    }
    individual_plmn_list_r15_l_& set_individual_plmn_list_r15()
    {
      set(types::individual_plmn_list_r15);
      return c.get<individual_plmn_list_r15_l_>();
    }

  private:
    types                                                                                                type_;
    choice_buffer_t<MAX2(sizeof(individual_plmn_list_r15_l_), sizeof(uac_ac1_select_assist_info_r15_e))> c;

    void destroy_();
  };

  // member variables
  bool                              ext                                    = false;
  bool                              uac_barr_for_common_r15_present        = false;
  bool                              uac_barr_per_plmn_list_r15_present     = false;
  bool                              uac_ac1_select_assist_info_r15_present = false;
  bool                              late_non_crit_ext_present              = false;
  uac_barr_per_cat_list_r15_l       uac_barr_for_common_r15;
  uac_barr_per_plmn_list_r15_l      uac_barr_per_plmn_list_r15;
  uac_barr_info_set_list_r15_l      uac_barr_info_set_list_r15;
  uac_ac1_select_assist_info_r15_c_ uac_ac1_select_assist_info_r15;
  dyn_octstring                     late_non_crit_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType26-r15 ::= SEQUENCE
struct sib_type26_r15_s {
  // member variables
  bool                              ext                                  = false;
  bool                              v2x_inter_freq_info_list_r15_present = false;
  bool                              cbr_pssch_tx_cfg_list_r15_present    = false;
  bool                              v2x_packet_dupl_cfg_r15_present      = false;
  bool                              sync_freq_list_r15_present           = false;
  bool                              slss_tx_multi_freq_r15_present       = false;
  bool                              v2x_freq_sel_cfg_list_r15_present    = false;
  bool                              thresh_s_rssi_cbr_r14_present        = false;
  sl_inter_freq_info_list_v2x_r14_l v2x_inter_freq_info_list_r15;
  sl_cbr_pppp_tx_cfg_list_r15_l     cbr_pssch_tx_cfg_list_r15;
  sl_v2x_packet_dupl_cfg_r15_s      v2x_packet_dupl_cfg_r15;
  sl_v2x_sync_freq_list_r15_l       sync_freq_list_r15;
  sl_v2x_freq_sel_cfg_list_r15_l    v2x_freq_sel_cfg_list_r15;
  uint8_t                           thresh_s_rssi_cbr_r14 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType3 ::= SEQUENCE
struct sib_type3_s {
  struct cell_resel_info_common_s_ {
    struct q_hyst_opts {
      enum options {
        db0,
        db1,
        db2,
        db3,
        db4,
        db5,
        db6,
        db8,
        db10,
        db12,
        db14,
        db16,
        db18,
        db20,
        db22,
        db24,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<q_hyst_opts> q_hyst_e_;
    struct speed_state_resel_pars_s_ {
      struct q_hyst_sf_s_ {
        struct sf_medium_opts {
          enum options { db_minus6, db_minus4, db_minus2, db0, nulltype } value;
          typedef int8_t number_type;

          std::string to_string() const;
          int8_t      to_number() const;
        };
        typedef enumerated<sf_medium_opts> sf_medium_e_;
        struct sf_high_opts {
          enum options { db_minus6, db_minus4, db_minus2, db0, nulltype } value;
          typedef int8_t number_type;

          std::string to_string() const;
          int8_t      to_number() const;
        };
        typedef enumerated<sf_high_opts> sf_high_e_;

        // member variables
        sf_medium_e_ sf_medium;
        sf_high_e_   sf_high;
      };

      // member variables
      mob_state_params_s mob_state_params;
      q_hyst_sf_s_       q_hyst_sf;
    };

    // member variables
    bool                      speed_state_resel_pars_present = false;
    q_hyst_e_                 q_hyst;
    speed_state_resel_pars_s_ speed_state_resel_pars;
  };
  struct cell_resel_serving_freq_info_s_ {
    // member variables
    bool    s_non_intra_search_present = false;
    uint8_t s_non_intra_search         = 0;
    uint8_t thresh_serving_low         = 0;
    uint8_t cell_resel_prio            = 0;
  };
  struct intra_freq_cell_resel_info_s_ {
    // member variables
    bool                        p_max_present            = false;
    bool                        s_intra_search_present   = false;
    bool                        allowed_meas_bw_present  = false;
    bool                        t_resel_eutra_sf_present = false;
    int8_t                      q_rx_lev_min             = -70;
    int8_t                      p_max                    = -30;
    uint8_t                     s_intra_search           = 0;
    allowed_meas_bw_e           allowed_meas_bw;
    bool                        presence_ant_port1 = false;
    fixed_bitstring<2>          neigh_cell_cfg;
    uint8_t                     t_resel_eutra = 0;
    speed_state_scale_factors_s t_resel_eutra_sf;
  };
  struct s_intra_search_v920_s_ {
    // member variables
    uint8_t s_intra_search_p_r9 = 0;
    uint8_t s_intra_search_q_r9 = 0;
  };
  struct s_non_intra_search_v920_s_ {
    // member variables
    uint8_t s_non_intra_search_p_r9 = 0;
    uint8_t s_non_intra_search_q_r9 = 0;
  };

  // member variables
  bool                            ext = false;
  cell_resel_info_common_s_       cell_resel_info_common;
  cell_resel_serving_freq_info_s_ cell_resel_serving_freq_info;
  intra_freq_cell_resel_info_s_   intra_freq_cell_resel_info;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;
  // group 0
  bool                                 s_intra_search_v920_present     = false;
  bool                                 s_non_intra_search_v920_present = false;
  bool                                 q_qual_min_r9_present           = false;
  bool                                 thresh_serving_low_q_r9_present = false;
  copy_ptr<s_intra_search_v920_s_>     s_intra_search_v920;
  copy_ptr<s_non_intra_search_v920_s_> s_non_intra_search_v920;
  int8_t                               q_qual_min_r9           = -34;
  uint8_t                              thresh_serving_low_q_r9 = 0;
  // group 1
  bool   q_qual_min_wb_r11_present = false;
  int8_t q_qual_min_wb_r11         = -34;
  // group 2
  bool   q_qual_min_rsrq_on_all_symbols_r12_present = false;
  int8_t q_qual_min_rsrq_on_all_symbols_r12         = -34;
  // group 3
  bool                                           cell_resel_serving_freq_info_v1310_present = false;
  bool                                           redist_serving_info_r13_present            = false;
  bool                                           cell_sel_info_ce_r13_present               = false;
  bool                                           t_resel_eutra_ce_r13_present               = false;
  copy_ptr<cell_resel_serving_freq_info_v1310_s> cell_resel_serving_freq_info_v1310;
  copy_ptr<redist_serving_info_r13_s>            redist_serving_info_r13;
  copy_ptr<cell_sel_info_ce_r13_s>               cell_sel_info_ce_r13;
  uint8_t                                        t_resel_eutra_ce_r13 = 0;
  // group 4
  bool                              cell_sel_info_ce1_r13_present = false;
  copy_ptr<cell_sel_info_ce1_r13_s> cell_sel_info_ce1_r13;
  // group 5
  bool                                cell_sel_info_ce1_v1360_present = false;
  copy_ptr<cell_sel_info_ce1_v1360_s> cell_sel_info_ce1_v1360;
  // group 6
  bool                                     cell_resel_info_common_v1460_present = false;
  copy_ptr<cell_resel_info_common_v1460_s> cell_resel_info_common_v1460;
  // group 7
  bool                                 cell_resel_info_hsdn_r15_present          = false;
  bool                                 cell_sel_info_ce_v1530_present            = false;
  bool                                 crs_intf_mitig_neigh_cells_ce_r15_present = false;
  copy_ptr<cell_resel_info_hsdn_r15_s> cell_resel_info_hsdn_r15;
  copy_ptr<cell_sel_info_ce_v1530_s>   cell_sel_info_ce_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType4 ::= SEQUENCE
struct sib_type4_s {
  // member variables
  bool                         ext                                = false;
  bool                         intra_freq_neigh_cell_list_present = false;
  bool                         intra_freq_black_cell_list_present = false;
  bool                         csg_pci_range_present              = false;
  intra_freq_neigh_cell_list_l intra_freq_neigh_cell_list;
  intra_freq_black_cell_list_l intra_freq_black_cell_list;
  pci_range_s                  csg_pci_range;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;
  // group 0
  bool                                            intra_freq_neigh_hsdn_cell_list_r15_present = false;
  copy_ptr<intra_freq_neigh_hsdn_cell_list_r15_l> intra_freq_neigh_hsdn_cell_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType5 ::= SEQUENCE
struct sib_type5_s {
  // member variables
  bool                           ext = false;
  inter_freq_carrier_freq_list_l inter_freq_carrier_freq_list;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;
  // group 0
  bool                                             inter_freq_carrier_freq_list_v1250_present   = false;
  bool                                             inter_freq_carrier_freq_list_ext_r12_present = false;
  copy_ptr<inter_freq_carrier_freq_list_v1250_l>   inter_freq_carrier_freq_list_v1250;
  copy_ptr<inter_freq_carrier_freq_list_ext_r12_l> inter_freq_carrier_freq_list_ext_r12;
  // group 1
  bool                                               inter_freq_carrier_freq_list_ext_v1280_present = false;
  copy_ptr<inter_freq_carrier_freq_list_ext_v1280_l> inter_freq_carrier_freq_list_ext_v1280;
  // group 2
  bool                                               inter_freq_carrier_freq_list_v1310_present     = false;
  bool                                               inter_freq_carrier_freq_list_ext_v1310_present = false;
  copy_ptr<inter_freq_carrier_freq_list_v1310_l>     inter_freq_carrier_freq_list_v1310;
  copy_ptr<inter_freq_carrier_freq_list_ext_v1310_l> inter_freq_carrier_freq_list_ext_v1310;
  // group 3
  bool                                               inter_freq_carrier_freq_list_v1350_present     = false;
  bool                                               inter_freq_carrier_freq_list_ext_v1350_present = false;
  copy_ptr<inter_freq_carrier_freq_list_v1350_l>     inter_freq_carrier_freq_list_v1350;
  copy_ptr<inter_freq_carrier_freq_list_ext_v1350_l> inter_freq_carrier_freq_list_ext_v1350;
  // group 4
  bool                                               inter_freq_carrier_freq_list_ext_v1360_present = false;
  copy_ptr<inter_freq_carrier_freq_list_ext_v1360_l> inter_freq_carrier_freq_list_ext_v1360;
  // group 5
  bool    scptm_freq_offset_r14_present = false;
  uint8_t scptm_freq_offset_r14         = 1;
  // group 6
  bool                                               inter_freq_carrier_freq_list_v1530_present     = false;
  bool                                               inter_freq_carrier_freq_list_ext_v1530_present = false;
  bool                                               meas_idle_cfg_sib_r15_present                  = false;
  copy_ptr<inter_freq_carrier_freq_list_v1530_l>     inter_freq_carrier_freq_list_v1530;
  copy_ptr<inter_freq_carrier_freq_list_ext_v1530_l> inter_freq_carrier_freq_list_ext_v1530;
  copy_ptr<meas_idle_cfg_sib_r15_s>                  meas_idle_cfg_sib_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType6 ::= SEQUENCE
struct sib_type6_s {
  typedef dyn_array<carrier_freq_info_utra_v1250_s> carrier_freq_list_utra_fdd_v1250_l_;
  typedef dyn_array<carrier_freq_info_utra_v1250_s> carrier_freq_list_utra_tdd_v1250_l_;

  // member variables
  bool                         ext                                = false;
  bool                         carrier_freq_list_utra_fdd_present = false;
  bool                         carrier_freq_list_utra_tdd_present = false;
  bool                         t_resel_utra_sf_present            = false;
  carrier_freq_list_utra_fdd_l carrier_freq_list_utra_fdd;
  carrier_freq_list_utra_tdd_l carrier_freq_list_utra_tdd;
  uint8_t                      t_resel_utra = 0;
  speed_state_scale_factors_s  t_resel_utra_sf;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;
  // group 0
  bool                                           carrier_freq_list_utra_fdd_v1250_present   = false;
  bool                                           carrier_freq_list_utra_tdd_v1250_present   = false;
  bool                                           carrier_freq_list_utra_fdd_ext_r12_present = false;
  bool                                           carrier_freq_list_utra_tdd_ext_r12_present = false;
  copy_ptr<carrier_freq_list_utra_fdd_v1250_l_>  carrier_freq_list_utra_fdd_v1250;
  copy_ptr<carrier_freq_list_utra_tdd_v1250_l_>  carrier_freq_list_utra_tdd_v1250;
  copy_ptr<carrier_freq_list_utra_fdd_ext_r12_l> carrier_freq_list_utra_fdd_ext_r12;
  copy_ptr<carrier_freq_list_utra_tdd_ext_r12_l> carrier_freq_list_utra_tdd_ext_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType7 ::= SEQUENCE
struct sib_type7_s {
  // member variables
  bool                            ext                             = false;
  bool                            t_resel_geran_sf_present        = false;
  bool                            carrier_freqs_info_list_present = false;
  uint8_t                         t_resel_geran                   = 0;
  speed_state_scale_factors_s     t_resel_geran_sf;
  carrier_freqs_info_list_geran_l carrier_freqs_info_list;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType8 ::= SEQUENCE
struct sib_type8_s {
  struct params_hrpd_s_ {
    // member variables
    bool                         cell_resel_params_hrpd_present = false;
    pre_regist_info_hrpd_s       pre_regist_info_hrpd;
    cell_resel_params_cdma2000_s cell_resel_params_hrpd;
  };
  struct params1_xrtt_s_ {
    // member variables
    bool                         csfb_regist_param1_xrtt_present = false;
    bool                         long_code_state1_xrtt_present   = false;
    bool                         cell_resel_params1_xrtt_present = false;
    csfb_regist_param1_xrtt_s    csfb_regist_param1_xrtt;
    fixed_bitstring<42>          long_code_state1_xrtt;
    cell_resel_params_cdma2000_s cell_resel_params1_xrtt;
  };

  // member variables
  bool                     ext                     = false;
  bool                     sys_time_info_present   = false;
  bool                     search_win_size_present = false;
  bool                     params_hrpd_present     = false;
  bool                     params1_xrtt_present    = false;
  sys_time_info_cdma2000_s sys_time_info;
  uint8_t                  search_win_size = 0;
  params_hrpd_s_           params_hrpd;
  params1_xrtt_s_          params1_xrtt;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;
  // group 0
  bool                                        csfb_support_for_dual_rx_ues_r9_present = false;
  bool                                        cell_resel_params_hrpd_v920_present     = false;
  bool                                        cell_resel_params1_xrtt_v920_present    = false;
  bool                                        csfb_regist_param1_xrtt_v920_present    = false;
  bool                                        ac_barr_cfg1_xrtt_r9_present            = false;
  bool                                        csfb_support_for_dual_rx_ues_r9         = false;
  copy_ptr<cell_resel_params_cdma2000_v920_s> cell_resel_params_hrpd_v920;
  copy_ptr<cell_resel_params_cdma2000_v920_s> cell_resel_params1_xrtt_v920;
  copy_ptr<csfb_regist_param1_xrtt_v920_s>    csfb_regist_param1_xrtt_v920;
  copy_ptr<ac_barr_cfg1_xrtt_r9_s>            ac_barr_cfg1_xrtt_r9;
  // group 1
  bool csfb_dual_rx_tx_support_r10_present = false;
  // group 2
  bool                               sib8_per_plmn_list_r11_present = false;
  copy_ptr<sib8_per_plmn_list_r11_l> sib8_per_plmn_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType9 ::= SEQUENCE
struct sib_type9_s {
  // member variables
  bool          ext              = false;
  bool          hnb_name_present = false;
  dyn_octstring hnb_name;
  // ...
  bool          late_non_crit_ext_present = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosSystemInformation-r15-IEs ::= SEQUENCE
struct pos_sys_info_r15_ies_s {
  struct pos_sib_type_and_info_r15_item_c_ {
    struct types_opts {
      enum options {
        pos_sib1_minus1_r15,
        pos_sib1_minus2_r15,
        pos_sib1_minus3_r15,
        pos_sib1_minus4_r15,
        pos_sib1_minus5_r15,
        pos_sib1_minus6_r15,
        pos_sib1_minus7_r15,
        pos_sib2_minus1_r15,
        pos_sib2_minus2_r15,
        pos_sib2_minus3_r15,
        pos_sib2_minus4_r15,
        pos_sib2_minus5_r15,
        pos_sib2_minus6_r15,
        pos_sib2_minus7_r15,
        pos_sib2_minus8_r15,
        pos_sib2_minus9_r15,
        pos_sib2_minus10_r15,
        pos_sib2_minus11_r15,
        pos_sib2_minus12_r15,
        pos_sib2_minus13_r15,
        pos_sib2_minus14_r15,
        pos_sib2_minus15_r15,
        pos_sib2_minus16_r15,
        pos_sib2_minus17_r15,
        pos_sib2_minus18_r15,
        pos_sib2_minus19_r15,
        pos_sib3_minus1_r15,
        // ...
        nulltype
      } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts, true> types;

    // choice methods
    pos_sib_type_and_info_r15_item_c_() = default;
    pos_sib_type_and_info_r15_item_c_(const pos_sib_type_and_info_r15_item_c_& other);
    pos_sib_type_and_info_r15_item_c_& operator=(const pos_sib_type_and_info_r15_item_c_& other);
    ~pos_sib_type_and_info_r15_item_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sib_pos_r15_s& pos_sib1_minus1_r15()
    {
      assert_choice_type("posSib1-1-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib1_minus2_r15()
    {
      assert_choice_type("posSib1-2-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib1_minus3_r15()
    {
      assert_choice_type("posSib1-3-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib1_minus4_r15()
    {
      assert_choice_type("posSib1-4-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib1_minus5_r15()
    {
      assert_choice_type("posSib1-5-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib1_minus6_r15()
    {
      assert_choice_type("posSib1-6-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib1_minus7_r15()
    {
      assert_choice_type("posSib1-7-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus1_r15()
    {
      assert_choice_type("posSib2-1-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus2_r15()
    {
      assert_choice_type("posSib2-2-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus3_r15()
    {
      assert_choice_type("posSib2-3-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus4_r15()
    {
      assert_choice_type("posSib2-4-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus5_r15()
    {
      assert_choice_type("posSib2-5-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus6_r15()
    {
      assert_choice_type("posSib2-6-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus7_r15()
    {
      assert_choice_type("posSib2-7-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus8_r15()
    {
      assert_choice_type("posSib2-8-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus9_r15()
    {
      assert_choice_type("posSib2-9-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus10_r15()
    {
      assert_choice_type("posSib2-10-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus11_r15()
    {
      assert_choice_type("posSib2-11-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus12_r15()
    {
      assert_choice_type("posSib2-12-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus13_r15()
    {
      assert_choice_type("posSib2-13-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus14_r15()
    {
      assert_choice_type("posSib2-14-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus15_r15()
    {
      assert_choice_type("posSib2-15-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus16_r15()
    {
      assert_choice_type("posSib2-16-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus17_r15()
    {
      assert_choice_type("posSib2-17-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus18_r15()
    {
      assert_choice_type("posSib2-18-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib2_minus19_r15()
    {
      assert_choice_type("posSib2-19-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& pos_sib3_minus1_r15()
    {
      assert_choice_type("posSib3-1-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib1_minus1_r15() const
    {
      assert_choice_type("posSib1-1-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib1_minus2_r15() const
    {
      assert_choice_type("posSib1-2-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib1_minus3_r15() const
    {
      assert_choice_type("posSib1-3-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib1_minus4_r15() const
    {
      assert_choice_type("posSib1-4-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib1_minus5_r15() const
    {
      assert_choice_type("posSib1-5-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib1_minus6_r15() const
    {
      assert_choice_type("posSib1-6-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib1_minus7_r15() const
    {
      assert_choice_type("posSib1-7-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus1_r15() const
    {
      assert_choice_type("posSib2-1-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus2_r15() const
    {
      assert_choice_type("posSib2-2-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus3_r15() const
    {
      assert_choice_type("posSib2-3-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus4_r15() const
    {
      assert_choice_type("posSib2-4-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus5_r15() const
    {
      assert_choice_type("posSib2-5-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus6_r15() const
    {
      assert_choice_type("posSib2-6-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus7_r15() const
    {
      assert_choice_type("posSib2-7-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus8_r15() const
    {
      assert_choice_type("posSib2-8-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus9_r15() const
    {
      assert_choice_type("posSib2-9-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus10_r15() const
    {
      assert_choice_type("posSib2-10-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus11_r15() const
    {
      assert_choice_type("posSib2-11-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus12_r15() const
    {
      assert_choice_type("posSib2-12-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus13_r15() const
    {
      assert_choice_type("posSib2-13-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus14_r15() const
    {
      assert_choice_type("posSib2-14-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus15_r15() const
    {
      assert_choice_type("posSib2-15-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus16_r15() const
    {
      assert_choice_type("posSib2-16-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus17_r15() const
    {
      assert_choice_type("posSib2-17-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus18_r15() const
    {
      assert_choice_type("posSib2-18-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib2_minus19_r15() const
    {
      assert_choice_type("posSib2-19-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    const sib_pos_r15_s& pos_sib3_minus1_r15() const
    {
      assert_choice_type("posSib3-1-r15", type_.to_string(), "posSIB-TypeAndInfo-r15-item");
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib1_minus1_r15()
    {
      set(types::pos_sib1_minus1_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib1_minus2_r15()
    {
      set(types::pos_sib1_minus2_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib1_minus3_r15()
    {
      set(types::pos_sib1_minus3_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib1_minus4_r15()
    {
      set(types::pos_sib1_minus4_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib1_minus5_r15()
    {
      set(types::pos_sib1_minus5_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib1_minus6_r15()
    {
      set(types::pos_sib1_minus6_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib1_minus7_r15()
    {
      set(types::pos_sib1_minus7_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus1_r15()
    {
      set(types::pos_sib2_minus1_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus2_r15()
    {
      set(types::pos_sib2_minus2_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus3_r15()
    {
      set(types::pos_sib2_minus3_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus4_r15()
    {
      set(types::pos_sib2_minus4_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus5_r15()
    {
      set(types::pos_sib2_minus5_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus6_r15()
    {
      set(types::pos_sib2_minus6_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus7_r15()
    {
      set(types::pos_sib2_minus7_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus8_r15()
    {
      set(types::pos_sib2_minus8_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus9_r15()
    {
      set(types::pos_sib2_minus9_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus10_r15()
    {
      set(types::pos_sib2_minus10_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus11_r15()
    {
      set(types::pos_sib2_minus11_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus12_r15()
    {
      set(types::pos_sib2_minus12_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus13_r15()
    {
      set(types::pos_sib2_minus13_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus14_r15()
    {
      set(types::pos_sib2_minus14_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus15_r15()
    {
      set(types::pos_sib2_minus15_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus16_r15()
    {
      set(types::pos_sib2_minus16_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus17_r15()
    {
      set(types::pos_sib2_minus17_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus18_r15()
    {
      set(types::pos_sib2_minus18_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib2_minus19_r15()
    {
      set(types::pos_sib2_minus19_r15);
      return c.get<sib_pos_r15_s>();
    }
    sib_pos_r15_s& set_pos_sib3_minus1_r15()
    {
      set(types::pos_sib3_minus1_r15);
      return c.get<sib_pos_r15_s>();
    }

  private:
    types                                  type_;
    choice_buffer_t<sizeof(sib_pos_r15_s)> c;

    void destroy_();
  };
  typedef dyn_array<pos_sib_type_and_info_r15_item_c_> pos_sib_type_and_info_r15_l_;

  // member variables
  bool                         late_non_crit_ext_present = false;
  bool                         non_crit_ext_present      = false;
  pos_sib_type_and_info_r15_l_ pos_sib_type_and_info_r15;
  dyn_octstring                late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SchedulingInfoList ::= SEQUENCE (SIZE (1..maxSI-Message)) OF SchedulingInfo
typedef dyn_array<sched_info_s> sched_info_list_l;

struct sib_info_item_c {
  struct types_opts {
    enum options {
      sib2,
      sib3,
      sib4,
      sib5,
      sib6,
      sib7,
      sib8,
      sib9,
      sib10,
      sib11,
      // ...
      sib12_v920,
      sib13_v920,
      sib14_v1130,
      sib15_v1130,
      sib16_v1130,
      sib17_v1250,
      sib18_v1250,
      sib19_v1250,
      sib20_v1310,
      sib21_v1430,
      sib24_v1530,
      sib25_v1530,
      sib26_v1530,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts, true, 13> types;

  // choice methods
  sib_info_item_c() = default;
  sib_info_item_c(const sib_info_item_c& other);
  sib_info_item_c& operator=(const sib_info_item_c& other);
  ~sib_info_item_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  sib_type2_s& sib2()
  {
    assert_choice_type("sib2", type_.to_string(), "");
    return c.get<sib_type2_s>();
  }
  sib_type3_s& sib3()
  {
    assert_choice_type("sib3", type_.to_string(), "");
    return c.get<sib_type3_s>();
  }
  sib_type4_s& sib4()
  {
    assert_choice_type("sib4", type_.to_string(), "");
    return c.get<sib_type4_s>();
  }
  sib_type5_s& sib5()
  {
    assert_choice_type("sib5", type_.to_string(), "");
    return c.get<sib_type5_s>();
  }
  sib_type6_s& sib6()
  {
    assert_choice_type("sib6", type_.to_string(), "");
    return c.get<sib_type6_s>();
  }
  sib_type7_s& sib7()
  {
    assert_choice_type("sib7", type_.to_string(), "");
    return c.get<sib_type7_s>();
  }
  sib_type8_s& sib8()
  {
    assert_choice_type("sib8", type_.to_string(), "");
    return c.get<sib_type8_s>();
  }
  sib_type9_s& sib9()
  {
    assert_choice_type("sib9", type_.to_string(), "");
    return c.get<sib_type9_s>();
  }
  sib_type10_s& sib10()
  {
    assert_choice_type("sib10", type_.to_string(), "");
    return c.get<sib_type10_s>();
  }
  sib_type11_s& sib11()
  {
    assert_choice_type("sib11", type_.to_string(), "");
    return c.get<sib_type11_s>();
  }
  sib_type12_r9_s& sib12_v920()
  {
    assert_choice_type("sib12-v920", type_.to_string(), "");
    return c.get<sib_type12_r9_s>();
  }
  sib_type13_r9_s& sib13_v920()
  {
    assert_choice_type("sib13-v920", type_.to_string(), "");
    return c.get<sib_type13_r9_s>();
  }
  sib_type14_r11_s& sib14_v1130()
  {
    assert_choice_type("sib14-v1130", type_.to_string(), "");
    return c.get<sib_type14_r11_s>();
  }
  sib_type15_r11_s& sib15_v1130()
  {
    assert_choice_type("sib15-v1130", type_.to_string(), "");
    return c.get<sib_type15_r11_s>();
  }
  sib_type16_r11_s& sib16_v1130()
  {
    assert_choice_type("sib16-v1130", type_.to_string(), "");
    return c.get<sib_type16_r11_s>();
  }
  sib_type17_r12_s& sib17_v1250()
  {
    assert_choice_type("sib17-v1250", type_.to_string(), "");
    return c.get<sib_type17_r12_s>();
  }
  sib_type18_r12_s& sib18_v1250()
  {
    assert_choice_type("sib18-v1250", type_.to_string(), "");
    return c.get<sib_type18_r12_s>();
  }
  sib_type19_r12_s& sib19_v1250()
  {
    assert_choice_type("sib19-v1250", type_.to_string(), "");
    return c.get<sib_type19_r12_s>();
  }
  sib_type20_r13_s& sib20_v1310()
  {
    assert_choice_type("sib20-v1310", type_.to_string(), "");
    return c.get<sib_type20_r13_s>();
  }
  sib_type21_r14_s& sib21_v1430()
  {
    assert_choice_type("sib21-v1430", type_.to_string(), "");
    return c.get<sib_type21_r14_s>();
  }
  sib_type24_r15_s& sib24_v1530()
  {
    assert_choice_type("sib24-v1530", type_.to_string(), "");
    return c.get<sib_type24_r15_s>();
  }
  sib_type25_r15_s& sib25_v1530()
  {
    assert_choice_type("sib25-v1530", type_.to_string(), "");
    return c.get<sib_type25_r15_s>();
  }
  sib_type26_r15_s& sib26_v1530()
  {
    assert_choice_type("sib26-v1530", type_.to_string(), "");
    return c.get<sib_type26_r15_s>();
  }
  const sib_type2_s& sib2() const
  {
    assert_choice_type("sib2", type_.to_string(), "");
    return c.get<sib_type2_s>();
  }
  const sib_type3_s& sib3() const
  {
    assert_choice_type("sib3", type_.to_string(), "");
    return c.get<sib_type3_s>();
  }
  const sib_type4_s& sib4() const
  {
    assert_choice_type("sib4", type_.to_string(), "");
    return c.get<sib_type4_s>();
  }
  const sib_type5_s& sib5() const
  {
    assert_choice_type("sib5", type_.to_string(), "");
    return c.get<sib_type5_s>();
  }
  const sib_type6_s& sib6() const
  {
    assert_choice_type("sib6", type_.to_string(), "");
    return c.get<sib_type6_s>();
  }
  const sib_type7_s& sib7() const
  {
    assert_choice_type("sib7", type_.to_string(), "");
    return c.get<sib_type7_s>();
  }
  const sib_type8_s& sib8() const
  {
    assert_choice_type("sib8", type_.to_string(), "");
    return c.get<sib_type8_s>();
  }
  const sib_type9_s& sib9() const
  {
    assert_choice_type("sib9", type_.to_string(), "");
    return c.get<sib_type9_s>();
  }
  const sib_type10_s& sib10() const
  {
    assert_choice_type("sib10", type_.to_string(), "");
    return c.get<sib_type10_s>();
  }
  const sib_type11_s& sib11() const
  {
    assert_choice_type("sib11", type_.to_string(), "");
    return c.get<sib_type11_s>();
  }
  const sib_type12_r9_s& sib12_v920() const
  {
    assert_choice_type("sib12-v920", type_.to_string(), "");
    return c.get<sib_type12_r9_s>();
  }
  const sib_type13_r9_s& sib13_v920() const
  {
    assert_choice_type("sib13-v920", type_.to_string(), "");
    return c.get<sib_type13_r9_s>();
  }
  const sib_type14_r11_s& sib14_v1130() const
  {
    assert_choice_type("sib14-v1130", type_.to_string(), "");
    return c.get<sib_type14_r11_s>();
  }
  const sib_type15_r11_s& sib15_v1130() const
  {
    assert_choice_type("sib15-v1130", type_.to_string(), "");
    return c.get<sib_type15_r11_s>();
  }
  const sib_type16_r11_s& sib16_v1130() const
  {
    assert_choice_type("sib16-v1130", type_.to_string(), "");
    return c.get<sib_type16_r11_s>();
  }
  const sib_type17_r12_s& sib17_v1250() const
  {
    assert_choice_type("sib17-v1250", type_.to_string(), "");
    return c.get<sib_type17_r12_s>();
  }
  const sib_type18_r12_s& sib18_v1250() const
  {
    assert_choice_type("sib18-v1250", type_.to_string(), "");
    return c.get<sib_type18_r12_s>();
  }
  const sib_type19_r12_s& sib19_v1250() const
  {
    assert_choice_type("sib19-v1250", type_.to_string(), "");
    return c.get<sib_type19_r12_s>();
  }
  const sib_type20_r13_s& sib20_v1310() const
  {
    assert_choice_type("sib20-v1310", type_.to_string(), "");
    return c.get<sib_type20_r13_s>();
  }
  const sib_type21_r14_s& sib21_v1430() const
  {
    assert_choice_type("sib21-v1430", type_.to_string(), "");
    return c.get<sib_type21_r14_s>();
  }
  const sib_type24_r15_s& sib24_v1530() const
  {
    assert_choice_type("sib24-v1530", type_.to_string(), "");
    return c.get<sib_type24_r15_s>();
  }
  const sib_type25_r15_s& sib25_v1530() const
  {
    assert_choice_type("sib25-v1530", type_.to_string(), "");
    return c.get<sib_type25_r15_s>();
  }
  const sib_type26_r15_s& sib26_v1530() const
  {
    assert_choice_type("sib26-v1530", type_.to_string(), "");
    return c.get<sib_type26_r15_s>();
  }
  sib_type2_s& set_sib2()
  {
    set(types::sib2);
    return c.get<sib_type2_s>();
  }
  sib_type3_s& set_sib3()
  {
    set(types::sib3);
    return c.get<sib_type3_s>();
  }
  sib_type4_s& set_sib4()
  {
    set(types::sib4);
    return c.get<sib_type4_s>();
  }
  sib_type5_s& set_sib5()
  {
    set(types::sib5);
    return c.get<sib_type5_s>();
  }
  sib_type6_s& set_sib6()
  {
    set(types::sib6);
    return c.get<sib_type6_s>();
  }
  sib_type7_s& set_sib7()
  {
    set(types::sib7);
    return c.get<sib_type7_s>();
  }
  sib_type8_s& set_sib8()
  {
    set(types::sib8);
    return c.get<sib_type8_s>();
  }
  sib_type9_s& set_sib9()
  {
    set(types::sib9);
    return c.get<sib_type9_s>();
  }
  sib_type10_s& set_sib10()
  {
    set(types::sib10);
    return c.get<sib_type10_s>();
  }
  sib_type11_s& set_sib11()
  {
    set(types::sib11);
    return c.get<sib_type11_s>();
  }
  sib_type12_r9_s& set_sib12_v920()
  {
    set(types::sib12_v920);
    return c.get<sib_type12_r9_s>();
  }
  sib_type13_r9_s& set_sib13_v920()
  {
    set(types::sib13_v920);
    return c.get<sib_type13_r9_s>();
  }
  sib_type14_r11_s& set_sib14_v1130()
  {
    set(types::sib14_v1130);
    return c.get<sib_type14_r11_s>();
  }
  sib_type15_r11_s& set_sib15_v1130()
  {
    set(types::sib15_v1130);
    return c.get<sib_type15_r11_s>();
  }
  sib_type16_r11_s& set_sib16_v1130()
  {
    set(types::sib16_v1130);
    return c.get<sib_type16_r11_s>();
  }
  sib_type17_r12_s& set_sib17_v1250()
  {
    set(types::sib17_v1250);
    return c.get<sib_type17_r12_s>();
  }
  sib_type18_r12_s& set_sib18_v1250()
  {
    set(types::sib18_v1250);
    return c.get<sib_type18_r12_s>();
  }
  sib_type19_r12_s& set_sib19_v1250()
  {
    set(types::sib19_v1250);
    return c.get<sib_type19_r12_s>();
  }
  sib_type20_r13_s& set_sib20_v1310()
  {
    set(types::sib20_v1310);
    return c.get<sib_type20_r13_s>();
  }
  sib_type21_r14_s& set_sib21_v1430()
  {
    set(types::sib21_v1430);
    return c.get<sib_type21_r14_s>();
  }
  sib_type24_r15_s& set_sib24_v1530()
  {
    set(types::sib24_v1530);
    return c.get<sib_type24_r15_s>();
  }
  sib_type25_r15_s& set_sib25_v1530()
  {
    set(types::sib25_v1530);
    return c.get<sib_type25_r15_s>();
  }
  sib_type26_r15_s& set_sib26_v1530()
  {
    set(types::sib26_v1530);
    return c.get<sib_type26_r15_s>();
  }

private:
  types type_;
  choice_buffer_t<MAX32(sizeof(sib_type10_s),
                        sizeof(sib_type11_s),
                        sizeof(sib_type12_r9_s),
                        sizeof(sib_type13_r9_s),
                        sizeof(sib_type14_r11_s),
                        sizeof(sib_type15_r11_s),
                        sizeof(sib_type16_r11_s),
                        sizeof(sib_type17_r12_s),
                        sizeof(sib_type18_r12_s),
                        sizeof(sib_type19_r12_s),
                        sizeof(sib_type20_r13_s),
                        sizeof(sib_type21_r14_s),
                        sizeof(sib_type24_r15_s),
                        sizeof(sib_type25_r15_s),
                        sizeof(sib_type26_r15_s),
                        sizeof(sib_type2_s),
                        sizeof(sib_type3_s),
                        sizeof(sib_type4_s),
                        sizeof(sib_type5_s),
                        sizeof(sib_type6_s),
                        sizeof(sib_type7_s),
                        sizeof(sib_type8_s),
                        sizeof(sib_type9_s),
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0)>
      c;

  void destroy_();
};

// SystemInformation-r8-IEs ::= SEQUENCE
struct sys_info_r8_ies_s {
  typedef sib_info_item_c                      sib_type_and_info_item_c_;
  typedef dyn_array<sib_type_and_info_item_c_> sib_type_and_info_l_;

  // member variables
  bool                 non_crit_ext_present = false;
  sib_type_and_info_l_ sib_type_and_info;
  sys_info_v8a0_ies_s  non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1-v890-IEs ::= SEQUENCE
struct sib_type1_v890_ies_s {
  // member variables
  bool                 late_non_crit_ext_present = false;
  bool                 non_crit_ext_present      = false;
  dyn_octstring        late_non_crit_ext;
  sib_type1_v920_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformation ::= SEQUENCE
struct sys_info_s {
  struct crit_exts_c_ {
    struct crit_exts_future_r15_c_ {
      struct types_opts {
        enum options { pos_sys_info_r15, crit_exts_future, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      crit_exts_future_r15_c_() = default;
      crit_exts_future_r15_c_(const crit_exts_future_r15_c_& other);
      crit_exts_future_r15_c_& operator=(const crit_exts_future_r15_c_& other);
      ~crit_exts_future_r15_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      pos_sys_info_r15_ies_s& pos_sys_info_r15()
      {
        assert_choice_type("posSystemInformation-r15", type_.to_string(), "criticalExtensionsFuture-r15");
        return c.get<pos_sys_info_r15_ies_s>();
      }
      const pos_sys_info_r15_ies_s& pos_sys_info_r15() const
      {
        assert_choice_type("posSystemInformation-r15", type_.to_string(), "criticalExtensionsFuture-r15");
        return c.get<pos_sys_info_r15_ies_s>();
      }
      pos_sys_info_r15_ies_s& set_pos_sys_info_r15()
      {
        set(types::pos_sys_info_r15);
        return c.get<pos_sys_info_r15_ies_s>();
      }

    private:
      types                                           type_;
      choice_buffer_t<sizeof(pos_sys_info_r15_ies_s)> c;

      void destroy_();
    };
    struct types_opts {
      enum options { sys_info_r8, crit_exts_future_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sys_info_r8_ies_s& sys_info_r8()
    {
      assert_choice_type("systemInformation-r8", type_.to_string(), "criticalExtensions");
      return c.get<sys_info_r8_ies_s>();
    }
    crit_exts_future_r15_c_& crit_exts_future_r15()
    {
      assert_choice_type("criticalExtensionsFuture-r15", type_.to_string(), "criticalExtensions");
      return c.get<crit_exts_future_r15_c_>();
    }
    const sys_info_r8_ies_s& sys_info_r8() const
    {
      assert_choice_type("systemInformation-r8", type_.to_string(), "criticalExtensions");
      return c.get<sys_info_r8_ies_s>();
    }
    const crit_exts_future_r15_c_& crit_exts_future_r15() const
    {
      assert_choice_type("criticalExtensionsFuture-r15", type_.to_string(), "criticalExtensions");
      return c.get<crit_exts_future_r15_c_>();
    }
    sys_info_r8_ies_s& set_sys_info_r8()
    {
      set(types::sys_info_r8);
      return c.get<sys_info_r8_ies_s>();
    }
    crit_exts_future_r15_c_& set_crit_exts_future_r15()
    {
      set(types::crit_exts_future_r15);
      return c.get<crit_exts_future_r15_c_>();
    }

  private:
    types                                                                             type_;
    choice_buffer_t<MAX2(sizeof(crit_exts_future_r15_c_), sizeof(sys_info_r8_ies_s))> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationBlockType1 ::= SEQUENCE
struct sib_type1_s {
  struct cell_access_related_info_s_ {
    struct cell_barred_opts {
      enum options { barred, not_barred, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<cell_barred_opts> cell_barred_e_;
    struct intra_freq_resel_opts {
      enum options { allowed, not_allowed, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<intra_freq_resel_opts> intra_freq_resel_e_;

    // member variables
    bool                csg_id_present = false;
    plmn_id_list_l      plmn_id_list;
    fixed_bitstring<16> tac;
    fixed_bitstring<28> cell_id;
    cell_barred_e_      cell_barred;
    intra_freq_resel_e_ intra_freq_resel;
    bool                csg_ind = false;
    fixed_bitstring<27> csg_id;
  };
  struct cell_sel_info_s_ {
    // member variables
    bool    q_rx_lev_min_offset_present = false;
    int8_t  q_rx_lev_min                = -70;
    uint8_t q_rx_lev_min_offset         = 1;
  };
  struct si_win_len_opts {
    enum options { ms1, ms2, ms5, ms10, ms15, ms20, ms40, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<si_win_len_opts> si_win_len_e_;

  // member variables
  bool                        p_max_present        = false;
  bool                        tdd_cfg_present      = false;
  bool                        non_crit_ext_present = false;
  cell_access_related_info_s_ cell_access_related_info;
  cell_sel_info_s_            cell_sel_info;
  int8_t                      p_max         = -30;
  uint8_t                     freq_band_ind = 1;
  sched_info_list_l           sched_info_list;
  tdd_cfg_s                   tdd_cfg;
  si_win_len_e_               si_win_len;
  uint8_t                     sys_info_value_tag = 0;
  sib_type1_v890_ies_s        non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BCCH-DL-SCH-MessageType ::= CHOICE
struct bcch_dl_sch_msg_type_c {
  struct c1_c_ {
    struct types_opts {
      enum options { sys_info, sib_type1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    c1_c_() = default;
    c1_c_(const c1_c_& other);
    c1_c_& operator=(const c1_c_& other);
    ~c1_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sys_info_s& sys_info()
    {
      assert_choice_type("systemInformation", type_.to_string(), "c1");
      return c.get<sys_info_s>();
    }
    sib_type1_s& sib_type1()
    {
      assert_choice_type("systemInformationBlockType1", type_.to_string(), "c1");
      return c.get<sib_type1_s>();
    }
    const sys_info_s& sys_info() const
    {
      assert_choice_type("systemInformation", type_.to_string(), "c1");
      return c.get<sys_info_s>();
    }
    const sib_type1_s& sib_type1() const
    {
      assert_choice_type("systemInformationBlockType1", type_.to_string(), "c1");
      return c.get<sib_type1_s>();
    }
    sys_info_s& set_sys_info()
    {
      set(types::sys_info);
      return c.get<sys_info_s>();
    }
    sib_type1_s& set_sib_type1()
    {
      set(types::sib_type1);
      return c.get<sib_type1_s>();
    }

  private:
    types                                                          type_;
    choice_buffer_t<MAX2(sizeof(sib_type1_s), sizeof(sys_info_s))> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  bcch_dl_sch_msg_type_c() = default;
  bcch_dl_sch_msg_type_c(const bcch_dl_sch_msg_type_c& other);
  bcch_dl_sch_msg_type_c& operator=(const bcch_dl_sch_msg_type_c& other);
  ~bcch_dl_sch_msg_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "BCCH-DL-SCH-MessageType");
    return c.get<c1_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "BCCH-DL-SCH-MessageType");
    return c.get<c1_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }

private:
  types                          type_;
  choice_buffer_t<sizeof(c1_c_)> c;

  void destroy_();
};

// BCCH-DL-SCH-Message ::= SEQUENCE
struct bcch_dl_sch_msg_s {
  // member variables
  bcch_dl_sch_msg_type_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformation-BR-r13 ::= SystemInformation
typedef sys_info_s sys_info_br_r13_s;

// SystemInformationBlockType1-BR-r13 ::= SystemInformationBlockType1
typedef sib_type1_s sib_type1_br_r13_s;

// BCCH-DL-SCH-MessageType-BR-r13 ::= CHOICE
struct bcch_dl_sch_msg_type_br_r13_c {
  struct c1_c_ {
    struct types_opts {
      enum options { sys_info_br_r13, sib_type1_br_r13, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    c1_c_() = default;
    c1_c_(const c1_c_& other);
    c1_c_& operator=(const c1_c_& other);
    ~c1_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sys_info_br_r13_s& sys_info_br_r13()
    {
      assert_choice_type("systemInformation-BR-r13", type_.to_string(), "c1");
      return c.get<sys_info_br_r13_s>();
    }
    sib_type1_br_r13_s& sib_type1_br_r13()
    {
      assert_choice_type("systemInformationBlockType1-BR-r13", type_.to_string(), "c1");
      return c.get<sib_type1_br_r13_s>();
    }
    const sys_info_br_r13_s& sys_info_br_r13() const
    {
      assert_choice_type("systemInformation-BR-r13", type_.to_string(), "c1");
      return c.get<sys_info_br_r13_s>();
    }
    const sib_type1_br_r13_s& sib_type1_br_r13() const
    {
      assert_choice_type("systemInformationBlockType1-BR-r13", type_.to_string(), "c1");
      return c.get<sib_type1_br_r13_s>();
    }
    sys_info_br_r13_s& set_sys_info_br_r13()
    {
      set(types::sys_info_br_r13);
      return c.get<sys_info_br_r13_s>();
    }
    sib_type1_br_r13_s& set_sib_type1_br_r13()
    {
      set(types::sib_type1_br_r13);
      return c.get<sib_type1_br_r13_s>();
    }

  private:
    types                                                                        type_;
    choice_buffer_t<MAX2(sizeof(sib_type1_br_r13_s), sizeof(sys_info_br_r13_s))> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  bcch_dl_sch_msg_type_br_r13_c() = default;
  bcch_dl_sch_msg_type_br_r13_c(const bcch_dl_sch_msg_type_br_r13_c& other);
  bcch_dl_sch_msg_type_br_r13_c& operator=(const bcch_dl_sch_msg_type_br_r13_c& other);
  ~bcch_dl_sch_msg_type_br_r13_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "BCCH-DL-SCH-MessageType-BR-r13");
    return c.get<c1_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "BCCH-DL-SCH-MessageType-BR-r13");
    return c.get<c1_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }

private:
  types                          type_;
  choice_buffer_t<sizeof(c1_c_)> c;

  void destroy_();
};

// BCCH-DL-SCH-Message-BR ::= SEQUENCE
struct bcch_dl_sch_msg_br_s {
  // member variables
  bcch_dl_sch_msg_type_br_r13_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SIB-Type-MBMS-r14 ::= ENUMERATED
struct sib_type_mbms_r14_opts {
  enum options {
    sib_type10,
    sib_type11,
    sib_type12_v920,
    sib_type13_v920,
    sib_type15_v1130,
    sib_type16_v1130,
    // ...
    nulltype
  } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<sib_type_mbms_r14_opts, true> sib_type_mbms_r14_e;

// SIB-MappingInfo-MBMS-r14 ::= SEQUENCE (SIZE (0..maxSIB-1)) OF SIB-Type-MBMS-r14
typedef bounded_array<sib_type_mbms_r14_e, 31> sib_map_info_mbms_r14_l;

// SchedulingInfo-MBMS-r14 ::= SEQUENCE
struct sched_info_mbms_r14_s {
  struct si_periodicity_r14_opts {
    enum options { rf16, rf32, rf64, rf128, rf256, rf512, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<si_periodicity_r14_opts> si_periodicity_r14_e_;

  // member variables
  si_periodicity_r14_e_   si_periodicity_r14;
  sib_map_info_mbms_r14_l sib_map_info_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NonMBSFN-SubframeConfig-r14 ::= SEQUENCE
struct non_mbsfn_sf_cfg_r14_s {
  struct radio_frame_alloc_period_r14_opts {
    enum options { rf4, rf8, rf16, rf32, rf64, rf128, rf512, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<radio_frame_alloc_period_r14_opts> radio_frame_alloc_period_r14_e_;

  // member variables
  radio_frame_alloc_period_r14_e_ radio_frame_alloc_period_r14;
  uint8_t                         radio_frame_alloc_offset_r14 = 0;
  fixed_bitstring<9>              sf_alloc_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityList-MBMS-r14 ::= SEQUENCE (SIZE (1..maxPLMN-r11)) OF PLMN-Identity
typedef dyn_array<plmn_id_s> plmn_id_list_mbms_r14_l;

// SchedulingInfoList-MBMS-r14 ::= SEQUENCE (SIZE (1..maxSI-Message)) OF SchedulingInfo-MBMS-r14
typedef dyn_array<sched_info_mbms_r14_s> sched_info_list_mbms_r14_l;

// SystemInformation-MBMS-r14 ::= SystemInformation
typedef sys_info_s sys_info_mbms_r14_s;

// SystemInformationBlockType1-MBMS-r14 ::= SEQUENCE
struct sib_type1_mbms_r14_s {
  struct cell_access_related_info_r14_s_ {
    // member variables
    plmn_id_list_mbms_r14_l plmn_id_list_r14;
    fixed_bitstring<16>     tac_r14;
    fixed_bitstring<28>     cell_id_r14;
  };
  struct si_win_len_r14_opts {
    enum options { ms1, ms2, ms5, ms10, ms15, ms20, ms40, ms80, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<si_win_len_r14_opts>           si_win_len_r14_e_;
  typedef dyn_array<cell_access_related_info_r14_s> cell_access_related_info_list_r14_l_;

  // member variables
  bool                                 multi_band_info_list_r14_present          = false;
  bool                                 non_mbsfn_sf_cfg_r14_present              = false;
  bool                                 sib_type13_r14_present                    = false;
  bool                                 cell_access_related_info_list_r14_present = false;
  bool                                 non_crit_ext_present                      = false;
  cell_access_related_info_r14_s_      cell_access_related_info_r14;
  uint16_t                             freq_band_ind_r14 = 1;
  multi_band_info_list_r11_l           multi_band_info_list_r14;
  sched_info_list_mbms_r14_l           sched_info_list_mbms_r14;
  si_win_len_r14_e_                    si_win_len_r14;
  uint8_t                              sys_info_value_tag_r14 = 0;
  non_mbsfn_sf_cfg_r14_s               non_mbsfn_sf_cfg_r14;
  pdsch_cfg_common_s                   pdsch_cfg_common_r14;
  sib_type13_r9_s                      sib_type13_r14;
  cell_access_related_info_list_r14_l_ cell_access_related_info_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BCCH-DL-SCH-MessageType-MBMS-r14 ::= CHOICE
struct bcch_dl_sch_msg_type_mbms_r14_c {
  struct c1_c_ {
    struct types_opts {
      enum options { sys_info_mbms_r14, sib_type1_mbms_r14, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    c1_c_() = default;
    c1_c_(const c1_c_& other);
    c1_c_& operator=(const c1_c_& other);
    ~c1_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sys_info_mbms_r14_s& sys_info_mbms_r14()
    {
      assert_choice_type("systemInformation-MBMS-r14", type_.to_string(), "c1");
      return c.get<sys_info_mbms_r14_s>();
    }
    sib_type1_mbms_r14_s& sib_type1_mbms_r14()
    {
      assert_choice_type("systemInformationBlockType1-MBMS-r14", type_.to_string(), "c1");
      return c.get<sib_type1_mbms_r14_s>();
    }
    const sys_info_mbms_r14_s& sys_info_mbms_r14() const
    {
      assert_choice_type("systemInformation-MBMS-r14", type_.to_string(), "c1");
      return c.get<sys_info_mbms_r14_s>();
    }
    const sib_type1_mbms_r14_s& sib_type1_mbms_r14() const
    {
      assert_choice_type("systemInformationBlockType1-MBMS-r14", type_.to_string(), "c1");
      return c.get<sib_type1_mbms_r14_s>();
    }
    sys_info_mbms_r14_s& set_sys_info_mbms_r14()
    {
      set(types::sys_info_mbms_r14);
      return c.get<sys_info_mbms_r14_s>();
    }
    sib_type1_mbms_r14_s& set_sib_type1_mbms_r14()
    {
      set(types::sib_type1_mbms_r14);
      return c.get<sib_type1_mbms_r14_s>();
    }

  private:
    types                                                                            type_;
    choice_buffer_t<MAX2(sizeof(sib_type1_mbms_r14_s), sizeof(sys_info_mbms_r14_s))> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  bcch_dl_sch_msg_type_mbms_r14_c() = default;
  bcch_dl_sch_msg_type_mbms_r14_c(const bcch_dl_sch_msg_type_mbms_r14_c& other);
  bcch_dl_sch_msg_type_mbms_r14_c& operator=(const bcch_dl_sch_msg_type_mbms_r14_c& other);
  ~bcch_dl_sch_msg_type_mbms_r14_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "BCCH-DL-SCH-MessageType-MBMS-r14");
    return c.get<c1_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "BCCH-DL-SCH-MessageType-MBMS-r14");
    return c.get<c1_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }

private:
  types                          type_;
  choice_buffer_t<sizeof(c1_c_)> c;

  void destroy_();
};

// BCCH-DL-SCH-Message-MBMS ::= SEQUENCE
struct bcch_dl_sch_msg_mbms_s {
  // member variables
  bcch_dl_sch_msg_type_mbms_r14_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NZP-FrequencyDensity-r14 ::= ENUMERATED
struct nzp_freq_density_r14_opts {
  enum options { d1, d2, d3, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<nzp_freq_density_r14_opts> nzp_freq_density_r14_e;

// P-C-AndCBSR-r13 ::= SEQUENCE
struct p_c_and_cbsr_r13_s {
  struct cbsr_sel_r13_c_ {
    struct non_precoded_r13_s_ {
      // member variables
      dyn_bitstring codebook_subset_restrict1_r13;
      dyn_bitstring codebook_subset_restrict2_r13;
    };
    struct beamformed_k1a_r13_s_ {
      // member variables
      dyn_bitstring codebook_subset_restrict3_r13;
    };
    struct beamformed_kn_r13_s_ {
      // member variables
      dyn_bitstring codebook_subset_restrict_r13;
    };
    struct types_opts {
      enum options { non_precoded_r13, beamformed_k1a_r13, beamformed_kn_r13, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    cbsr_sel_r13_c_() = default;
    cbsr_sel_r13_c_(const cbsr_sel_r13_c_& other);
    cbsr_sel_r13_c_& operator=(const cbsr_sel_r13_c_& other);
    ~cbsr_sel_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    non_precoded_r13_s_& non_precoded_r13()
    {
      assert_choice_type("nonPrecoded-r13", type_.to_string(), "cbsr-Selection-r13");
      return c.get<non_precoded_r13_s_>();
    }
    beamformed_k1a_r13_s_& beamformed_k1a_r13()
    {
      assert_choice_type("beamformedK1a-r13", type_.to_string(), "cbsr-Selection-r13");
      return c.get<beamformed_k1a_r13_s_>();
    }
    beamformed_kn_r13_s_& beamformed_kn_r13()
    {
      assert_choice_type("beamformedKN-r13", type_.to_string(), "cbsr-Selection-r13");
      return c.get<beamformed_kn_r13_s_>();
    }
    const non_precoded_r13_s_& non_precoded_r13() const
    {
      assert_choice_type("nonPrecoded-r13", type_.to_string(), "cbsr-Selection-r13");
      return c.get<non_precoded_r13_s_>();
    }
    const beamformed_k1a_r13_s_& beamformed_k1a_r13() const
    {
      assert_choice_type("beamformedK1a-r13", type_.to_string(), "cbsr-Selection-r13");
      return c.get<beamformed_k1a_r13_s_>();
    }
    const beamformed_kn_r13_s_& beamformed_kn_r13() const
    {
      assert_choice_type("beamformedKN-r13", type_.to_string(), "cbsr-Selection-r13");
      return c.get<beamformed_kn_r13_s_>();
    }
    non_precoded_r13_s_& set_non_precoded_r13()
    {
      set(types::non_precoded_r13);
      return c.get<non_precoded_r13_s_>();
    }
    beamformed_k1a_r13_s_& set_beamformed_k1a_r13()
    {
      set(types::beamformed_k1a_r13);
      return c.get<beamformed_k1a_r13_s_>();
    }
    beamformed_kn_r13_s_& set_beamformed_kn_r13()
    {
      set(types::beamformed_kn_r13);
      return c.get<beamformed_kn_r13_s_>();
    }

  private:
    types type_;
    choice_buffer_t<MAX4(sizeof(beamformed_k1a_r13_s_), sizeof(beamformed_kn_r13_s_), sizeof(non_precoded_r13_s_), 0)>
        c;

    void destroy_();
  };

  // member variables
  bool            ext     = false;
  int8_t          p_c_r13 = -8;
  cbsr_sel_r13_c_ cbsr_sel_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-Config-NZP-v1430 ::= SEQUENCE
struct csi_rs_cfg_nzp_v1430_s {
  // member variables
  bool                   tx_comb_r14_present      = false;
  bool                   freq_density_r14_present = false;
  uint8_t                tx_comb_r14              = 0;
  nzp_freq_density_r14_e freq_density_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigNZP-Activation-r14 ::= SEQUENCE
struct csi_rs_cfg_nzp_activation_r14_s {
  struct csi_rs_nzp_mode_r14_opts {
    enum options { semi_persistent, aperiodic, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<csi_rs_nzp_mode_r14_opts> csi_rs_nzp_mode_r14_e_;

  // member variables
  csi_rs_nzp_mode_r14_e_ csi_rs_nzp_mode_r14;
  uint8_t                activ_res_r14 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigNZP-r11 ::= SEQUENCE
struct csi_rs_cfg_nzp_r11_s {
  struct ant_ports_count_r11_opts {
    enum options { an1, an2, an4, an8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ant_ports_count_r11_opts> ant_ports_count_r11_e_;
  struct qcl_crs_info_r11_s_ {
    struct crs_ports_count_r11_opts {
      enum options { n1, n2, n4, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<crs_ports_count_r11_opts> crs_ports_count_r11_e_;
    struct mbsfn_sf_cfg_list_r11_c_ {
      struct setup_s_ {
        // member variables
        mbsfn_sf_cfg_list_l sf_cfg_list;
      };
      typedef setup_e types;

      // choice methods
      mbsfn_sf_cfg_list_r11_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-r11");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-r11");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                     mbsfn_sf_cfg_list_r11_present = false;
    uint16_t                 qcl_scrambling_id_r11         = 0;
    crs_ports_count_r11_e_   crs_ports_count_r11;
    mbsfn_sf_cfg_list_r11_c_ mbsfn_sf_cfg_list_r11;
  };
  struct mbsfn_sf_cfg_list_v1430_c_ {
    struct setup_s_ {
      // member variables
      mbsfn_sf_cfg_list_v1430_l sf_cfg_list_v1430;
    };
    typedef setup_e types;

    // choice methods
    mbsfn_sf_cfg_list_v1430_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-v1430");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-v1430");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                   ext                      = false;
  bool                   qcl_crs_info_r11_present = false;
  uint8_t                csi_rs_cfg_nzp_id_r11    = 1;
  ant_ports_count_r11_e_ ant_ports_count_r11;
  uint8_t                res_cfg_r11       = 0;
  uint8_t                sf_cfg_r11        = 0;
  uint16_t               scrambling_id_r11 = 0;
  qcl_crs_info_r11_s_    qcl_crs_info_r11;
  // ...
  // group 0
  bool    csi_rs_cfg_nzp_id_v1310_present = false;
  uint8_t csi_rs_cfg_nzp_id_v1310         = 4;
  // group 1
  bool                   tx_comb_r14_present      = false;
  bool                   freq_density_r14_present = false;
  uint8_t                tx_comb_r14              = 0;
  nzp_freq_density_r14_e freq_density_r14;
  // group 2
  bool                                 mbsfn_sf_cfg_list_v1430_present = false;
  copy_ptr<mbsfn_sf_cfg_list_v1430_c_> mbsfn_sf_cfg_list_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NZP-ResourceConfig-r13 ::= SEQUENCE
struct nzp_res_cfg_r13_s {
  // member variables
  bool    ext         = false;
  uint8_t res_cfg_r13 = 0;
  // ...
  // group 0
  bool                   tx_comb_r14_present      = false;
  bool                   freq_density_r14_present = false;
  uint8_t                tx_comb_r14              = 0;
  nzp_freq_density_r14_e freq_density_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// P-C-AndCBSR-Pair-r13 ::= SEQUENCE (SIZE (1..2)) OF P-C-AndCBSR-r13
typedef dyn_array<p_c_and_cbsr_r13_s> p_c_and_cbsr_pair_r13_l;

// P-C-AndCBSR-r15 ::= SEQUENCE
struct p_c_and_cbsr_r15_s {
  // member variables
  int8_t        p_c_r15 = -8;
  dyn_bitstring codebook_subset_restrict4_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigBeamformed-r14 ::= SEQUENCE
struct csi_rs_cfg_beamformed_r14_s {
  typedef bounded_array<uint8_t, 7>          csi_rs_cfg_nzp_id_list_ext_r14_l_;
  typedef bounded_array<uint8_t, 8>          csi_im_cfg_id_list_r14_l_;
  typedef dyn_array<p_c_and_cbsr_pair_r13_l> p_c_and_cbsr_per_res_cfg_list_r14_l_;
  typedef bounded_array<bool, 7>             ace_for4_tx_per_res_cfg_list_r14_l_;
  typedef dyn_array<csi_rs_cfg_nzp_r11_s>    csi_rs_cfg_nzp_ap_list_r14_l_;

  // member variables
  bool                                 csi_rs_cfg_nzp_id_list_ext_r14_present              = false;
  bool                                 csi_im_cfg_id_list_r14_present                      = false;
  bool                                 p_c_and_cbsr_per_res_cfg_list_r14_present           = false;
  bool                                 ace_for4_tx_per_res_cfg_list_r14_present            = false;
  bool                                 alternative_codebook_enabled_beamformed_r14_present = false;
  bool                                 ch_meas_restrict_r14_present                        = false;
  bool                                 csi_rs_cfg_nzp_ap_list_r14_present                  = false;
  bool                                 nzp_res_cfg_original_v1430_present                  = false;
  bool                                 csi_rs_nzp_activation_r14_present                   = false;
  csi_rs_cfg_nzp_id_list_ext_r14_l_    csi_rs_cfg_nzp_id_list_ext_r14;
  csi_im_cfg_id_list_r14_l_            csi_im_cfg_id_list_r14;
  p_c_and_cbsr_per_res_cfg_list_r14_l_ p_c_and_cbsr_per_res_cfg_list_r14;
  ace_for4_tx_per_res_cfg_list_r14_l_  ace_for4_tx_per_res_cfg_list_r14;
  csi_rs_cfg_nzp_ap_list_r14_l_        csi_rs_cfg_nzp_ap_list_r14;
  csi_rs_cfg_nzp_v1430_s               nzp_res_cfg_original_v1430;
  csi_rs_cfg_nzp_activation_r14_s      csi_rs_nzp_activation_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigNZP-EMIMO-r13 ::= CHOICE
struct csi_rs_cfg_nzp_emimo_r13_c {
  struct setup_s_ {
    typedef dyn_array<nzp_res_cfg_r13_s> nzp_res_cfg_list_r13_l_;
    struct cdm_type_r13_opts {
      enum options { cdm2, cdm4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<cdm_type_r13_opts> cdm_type_r13_e_;

    // member variables
    bool                    cdm_type_r13_present = false;
    nzp_res_cfg_list_r13_l_ nzp_res_cfg_list_r13;
    cdm_type_r13_e_         cdm_type_r13;
  };
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_nzp_emimo_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigNZP-EMIMO-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigNZP-EMIMO-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CSI-RS-ConfigNZP-EMIMO-v1430 ::= SEQUENCE
struct csi_rs_cfg_nzp_emimo_v1430_s {
  typedef dyn_array<nzp_res_cfg_r13_s> nzp_res_cfg_list_ext_r14_l_;

  // member variables
  bool                        cdm_type_v1430_present = false;
  nzp_res_cfg_list_ext_r14_l_ nzp_res_cfg_list_ext_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// P-C-AndCBSR-Pair-r15 ::= SEQUENCE (SIZE (1..2)) OF P-C-AndCBSR-r15
typedef dyn_array<p_c_and_cbsr_r15_s> p_c_and_cbsr_pair_r15_l;

// CQI-ReportModeAperiodic ::= ENUMERATED
struct cqi_report_mode_aperiodic_opts {
  enum options { rm12, rm20, rm22, rm30, rm31, rm32_v1250, rm10_v1310, rm11_v1310, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<cqi_report_mode_aperiodic_opts> cqi_report_mode_aperiodic_e;

// CSI-RS-ConfigBeamformed-r13 ::= SEQUENCE
struct csi_rs_cfg_beamformed_r13_s {
  typedef bounded_array<uint8_t, 7>          csi_rs_cfg_nzp_id_list_ext_r13_l_;
  typedef bounded_array<uint8_t, 8>          csi_im_cfg_id_list_r13_l_;
  typedef dyn_array<p_c_and_cbsr_pair_r13_l> p_c_and_cbsr_per_res_cfg_list_r13_l_;
  typedef bounded_array<bool, 7>             ace_for4_tx_per_res_cfg_list_r13_l_;

  // member variables
  bool                                 csi_rs_cfg_nzp_id_list_ext_r13_present              = false;
  bool                                 csi_im_cfg_id_list_r13_present                      = false;
  bool                                 p_c_and_cbsr_per_res_cfg_list_r13_present           = false;
  bool                                 ace_for4_tx_per_res_cfg_list_r13_present            = false;
  bool                                 alternative_codebook_enabled_beamformed_r13_present = false;
  bool                                 ch_meas_restrict_r13_present                        = false;
  csi_rs_cfg_nzp_id_list_ext_r13_l_    csi_rs_cfg_nzp_id_list_ext_r13;
  csi_im_cfg_id_list_r13_l_            csi_im_cfg_id_list_r13;
  p_c_and_cbsr_per_res_cfg_list_r13_l_ p_c_and_cbsr_per_res_cfg_list_r13;
  ace_for4_tx_per_res_cfg_list_r13_l_  ace_for4_tx_per_res_cfg_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigBeamformed-v1430 ::= SEQUENCE
struct csi_rs_cfg_beamformed_v1430_s {
  typedef dyn_array<csi_rs_cfg_nzp_r11_s> csi_rs_cfg_nzp_ap_list_r14_l_;

  // member variables
  bool                            csi_rs_cfg_nzp_ap_list_r14_present = false;
  bool                            nzp_res_cfg_original_v1430_present = false;
  bool                            csi_rs_nzp_activation_r14_present  = false;
  csi_rs_cfg_nzp_ap_list_r14_l_   csi_rs_cfg_nzp_ap_list_r14;
  csi_rs_cfg_nzp_v1430_s          nzp_res_cfg_original_v1430;
  csi_rs_cfg_nzp_activation_r14_s csi_rs_nzp_activation_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigEMIMO2-r14 ::= CHOICE
struct csi_rs_cfg_emimo2_r14_c {
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_emimo2_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  csi_rs_cfg_beamformed_r14_s& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO2-r14");
    return c;
  }
  const csi_rs_cfg_beamformed_r14_s& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO2-r14");
    return c;
  }
  csi_rs_cfg_beamformed_r14_s& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types                       type_;
  csi_rs_cfg_beamformed_r14_s c;
};

// CSI-RS-ConfigNonPrecoded-r13 ::= SEQUENCE
struct csi_rs_cfg_non_precoded_r13_s {
  struct codebook_cfg_n1_r13_opts {
    enum options { n1, n2, n3, n4, n8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_cfg_n1_r13_opts> codebook_cfg_n1_r13_e_;
  struct codebook_cfg_n2_r13_opts {
    enum options { n1, n2, n3, n4, n8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_cfg_n2_r13_opts> codebook_cfg_n2_r13_e_;
  struct codebook_over_sampling_rate_cfg_o1_r13_opts {
    enum options { n4, n8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_over_sampling_rate_cfg_o1_r13_opts> codebook_over_sampling_rate_cfg_o1_r13_e_;
  struct codebook_over_sampling_rate_cfg_o2_r13_opts {
    enum options { n4, n8, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_over_sampling_rate_cfg_o2_r13_opts> codebook_over_sampling_rate_cfg_o2_r13_e_;
  typedef bounded_array<uint8_t, 2>                               csi_im_cfg_id_list_r13_l_;

  // member variables
  bool                                      p_c_and_cbsr_list_r13_present                  = false;
  bool                                      codebook_over_sampling_rate_cfg_o1_r13_present = false;
  bool                                      codebook_over_sampling_rate_cfg_o2_r13_present = false;
  bool                                      csi_im_cfg_id_list_r13_present                 = false;
  bool                                      csi_rs_cfg_nzp_emimo_r13_present               = false;
  p_c_and_cbsr_pair_r13_l                   p_c_and_cbsr_list_r13;
  codebook_cfg_n1_r13_e_                    codebook_cfg_n1_r13;
  codebook_cfg_n2_r13_e_                    codebook_cfg_n2_r13;
  codebook_over_sampling_rate_cfg_o1_r13_e_ codebook_over_sampling_rate_cfg_o1_r13;
  codebook_over_sampling_rate_cfg_o2_r13_e_ codebook_over_sampling_rate_cfg_o2_r13;
  uint8_t                                   codebook_cfg_r13 = 1;
  csi_im_cfg_id_list_r13_l_                 csi_im_cfg_id_list_r13;
  csi_rs_cfg_nzp_emimo_r13_c                csi_rs_cfg_nzp_emimo_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigNonPrecoded-v1430 ::= SEQUENCE
struct csi_rs_cfg_non_precoded_v1430_s {
  struct codebook_cfg_n1_v1430_opts {
    enum options { n5, n6, n7, n10, n12, n14, n16, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_cfg_n1_v1430_opts> codebook_cfg_n1_v1430_e_;
  struct codebook_cfg_n2_v1430_opts {
    enum options { n5, n6, n7, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_cfg_n2_v1430_opts> codebook_cfg_n2_v1430_e_;

  // member variables
  bool                         csi_rs_cfg_nzp_emimo_v1430_present = false;
  csi_rs_cfg_nzp_emimo_v1430_s csi_rs_cfg_nzp_emimo_v1430;
  codebook_cfg_n1_v1430_e_     codebook_cfg_n1_v1430;
  codebook_cfg_n2_v1430_e_     codebook_cfg_n2_v1430;
  csi_rs_cfg_nzp_v1430_s       nzp_res_cfg_tm9_original_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigNonPrecoded-v1480 ::= SEQUENCE
struct csi_rs_cfg_non_precoded_v1480_s {
  struct codebook_cfg_n1_v1480_opts {
    enum options { n5, n6, n7, n10, n12, n14, n16, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_cfg_n1_v1480_opts> codebook_cfg_n1_v1480_e_;
  struct codebook_cfg_n2_r1480_opts {
    enum options { n5, n6, n7, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<codebook_cfg_n2_r1480_opts> codebook_cfg_n2_r1480_e_;

  // member variables
  bool                         csi_rs_cfg_nzp_emimo_v1480_present = false;
  bool                         codebook_cfg_n1_v1480_present      = false;
  bool                         codebook_cfg_n2_r1480_present      = false;
  csi_rs_cfg_nzp_emimo_v1430_s csi_rs_cfg_nzp_emimo_v1480;
  codebook_cfg_n1_v1480_e_     codebook_cfg_n1_v1480;
  codebook_cfg_n2_r1480_e_     codebook_cfg_n2_r1480;
  csi_rs_cfg_nzp_v1430_s       nzp_res_cfg_tm9_original_v1480;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigNonPrecoded-v1530 ::= SEQUENCE
struct csi_rs_cfg_non_precoded_v1530_s {
  // member variables
  bool                    p_c_and_cbsr_list_r15_present = false;
  p_c_and_cbsr_pair_r15_l p_c_and_cbsr_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// P-C-AndCBSR-r11 ::= SEQUENCE
struct p_c_and_cbsr_r11_s {
  // member variables
  int8_t        p_c_r11 = -8;
  dyn_bitstring codebook_subset_restrict_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportAperiodicProc-r11 ::= SEQUENCE
struct cqi_report_aperiodic_proc_r11_s {
  // member variables
  cqi_report_mode_aperiodic_e cqi_report_mode_aperiodic_r11;
  bool                        trigger01_r11 = false;
  bool                        trigger10_r11 = false;
  bool                        trigger11_r11 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportAperiodicProc-v1310 ::= SEQUENCE
struct cqi_report_aperiodic_proc_v1310_s {
  // member variables
  bool trigger001_r13 = false;
  bool trigger010_r13 = false;
  bool trigger011_r13 = false;
  bool trigger100_r13 = false;
  bool trigger101_r13 = false;
  bool trigger110_r13 = false;
  bool trigger111_r13 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportBothProc-r11 ::= SEQUENCE
struct cqi_report_both_proc_r11_s {
  // member variables
  bool    ri_ref_csi_process_id_r11_present = false;
  bool    pmi_ri_report_r11_present         = false;
  uint8_t ri_ref_csi_process_id_r11         = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CRI-ReportConfig-r13 ::= CHOICE
struct cri_report_cfg_r13_c {
  struct setup_s_ {
    // member variables
    bool     cri_cfg_idx2_r13_present = false;
    uint16_t cri_cfg_idx_r13          = 0;
    uint16_t cri_cfg_idx2_r13         = 0;
  };
  typedef setup_e types;

  // choice methods
  cri_report_cfg_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CRI-ReportConfig-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CRI-ReportConfig-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CSI-RS-ConfigEMIMO-Hybrid-r14 ::= CHOICE
struct csi_rs_cfg_emimo_hybrid_r14_c {
  struct setup_s_ {
    // member variables
    bool                    periodicity_offset_idx_r14_present = false;
    bool                    e_mimo_type2_r14_present           = false;
    uint16_t                periodicity_offset_idx_r14         = 0;
    csi_rs_cfg_emimo2_r14_c e_mimo_type2_r14;
  };
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_emimo_hybrid_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-Hybrid-r14");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-Hybrid-r14");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CSI-RS-ConfigEMIMO-r13 ::= CHOICE
struct csi_rs_cfg_emimo_r13_c {
  struct setup_c_ {
    struct types_opts {
      enum options { non_precoded_r13, beamformed_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    setup_c_() = default;
    setup_c_(const setup_c_& other);
    setup_c_& operator=(const setup_c_& other);
    ~setup_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csi_rs_cfg_non_precoded_r13_s& non_precoded_r13()
    {
      assert_choice_type("nonPrecoded-r13", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_non_precoded_r13_s>();
    }
    csi_rs_cfg_beamformed_r13_s& beamformed_r13()
    {
      assert_choice_type("beamformed-r13", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_beamformed_r13_s>();
    }
    const csi_rs_cfg_non_precoded_r13_s& non_precoded_r13() const
    {
      assert_choice_type("nonPrecoded-r13", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_non_precoded_r13_s>();
    }
    const csi_rs_cfg_beamformed_r13_s& beamformed_r13() const
    {
      assert_choice_type("beamformed-r13", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_beamformed_r13_s>();
    }
    csi_rs_cfg_non_precoded_r13_s& set_non_precoded_r13()
    {
      set(types::non_precoded_r13);
      return c.get<csi_rs_cfg_non_precoded_r13_s>();
    }
    csi_rs_cfg_beamformed_r13_s& set_beamformed_r13()
    {
      set(types::beamformed_r13);
      return c.get<csi_rs_cfg_beamformed_r13_s>();
    }

  private:
    types                                                                                             type_;
    choice_buffer_t<MAX2(sizeof(csi_rs_cfg_beamformed_r13_s), sizeof(csi_rs_cfg_non_precoded_r13_s))> c;

    void destroy_();
  };
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_emimo_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_c_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-r13");
    return c;
  }
  const setup_c_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-r13");
    return c;
  }
  setup_c_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_c_ c;
};

// CSI-RS-ConfigEMIMO-v1430 ::= CHOICE
struct csi_rs_cfg_emimo_v1430_c {
  struct setup_c_ {
    struct types_opts {
      enum options { non_precoded_v1430, beamformed_v1430, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    setup_c_() = default;
    setup_c_(const setup_c_& other);
    setup_c_& operator=(const setup_c_& other);
    ~setup_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csi_rs_cfg_non_precoded_v1430_s& non_precoded_v1430()
    {
      assert_choice_type("nonPrecoded-v1430", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_non_precoded_v1430_s>();
    }
    csi_rs_cfg_beamformed_v1430_s& beamformed_v1430()
    {
      assert_choice_type("beamformed-v1430", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_beamformed_v1430_s>();
    }
    const csi_rs_cfg_non_precoded_v1430_s& non_precoded_v1430() const
    {
      assert_choice_type("nonPrecoded-v1430", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_non_precoded_v1430_s>();
    }
    const csi_rs_cfg_beamformed_v1430_s& beamformed_v1430() const
    {
      assert_choice_type("beamformed-v1430", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_beamformed_v1430_s>();
    }
    csi_rs_cfg_non_precoded_v1430_s& set_non_precoded_v1430()
    {
      set(types::non_precoded_v1430);
      return c.get<csi_rs_cfg_non_precoded_v1430_s>();
    }
    csi_rs_cfg_beamformed_v1430_s& set_beamformed_v1430()
    {
      set(types::beamformed_v1430);
      return c.get<csi_rs_cfg_beamformed_v1430_s>();
    }

  private:
    types                                                                                                 type_;
    choice_buffer_t<MAX2(sizeof(csi_rs_cfg_beamformed_v1430_s), sizeof(csi_rs_cfg_non_precoded_v1430_s))> c;

    void destroy_();
  };
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_emimo_v1430_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_c_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-v1430");
    return c;
  }
  const setup_c_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-v1430");
    return c;
  }
  setup_c_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_c_ c;
};

// CSI-RS-ConfigEMIMO-v1480 ::= CHOICE
struct csi_rs_cfg_emimo_v1480_c {
  struct setup_c_ {
    struct types_opts {
      enum options { non_precoded_v1480, beamformed_v1480, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    setup_c_() = default;
    setup_c_(const setup_c_& other);
    setup_c_& operator=(const setup_c_& other);
    ~setup_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csi_rs_cfg_non_precoded_v1480_s& non_precoded_v1480()
    {
      assert_choice_type("nonPrecoded-v1480", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_non_precoded_v1480_s>();
    }
    csi_rs_cfg_beamformed_v1430_s& beamformed_v1480()
    {
      assert_choice_type("beamformed-v1480", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_beamformed_v1430_s>();
    }
    const csi_rs_cfg_non_precoded_v1480_s& non_precoded_v1480() const
    {
      assert_choice_type("nonPrecoded-v1480", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_non_precoded_v1480_s>();
    }
    const csi_rs_cfg_beamformed_v1430_s& beamformed_v1480() const
    {
      assert_choice_type("beamformed-v1480", type_.to_string(), "setup");
      return c.get<csi_rs_cfg_beamformed_v1430_s>();
    }
    csi_rs_cfg_non_precoded_v1480_s& set_non_precoded_v1480()
    {
      set(types::non_precoded_v1480);
      return c.get<csi_rs_cfg_non_precoded_v1480_s>();
    }
    csi_rs_cfg_beamformed_v1430_s& set_beamformed_v1480()
    {
      set(types::beamformed_v1480);
      return c.get<csi_rs_cfg_beamformed_v1430_s>();
    }

  private:
    types                                                                                                 type_;
    choice_buffer_t<MAX2(sizeof(csi_rs_cfg_beamformed_v1430_s), sizeof(csi_rs_cfg_non_precoded_v1480_s))> c;

    void destroy_();
  };
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_emimo_v1480_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_c_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-v1480");
    return c;
  }
  const setup_c_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-v1480");
    return c;
  }
  setup_c_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_c_ c;
};

// CSI-RS-ConfigEMIMO-v1530 ::= CHOICE
struct csi_rs_cfg_emimo_v1530_c {
  struct setup_c_ {
    struct types_opts {
      enum options { non_precoded_v1530, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::non_precoded_v1530; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csi_rs_cfg_non_precoded_v1530_s&       non_precoded_v1530() { return c; }
    const csi_rs_cfg_non_precoded_v1530_s& non_precoded_v1530() const { return c; }

  private:
    csi_rs_cfg_non_precoded_v1530_s c;
  };
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_emimo_v1530_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_c_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-v1530");
    return c;
  }
  const setup_c_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigEMIMO-v1530");
    return c;
  }
  setup_c_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_c_ c;
};

// P-C-AndCBSR-Pair-r13a ::= SEQUENCE (SIZE (1..2)) OF P-C-AndCBSR-r11
typedef dyn_array<p_c_and_cbsr_r11_s> p_c_and_cbsr_pair_r13a_l;

// CQI-ReportPeriodicProcExt-r11 ::= SEQUENCE
struct cqi_report_periodic_proc_ext_r11_s {
  struct cqi_format_ind_periodic_r11_c_ {
    struct wideband_cqi_r11_s_ {
      struct csi_report_mode_r11_opts {
        enum options { submode1, submode2, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<csi_report_mode_r11_opts> csi_report_mode_r11_e_;

      // member variables
      bool                   csi_report_mode_r11_present = false;
      csi_report_mode_r11_e_ csi_report_mode_r11;
    };
    struct subband_cqi_r11_s_ {
      struct periodicity_factor_r11_opts {
        enum options { n2, n4, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<periodicity_factor_r11_opts> periodicity_factor_r11_e_;

      // member variables
      uint8_t                   k = 1;
      periodicity_factor_r11_e_ periodicity_factor_r11;
    };
    struct types_opts {
      enum options { wideband_cqi_r11, subband_cqi_r11, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    cqi_format_ind_periodic_r11_c_() = default;
    cqi_format_ind_periodic_r11_c_(const cqi_format_ind_periodic_r11_c_& other);
    cqi_format_ind_periodic_r11_c_& operator=(const cqi_format_ind_periodic_r11_c_& other);
    ~cqi_format_ind_periodic_r11_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    wideband_cqi_r11_s_& wideband_cqi_r11()
    {
      assert_choice_type("widebandCQI-r11", type_.to_string(), "cqi-FormatIndicatorPeriodic-r11");
      return c.get<wideband_cqi_r11_s_>();
    }
    subband_cqi_r11_s_& subband_cqi_r11()
    {
      assert_choice_type("subbandCQI-r11", type_.to_string(), "cqi-FormatIndicatorPeriodic-r11");
      return c.get<subband_cqi_r11_s_>();
    }
    const wideband_cqi_r11_s_& wideband_cqi_r11() const
    {
      assert_choice_type("widebandCQI-r11", type_.to_string(), "cqi-FormatIndicatorPeriodic-r11");
      return c.get<wideband_cqi_r11_s_>();
    }
    const subband_cqi_r11_s_& subband_cqi_r11() const
    {
      assert_choice_type("subbandCQI-r11", type_.to_string(), "cqi-FormatIndicatorPeriodic-r11");
      return c.get<subband_cqi_r11_s_>();
    }
    wideband_cqi_r11_s_& set_wideband_cqi_r11()
    {
      set(types::wideband_cqi_r11);
      return c.get<wideband_cqi_r11_s_>();
    }
    subband_cqi_r11_s_& set_subband_cqi_r11()
    {
      set(types::subband_cqi_r11);
      return c.get<subband_cqi_r11_s_>();
    }

  private:
    types                                                                          type_;
    choice_buffer_t<MAX2(sizeof(subband_cqi_r11_s_), sizeof(wideband_cqi_r11_s_))> c;

    void destroy_();
  };
  struct csi_cfg_idx_r11_c_ {
    struct setup_s_ {
      // member variables
      bool     ri_cfg_idx2_r11_present = false;
      uint16_t cqi_pmi_cfg_idx2_r11    = 0;
      uint16_t ri_cfg_idx2_r11         = 0;
    };
    typedef setup_e types;

    // choice methods
    csi_cfg_idx_r11_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "csi-ConfigIndex-r11");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "csi-ConfigIndex-r11");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct periodicity_factor_wb_r13_opts {
    enum options { n2, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<periodicity_factor_wb_r13_opts> periodicity_factor_wb_r13_e_;

  // member variables
  bool                           ext                                 = false;
  bool                           ri_cfg_idx_r11_present              = false;
  bool                           csi_cfg_idx_r11_present             = false;
  uint8_t                        cqi_report_periodic_proc_ext_id_r11 = 1;
  uint16_t                       cqi_pmi_cfg_idx_r11                 = 0;
  cqi_format_ind_periodic_r11_c_ cqi_format_ind_periodic_r11;
  uint16_t                       ri_cfg_idx_r11 = 0;
  csi_cfg_idx_r11_c_             csi_cfg_idx_r11;
  // ...
  // group 0
  bool                           cri_report_cfg_r13_present = false;
  copy_ptr<cri_report_cfg_r13_c> cri_report_cfg_r13;
  // group 1
  bool                         periodicity_factor_wb_r13_present = false;
  periodicity_factor_wb_r13_e_ periodicity_factor_wb_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-IM-Config-r11 ::= SEQUENCE
struct csi_im_cfg_r11_s {
  // member variables
  bool    ext               = false;
  uint8_t csi_im_cfg_id_r11 = 1;
  uint8_t res_cfg_r11       = 0;
  uint8_t sf_cfg_r11        = 0;
  // ...
  // group 0
  bool interference_meas_restrict_r13_present = false;
  bool interference_meas_restrict_r13         = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-IM-ConfigExt-r12 ::= SEQUENCE
struct csi_im_cfg_ext_r12_s {
  // member variables
  bool    ext                 = false;
  uint8_t csi_im_cfg_id_v1250 = 4;
  uint8_t res_cfg_r12         = 0;
  uint8_t sf_cfg_r12          = 0;
  // ...
  // group 0
  bool    interference_meas_restrict_r13_present = false;
  bool    csi_im_cfg_id_v1310_present            = false;
  bool    interference_meas_restrict_r13         = false;
  uint8_t csi_im_cfg_id_v1310                    = 5;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-Process-r11 ::= SEQUENCE
struct csi_process_r11_s {
  struct csi_im_cfg_id_list_r12_c_ {
    typedef bounded_array<uint8_t, 2> setup_l_;
    typedef setup_e                   types;

    // choice methods
    csi_im_cfg_id_list_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_l_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "csi-IM-ConfigIdList-r12");
      return c;
    }
    const setup_l_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "csi-IM-ConfigIdList-r12");
      return c;
    }
    setup_l_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_l_ c;
  };
  struct cqi_report_aperiodic_proc2_r12_c_ {
    typedef setup_e types;

    // choice methods
    cqi_report_aperiodic_proc2_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cqi_report_aperiodic_proc_r11_s& setup()
    {
      assert_choice_type("setup", type_.to_string(), "cqi-ReportAperiodicProc2-r12");
      return c;
    }
    const cqi_report_aperiodic_proc_r11_s& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "cqi-ReportAperiodicProc2-r12");
      return c;
    }
    cqi_report_aperiodic_proc_r11_s& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types                           type_;
    cqi_report_aperiodic_proc_r11_s c;
  };
  struct cqi_report_aperiodic_proc_v1310_c_ {
    typedef setup_e types;

    // choice methods
    cqi_report_aperiodic_proc_v1310_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cqi_report_aperiodic_proc_v1310_s& setup()
    {
      assert_choice_type("setup", type_.to_string(), "cqi-ReportAperiodicProc-v1310");
      return c;
    }
    const cqi_report_aperiodic_proc_v1310_s& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "cqi-ReportAperiodicProc-v1310");
      return c;
    }
    cqi_report_aperiodic_proc_v1310_s& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types                             type_;
    cqi_report_aperiodic_proc_v1310_s c;
  };
  struct cqi_report_aperiodic_proc2_v1310_c_ {
    typedef setup_e types;

    // choice methods
    cqi_report_aperiodic_proc2_v1310_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cqi_report_aperiodic_proc_v1310_s& setup()
    {
      assert_choice_type("setup", type_.to_string(), "cqi-ReportAperiodicProc2-v1310");
      return c;
    }
    const cqi_report_aperiodic_proc_v1310_s& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "cqi-ReportAperiodicProc2-v1310");
      return c;
    }
    cqi_report_aperiodic_proc_v1310_s& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types                             type_;
    cqi_report_aperiodic_proc_v1310_s c;
  };

  // member variables
  bool                            ext                                     = false;
  bool                            cqi_report_both_proc_r11_present        = false;
  bool                            cqi_report_periodic_proc_id_r11_present = false;
  bool                            cqi_report_aperiodic_proc_r11_present   = false;
  uint8_t                         csi_process_id_r11                      = 1;
  uint8_t                         csi_rs_cfg_nzp_id_r11                   = 1;
  uint8_t                         csi_im_cfg_id_r11                       = 1;
  p_c_and_cbsr_pair_r13a_l        p_c_and_cbsr_list_r11;
  cqi_report_both_proc_r11_s      cqi_report_both_proc_r11;
  uint8_t                         cqi_report_periodic_proc_id_r11 = 0;
  cqi_report_aperiodic_proc_r11_s cqi_report_aperiodic_proc_r11;
  // ...
  // group 0
  bool                                        alternative_codebook_enabled_for4_tx_proc_r12_present = false;
  bool                                        csi_im_cfg_id_list_r12_present                        = false;
  bool                                        cqi_report_aperiodic_proc2_r12_present                = false;
  copy_ptr<csi_im_cfg_id_list_r12_c_>         csi_im_cfg_id_list_r12;
  copy_ptr<cqi_report_aperiodic_proc2_r12_c_> cqi_report_aperiodic_proc2_r12;
  // group 1
  bool                                          cqi_report_aperiodic_proc_v1310_present  = false;
  bool                                          cqi_report_aperiodic_proc2_v1310_present = false;
  bool                                          e_mimo_type_r13_present                  = false;
  copy_ptr<cqi_report_aperiodic_proc_v1310_c_>  cqi_report_aperiodic_proc_v1310;
  copy_ptr<cqi_report_aperiodic_proc2_v1310_c_> cqi_report_aperiodic_proc2_v1310;
  copy_ptr<csi_rs_cfg_emimo_r13_c>              e_mimo_type_r13;
  // group 2
  bool                                    dummy_present                         = false;
  bool                                    e_mimo_hybrid_r14_present             = false;
  bool                                    advanced_codebook_enabled_r14_present = false;
  copy_ptr<csi_rs_cfg_emimo_v1430_c>      dummy;
  copy_ptr<csi_rs_cfg_emimo_hybrid_r14_c> e_mimo_hybrid_r14;
  bool                                    advanced_codebook_enabled_r14 = false;
  // group 3
  bool                               e_mimo_type_v1480_present = false;
  copy_ptr<csi_rs_cfg_emimo_v1480_c> e_mimo_type_v1480;
  // group 4
  bool                               fe_comp_csi_enabled_v1530_present = false;
  bool                               e_mimo_type_v1530_present         = false;
  bool                               fe_comp_csi_enabled_v1530         = false;
  copy_ptr<csi_rs_cfg_emimo_v1530_c> e_mimo_type_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportPeriodicProcExtToAddModList-r11 ::= SEQUENCE (SIZE (1..maxCQI-ProcExt-r11)) OF
// CQI-ReportPeriodicProcExt-r11
typedef dyn_array<cqi_report_periodic_proc_ext_r11_s> cqi_report_periodic_proc_ext_to_add_mod_list_r11_l;

// CQI-ReportPeriodicProcExtToReleaseList-r11 ::= SEQUENCE (SIZE (1..maxCQI-ProcExt-r11)) OF INTEGER
typedef bounded_array<uint8_t, 3> cqi_report_periodic_proc_ext_to_release_list_r11_l;

// CSI-IM-ConfigToAddModList-r11 ::= SEQUENCE (SIZE (1..maxCSI-IM-r11)) OF CSI-IM-Config-r11
typedef dyn_array<csi_im_cfg_r11_s> csi_im_cfg_to_add_mod_list_r11_l;

// CSI-IM-ConfigToAddModListExt-r13 ::= SEQUENCE (SIZE (1..maxCSI-IM-v1310)) OF CSI-IM-ConfigExt-r12
typedef dyn_array<csi_im_cfg_ext_r12_s> csi_im_cfg_to_add_mod_list_ext_r13_l;

// CSI-IM-ConfigToReleaseList-r11 ::= SEQUENCE (SIZE (1..maxCSI-IM-r11)) OF INTEGER
typedef bounded_array<uint8_t, 3> csi_im_cfg_to_release_list_r11_l;

// CSI-IM-ConfigToReleaseListExt-r13 ::= SEQUENCE (SIZE (1..maxCSI-IM-v1310)) OF INTEGER
typedef bounded_array<uint8_t, 20> csi_im_cfg_to_release_list_ext_r13_l;

// CSI-ProcessToAddModList-r11 ::= SEQUENCE (SIZE (1..maxCSI-Proc-r11)) OF CSI-Process-r11
typedef dyn_array<csi_process_r11_s> csi_process_to_add_mod_list_r11_l;

// CSI-ProcessToReleaseList-r11 ::= SEQUENCE (SIZE (1..maxCSI-Proc-r11)) OF INTEGER
typedef bounded_array<uint8_t, 4> csi_process_to_release_list_r11_l;

// DCI7-CandidatesPerAL-SPDCCH-r15 ::= SEQUENCE (SIZE(1..4)) OF INTEGER
typedef bounded_array<uint8_t, 4> dci7_candidates_per_al_spdcch_r15_l;

// N4SPUCCH-Resource-r15 ::= SEQUENCE
struct n4_spucch_res_r15_s {
  // member variables
  uint8_t n4start_prb_r15 = 0;
  uint8_t n4nof_prb_r15   = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PollByte-r14 ::= ENUMERATED
struct poll_byte_r14_opts {
  enum options {
    kb1,
    kb2,
    kb5,
    kb8,
    kb10,
    kb15,
    kb3500,
    kb4000,
    kb4500,
    kb5000,
    kb5500,
    kb6000,
    kb6500,
    kb7000,
    kb7500,
    kb8000,
    kb9000,
    kb10000,
    kb11000,
    kb12000,
    kb13000,
    kb14000,
    kb15000,
    kb16000,
    kb17000,
    kb18000,
    kb19000,
    kb20000,
    kb25000,
    kb30000,
    kb35000,
    kb40000,
    nulltype
  } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<poll_byte_r14_opts> poll_byte_r14_e;

// PollPDU-r15 ::= ENUMERATED
struct poll_pdu_r15_opts {
  enum options {
    p4,
    p8,
    p16,
    p32,
    p64,
    p128,
    p256,
    p512,
    p1024,
    p2048_r15,
    p4096_r15,
    p6144_r15,
    p8192_r15,
    p12288_r15,
    p16384_r15,
    p_infinity,
    nulltype
  } value;
  typedef int16_t number_type;

  std::string to_string() const;
  int16_t     to_number() const;
};
typedef enumerated<poll_pdu_r15_opts> poll_pdu_r15_e;

// SN-FieldLength ::= ENUMERATED
struct sn_field_len_opts {
  enum options { size5, size10, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<sn_field_len_opts> sn_field_len_e;

// SN-FieldLength-r15 ::= ENUMERATED
struct sn_field_len_r15_opts {
  enum options { size5, size10, size16_r15, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<sn_field_len_r15_opts> sn_field_len_r15_e;

// T-PollRetransmit ::= ENUMERATED
struct t_poll_retx_opts {
  enum options {
    ms5,
    ms10,
    ms15,
    ms20,
    ms25,
    ms30,
    ms35,
    ms40,
    ms45,
    ms50,
    ms55,
    ms60,
    ms65,
    ms70,
    ms75,
    ms80,
    ms85,
    ms90,
    ms95,
    ms100,
    ms105,
    ms110,
    ms115,
    ms120,
    ms125,
    ms130,
    ms135,
    ms140,
    ms145,
    ms150,
    ms155,
    ms160,
    ms165,
    ms170,
    ms175,
    ms180,
    ms185,
    ms190,
    ms195,
    ms200,
    ms205,
    ms210,
    ms215,
    ms220,
    ms225,
    ms230,
    ms235,
    ms240,
    ms245,
    ms250,
    ms300,
    ms350,
    ms400,
    ms450,
    ms500,
    ms800_v1310,
    ms1000_v1310,
    ms2000_v1310,
    ms4000_v1310,
    spare5,
    spare4,
    spare3,
    spare2,
    spare1,
    nulltype
  } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<t_poll_retx_opts> t_poll_retx_e;

// T-Reordering ::= ENUMERATED
struct t_reordering_opts {
  enum options {
    ms0,
    ms5,
    ms10,
    ms15,
    ms20,
    ms25,
    ms30,
    ms35,
    ms40,
    ms45,
    ms50,
    ms55,
    ms60,
    ms65,
    ms70,
    ms75,
    ms80,
    ms85,
    ms90,
    ms95,
    ms100,
    ms110,
    ms120,
    ms130,
    ms140,
    ms150,
    ms160,
    ms170,
    ms180,
    ms190,
    ms200,
    ms1600_v1310,
    nulltype
  } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<t_reordering_opts> t_reordering_e;

// T-StatusProhibit ::= ENUMERATED
struct t_status_prohibit_opts {
  enum options {
    ms0,
    ms5,
    ms10,
    ms15,
    ms20,
    ms25,
    ms30,
    ms35,
    ms40,
    ms45,
    ms50,
    ms55,
    ms60,
    ms65,
    ms70,
    ms75,
    ms80,
    ms85,
    ms90,
    ms95,
    ms100,
    ms105,
    ms110,
    ms115,
    ms120,
    ms125,
    ms130,
    ms135,
    ms140,
    ms145,
    ms150,
    ms155,
    ms160,
    ms165,
    ms170,
    ms175,
    ms180,
    ms185,
    ms190,
    ms195,
    ms200,
    ms205,
    ms210,
    ms215,
    ms220,
    ms225,
    ms230,
    ms235,
    ms240,
    ms245,
    ms250,
    ms300,
    ms350,
    ms400,
    ms450,
    ms500,
    ms800_v1310,
    ms1000_v1310,
    ms1200_v1310,
    ms1600_v1310,
    ms2000_v1310,
    ms2400_v1310,
    spare2,
    spare1,
    nulltype
  } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<t_status_prohibit_opts> t_status_prohibit_e;

// ZeroTxPowerCSI-RS-r12 ::= SEQUENCE
struct zero_tx_pwr_csi_rs_r12_s {
  // member variables
  fixed_bitstring<16> zero_tx_pwr_res_cfg_list_r12;
  uint8_t             zero_tx_pwr_sf_cfg_r12 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportAperiodic-r10 ::= CHOICE
struct cqi_report_aperiodic_r10_c {
  struct setup_s_ {
    struct aperiodic_csi_trigger_r10_s_ {
      // member variables
      fixed_bitstring<8> trigger1_r10;
      fixed_bitstring<8> trigger2_r10;
    };

    // member variables
    bool                         aperiodic_csi_trigger_r10_present = false;
    cqi_report_mode_aperiodic_e  cqi_report_mode_aperiodic_r10;
    aperiodic_csi_trigger_r10_s_ aperiodic_csi_trigger_r10;
  };
  typedef setup_e types;

  // choice methods
  cqi_report_aperiodic_r10_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportAperiodic-r10");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportAperiodic-r10");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CQI-ReportAperiodic-v1250 ::= CHOICE
struct cqi_report_aperiodic_v1250_c {
  struct setup_s_ {
    struct aperiodic_csi_trigger_v1250_s_ {
      struct trigger_sf_set_ind_r12_opts {
        enum options { s1, s2, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<trigger_sf_set_ind_r12_opts> trigger_sf_set_ind_r12_e_;

      // member variables
      trigger_sf_set_ind_r12_e_ trigger_sf_set_ind_r12;
      fixed_bitstring<8>        trigger1_sf_set_ind_r12;
      fixed_bitstring<8>        trigger2_sf_set_ind_r12;
    };

    // member variables
    aperiodic_csi_trigger_v1250_s_ aperiodic_csi_trigger_v1250;
  };
  typedef setup_e types;

  // choice methods
  cqi_report_aperiodic_v1250_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportAperiodic-v1250");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportAperiodic-v1250");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CQI-ReportAperiodic-v1310 ::= CHOICE
struct cqi_report_aperiodic_v1310_c {
  struct setup_s_ {
    struct aperiodic_csi_trigger_v1310_s_ {
      // member variables
      fixed_bitstring<32> trigger1_r13;
      fixed_bitstring<32> trigger2_r13;
      fixed_bitstring<32> trigger3_r13;
      fixed_bitstring<32> trigger4_r13;
      fixed_bitstring<32> trigger5_r13;
      fixed_bitstring<32> trigger6_r13;
    };
    struct aperiodic_csi_trigger2_r13_c_ {
      struct setup_s_ {
        // member variables
        fixed_bitstring<32> trigger1_sf_set_ind_r13;
        fixed_bitstring<32> trigger2_sf_set_ind_r13;
        fixed_bitstring<32> trigger3_sf_set_ind_r13;
        fixed_bitstring<32> trigger4_sf_set_ind_r13;
        fixed_bitstring<32> trigger5_sf_set_ind_r13;
        fixed_bitstring<32> trigger6_sf_set_ind_r13;
      };
      typedef setup_e types;

      // choice methods
      aperiodic_csi_trigger2_r13_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "aperiodicCSI-Trigger2-r13");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "aperiodicCSI-Trigger2-r13");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                           aperiodic_csi_trigger_v1310_present = false;
    bool                           aperiodic_csi_trigger2_r13_present  = false;
    aperiodic_csi_trigger_v1310_s_ aperiodic_csi_trigger_v1310;
    aperiodic_csi_trigger2_r13_c_  aperiodic_csi_trigger2_r13;
  };
  typedef setup_e types;

  // choice methods
  cqi_report_aperiodic_v1310_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportAperiodic-v1310");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportAperiodic-v1310");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CQI-ReportAperiodicHybrid-r14 ::= SEQUENCE
struct cqi_report_aperiodic_hybrid_r14_s {
  struct triggers_r14_c_ {
    struct one_bit_r14_s_ {
      // member variables
      fixed_bitstring<8> trigger1_ind_r14;
    };
    struct two_bit_r14_s_ {
      // member variables
      fixed_bitstring<8> trigger01_ind_r14;
      fixed_bitstring<8> trigger10_ind_r14;
      fixed_bitstring<8> trigger11_ind_r14;
    };
    struct three_bit_r14_s_ {
      // member variables
      fixed_bitstring<32> trigger001_ind_r14;
      fixed_bitstring<32> trigger010_ind_r14;
      fixed_bitstring<32> trigger011_ind_r14;
      fixed_bitstring<32> trigger100_ind_r14;
      fixed_bitstring<32> trigger101_ind_r14;
      fixed_bitstring<32> trigger110_ind_r14;
      fixed_bitstring<32> trigger111_ind_r14;
    };
    struct types_opts {
      enum options { one_bit_r14, two_bit_r14, three_bit_r14, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    triggers_r14_c_() = default;
    triggers_r14_c_(const triggers_r14_c_& other);
    triggers_r14_c_& operator=(const triggers_r14_c_& other);
    ~triggers_r14_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    one_bit_r14_s_& one_bit_r14()
    {
      assert_choice_type("oneBit-r14", type_.to_string(), "triggers-r14");
      return c.get<one_bit_r14_s_>();
    }
    two_bit_r14_s_& two_bit_r14()
    {
      assert_choice_type("twoBit-r14", type_.to_string(), "triggers-r14");
      return c.get<two_bit_r14_s_>();
    }
    three_bit_r14_s_& three_bit_r14()
    {
      assert_choice_type("threeBit-r14", type_.to_string(), "triggers-r14");
      return c.get<three_bit_r14_s_>();
    }
    const one_bit_r14_s_& one_bit_r14() const
    {
      assert_choice_type("oneBit-r14", type_.to_string(), "triggers-r14");
      return c.get<one_bit_r14_s_>();
    }
    const two_bit_r14_s_& two_bit_r14() const
    {
      assert_choice_type("twoBit-r14", type_.to_string(), "triggers-r14");
      return c.get<two_bit_r14_s_>();
    }
    const three_bit_r14_s_& three_bit_r14() const
    {
      assert_choice_type("threeBit-r14", type_.to_string(), "triggers-r14");
      return c.get<three_bit_r14_s_>();
    }
    one_bit_r14_s_& set_one_bit_r14()
    {
      set(types::one_bit_r14);
      return c.get<one_bit_r14_s_>();
    }
    two_bit_r14_s_& set_two_bit_r14()
    {
      set(types::two_bit_r14);
      return c.get<two_bit_r14_s_>();
    }
    three_bit_r14_s_& set_three_bit_r14()
    {
      set(types::three_bit_r14);
      return c.get<three_bit_r14_s_>();
    }

  private:
    types                                                                                              type_;
    choice_buffer_t<MAX4(sizeof(one_bit_r14_s_), sizeof(three_bit_r14_s_), sizeof(two_bit_r14_s_), 0)> c;

    void destroy_();
  };

  // member variables
  bool            triggers_r14_present = false;
  triggers_r14_c_ triggers_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportBoth-r11 ::= SEQUENCE
struct cqi_report_both_r11_s {
  // member variables
  bool                              csi_im_cfg_to_release_list_r11_present  = false;
  bool                              csi_im_cfg_to_add_mod_list_r11_present  = false;
  bool                              csi_process_to_release_list_r11_present = false;
  bool                              csi_process_to_add_mod_list_r11_present = false;
  csi_im_cfg_to_release_list_r11_l  csi_im_cfg_to_release_list_r11;
  csi_im_cfg_to_add_mod_list_r11_l  csi_im_cfg_to_add_mod_list_r11;
  csi_process_to_release_list_r11_l csi_process_to_release_list_r11;
  csi_process_to_add_mod_list_r11_l csi_process_to_add_mod_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportBoth-v1250 ::= SEQUENCE
struct cqi_report_both_v1250_s {
  // member variables
  bool                 csi_im_cfg_to_release_list_ext_r12_present = false;
  bool                 csi_im_cfg_to_add_mod_list_ext_r12_present = false;
  uint8_t              csi_im_cfg_to_release_list_ext_r12         = 4;
  csi_im_cfg_ext_r12_s csi_im_cfg_to_add_mod_list_ext_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportBoth-v1310 ::= SEQUENCE
struct cqi_report_both_v1310_s {
  // member variables
  bool                                 csi_im_cfg_to_release_list_ext_r13_present = false;
  bool                                 csi_im_cfg_to_add_mod_list_ext_r13_present = false;
  csi_im_cfg_to_release_list_ext_r13_l csi_im_cfg_to_release_list_ext_r13;
  csi_im_cfg_to_add_mod_list_ext_r13_l csi_im_cfg_to_add_mod_list_ext_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportPeriodic-r10 ::= CHOICE
struct cqi_report_periodic_r10_c {
  struct setup_s_ {
    struct cqi_format_ind_periodic_r10_c_ {
      struct wideband_cqi_r10_s_ {
        struct csi_report_mode_r10_opts {
          enum options { submode1, submode2, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<csi_report_mode_r10_opts> csi_report_mode_r10_e_;

        // member variables
        bool                   csi_report_mode_r10_present = false;
        csi_report_mode_r10_e_ csi_report_mode_r10;
      };
      struct subband_cqi_r10_s_ {
        struct periodicity_factor_r10_opts {
          enum options { n2, n4, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<periodicity_factor_r10_opts> periodicity_factor_r10_e_;

        // member variables
        uint8_t                   k = 1;
        periodicity_factor_r10_e_ periodicity_factor_r10;
      };
      struct types_opts {
        enum options { wideband_cqi_r10, subband_cqi_r10, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      cqi_format_ind_periodic_r10_c_() = default;
      cqi_format_ind_periodic_r10_c_(const cqi_format_ind_periodic_r10_c_& other);
      cqi_format_ind_periodic_r10_c_& operator=(const cqi_format_ind_periodic_r10_c_& other);
      ~cqi_format_ind_periodic_r10_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      wideband_cqi_r10_s_& wideband_cqi_r10()
      {
        assert_choice_type("widebandCQI-r10", type_.to_string(), "cqi-FormatIndicatorPeriodic-r10");
        return c.get<wideband_cqi_r10_s_>();
      }
      subband_cqi_r10_s_& subband_cqi_r10()
      {
        assert_choice_type("subbandCQI-r10", type_.to_string(), "cqi-FormatIndicatorPeriodic-r10");
        return c.get<subband_cqi_r10_s_>();
      }
      const wideband_cqi_r10_s_& wideband_cqi_r10() const
      {
        assert_choice_type("widebandCQI-r10", type_.to_string(), "cqi-FormatIndicatorPeriodic-r10");
        return c.get<wideband_cqi_r10_s_>();
      }
      const subband_cqi_r10_s_& subband_cqi_r10() const
      {
        assert_choice_type("subbandCQI-r10", type_.to_string(), "cqi-FormatIndicatorPeriodic-r10");
        return c.get<subband_cqi_r10_s_>();
      }
      wideband_cqi_r10_s_& set_wideband_cqi_r10()
      {
        set(types::wideband_cqi_r10);
        return c.get<wideband_cqi_r10_s_>();
      }
      subband_cqi_r10_s_& set_subband_cqi_r10()
      {
        set(types::subband_cqi_r10);
        return c.get<subband_cqi_r10_s_>();
      }

    private:
      types                                                                          type_;
      choice_buffer_t<MAX2(sizeof(subband_cqi_r10_s_), sizeof(wideband_cqi_r10_s_))> c;

      void destroy_();
    };
    struct csi_cfg_idx_r10_c_ {
      struct setup_s_ {
        // member variables
        bool     ri_cfg_idx2_r10_present = false;
        uint16_t cqi_pmi_cfg_idx2_r10    = 0;
        uint16_t ri_cfg_idx2_r10         = 0;
      };
      typedef setup_e types;

      // choice methods
      csi_cfg_idx_r10_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "csi-ConfigIndex-r10");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "csi-ConfigIndex-r10");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                           cqi_pucch_res_idx_p1_r10_present = false;
    bool                           ri_cfg_idx_present               = false;
    bool                           cqi_mask_r9_present              = false;
    bool                           csi_cfg_idx_r10_present          = false;
    uint16_t                       cqi_pucch_res_idx_r10            = 0;
    uint16_t                       cqi_pucch_res_idx_p1_r10         = 0;
    uint16_t                       cqi_pmi_cfg_idx                  = 0;
    cqi_format_ind_periodic_r10_c_ cqi_format_ind_periodic_r10;
    uint16_t                       ri_cfg_idx             = 0;
    bool                           simul_ack_nack_and_cqi = false;
    csi_cfg_idx_r10_c_             csi_cfg_idx_r10;
  };
  typedef setup_e types;

  // choice methods
  cqi_report_periodic_r10_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportPeriodic-r10");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportPeriodic-r10");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CQI-ReportPeriodic-v1130 ::= SEQUENCE
struct cqi_report_periodic_v1130_s {
  // member variables
  bool                                               simul_ack_nack_and_cqi_format3_r11_present               = false;
  bool                                               cqi_report_periodic_proc_ext_to_release_list_r11_present = false;
  bool                                               cqi_report_periodic_proc_ext_to_add_mod_list_r11_present = false;
  cqi_report_periodic_proc_ext_to_release_list_r11_l cqi_report_periodic_proc_ext_to_release_list_r11;
  cqi_report_periodic_proc_ext_to_add_mod_list_r11_l cqi_report_periodic_proc_ext_to_add_mod_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportPeriodic-v1310 ::= SEQUENCE
struct cqi_report_periodic_v1310_s {
  // member variables
  bool                 cri_report_cfg_r13_present                         = false;
  bool                 simul_ack_nack_and_cqi_format4_format5_r13_present = false;
  cri_report_cfg_r13_c cri_report_cfg_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportPeriodic-v1320 ::= SEQUENCE
struct cqi_report_periodic_v1320_s {
  struct periodicity_factor_wb_r13_opts {
    enum options { n2, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<periodicity_factor_wb_r13_opts> periodicity_factor_wb_r13_e_;

  // member variables
  bool                         periodicity_factor_wb_r13_present = false;
  periodicity_factor_wb_r13_e_ periodicity_factor_wb_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-AM-RLC-r15 ::= SEQUENCE
struct dl_am_rlc_r15_s {
  // member variables
  t_reordering_e      t_reordering_r15;
  t_status_prohibit_e t_status_prohibit_r15;
  bool                extended_rlc_li_field_r15 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-UM-RLC-r15 ::= SEQUENCE
struct dl_um_rlc_r15_s {
  // member variables
  sn_field_len_r15_e sn_field_len_r15;
  t_reordering_e     t_reordering_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasSubframePattern-r10 ::= CHOICE
struct meas_sf_pattern_r10_c {
  struct sf_pattern_tdd_r10_c_ {
    struct types_opts {
      enum options { sf_cfg1_minus5_r10, sf_cfg0_r10, sf_cfg6_r10, /*...*/ nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts, true> types;

    // choice methods
    sf_pattern_tdd_r10_c_() = default;
    sf_pattern_tdd_r10_c_(const sf_pattern_tdd_r10_c_& other);
    sf_pattern_tdd_r10_c_& operator=(const sf_pattern_tdd_r10_c_& other);
    ~sf_pattern_tdd_r10_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<20>& sf_cfg1_minus5_r10()
    {
      assert_choice_type("subframeConfig1-5-r10", type_.to_string(), "subframePatternTDD-r10");
      return c.get<fixed_bitstring<20> >();
    }
    fixed_bitstring<70>& sf_cfg0_r10()
    {
      assert_choice_type("subframeConfig0-r10", type_.to_string(), "subframePatternTDD-r10");
      return c.get<fixed_bitstring<70> >();
    }
    fixed_bitstring<60>& sf_cfg6_r10()
    {
      assert_choice_type("subframeConfig6-r10", type_.to_string(), "subframePatternTDD-r10");
      return c.get<fixed_bitstring<60> >();
    }
    const fixed_bitstring<20>& sf_cfg1_minus5_r10() const
    {
      assert_choice_type("subframeConfig1-5-r10", type_.to_string(), "subframePatternTDD-r10");
      return c.get<fixed_bitstring<20> >();
    }
    const fixed_bitstring<70>& sf_cfg0_r10() const
    {
      assert_choice_type("subframeConfig0-r10", type_.to_string(), "subframePatternTDD-r10");
      return c.get<fixed_bitstring<70> >();
    }
    const fixed_bitstring<60>& sf_cfg6_r10() const
    {
      assert_choice_type("subframeConfig6-r10", type_.to_string(), "subframePatternTDD-r10");
      return c.get<fixed_bitstring<60> >();
    }
    fixed_bitstring<20>& set_sf_cfg1_minus5_r10()
    {
      set(types::sf_cfg1_minus5_r10);
      return c.get<fixed_bitstring<20> >();
    }
    fixed_bitstring<70>& set_sf_cfg0_r10()
    {
      set(types::sf_cfg0_r10);
      return c.get<fixed_bitstring<70> >();
    }
    fixed_bitstring<60>& set_sf_cfg6_r10()
    {
      set(types::sf_cfg6_r10);
      return c.get<fixed_bitstring<60> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<70>)> c;

    void destroy_();
  };
  struct types_opts {
    enum options { sf_pattern_fdd_r10, sf_pattern_tdd_r10, /*...*/ nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts, true> types;

  // choice methods
  meas_sf_pattern_r10_c() = default;
  meas_sf_pattern_r10_c(const meas_sf_pattern_r10_c& other);
  meas_sf_pattern_r10_c& operator=(const meas_sf_pattern_r10_c& other);
  ~meas_sf_pattern_r10_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<40>& sf_pattern_fdd_r10()
  {
    assert_choice_type("subframePatternFDD-r10", type_.to_string(), "MeasSubframePattern-r10");
    return c.get<fixed_bitstring<40> >();
  }
  sf_pattern_tdd_r10_c_& sf_pattern_tdd_r10()
  {
    assert_choice_type("subframePatternTDD-r10", type_.to_string(), "MeasSubframePattern-r10");
    return c.get<sf_pattern_tdd_r10_c_>();
  }
  const fixed_bitstring<40>& sf_pattern_fdd_r10() const
  {
    assert_choice_type("subframePatternFDD-r10", type_.to_string(), "MeasSubframePattern-r10");
    return c.get<fixed_bitstring<40> >();
  }
  const sf_pattern_tdd_r10_c_& sf_pattern_tdd_r10() const
  {
    assert_choice_type("subframePatternTDD-r10", type_.to_string(), "MeasSubframePattern-r10");
    return c.get<sf_pattern_tdd_r10_c_>();
  }
  fixed_bitstring<40>& set_sf_pattern_fdd_r10()
  {
    set(types::sf_pattern_fdd_r10);
    return c.get<fixed_bitstring<40> >();
  }
  sf_pattern_tdd_r10_c_& set_sf_pattern_tdd_r10()
  {
    set(types::sf_pattern_tdd_r10);
    return c.get<sf_pattern_tdd_r10_c_>();
  }

private:
  types                                                                             type_;
  choice_buffer_t<MAX2(sizeof(fixed_bitstring<40>), sizeof(sf_pattern_tdd_r10_c_))> c;

  void destroy_();
};

// PollByte ::= ENUMERATED
struct poll_byte_opts {
  enum options {
    kb25,
    kb50,
    kb75,
    kb100,
    kb125,
    kb250,
    kb375,
    kb500,
    kb750,
    kb1000,
    kb1250,
    kb1500,
    kb2000,
    kb3000,
    kbinfinity,
    spare1,
    nulltype
  } value;
  typedef int16_t number_type;

  std::string to_string() const;
  int16_t     to_number() const;
};
typedef enumerated<poll_byte_opts> poll_byte_e;

// PollPDU ::= ENUMERATED
struct poll_pdu_opts {
  enum options { p4, p8, p16, p32, p64, p128, p256, p_infinity, nulltype } value;
  typedef int16_t number_type;

  std::string to_string() const;
  int16_t     to_number() const;
};
typedef enumerated<poll_pdu_opts> poll_pdu_e;

// SPDCCH-Elements-r15 ::= CHOICE
struct spdcch_elems_r15_c {
  struct setup_s_ {
    struct spdcch_set_ref_sig_r15_opts {
      enum options { crs, dmrs, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<spdcch_set_ref_sig_r15_opts> spdcch_set_ref_sig_r15_e_;
    struct tx_type_r15_opts {
      enum options { localised, distributed, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<tx_type_r15_opts>                   tx_type_r15_e_;
    typedef bounded_array<uint8_t, 4>                      dci7_candidates_per_al_pdcch_r15_l_;
    typedef dyn_array<dci7_candidates_per_al_spdcch_r15_l> dci7_candidate_sets_per_al_spdcch_r15_l_;
    struct res_block_assign_r15_s_ {
      // member variables
      uint8_t             num_rb_in_freq_domain_r15 = 2;
      fixed_bitstring<98> res_block_assign_r15;
    };
    typedef bounded_array<uint8_t, 4> al_start_point_spdcch_r15_l_;
    struct sf_type_r15_opts {
      enum options { mbsfn, nonmbsfn, all, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<sf_type_r15_opts> sf_type_r15_e_;
    struct rate_matching_mode_r15_opts {
      enum options { m1, m2, m3, m4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<rate_matching_mode_r15_opts> rate_matching_mode_r15_e_;

    // member variables
    bool                                     ext                                           = false;
    bool                                     spdcch_set_cfg_id_r15_present                 = false;
    bool                                     spdcch_set_ref_sig_r15_present                = false;
    bool                                     tx_type_r15_present                           = false;
    bool                                     spdcch_no_of_symbols_r15_present              = false;
    bool                                     dmrs_scrambling_seq_int_r15_present           = false;
    bool                                     dci7_candidates_per_al_pdcch_r15_present      = false;
    bool                                     dci7_candidate_sets_per_al_spdcch_r15_present = false;
    bool                                     res_block_assign_r15_present                  = false;
    bool                                     subslot_applicability_r15_present             = false;
    bool                                     al_start_point_spdcch_r15_present             = false;
    bool                                     sf_type_r15_present                           = false;
    bool                                     rate_matching_mode_r15_present                = false;
    uint8_t                                  spdcch_set_cfg_id_r15                         = 0;
    spdcch_set_ref_sig_r15_e_                spdcch_set_ref_sig_r15;
    tx_type_r15_e_                           tx_type_r15;
    uint8_t                                  spdcch_no_of_symbols_r15    = 1;
    uint16_t                                 dmrs_scrambling_seq_int_r15 = 0;
    dci7_candidates_per_al_pdcch_r15_l_      dci7_candidates_per_al_pdcch_r15;
    dci7_candidate_sets_per_al_spdcch_r15_l_ dci7_candidate_sets_per_al_spdcch_r15;
    res_block_assign_r15_s_                  res_block_assign_r15;
    fixed_bitstring<5>                       subslot_applicability_r15;
    al_start_point_spdcch_r15_l_             al_start_point_spdcch_r15;
    sf_type_r15_e_                           sf_type_r15;
    rate_matching_mode_r15_e_                rate_matching_mode_r15;
    // ...
  };
  typedef setup_e types;

  // choice methods
  spdcch_elems_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPDCCH-Elements-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPDCCH-Elements-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SPUCCH-Elements-r15 ::= CHOICE
struct spucch_elems_r15_c {
  struct setup_s_ {
    typedef bounded_array<uint16_t, 4>     n1_subslot_spucch_an_list_r15_l_;
    typedef dyn_array<n4_spucch_res_r15_s> n4_spucch_slot_res_r15_l_;
    typedef dyn_array<n4_spucch_res_r15_s> n4_spucch_subslot_res_r15_l_;

    // member variables
    bool                             n1_subslot_spucch_an_list_r15_present              = false;
    bool                             n1_slot_spucch_fh_an_list_r15_present              = false;
    bool                             n1_slot_spucch_no_fh_an_list_r15_present           = false;
    bool                             n3_spucch_an_list_r15_present                      = false;
    bool                             n4_spucch_slot_res_r15_present                     = false;
    bool                             n4_spucch_subslot_res_r15_present                  = false;
    bool                             n4max_coderate_slot_pucch_r15_present              = false;
    bool                             n4max_coderate_subslot_pucch_r15_present           = false;
    bool                             n4max_coderate_multi_res_slot_pucch_r15_present    = false;
    bool                             n4max_coderate_multi_res_subslot_pucch_r15_present = false;
    n1_subslot_spucch_an_list_r15_l_ n1_subslot_spucch_an_list_r15;
    uint16_t                         n1_slot_spucch_fh_an_list_r15    = 0;
    uint16_t                         n1_slot_spucch_no_fh_an_list_r15 = 0;
    uint16_t                         n3_spucch_an_list_r15            = 0;
    n4_spucch_slot_res_r15_l_        n4_spucch_slot_res_r15;
    n4_spucch_subslot_res_r15_l_     n4_spucch_subslot_res_r15;
    uint8_t                          n4max_coderate_slot_pucch_r15              = 0;
    uint8_t                          n4max_coderate_subslot_pucch_r15           = 0;
    uint8_t                          n4max_coderate_multi_res_slot_pucch_r15    = 0;
    uint8_t                          n4max_coderate_multi_res_subslot_pucch_r15 = 0;
  };
  typedef setup_e types;

  // choice methods
  spucch_elems_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPUCCH-Elements-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPUCCH-Elements-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// TPC-Index ::= CHOICE
struct tpc_idx_c {
  struct types_opts {
    enum options { idx_of_format3, idx_of_format3_a, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  tpc_idx_c() = default;
  tpc_idx_c(const tpc_idx_c& other);
  tpc_idx_c& operator=(const tpc_idx_c& other);
  ~tpc_idx_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& idx_of_format3()
  {
    assert_choice_type("indexOfFormat3", type_.to_string(), "TPC-Index");
    return c.get<uint8_t>();
  }
  uint8_t& idx_of_format3_a()
  {
    assert_choice_type("indexOfFormat3A", type_.to_string(), "TPC-Index");
    return c.get<uint8_t>();
  }
  const uint8_t& idx_of_format3() const
  {
    assert_choice_type("indexOfFormat3", type_.to_string(), "TPC-Index");
    return c.get<uint8_t>();
  }
  const uint8_t& idx_of_format3_a() const
  {
    assert_choice_type("indexOfFormat3A", type_.to_string(), "TPC-Index");
    return c.get<uint8_t>();
  }
  uint8_t& set_idx_of_format3()
  {
    set(types::idx_of_format3);
    return c.get<uint8_t>();
  }
  uint8_t& set_idx_of_format3_a()
  {
    set(types::idx_of_format3_a);
    return c.get<uint8_t>();
  }

private:
  types              type_;
  choice_buffer_t<8> c;

  void destroy_();
};

// UL-AM-RLC-r15 ::= SEQUENCE
struct ul_am_rlc_r15_s {
  struct max_retx_thres_r15_opts {
    enum options { t1, t2, t3, t4, t6, t8, t16, t32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<max_retx_thres_r15_opts> max_retx_thres_r15_e_;

  // member variables
  t_poll_retx_e         t_poll_retx_r15;
  poll_pdu_r15_e        poll_pdu_r15;
  poll_byte_r14_e       poll_byte_r15;
  max_retx_thres_r15_e_ max_retx_thres_r15;
  bool                  extended_rlc_li_field_r15 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-UM-RLC ::= SEQUENCE
struct ul_um_rlc_s {
  // member variables
  sn_field_len_e sn_field_len;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ZeroTxPowerCSI-RS-Conf-r12 ::= CHOICE
struct zero_tx_pwr_csi_rs_conf_r12_c {
  typedef setup_e types;

  // choice methods
  zero_tx_pwr_csi_rs_conf_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  zero_tx_pwr_csi_rs_r12_s& setup()
  {
    assert_choice_type("setup", type_.to_string(), "ZeroTxPowerCSI-RS-Conf-r12");
    return c;
  }
  const zero_tx_pwr_csi_rs_r12_s& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "ZeroTxPowerCSI-RS-Conf-r12");
    return c;
  }
  zero_tx_pwr_csi_rs_r12_s& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types                    type_;
  zero_tx_pwr_csi_rs_r12_s c;
};

// CQI-ReportConfig-r10 ::= SEQUENCE
struct cqi_report_cfg_r10_s {
  struct csi_sf_pattern_cfg_r10_c_ {
    struct setup_s_ {
      // member variables
      meas_sf_pattern_r10_c csi_meas_sf_set1_r10;
      meas_sf_pattern_r10_c csi_meas_sf_set2_r10;
    };
    typedef setup_e types;

    // choice methods
    csi_sf_pattern_cfg_r10_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "csi-SubframePatternConfig-r10");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "csi-SubframePatternConfig-r10");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                       cqi_report_aperiodic_r10_present = false;
  bool                       cqi_report_periodic_r10_present  = false;
  bool                       pmi_ri_report_r9_present         = false;
  bool                       csi_sf_pattern_cfg_r10_present   = false;
  cqi_report_aperiodic_r10_c cqi_report_aperiodic_r10;
  int8_t                     nom_pdsch_rs_epre_offset = -1;
  cqi_report_periodic_r10_c  cqi_report_periodic_r10;
  csi_sf_pattern_cfg_r10_c_  csi_sf_pattern_cfg_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-v1130 ::= SEQUENCE
struct cqi_report_cfg_v1130_s {
  // member variables
  cqi_report_periodic_v1130_s cqi_report_periodic_v1130;
  cqi_report_both_r11_s       cqi_report_both_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-v1250 ::= SEQUENCE
struct cqi_report_cfg_v1250_s {
  struct csi_sf_pattern_cfg_r12_c_ {
    struct setup_s_ {
      // member variables
      fixed_bitstring<10> csi_meas_sf_sets_r12;
    };
    typedef setup_e types;

    // choice methods
    csi_sf_pattern_cfg_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "csi-SubframePatternConfig-r12");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "csi-SubframePatternConfig-r12");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct alt_cqi_table_r12_opts {
    enum options { all_sfs, csi_sf_set1, csi_sf_set2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<alt_cqi_table_r12_opts> alt_cqi_table_r12_e_;

  // member variables
  bool                         csi_sf_pattern_cfg_r12_present     = false;
  bool                         cqi_report_both_v1250_present      = false;
  bool                         cqi_report_aperiodic_v1250_present = false;
  bool                         alt_cqi_table_r12_present          = false;
  csi_sf_pattern_cfg_r12_c_    csi_sf_pattern_cfg_r12;
  cqi_report_both_v1250_s      cqi_report_both_v1250;
  cqi_report_aperiodic_v1250_c cqi_report_aperiodic_v1250;
  alt_cqi_table_r12_e_         alt_cqi_table_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-v1310 ::= SEQUENCE
struct cqi_report_cfg_v1310_s {
  // member variables
  bool                         cqi_report_both_v1310_present      = false;
  bool                         cqi_report_aperiodic_v1310_present = false;
  bool                         cqi_report_periodic_v1310_present  = false;
  cqi_report_both_v1310_s      cqi_report_both_v1310;
  cqi_report_aperiodic_v1310_c cqi_report_aperiodic_v1310;
  cqi_report_periodic_v1310_s  cqi_report_periodic_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-v1320 ::= SEQUENCE
struct cqi_report_cfg_v1320_s {
  // member variables
  bool                        cqi_report_periodic_v1320_present = false;
  cqi_report_periodic_v1320_s cqi_report_periodic_v1320;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-v1430 ::= SEQUENCE
struct cqi_report_cfg_v1430_s {
  // member variables
  bool                              cqi_report_aperiodic_hybrid_r14_present = false;
  cqi_report_aperiodic_hybrid_r14_s cqi_report_aperiodic_hybrid_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-Config-r10 ::= SEQUENCE
struct csi_rs_cfg_r10_s {
  struct csi_rs_r10_c_ {
    struct setup_s_ {
      struct ant_ports_count_r10_opts {
        enum options { an1, an2, an4, an8, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<ant_ports_count_r10_opts> ant_ports_count_r10_e_;

      // member variables
      ant_ports_count_r10_e_ ant_ports_count_r10;
      uint8_t                res_cfg_r10 = 0;
      uint8_t                sf_cfg_r10  = 0;
      int8_t                 p_c_r10     = -8;
    };
    typedef setup_e types;

    // choice methods
    csi_rs_r10_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "csi-RS-r10");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "csi-RS-r10");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                          csi_rs_r10_present             = false;
  bool                          zero_tx_pwr_csi_rs_r10_present = false;
  csi_rs_r10_c_                 csi_rs_r10;
  zero_tx_pwr_csi_rs_conf_r12_c zero_tx_pwr_csi_rs_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-Config-v1250 ::= SEQUENCE
struct csi_rs_cfg_v1250_s {
  struct ds_zero_tx_pwr_csi_rs_r12_c_ {
    struct setup_s_ {
      typedef dyn_array<zero_tx_pwr_csi_rs_r12_s> zero_tx_pwr_csi_rs_list_r12_l_;

      // member variables
      zero_tx_pwr_csi_rs_list_r12_l_ zero_tx_pwr_csi_rs_list_r12;
    };
    typedef setup_e types;

    // choice methods
    ds_zero_tx_pwr_csi_rs_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ds-ZeroTxPowerCSI-RS-r12");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ds-ZeroTxPowerCSI-RS-r12");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                          zero_tx_pwr_csi_rs2_r12_present   = false;
  bool                          ds_zero_tx_pwr_csi_rs_r12_present = false;
  zero_tx_pwr_csi_rs_conf_r12_c zero_tx_pwr_csi_rs2_r12;
  ds_zero_tx_pwr_csi_rs_r12_c_  ds_zero_tx_pwr_csi_rs_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-Config-v1310 ::= SEQUENCE
struct csi_rs_cfg_v1310_s {
  // member variables
  bool                   e_mimo_type_r13_present = false;
  csi_rs_cfg_emimo_r13_c e_mimo_type_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-Config-v1430 ::= SEQUENCE
struct csi_rs_cfg_v1430_s {
  // member variables
  bool                          dummy_present                         = false;
  bool                          e_mimo_hybrid_r14_present             = false;
  bool                          advanced_codebook_enabled_r14_present = false;
  csi_rs_cfg_emimo_v1430_c      dummy;
  csi_rs_cfg_emimo_hybrid_r14_c e_mimo_hybrid_r14;
  bool                          advanced_codebook_enabled_r14 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigZP-r11 ::= SEQUENCE
struct csi_rs_cfg_zp_r11_s {
  // member variables
  bool                ext                  = false;
  uint8_t             csi_rs_cfg_zp_id_r11 = 1;
  fixed_bitstring<16> res_cfg_list_r11;
  uint8_t             sf_cfg_r11 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-AM-RLC ::= SEQUENCE
struct dl_am_rlc_s {
  // member variables
  t_reordering_e      t_reordering;
  t_status_prohibit_e t_status_prohibit;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-UM-RLC ::= SEQUENCE
struct dl_um_rlc_s {
  // member variables
  sn_field_len_e sn_field_len;
  t_reordering_e t_reordering;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DeltaTxD-OffsetListSPUCCH-r15 ::= SEQUENCE
struct delta_tx_d_offset_list_spucch_r15_s {
  struct delta_tx_d_offset_spucch_format1_r15_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_spucch_format1_r15_opts> delta_tx_d_offset_spucch_format1_r15_e_;
  struct delta_tx_d_offset_spucch_format1a_r15_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_spucch_format1a_r15_opts> delta_tx_d_offset_spucch_format1a_r15_e_;
  struct delta_tx_d_offset_spucch_format1b_r15_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_spucch_format1b_r15_opts> delta_tx_d_offset_spucch_format1b_r15_e_;
  struct delta_tx_d_offset_spucch_format3_r15_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_spucch_format3_r15_opts> delta_tx_d_offset_spucch_format3_r15_e_;

  // member variables
  bool                                     ext = false;
  delta_tx_d_offset_spucch_format1_r15_e_  delta_tx_d_offset_spucch_format1_r15;
  delta_tx_d_offset_spucch_format1a_r15_e_ delta_tx_d_offset_spucch_format1a_r15;
  delta_tx_d_offset_spucch_format1b_r15_e_ delta_tx_d_offset_spucch_format1b_r15;
  delta_tx_d_offset_spucch_format3_r15_e_  delta_tx_d_offset_spucch_format3_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EPDCCH-SetConfig-r11 ::= SEQUENCE
struct epdcch_set_cfg_r11_s {
  struct tx_type_r11_opts {
    enum options { localised, distributed, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<tx_type_r11_opts> tx_type_r11_e_;
  struct res_block_assign_r11_s_ {
    struct num_prb_pairs_r11_opts {
      enum options { n2, n4, n8, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<num_prb_pairs_r11_opts> num_prb_pairs_r11_e_;

    // member variables
    num_prb_pairs_r11_e_ num_prb_pairs_r11;
    dyn_bitstring        res_block_assign_r11;
  };
  struct csi_rs_cfg_zp_id2_r12_c_ {
    typedef setup_e types;

    // choice methods
    csi_rs_cfg_zp_id2_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& setup()
    {
      assert_choice_type("setup", type_.to_string(), "csi-RS-ConfigZPId2-r12");
      return c;
    }
    const uint8_t& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "csi-RS-ConfigZPId2-r12");
      return c;
    }
    uint8_t& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types   type_;
    uint8_t c;
  };
  struct num_prb_pairs_v1310_c_ {
    typedef setup_e types;

    // choice methods
    num_prb_pairs_v1310_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;

  private:
    types type_;
  };
  struct mpdcch_cfg_r13_c_ {
    struct setup_s_ {
      struct csi_num_repeat_ce_r13_opts {
        enum options { sf1, sf2, sf4, sf8, sf16, sf32, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<csi_num_repeat_ce_r13_opts> csi_num_repeat_ce_r13_e_;
      struct mpdcch_pdsch_hop_cfg_r13_opts {
        enum options { on, off, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<mpdcch_pdsch_hop_cfg_r13_opts> mpdcch_pdsch_hop_cfg_r13_e_;
      struct mpdcch_start_sf_uess_r13_c_ {
        struct fdd_r13_opts {
          enum options { v1, v1dot5, v2, v2dot5, v4, v5, v8, v10, nulltype } value;
          typedef float number_type;

          std::string to_string() const;
          float       to_number() const;
          std::string to_number_string() const;
        };
        typedef enumerated<fdd_r13_opts> fdd_r13_e_;
        struct tdd_r13_opts {
          enum options { v1, v2, v4, v5, v8, v10, v20, spare1, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<tdd_r13_opts> tdd_r13_e_;
        struct types_opts {
          enum options { fdd_r13, tdd_r13, nulltype } value;

          std::string to_string() const;
        };
        typedef enumerated<types_opts> types;

        // choice methods
        mpdcch_start_sf_uess_r13_c_() = default;
        mpdcch_start_sf_uess_r13_c_(const mpdcch_start_sf_uess_r13_c_& other);
        mpdcch_start_sf_uess_r13_c_& operator=(const mpdcch_start_sf_uess_r13_c_& other);
        ~mpdcch_start_sf_uess_r13_c_() { destroy_(); }
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        fdd_r13_e_& fdd_r13()
        {
          assert_choice_type("fdd-r13", type_.to_string(), "mpdcch-StartSF-UESS-r13");
          return c.get<fdd_r13_e_>();
        }
        tdd_r13_e_& tdd_r13()
        {
          assert_choice_type("tdd-r13", type_.to_string(), "mpdcch-StartSF-UESS-r13");
          return c.get<tdd_r13_e_>();
        }
        const fdd_r13_e_& fdd_r13() const
        {
          assert_choice_type("fdd-r13", type_.to_string(), "mpdcch-StartSF-UESS-r13");
          return c.get<fdd_r13_e_>();
        }
        const tdd_r13_e_& tdd_r13() const
        {
          assert_choice_type("tdd-r13", type_.to_string(), "mpdcch-StartSF-UESS-r13");
          return c.get<tdd_r13_e_>();
        }
        fdd_r13_e_& set_fdd_r13()
        {
          set(types::fdd_r13);
          return c.get<fdd_r13_e_>();
        }
        tdd_r13_e_& set_tdd_r13()
        {
          set(types::tdd_r13);
          return c.get<tdd_r13_e_>();
        }

      private:
        types                                                         type_;
        choice_buffer_t<MAX2(sizeof(fdd_r13_e_), sizeof(tdd_r13_e_))> c;

        void destroy_();
      };
      struct mpdcch_num_repeat_r13_opts {
        enum options { r1, r2, r4, r8, r16, r32, r64, r128, r256, nulltype } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<mpdcch_num_repeat_r13_opts> mpdcch_num_repeat_r13_e_;

      // member variables
      csi_num_repeat_ce_r13_e_    csi_num_repeat_ce_r13;
      mpdcch_pdsch_hop_cfg_r13_e_ mpdcch_pdsch_hop_cfg_r13;
      mpdcch_start_sf_uess_r13_c_ mpdcch_start_sf_uess_r13;
      mpdcch_num_repeat_r13_e_    mpdcch_num_repeat_r13;
      uint8_t                     mpdcch_nb_r13 = 1;
    };
    typedef setup_e types;

    // choice methods
    mpdcch_cfg_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "mpdcch-config-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "mpdcch-config-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                    ext                           = false;
  bool                    re_map_qcl_cfg_id_r11_present = false;
  uint8_t                 set_cfg_id_r11                = 0;
  tx_type_r11_e_          tx_type_r11;
  res_block_assign_r11_s_ res_block_assign_r11;
  uint16_t                dmrs_scrambling_seq_int_r11 = 0;
  uint16_t                pucch_res_start_offset_r11  = 0;
  uint8_t                 re_map_qcl_cfg_id_r11       = 1;
  // ...
  // group 0
  bool                               csi_rs_cfg_zp_id2_r12_present = false;
  copy_ptr<csi_rs_cfg_zp_id2_r12_c_> csi_rs_cfg_zp_id2_r12;
  // group 1
  bool                             num_prb_pairs_v1310_present = false;
  bool                             mpdcch_cfg_r13_present      = false;
  copy_ptr<num_prb_pairs_v1310_c_> num_prb_pairs_v1310;
  copy_ptr<mpdcch_cfg_r13_c_>      mpdcch_cfg_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Enable256QAM-r14 ::= CHOICE
struct enable256_qam_r14_c {
  struct setup_c_ {
    struct tpc_sf_set_cfgured_r14_s_ {
      // member variables
      bool sf_set1_dci_format0_r14 = false;
      bool sf_set1_dci_format4_r14 = false;
      bool sf_set2_dci_format0_r14 = false;
      bool sf_set2_dci_format4_r14 = false;
    };
    struct tpc_sf_set_not_cfgured_r14_s_ {
      // member variables
      bool dci_format0_r14 = false;
      bool dci_format4_r14 = false;
    };
    struct types_opts {
      enum options { tpc_sf_set_cfgured_r14, tpc_sf_set_not_cfgured_r14, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    setup_c_() = default;
    setup_c_(const setup_c_& other);
    setup_c_& operator=(const setup_c_& other);
    ~setup_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    tpc_sf_set_cfgured_r14_s_& tpc_sf_set_cfgured_r14()
    {
      assert_choice_type("tpc-SubframeSet-Configured-r14", type_.to_string(), "setup");
      return c.get<tpc_sf_set_cfgured_r14_s_>();
    }
    tpc_sf_set_not_cfgured_r14_s_& tpc_sf_set_not_cfgured_r14()
    {
      assert_choice_type("tpc-SubframeSet-NotConfigured-r14", type_.to_string(), "setup");
      return c.get<tpc_sf_set_not_cfgured_r14_s_>();
    }
    const tpc_sf_set_cfgured_r14_s_& tpc_sf_set_cfgured_r14() const
    {
      assert_choice_type("tpc-SubframeSet-Configured-r14", type_.to_string(), "setup");
      return c.get<tpc_sf_set_cfgured_r14_s_>();
    }
    const tpc_sf_set_not_cfgured_r14_s_& tpc_sf_set_not_cfgured_r14() const
    {
      assert_choice_type("tpc-SubframeSet-NotConfigured-r14", type_.to_string(), "setup");
      return c.get<tpc_sf_set_not_cfgured_r14_s_>();
    }
    tpc_sf_set_cfgured_r14_s_& set_tpc_sf_set_cfgured_r14()
    {
      set(types::tpc_sf_set_cfgured_r14);
      return c.get<tpc_sf_set_cfgured_r14_s_>();
    }
    tpc_sf_set_not_cfgured_r14_s_& set_tpc_sf_set_not_cfgured_r14()
    {
      set(types::tpc_sf_set_not_cfgured_r14);
      return c.get<tpc_sf_set_not_cfgured_r14_s_>();
    }

  private:
    types                                                                                           type_;
    choice_buffer_t<MAX2(sizeof(tpc_sf_set_cfgured_r14_s_), sizeof(tpc_sf_set_not_cfgured_r14_s_))> c;

    void destroy_();
  };
  typedef setup_e types;

  // choice methods
  enable256_qam_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_c_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "Enable256QAM-r14");
    return c;
  }
  const setup_c_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "Enable256QAM-r14");
    return c;
  }
  setup_c_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_c_ c;
};

// LogicalChannelConfig ::= SEQUENCE
struct lc_ch_cfg_s {
  struct ul_specific_params_s_ {
    struct prioritised_bit_rate_opts {
      enum options {
        kbps0,
        kbps8,
        kbps16,
        kbps32,
        kbps64,
        kbps128,
        kbps256,
        infinity,
        kbps512_v1020,
        kbps1024_v1020,
        kbps2048_v1020,
        spare5,
        spare4,
        spare3,
        spare2,
        spare1,
        nulltype
      } value;
      typedef int16_t number_type;

      std::string to_string() const;
      int16_t     to_number() const;
    };
    typedef enumerated<prioritised_bit_rate_opts> prioritised_bit_rate_e_;
    struct bucket_size_dur_opts {
      enum options { ms50, ms100, ms150, ms300, ms500, ms1000, spare2, spare1, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<bucket_size_dur_opts> bucket_size_dur_e_;

    // member variables
    bool                    lc_ch_group_present = false;
    uint8_t                 prio                = 1;
    prioritised_bit_rate_e_ prioritised_bit_rate;
    bucket_size_dur_e_      bucket_size_dur;
    uint8_t                 lc_ch_group = 0;
  };
  struct bit_rate_query_prohibit_timer_r14_opts {
    enum options { s0, s0dot4, s0dot8, s1dot6, s3, s6, s12, s30, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<bit_rate_query_prohibit_timer_r14_opts> bit_rate_query_prohibit_timer_r14_e_;
  struct allowed_tti_lens_r15_c_ {
    struct setup_s_ {
      // member variables
      bool short_tti_r15 = false;
      bool sf_tti_r15    = false;
    };
    typedef setup_e types;

    // choice methods
    allowed_tti_lens_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "allowedTTI-Lengths-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "allowedTTI-Lengths-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct lc_ch_sr_restrict_r15_c_ {
    struct setup_opts {
      enum options { spucch, pucch, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<setup_opts> setup_e_;
    typedef setup_e                types;

    // choice methods
    lc_ch_sr_restrict_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_e_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "logicalChannelSR-Restriction-r15");
      return c;
    }
    const setup_e_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "logicalChannelSR-Restriction-r15");
      return c;
    }
    setup_e_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_e_ c;
  };
  struct chl_access_prio_r15_c_ {
    typedef setup_e types;

    // choice methods
    chl_access_prio_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& setup()
    {
      assert_choice_type("setup", type_.to_string(), "channellAccessPriority-r15");
      return c;
    }
    const uint8_t& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "channellAccessPriority-r15");
      return c;
    }
    uint8_t& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types   type_;
    uint8_t c;
  };

  // member variables
  bool                  ext                        = false;
  bool                  ul_specific_params_present = false;
  ul_specific_params_s_ ul_specific_params;
  // ...
  // group 0
  bool lc_ch_sr_mask_r9_present = false;
  // group 1
  bool lc_ch_sr_prohibit_r12_present = false;
  bool lc_ch_sr_prohibit_r12         = false;
  // group 2
  bool                                 laa_ul_allowed_r14_present                = false;
  bool                                 bit_rate_query_prohibit_timer_r14_present = false;
  bool                                 laa_ul_allowed_r14                        = false;
  bit_rate_query_prohibit_timer_r14_e_ bit_rate_query_prohibit_timer_r14;
  // group 3
  bool                               allowed_tti_lens_r15_present  = false;
  bool                               lc_ch_sr_restrict_r15_present = false;
  bool                               chl_access_prio_r15_present   = false;
  bool                               lch_cell_restrict_r15_present = false;
  copy_ptr<allowed_tti_lens_r15_c_>  allowed_tti_lens_r15;
  copy_ptr<lc_ch_sr_restrict_r15_c_> lc_ch_sr_restrict_r15;
  copy_ptr<chl_access_prio_r15_c_>   chl_access_prio_r15;
  fixed_bitstring<32>                lch_cell_restrict_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// P-a ::= ENUMERATED
struct p_a_opts {
  enum options { db_minus6, db_minus4dot77, db_minus3, db_minus1dot77, db0, db1, db2, db3, nulltype } value;
  typedef float number_type;

  std::string to_string() const;
  float       to_number() const;
  std::string to_number_string() const;
};
typedef enumerated<p_a_opts> p_a_e;

// PDSCH-RE-MappingQCL-Config-r11 ::= SEQUENCE
struct pdsch_re_map_qcl_cfg_r11_s {
  struct optional_set_of_fields_r11_s_ {
    struct crs_ports_count_r11_opts {
      enum options { n1, n2, n4, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<crs_ports_count_r11_opts> crs_ports_count_r11_e_;
    struct mbsfn_sf_cfg_list_r11_c_ {
      struct setup_s_ {
        // member variables
        mbsfn_sf_cfg_list_l sf_cfg_list;
      };
      typedef setup_e types;

      // choice methods
      mbsfn_sf_cfg_list_r11_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-r11");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-r11");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };
    struct pdsch_start_r11_opts {
      enum options { reserved, n1, n2, n3, n4, assigned, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<pdsch_start_r11_opts> pdsch_start_r11_e_;

    // member variables
    bool                     mbsfn_sf_cfg_list_r11_present = false;
    crs_ports_count_r11_e_   crs_ports_count_r11;
    uint8_t                  crs_freq_shift_r11 = 0;
    mbsfn_sf_cfg_list_r11_c_ mbsfn_sf_cfg_list_r11;
    pdsch_start_r11_e_       pdsch_start_r11;
  };
  struct mbsfn_sf_cfg_list_v1430_c_ {
    struct setup_s_ {
      // member variables
      mbsfn_sf_cfg_list_v1430_l sf_cfg_list_v1430;
    };
    typedef setup_e types;

    // choice methods
    mbsfn_sf_cfg_list_v1430_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-v1430");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-v1430");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct codeword_one_cfg_v1530_c_ {
    struct setup_s_ {
      struct crs_ports_count_v1530_opts {
        enum options { n1, n2, n4, spare1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<crs_ports_count_v1530_opts> crs_ports_count_v1530_e_;
      struct pdsch_start_v1530_opts {
        enum options { reserved, n1, n2, n3, n4, assigned, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<pdsch_start_v1530_opts> pdsch_start_v1530_e_;

      // member variables
      bool                      mbsfn_sf_cfg_list_v1530_present     = false;
      bool                      mbsfn_sf_cfg_list_ext_v1530_present = false;
      bool                      qcl_csi_rs_cfg_nzp_id_v1530_present = false;
      crs_ports_count_v1530_e_  crs_ports_count_v1530;
      uint8_t                   crs_freq_shift_v1530 = 0;
      mbsfn_sf_cfg_list_l       mbsfn_sf_cfg_list_v1530;
      mbsfn_sf_cfg_list_v1430_l mbsfn_sf_cfg_list_ext_v1530;
      pdsch_start_v1530_e_      pdsch_start_v1530;
      uint8_t                   csi_rs_cfg_zp_id_v1530      = 1;
      uint8_t                   qcl_csi_rs_cfg_nzp_id_v1530 = 1;
    };
    typedef setup_e types;

    // choice methods
    codeword_one_cfg_v1530_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "codewordOneConfig-v1530");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "codewordOneConfig-v1530");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                          ext                                = false;
  bool                          optional_set_of_fields_r11_present = false;
  bool                          qcl_csi_rs_cfg_nzp_id_r11_present  = false;
  uint8_t                       pdsch_re_map_qcl_cfg_id_r11        = 1;
  optional_set_of_fields_r11_s_ optional_set_of_fields_r11;
  uint8_t                       csi_rs_cfg_zp_id_r11      = 1;
  uint8_t                       qcl_csi_rs_cfg_nzp_id_r11 = 1;
  // ...
  // group 0
  bool                                 mbsfn_sf_cfg_list_v1430_present = false;
  copy_ptr<mbsfn_sf_cfg_list_v1430_c_> mbsfn_sf_cfg_list_v1430;
  // group 1
  bool                                codeword_one_cfg_v1530_present = false;
  copy_ptr<codeword_one_cfg_v1530_c_> codeword_one_cfg_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PollPDU-v1310 ::= ENUMERATED
struct poll_pdu_v1310_opts {
  enum options { p512, p1024, p2048, p4096, p6144, p8192, p12288, p16384, nulltype } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<poll_pdu_v1310_opts> poll_pdu_v1310_e;

// RLC-Config-r15 ::= SEQUENCE
struct rlc_cfg_r15_s {
  struct mode_r15_c_ {
    struct am_r15_s_ {
      // member variables
      ul_am_rlc_r15_s ul_am_rlc_r15;
      dl_am_rlc_r15_s dl_am_rlc_r15;
    };
    struct um_bi_dir_r15_s_ {
      // member variables
      ul_um_rlc_s     ul_um_rlc_r15;
      dl_um_rlc_r15_s dl_um_rlc_r15;
    };
    struct um_uni_dir_ul_r15_s_ {
      // member variables
      ul_um_rlc_s ul_um_rlc_r15;
    };
    struct um_uni_dir_dl_r15_s_ {
      // member variables
      dl_um_rlc_r15_s dl_um_rlc_r15;
    };
    struct types_opts {
      enum options { am_r15, um_bi_dir_r15, um_uni_dir_ul_r15, um_uni_dir_dl_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    mode_r15_c_() = default;
    mode_r15_c_(const mode_r15_c_& other);
    mode_r15_c_& operator=(const mode_r15_c_& other);
    ~mode_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    am_r15_s_& am_r15()
    {
      assert_choice_type("am-r15", type_.to_string(), "mode-r15");
      return c.get<am_r15_s_>();
    }
    um_bi_dir_r15_s_& um_bi_dir_r15()
    {
      assert_choice_type("um-Bi-Directional-r15", type_.to_string(), "mode-r15");
      return c.get<um_bi_dir_r15_s_>();
    }
    um_uni_dir_ul_r15_s_& um_uni_dir_ul_r15()
    {
      assert_choice_type("um-Uni-Directional-UL-r15", type_.to_string(), "mode-r15");
      return c.get<um_uni_dir_ul_r15_s_>();
    }
    um_uni_dir_dl_r15_s_& um_uni_dir_dl_r15()
    {
      assert_choice_type("um-Uni-Directional-DL-r15", type_.to_string(), "mode-r15");
      return c.get<um_uni_dir_dl_r15_s_>();
    }
    const am_r15_s_& am_r15() const
    {
      assert_choice_type("am-r15", type_.to_string(), "mode-r15");
      return c.get<am_r15_s_>();
    }
    const um_bi_dir_r15_s_& um_bi_dir_r15() const
    {
      assert_choice_type("um-Bi-Directional-r15", type_.to_string(), "mode-r15");
      return c.get<um_bi_dir_r15_s_>();
    }
    const um_uni_dir_ul_r15_s_& um_uni_dir_ul_r15() const
    {
      assert_choice_type("um-Uni-Directional-UL-r15", type_.to_string(), "mode-r15");
      return c.get<um_uni_dir_ul_r15_s_>();
    }
    const um_uni_dir_dl_r15_s_& um_uni_dir_dl_r15() const
    {
      assert_choice_type("um-Uni-Directional-DL-r15", type_.to_string(), "mode-r15");
      return c.get<um_uni_dir_dl_r15_s_>();
    }
    am_r15_s_& set_am_r15()
    {
      set(types::am_r15);
      return c.get<am_r15_s_>();
    }
    um_bi_dir_r15_s_& set_um_bi_dir_r15()
    {
      set(types::um_bi_dir_r15);
      return c.get<um_bi_dir_r15_s_>();
    }
    um_uni_dir_ul_r15_s_& set_um_uni_dir_ul_r15()
    {
      set(types::um_uni_dir_ul_r15);
      return c.get<um_uni_dir_ul_r15_s_>();
    }
    um_uni_dir_dl_r15_s_& set_um_uni_dir_dl_r15()
    {
      set(types::um_uni_dir_dl_r15);
      return c.get<um_uni_dir_dl_r15_s_>();
    }

  private:
    types type_;
    choice_buffer_t<MAX4(
        sizeof(am_r15_s_), sizeof(um_bi_dir_r15_s_), sizeof(um_uni_dir_dl_r15_s_), sizeof(um_uni_dir_ul_r15_s_))>
        c;

    void destroy_();
  };

  // member variables
  bool        ext                                   = false;
  bool        reestablish_rlc_r15_present           = false;
  bool        rlc_out_of_order_delivery_r15_present = false;
  mode_r15_c_ mode_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SPDCCH-Set-r15 ::= SEQUENCE (SIZE (1..4)) OF SPDCCH-Elements-r15
typedef dyn_array<spdcch_elems_r15_c> spdcch_set_r15_l;

// SPUCCH-Set-r15 ::= SEQUENCE (SIZE (1..4)) OF SPUCCH-Elements-r15
typedef dyn_array<spucch_elems_r15_c> spucch_set_r15_l;

// SR-SubslotSPUCCH-ResourceList-r15 ::= SEQUENCE (SIZE(1..4)) OF INTEGER
typedef bounded_array<uint16_t, 4> sr_subslot_spucch_res_list_r15_l;

// SRS-AntennaPort ::= ENUMERATED
struct srs_ant_port_opts {
  enum options { an1, an2, an4, spare1, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<srs_ant_port_opts> srs_ant_port_e;

// ShortTTI-Length-r15 ::= ENUMERATED
struct short_tti_len_r15_opts {
  enum options { slot, subslot, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<short_tti_len_r15_opts> short_tti_len_r15_e;

// TPC-PDCCH-Config ::= CHOICE
struct tpc_pdcch_cfg_c {
  struct setup_s_ {
    // member variables
    fixed_bitstring<16> tpc_rnti;
    tpc_idx_c           tpc_idx;
  };
  typedef setup_e types;

  // choice methods
  tpc_pdcch_cfg_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "TPC-PDCCH-Config");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "TPC-PDCCH-Config");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// UL-AM-RLC ::= SEQUENCE
struct ul_am_rlc_s {
  struct max_retx_thres_opts {
    enum options { t1, t2, t3, t4, t6, t8, t16, t32, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<max_retx_thres_opts> max_retx_thres_e_;

  // member variables
  t_poll_retx_e     t_poll_retx;
  poll_pdu_e        poll_pdu;
  poll_byte_e       poll_byte;
  max_retx_thres_e_ max_retx_thres;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoDedicatedSTTI-r15 ::= CHOICE
struct ant_info_ded_stti_r15_c {
  struct setup_s_ {
    struct tx_mode_dl_mbsfn_r15_opts {
      enum options { tm9, tm10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tx_mode_dl_mbsfn_r15_opts> tx_mode_dl_mbsfn_r15_e_;
    struct tx_mode_dl_non_mbsfn_r15_opts {
      enum options { tm1, tm2, tm3, tm4, tm6, tm8, tm9, tm10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tx_mode_dl_non_mbsfn_r15_opts> tx_mode_dl_non_mbsfn_r15_e_;
    struct codebook_subset_restrict_c_ {
      struct types_opts {
        enum options {
          n2_tx_ant_tm3_r15,
          n4_tx_ant_tm3_r15,
          n2_tx_ant_tm4_r15,
          n4_tx_ant_tm4_r15,
          n2_tx_ant_tm5_r15,
          n4_tx_ant_tm5_r15,
          n2_tx_ant_tm6_r15,
          n4_tx_ant_tm6_r15,
          n2_tx_ant_tm8_r15,
          n4_tx_ant_tm8_r15,
          n2_tx_ant_tm9and10_r15,
          n4_tx_ant_tm9and10_r15,
          n8_tx_ant_tm9and10_r15,
          nulltype
        } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      codebook_subset_restrict_c_() = default;
      codebook_subset_restrict_c_(const codebook_subset_restrict_c_& other);
      codebook_subset_restrict_c_& operator=(const codebook_subset_restrict_c_& other);
      ~codebook_subset_restrict_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      fixed_bitstring<2>& n2_tx_ant_tm3_r15()
      {
        assert_choice_type("n2TxAntenna-tm3-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<2> >();
      }
      fixed_bitstring<4>& n4_tx_ant_tm3_r15()
      {
        assert_choice_type("n4TxAntenna-tm3-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<4> >();
      }
      fixed_bitstring<6>& n2_tx_ant_tm4_r15()
      {
        assert_choice_type("n2TxAntenna-tm4-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<6> >();
      }
      fixed_bitstring<64>& n4_tx_ant_tm4_r15()
      {
        assert_choice_type("n4TxAntenna-tm4-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<64> >();
      }
      fixed_bitstring<4>& n2_tx_ant_tm5_r15()
      {
        assert_choice_type("n2TxAntenna-tm5-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<4> >();
      }
      fixed_bitstring<16>& n4_tx_ant_tm5_r15()
      {
        assert_choice_type("n4TxAntenna-tm5-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<16> >();
      }
      fixed_bitstring<4>& n2_tx_ant_tm6_r15()
      {
        assert_choice_type("n2TxAntenna-tm6-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<4> >();
      }
      fixed_bitstring<16>& n4_tx_ant_tm6_r15()
      {
        assert_choice_type("n4TxAntenna-tm6-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<16> >();
      }
      fixed_bitstring<6>& n2_tx_ant_tm8_r15()
      {
        assert_choice_type("n2TxAntenna-tm8-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<6> >();
      }
      fixed_bitstring<64>& n4_tx_ant_tm8_r15()
      {
        assert_choice_type("n4TxAntenna-tm8-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<64> >();
      }
      fixed_bitstring<6>& n2_tx_ant_tm9and10_r15()
      {
        assert_choice_type("n2TxAntenna-tm9and10-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<6> >();
      }
      fixed_bitstring<96>& n4_tx_ant_tm9and10_r15()
      {
        assert_choice_type("n4TxAntenna-tm9and10-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<96> >();
      }
      fixed_bitstring<109>& n8_tx_ant_tm9and10_r15()
      {
        assert_choice_type("n8TxAntenna-tm9and10-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<109> >();
      }
      const fixed_bitstring<2>& n2_tx_ant_tm3_r15() const
      {
        assert_choice_type("n2TxAntenna-tm3-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<2> >();
      }
      const fixed_bitstring<4>& n4_tx_ant_tm3_r15() const
      {
        assert_choice_type("n4TxAntenna-tm3-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<4> >();
      }
      const fixed_bitstring<6>& n2_tx_ant_tm4_r15() const
      {
        assert_choice_type("n2TxAntenna-tm4-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<6> >();
      }
      const fixed_bitstring<64>& n4_tx_ant_tm4_r15() const
      {
        assert_choice_type("n4TxAntenna-tm4-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<64> >();
      }
      const fixed_bitstring<4>& n2_tx_ant_tm5_r15() const
      {
        assert_choice_type("n2TxAntenna-tm5-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<4> >();
      }
      const fixed_bitstring<16>& n4_tx_ant_tm5_r15() const
      {
        assert_choice_type("n4TxAntenna-tm5-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<16> >();
      }
      const fixed_bitstring<4>& n2_tx_ant_tm6_r15() const
      {
        assert_choice_type("n2TxAntenna-tm6-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<4> >();
      }
      const fixed_bitstring<16>& n4_tx_ant_tm6_r15() const
      {
        assert_choice_type("n4TxAntenna-tm6-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<16> >();
      }
      const fixed_bitstring<6>& n2_tx_ant_tm8_r15() const
      {
        assert_choice_type("n2TxAntenna-tm8-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<6> >();
      }
      const fixed_bitstring<64>& n4_tx_ant_tm8_r15() const
      {
        assert_choice_type("n4TxAntenna-tm8-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<64> >();
      }
      const fixed_bitstring<6>& n2_tx_ant_tm9and10_r15() const
      {
        assert_choice_type("n2TxAntenna-tm9and10-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<6> >();
      }
      const fixed_bitstring<96>& n4_tx_ant_tm9and10_r15() const
      {
        assert_choice_type("n4TxAntenna-tm9and10-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<96> >();
      }
      const fixed_bitstring<109>& n8_tx_ant_tm9and10_r15() const
      {
        assert_choice_type("n8TxAntenna-tm9and10-r15", type_.to_string(), "codebookSubsetRestriction");
        return c.get<fixed_bitstring<109> >();
      }
      fixed_bitstring<2>& set_n2_tx_ant_tm3_r15()
      {
        set(types::n2_tx_ant_tm3_r15);
        return c.get<fixed_bitstring<2> >();
      }
      fixed_bitstring<4>& set_n4_tx_ant_tm3_r15()
      {
        set(types::n4_tx_ant_tm3_r15);
        return c.get<fixed_bitstring<4> >();
      }
      fixed_bitstring<6>& set_n2_tx_ant_tm4_r15()
      {
        set(types::n2_tx_ant_tm4_r15);
        return c.get<fixed_bitstring<6> >();
      }
      fixed_bitstring<64>& set_n4_tx_ant_tm4_r15()
      {
        set(types::n4_tx_ant_tm4_r15);
        return c.get<fixed_bitstring<64> >();
      }
      fixed_bitstring<4>& set_n2_tx_ant_tm5_r15()
      {
        set(types::n2_tx_ant_tm5_r15);
        return c.get<fixed_bitstring<4> >();
      }
      fixed_bitstring<16>& set_n4_tx_ant_tm5_r15()
      {
        set(types::n4_tx_ant_tm5_r15);
        return c.get<fixed_bitstring<16> >();
      }
      fixed_bitstring<4>& set_n2_tx_ant_tm6_r15()
      {
        set(types::n2_tx_ant_tm6_r15);
        return c.get<fixed_bitstring<4> >();
      }
      fixed_bitstring<16>& set_n4_tx_ant_tm6_r15()
      {
        set(types::n4_tx_ant_tm6_r15);
        return c.get<fixed_bitstring<16> >();
      }
      fixed_bitstring<6>& set_n2_tx_ant_tm8_r15()
      {
        set(types::n2_tx_ant_tm8_r15);
        return c.get<fixed_bitstring<6> >();
      }
      fixed_bitstring<64>& set_n4_tx_ant_tm8_r15()
      {
        set(types::n4_tx_ant_tm8_r15);
        return c.get<fixed_bitstring<64> >();
      }
      fixed_bitstring<6>& set_n2_tx_ant_tm9and10_r15()
      {
        set(types::n2_tx_ant_tm9and10_r15);
        return c.get<fixed_bitstring<6> >();
      }
      fixed_bitstring<96>& set_n4_tx_ant_tm9and10_r15()
      {
        set(types::n4_tx_ant_tm9and10_r15);
        return c.get<fixed_bitstring<96> >();
      }
      fixed_bitstring<109>& set_n8_tx_ant_tm9and10_r15()
      {
        set(types::n8_tx_ant_tm9and10_r15);
        return c.get<fixed_bitstring<109> >();
      }

    private:
      types                                         type_;
      choice_buffer_t<sizeof(fixed_bitstring<109>)> c;

      void destroy_();
    };
    struct max_layers_mimo_stti_r15_opts {
      enum options { two_layers, four_layers, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<max_layers_mimo_stti_r15_opts> max_layers_mimo_stti_r15_e_;

    // member variables
    bool                        tx_mode_dl_mbsfn_r15_present     = false;
    bool                        tx_mode_dl_non_mbsfn_r15_present = false;
    bool                        codebook_subset_restrict_present = false;
    bool                        max_layers_mimo_stti_r15_present = false;
    tx_mode_dl_mbsfn_r15_e_     tx_mode_dl_mbsfn_r15;
    tx_mode_dl_non_mbsfn_r15_e_ tx_mode_dl_non_mbsfn_r15;
    codebook_subset_restrict_c_ codebook_subset_restrict;
    max_layers_mimo_stti_r15_e_ max_layers_mimo_stti_r15;
    bool                        slot_subslot_pdsch_tx_div_minus2_layer_r15 = false;
    bool                        slot_subslot_pdsch_tx_div_minus4_layer_r15 = false;
  };
  typedef setup_e types;

  // choice methods
  ant_info_ded_stti_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "AntennaInfoDedicatedSTTI-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "AntennaInfoDedicatedSTTI-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// AntennaInfoUL-STTI-r15 ::= SEQUENCE
struct ant_info_ul_stti_r15_s {
  struct tx_mode_ul_stti_r15_opts {
    enum options { tm1, tm2, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<tx_mode_ul_stti_r15_opts> tx_mode_ul_stti_r15_e_;

  // member variables
  bool                   tx_mode_ul_stti_r15_present = false;
  tx_mode_ul_stti_r15_e_ tx_mode_ul_stti_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-r15 ::= CHOICE
struct cqi_report_cfg_r15_c {
  struct setup_s_ {
    struct alt_cqi_table_minus1024_qam_r15_opts {
      enum options { all_sfs, csi_sf_set1, csi_sf_set2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<alt_cqi_table_minus1024_qam_r15_opts> alt_cqi_table_minus1024_qam_r15_e_;

    // member variables
    bool                               cqi_report_cfg_r10_present              = false;
    bool                               cqi_report_cfg_v1130_present            = false;
    bool                               cqi_report_cfg_pcell_v1250_present      = false;
    bool                               cqi_report_cfg_v1310_present            = false;
    bool                               cqi_report_cfg_v1320_present            = false;
    bool                               cqi_report_cfg_v1430_present            = false;
    bool                               alt_cqi_table_minus1024_qam_r15_present = false;
    cqi_report_cfg_r10_s               cqi_report_cfg_r10;
    cqi_report_cfg_v1130_s             cqi_report_cfg_v1130;
    cqi_report_cfg_v1250_s             cqi_report_cfg_pcell_v1250;
    cqi_report_cfg_v1310_s             cqi_report_cfg_v1310;
    cqi_report_cfg_v1320_s             cqi_report_cfg_v1320;
    cqi_report_cfg_v1430_s             cqi_report_cfg_v1430;
    alt_cqi_table_minus1024_qam_r15_e_ alt_cqi_table_minus1024_qam_r15;
  };
  typedef setup_e types;

  // choice methods
  cqi_report_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportConfig-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportConfig-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CQI-ReportPeriodic ::= CHOICE
struct cqi_report_periodic_c {
  struct setup_s_ {
    struct cqi_format_ind_periodic_c_ {
      struct subband_cqi_s_ {
        // member variables
        uint8_t k = 1;
      };
      struct types_opts {
        enum options { wideband_cqi, subband_cqi, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      cqi_format_ind_periodic_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      subband_cqi_s_& subband_cqi()
      {
        assert_choice_type("subbandCQI", type_.to_string(), "cqi-FormatIndicatorPeriodic");
        return c;
      }
      const subband_cqi_s_& subband_cqi() const
      {
        assert_choice_type("subbandCQI", type_.to_string(), "cqi-FormatIndicatorPeriodic");
        return c;
      }
      subband_cqi_s_& set_subband_cqi()
      {
        set(types::subband_cqi);
        return c;
      }

    private:
      types          type_;
      subband_cqi_s_ c;
    };

    // member variables
    bool                       ri_cfg_idx_present = false;
    uint16_t                   cqi_pucch_res_idx  = 0;
    uint16_t                   cqi_pmi_cfg_idx    = 0;
    cqi_format_ind_periodic_c_ cqi_format_ind_periodic;
    uint16_t                   ri_cfg_idx             = 0;
    bool                       simul_ack_nack_and_cqi = false;
  };
  typedef setup_e types;

  // choice methods
  cqi_report_periodic_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportPeriodic");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportPeriodic");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CRS-AssistanceInfo-r11 ::= SEQUENCE
struct crs_assist_info_r11_s {
  struct ant_ports_count_r11_opts {
    enum options { an1, an2, an4, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ant_ports_count_r11_opts> ant_ports_count_r11_e_;

  // member variables
  bool                   ext     = false;
  uint16_t               pci_r11 = 0;
  ant_ports_count_r11_e_ ant_ports_count_r11;
  mbsfn_sf_cfg_list_l    mbsfn_sf_cfg_list_r11;
  // ...
  // group 0
  bool                                mbsfn_sf_cfg_list_v1430_present = false;
  copy_ptr<mbsfn_sf_cfg_list_v1430_l> mbsfn_sf_cfg_list_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CRS-AssistanceInfo-r13 ::= SEQUENCE
struct crs_assist_info_r13_s {
  struct ant_ports_count_r13_opts {
    enum options { an1, an2, an4, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ant_ports_count_r13_opts> ant_ports_count_r13_e_;

  // member variables
  bool                   ext                           = false;
  bool                   mbsfn_sf_cfg_list_r13_present = false;
  uint16_t               pci_r13                       = 0;
  ant_ports_count_r13_e_ ant_ports_count_r13;
  mbsfn_sf_cfg_list_l    mbsfn_sf_cfg_list_r13;
  // ...
  // group 0
  bool                                mbsfn_sf_cfg_list_v1430_present = false;
  copy_ptr<mbsfn_sf_cfg_list_v1430_l> mbsfn_sf_cfg_list_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CRS-AssistanceInfo-r15 ::= SEQUENCE
struct crs_assist_info_r15_s {
  // member variables
  bool     crs_intf_mitig_enabled_minus15_present = false;
  uint16_t pci_r15                                = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-Config-r15 ::= CHOICE
struct csi_rs_cfg_r15_c {
  struct setup_s_ {
    // member variables
    bool               csi_rs_cfg_r10_present   = false;
    bool               csi_rs_cfg_v1250_present = false;
    bool               csi_rs_cfg_v1310_present = false;
    bool               csi_rs_cfg_v1430_present = false;
    csi_rs_cfg_r10_s   csi_rs_cfg_r10;
    csi_rs_cfg_v1250_s csi_rs_cfg_v1250;
    csi_rs_cfg_v1310_s csi_rs_cfg_v1310;
    csi_rs_cfg_v1430_s csi_rs_cfg_v1430;
  };
  typedef setup_e types;

  // choice methods
  csi_rs_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-Config-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-Config-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CSI-RS-ConfigNZPToAddModList-r15 ::= SEQUENCE (SIZE (1..maxCSI-RS-NZP-r13)) OF CSI-RS-ConfigNZP-r11
typedef dyn_array<csi_rs_cfg_nzp_r11_s> csi_rs_cfg_nzp_to_add_mod_list_r15_l;

// CSI-RS-ConfigNZPToReleaseList-r15 ::= SEQUENCE (SIZE (1..maxCSI-RS-NZP-r13)) OF INTEGER
typedef bounded_array<uint8_t, 24> csi_rs_cfg_nzp_to_release_list_r15_l;

// CSI-RS-ConfigZP-ApList-r14 ::= CHOICE
struct csi_rs_cfg_zp_ap_list_r14_c {
  typedef dyn_array<csi_rs_cfg_zp_r11_s> setup_l_;
  typedef setup_e                        types;

  // choice methods
  csi_rs_cfg_zp_ap_list_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_l_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigZP-ApList-r14");
    return c;
  }
  const setup_l_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CSI-RS-ConfigZP-ApList-r14");
    return c;
  }
  setup_l_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_l_ c;
};

// CSI-RS-ConfigZPToAddModList-r11 ::= SEQUENCE (SIZE (1..maxCSI-RS-ZP-r11)) OF CSI-RS-ConfigZP-r11
typedef dyn_array<csi_rs_cfg_zp_r11_s> csi_rs_cfg_zp_to_add_mod_list_r11_l;

// CSI-RS-ConfigZPToReleaseList-r11 ::= SEQUENCE (SIZE (1..maxCSI-RS-ZP-r11)) OF INTEGER
typedef bounded_array<uint8_t, 4> csi_rs_cfg_zp_to_release_list_r11_l;

// DMRS-Config-r11 ::= CHOICE
struct dmrs_cfg_r11_c {
  struct setup_s_ {
    // member variables
    uint16_t scrambling_id_r11  = 0;
    uint16_t scrambling_id2_r11 = 0;
  };
  typedef setup_e types;

  // choice methods
  dmrs_cfg_r11_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "DMRS-Config-r11");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "DMRS-Config-r11");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// DMRS-Config-v1310 ::= SEQUENCE
struct dmrs_cfg_v1310_s {
  // member variables
  bool dmrs_table_alt_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DeltaTxD-OffsetListPUCCH-r10 ::= SEQUENCE
struct delta_tx_d_offset_list_pucch_r10_s {
  struct delta_tx_d_offset_pucch_format1_r10_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_pucch_format1_r10_opts> delta_tx_d_offset_pucch_format1_r10_e_;
  struct delta_tx_d_offset_pucch_format1a1b_r10_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_pucch_format1a1b_r10_opts> delta_tx_d_offset_pucch_format1a1b_r10_e_;
  struct delta_tx_d_offset_pucch_format22a2b_r10_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_pucch_format22a2b_r10_opts> delta_tx_d_offset_pucch_format22a2b_r10_e_;
  struct delta_tx_d_offset_pucch_format3_r10_opts {
    enum options { db0, db_minus2, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_pucch_format3_r10_opts> delta_tx_d_offset_pucch_format3_r10_e_;

  // member variables
  bool                                       ext = false;
  delta_tx_d_offset_pucch_format1_r10_e_     delta_tx_d_offset_pucch_format1_r10;
  delta_tx_d_offset_pucch_format1a1b_r10_e_  delta_tx_d_offset_pucch_format1a1b_r10;
  delta_tx_d_offset_pucch_format22a2b_r10_e_ delta_tx_d_offset_pucch_format22a2b_r10;
  delta_tx_d_offset_pucch_format3_r10_e_     delta_tx_d_offset_pucch_format3_r10;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DeltaTxD-OffsetListPUCCH-v1130 ::= SEQUENCE
struct delta_tx_d_offset_list_pucch_v1130_s {
  struct delta_tx_d_offset_pucch_format1b_cs_r11_opts {
    enum options { db0, db_minus1, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_tx_d_offset_pucch_format1b_cs_r11_opts> delta_tx_d_offset_pucch_format1b_cs_r11_e_;

  // member variables
  delta_tx_d_offset_pucch_format1b_cs_r11_e_ delta_tx_d_offset_pucch_format1b_cs_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EIMTA-MainConfig-r12 ::= CHOICE
struct eimta_main_cfg_r12_c {
  struct setup_s_ {
    struct eimta_cmd_periodicity_r12_opts {
      enum options { sf10, sf20, sf40, sf80, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<eimta_cmd_periodicity_r12_opts> eimta_cmd_periodicity_r12_e_;

    // member variables
    fixed_bitstring<16>          eimta_rnti_r12;
    eimta_cmd_periodicity_r12_e_ eimta_cmd_periodicity_r12;
    fixed_bitstring<10>          eimta_cmd_sf_set_r12;
  };
  typedef setup_e types;

  // choice methods
  eimta_main_cfg_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "EIMTA-MainConfig-r12");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "EIMTA-MainConfig-r12");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// EIMTA-MainConfigServCell-r12 ::= CHOICE
struct eimta_main_cfg_serv_cell_r12_c {
  struct setup_s_ {
    struct eimta_harq_ref_cfg_r12_opts {
      enum options { sa2, sa4, sa5, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<eimta_harq_ref_cfg_r12_opts> eimta_harq_ref_cfg_r12_e_;
    struct mbsfn_sf_cfg_list_v1250_c_ {
      struct setup_s_ {
        // member variables
        mbsfn_sf_cfg_list_l sf_cfg_list_r12;
      };
      typedef setup_e types;

      // choice methods
      mbsfn_sf_cfg_list_v1250_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-v1250");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "mbsfn-SubframeConfigList-v1250");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    uint8_t                    eimta_ul_dl_cfg_idx_r12 = 1;
    eimta_harq_ref_cfg_r12_e_  eimta_harq_ref_cfg_r12;
    mbsfn_sf_cfg_list_v1250_c_ mbsfn_sf_cfg_list_v1250;
  };
  typedef setup_e types;

  // choice methods
  eimta_main_cfg_serv_cell_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "EIMTA-MainConfigServCell-r12");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "EIMTA-MainConfigServCell-r12");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// EPDCCH-SetConfigToAddModList-r11 ::= SEQUENCE (SIZE(1..maxEPDCCH-Set-r11)) OF EPDCCH-SetConfig-r11
typedef dyn_array<epdcch_set_cfg_r11_s> epdcch_set_cfg_to_add_mod_list_r11_l;

// EPDCCH-SetConfigToReleaseList-r11 ::= SEQUENCE (SIZE(1..maxEPDCCH-Set-r11)) OF INTEGER
typedef bounded_array<uint8_t, 2> epdcch_set_cfg_to_release_list_r11_l;

// Format4-resource-r13 ::= SEQUENCE
struct format4_res_r13_s {
  // member variables
  uint8_t start_prb_format4_r13 = 0;
  uint8_t nof_prb_format4_r13   = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Format5-resource-r13 ::= SEQUENCE
struct format5_res_r13_s {
  // member variables
  uint8_t start_prb_format5_r13 = 0;
  uint8_t cdm_idx_format5_r13   = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// N1PUCCH-AN-CS-r10 ::= SEQUENCE (SIZE (1..4)) OF INTEGER
typedef bounded_array<uint16_t, 4> n1_pucch_an_cs_r10_l;

// N1PUCCH-AN-PersistentList ::= SEQUENCE (SIZE (1..4)) OF INTEGER
typedef bounded_array<uint16_t, 4> n1_pucch_an_persistent_list_l;

// NeighCellsInfo-r12 ::= SEQUENCE
struct neigh_cells_info_r12_s {
  struct crs_ports_count_r12_opts {
    enum options { n1, n2, n4, spare, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<crs_ports_count_r12_opts> crs_ports_count_r12_e_;
  typedef bounded_array<p_a_e, 3>              p_a_list_r12_l_;

  // member variables
  bool                   ext                      = false;
  bool                   mbsfn_sf_cfg_r12_present = false;
  uint16_t               pci_r12                  = 0;
  uint8_t                p_b_r12                  = 0;
  crs_ports_count_r12_e_ crs_ports_count_r12;
  mbsfn_sf_cfg_list_l    mbsfn_sf_cfg_r12;
  p_a_list_r12_l_        p_a_list_r12;
  fixed_bitstring<8>     tx_mode_list_r12;
  uint8_t                res_alloc_granularity_r12 = 1;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCCH-CandidateReductionValue-r13 ::= ENUMERATED
struct pdcch_candidate_reduction_value_r13_opts {
  enum options { n0, n33, n66, n100, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<pdcch_candidate_reduction_value_r13_opts> pdcch_candidate_reduction_value_r13_e;

// PDCP-Config ::= SEQUENCE
struct pdcp_cfg_s {
  struct discard_timer_opts {
    enum options { ms50, ms100, ms150, ms300, ms500, ms750, ms1500, infinity, nulltype } value;
    typedef int16_t number_type;

    std::string to_string() const;
    int16_t     to_number() const;
  };
  typedef enumerated<discard_timer_opts> discard_timer_e_;
  struct rlc_am_s_ {
    // member variables
    bool status_report_required = false;
  };
  struct rlc_um_s_ {
    struct pdcp_sn_size_opts {
      enum options { len7bits, len12bits, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<pdcp_sn_size_opts> pdcp_sn_size_e_;

    // member variables
    pdcp_sn_size_e_ pdcp_sn_size;
  };
  struct hdr_compress_c_ {
    struct rohc_s_ {
      struct profiles_s_ {
        // member variables
        bool profile0x0001 = false;
        bool profile0x0002 = false;
        bool profile0x0003 = false;
        bool profile0x0004 = false;
        bool profile0x0006 = false;
        bool profile0x0101 = false;
        bool profile0x0102 = false;
        bool profile0x0103 = false;
        bool profile0x0104 = false;
      };

      // member variables
      bool        ext             = false;
      bool        max_cid_present = false;
      uint16_t    max_cid         = 1;
      profiles_s_ profiles;
      // ...
    };
    struct types_opts {
      enum options { not_used, rohc, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    hdr_compress_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rohc_s_& rohc()
    {
      assert_choice_type("rohc", type_.to_string(), "headerCompression");
      return c;
    }
    const rohc_s_& rohc() const
    {
      assert_choice_type("rohc", type_.to_string(), "headerCompression");
      return c;
    }
    rohc_s_& set_rohc()
    {
      set(types::rohc);
      return c;
    }

  private:
    types   type_;
    rohc_s_ c;
  };
  struct t_reordering_r12_opts {
    enum options {
      ms0,
      ms20,
      ms40,
      ms60,
      ms80,
      ms100,
      ms120,
      ms140,
      ms160,
      ms180,
      ms200,
      ms220,
      ms240,
      ms260,
      ms280,
      ms300,
      ms500,
      ms750,
      spare14,
      spare13,
      spare12,
      spare11,
      spare10,
      spare9,
      spare8,
      spare7,
      spare6,
      spare5,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t_reordering_r12_opts> t_reordering_r12_e_;
  struct ul_data_split_thres_r13_c_ {
    struct setup_opts {
      enum options {
        b0,
        b100,
        b200,
        b400,
        b800,
        b1600,
        b3200,
        b6400,
        b12800,
        b25600,
        b51200,
        b102400,
        b204800,
        b409600,
        b819200,
        spare1,
        nulltype
      } value;
      typedef uint32_t number_type;

      std::string to_string() const;
      uint32_t    to_number() const;
    };
    typedef enumerated<setup_opts> setup_e_;
    typedef setup_e                types;

    // choice methods
    ul_data_split_thres_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_e_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ul-DataSplitThreshold-r13");
      return c;
    }
    const setup_e_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ul-DataSplitThreshold-r13");
      return c;
    }
    setup_e_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_e_ c;
  };
  struct status_feedback_r13_c_ {
    struct setup_s_ {
      struct status_pdu_type_for_polling_r13_opts {
        enum options { type1, type2, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<status_pdu_type_for_polling_r13_opts> status_pdu_type_for_polling_r13_e_;
      struct status_pdu_periodicity_type1_r13_opts {
        enum options {
          ms5,
          ms10,
          ms20,
          ms30,
          ms40,
          ms50,
          ms60,
          ms70,
          ms80,
          ms90,
          ms100,
          ms150,
          ms200,
          ms300,
          ms500,
          ms1000,
          ms2000,
          ms5000,
          ms10000,
          ms20000,
          ms50000,
          nulltype
        } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<status_pdu_periodicity_type1_r13_opts> status_pdu_periodicity_type1_r13_e_;
      struct status_pdu_periodicity_type2_r13_opts {
        enum options {
          ms5,
          ms10,
          ms20,
          ms30,
          ms40,
          ms50,
          ms60,
          ms70,
          ms80,
          ms90,
          ms100,
          ms150,
          ms200,
          ms300,
          ms500,
          ms1000,
          ms2000,
          ms5000,
          ms10000,
          ms20000,
          ms50000,
          nulltype
        } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<status_pdu_periodicity_type2_r13_opts> status_pdu_periodicity_type2_r13_e_;
      struct status_pdu_periodicity_offset_r13_opts {
        enum options { ms1, ms2, ms5, ms10, ms25, ms50, ms100, ms250, ms500, ms2500, ms5000, ms25000, nulltype } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<status_pdu_periodicity_offset_r13_opts> status_pdu_periodicity_offset_r13_e_;

      // member variables
      bool                                 status_pdu_type_for_polling_r13_present   = false;
      bool                                 status_pdu_periodicity_type1_r13_present  = false;
      bool                                 status_pdu_periodicity_type2_r13_present  = false;
      bool                                 status_pdu_periodicity_offset_r13_present = false;
      status_pdu_type_for_polling_r13_e_   status_pdu_type_for_polling_r13;
      status_pdu_periodicity_type1_r13_e_  status_pdu_periodicity_type1_r13;
      status_pdu_periodicity_type2_r13_e_  status_pdu_periodicity_type2_r13;
      status_pdu_periodicity_offset_r13_e_ status_pdu_periodicity_offset_r13;
    };
    typedef setup_e types;

    // choice methods
    status_feedback_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "statusFeedback-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "statusFeedback-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct ul_lwa_cfg_r14_c_ {
    struct setup_s_ {
      struct ul_lwa_data_split_thres_r14_opts {
        enum options {
          b0,
          b100,
          b200,
          b400,
          b800,
          b1600,
          b3200,
          b6400,
          b12800,
          b25600,
          b51200,
          b102400,
          b204800,
          b409600,
          b819200,
          nulltype
        } value;
        typedef uint32_t number_type;

        std::string to_string() const;
        uint32_t    to_number() const;
      };
      typedef enumerated<ul_lwa_data_split_thres_r14_opts> ul_lwa_data_split_thres_r14_e_;

      // member variables
      bool                           ul_lwa_data_split_thres_r14_present = false;
      bool                           ul_lwa_drb_via_wlan_r14             = false;
      ul_lwa_data_split_thres_r14_e_ ul_lwa_data_split_thres_r14;
    };
    typedef setup_e types;

    // choice methods
    ul_lwa_cfg_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ul-LWA-Config-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ul-LWA-Config-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct ul_only_hdr_compress_r14_c_ {
    struct rohc_r14_s_ {
      struct profiles_r14_s_ {
        // member variables
        bool profile0x0006_r14 = false;
      };

      // member variables
      bool            ext                 = false;
      bool            max_cid_r14_present = false;
      uint16_t        max_cid_r14         = 1;
      profiles_r14_s_ profiles_r14;
      // ...
    };
    struct types_opts {
      enum options { not_used_r14, rohc_r14, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ul_only_hdr_compress_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rohc_r14_s_& rohc_r14()
    {
      assert_choice_type("rohc-r14", type_.to_string(), "uplinkOnlyHeaderCompression-r14");
      return c;
    }
    const rohc_r14_s_& rohc_r14() const
    {
      assert_choice_type("rohc-r14", type_.to_string(), "uplinkOnlyHeaderCompression-r14");
      return c;
    }
    rohc_r14_s_& set_rohc_r14()
    {
      set(types::rohc_r14);
      return c;
    }

  private:
    types       type_;
    rohc_r14_s_ c;
  };
  struct ul_data_compress_r15_s_ {
    struct buffer_size_r15_opts {
      enum options { kbyte2, kbyte4, kbyte8, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<buffer_size_r15_opts> buffer_size_r15_e_;
    struct dictionary_r15_opts {
      enum options { sip_sdp, operator_type, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<dictionary_r15_opts> dictionary_r15_e_;

    // member variables
    bool               ext                    = false;
    bool               dictionary_r15_present = false;
    buffer_size_r15_e_ buffer_size_r15;
    dictionary_r15_e_  dictionary_r15;
    // ...
  };
  struct pdcp_dupl_cfg_r15_c_ {
    struct setup_s_ {
      struct pdcp_dupl_r15_opts {
        enum options { cfgured, activ, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<pdcp_dupl_r15_opts> pdcp_dupl_r15_e_;

      // member variables
      pdcp_dupl_r15_e_ pdcp_dupl_r15;
    };
    typedef setup_e types;

    // choice methods
    pdcp_dupl_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "pdcp-DuplicationConfig-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "pdcp-DuplicationConfig-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool             ext                   = false;
  bool             discard_timer_present = false;
  bool             rlc_am_present        = false;
  bool             rlc_um_present        = false;
  discard_timer_e_ discard_timer;
  rlc_am_s_        rlc_am;
  rlc_um_s_        rlc_um;
  hdr_compress_c_  hdr_compress;
  // ...
  // group 0
  bool rn_integrity_protection_r10_present = false;
  // group 1
  bool pdcp_sn_size_v1130_present = false;
  // group 2
  bool                ul_data_split_drb_via_scg_r12_present = false;
  bool                t_reordering_r12_present              = false;
  bool                ul_data_split_drb_via_scg_r12         = false;
  t_reordering_r12_e_ t_reordering_r12;
  // group 3
  bool                                 ul_data_split_thres_r13_present = false;
  bool                                 pdcp_sn_size_v1310_present      = false;
  bool                                 status_feedback_r13_present     = false;
  copy_ptr<ul_data_split_thres_r13_c_> ul_data_split_thres_r13;
  copy_ptr<status_feedback_r13_c_>     status_feedback_r13;
  // group 4
  bool                                  ul_lwa_cfg_r14_present           = false;
  bool                                  ul_only_hdr_compress_r14_present = false;
  copy_ptr<ul_lwa_cfg_r14_c_>           ul_lwa_cfg_r14;
  copy_ptr<ul_only_hdr_compress_r14_c_> ul_only_hdr_compress_r14;
  // group 5
  bool                              ul_data_compress_r15_present = false;
  bool                              pdcp_dupl_cfg_r15_present    = false;
  copy_ptr<ul_data_compress_r15_s_> ul_data_compress_r15;
  copy_ptr<pdcp_dupl_cfg_r15_c_>    pdcp_dupl_cfg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated-v1530 ::= SEQUENCE
struct pucch_cfg_ded_v1530_s {
  struct codebooksize_determination_stti_r15_opts {
    enum options { dai, cc, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<codebooksize_determination_stti_r15_opts> codebooksize_determination_stti_r15_e_;

  // member variables
  bool                                   n1_pucch_an_spt_r15_present                 = false;
  bool                                   codebooksize_determination_stti_r15_present = false;
  uint16_t                               n1_pucch_an_spt_r15                         = 0;
  codebooksize_determination_stti_r15_e_ codebooksize_determination_stti_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-Format3-Conf-r13 ::= SEQUENCE
struct pucch_format3_conf_r13_s {
  typedef bounded_array<uint16_t, 4> n3_pucch_an_list_r13_l_;
  struct two_ant_port_activ_pucch_format3_r13_c_ {
    struct setup_s_ {
      typedef bounded_array<uint16_t, 4> n3_pucch_an_list_p1_r13_l_;

      // member variables
      n3_pucch_an_list_p1_r13_l_ n3_pucch_an_list_p1_r13;
    };
    typedef setup_e types;

    // choice methods
    two_ant_port_activ_pucch_format3_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivatedPUCCH-Format3-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivatedPUCCH-Format3-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                                    n3_pucch_an_list_r13_present                 = false;
  bool                                    two_ant_port_activ_pucch_format3_r13_present = false;
  n3_pucch_an_list_r13_l_                 n3_pucch_an_list_r13;
  two_ant_port_activ_pucch_format3_r13_c_ two_ant_port_activ_pucch_format3_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RE-MappingQCLConfigToAddModList-r11 ::= SEQUENCE (SIZE (1..maxRE-MapQCL-r11)) OF PDSCH-RE-MappingQCL-Config-r11
typedef dyn_array<pdsch_re_map_qcl_cfg_r11_s> re_map_qcl_cfg_to_add_mod_list_r11_l;

// RE-MappingQCLConfigToReleaseList-r11 ::= SEQUENCE (SIZE (1..maxRE-MapQCL-r11)) OF INTEGER
typedef bounded_array<uint8_t, 4> re_map_qcl_cfg_to_release_list_r11_l;

// RLC-BearerConfig-r15 ::= CHOICE
struct rlc_bearer_cfg_r15_c {
  struct setup_s_ {
    struct lc_ch_id_cfg_r15_c_ {
      struct types_opts {
        enum options { lc_ch_id_r15, lc_ch_id_ext_r15, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      lc_ch_id_cfg_r15_c_() = default;
      lc_ch_id_cfg_r15_c_(const lc_ch_id_cfg_r15_c_& other);
      lc_ch_id_cfg_r15_c_& operator=(const lc_ch_id_cfg_r15_c_& other);
      ~lc_ch_id_cfg_r15_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint8_t& lc_ch_id_r15()
      {
        assert_choice_type("logicalChannelIdentity-r15", type_.to_string(), "logicalChannelIdentityConfig-r15");
        return c.get<uint8_t>();
      }
      uint8_t& lc_ch_id_ext_r15()
      {
        assert_choice_type("logicalChannelIdentityExt-r15", type_.to_string(), "logicalChannelIdentityConfig-r15");
        return c.get<uint8_t>();
      }
      const uint8_t& lc_ch_id_r15() const
      {
        assert_choice_type("logicalChannelIdentity-r15", type_.to_string(), "logicalChannelIdentityConfig-r15");
        return c.get<uint8_t>();
      }
      const uint8_t& lc_ch_id_ext_r15() const
      {
        assert_choice_type("logicalChannelIdentityExt-r15", type_.to_string(), "logicalChannelIdentityConfig-r15");
        return c.get<uint8_t>();
      }
      uint8_t& set_lc_ch_id_r15()
      {
        set(types::lc_ch_id_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_lc_ch_id_ext_r15()
      {
        set(types::lc_ch_id_ext_r15);
        return c.get<uint8_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };

    // member variables
    bool                rlc_cfg_r15_present   = false;
    bool                lc_ch_cfg_r15_present = false;
    rlc_cfg_r15_s       rlc_cfg_r15;
    lc_ch_id_cfg_r15_c_ lc_ch_id_cfg_r15;
    lc_ch_cfg_s         lc_ch_cfg_r15;
  };
  typedef setup_e types;

  // choice methods
  rlc_bearer_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RLC-BearerConfig-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RLC-BearerConfig-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RLC-Config ::= CHOICE
struct rlc_cfg_c {
  struct am_s_ {
    // member variables
    ul_am_rlc_s ul_am_rlc;
    dl_am_rlc_s dl_am_rlc;
  };
  struct um_bi_dir_s_ {
    // member variables
    ul_um_rlc_s ul_um_rlc;
    dl_um_rlc_s dl_um_rlc;
  };
  struct um_uni_dir_ul_s_ {
    // member variables
    ul_um_rlc_s ul_um_rlc;
  };
  struct um_uni_dir_dl_s_ {
    // member variables
    dl_um_rlc_s dl_um_rlc;
  };
  struct types_opts {
    enum options { am, um_bi_dir, um_uni_dir_ul, um_uni_dir_dl, /*...*/ nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts, true> types;

  // choice methods
  rlc_cfg_c() = default;
  rlc_cfg_c(const rlc_cfg_c& other);
  rlc_cfg_c& operator=(const rlc_cfg_c& other);
  ~rlc_cfg_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  am_s_& am()
  {
    assert_choice_type("am", type_.to_string(), "RLC-Config");
    return c.get<am_s_>();
  }
  um_bi_dir_s_& um_bi_dir()
  {
    assert_choice_type("um-Bi-Directional", type_.to_string(), "RLC-Config");
    return c.get<um_bi_dir_s_>();
  }
  um_uni_dir_ul_s_& um_uni_dir_ul()
  {
    assert_choice_type("um-Uni-Directional-UL", type_.to_string(), "RLC-Config");
    return c.get<um_uni_dir_ul_s_>();
  }
  um_uni_dir_dl_s_& um_uni_dir_dl()
  {
    assert_choice_type("um-Uni-Directional-DL", type_.to_string(), "RLC-Config");
    return c.get<um_uni_dir_dl_s_>();
  }
  const am_s_& am() const
  {
    assert_choice_type("am", type_.to_string(), "RLC-Config");
    return c.get<am_s_>();
  }
  const um_bi_dir_s_& um_bi_dir() const
  {
    assert_choice_type("um-Bi-Directional", type_.to_string(), "RLC-Config");
    return c.get<um_bi_dir_s_>();
  }
  const um_uni_dir_ul_s_& um_uni_dir_ul() const
  {
    assert_choice_type("um-Uni-Directional-UL", type_.to_string(), "RLC-Config");
    return c.get<um_uni_dir_ul_s_>();
  }
  const um_uni_dir_dl_s_& um_uni_dir_dl() const
  {
    assert_choice_type("um-Uni-Directional-DL", type_.to_string(), "RLC-Config");
    return c.get<um_uni_dir_dl_s_>();
  }
  am_s_& set_am()
  {
    set(types::am);
    return c.get<am_s_>();
  }
  um_bi_dir_s_& set_um_bi_dir()
  {
    set(types::um_bi_dir);
    return c.get<um_bi_dir_s_>();
  }
  um_uni_dir_ul_s_& set_um_uni_dir_ul()
  {
    set(types::um_uni_dir_ul);
    return c.get<um_uni_dir_ul_s_>();
  }
  um_uni_dir_dl_s_& set_um_uni_dir_dl()
  {
    set(types::um_uni_dir_dl);
    return c.get<um_uni_dir_dl_s_>();
  }

private:
  types                                                                                                          type_;
  choice_buffer_t<MAX4(sizeof(am_s_), sizeof(um_bi_dir_s_), sizeof(um_uni_dir_dl_s_), sizeof(um_uni_dir_ul_s_))> c;

  void destroy_();
};

// RLC-Config-v1250 ::= SEQUENCE
struct rlc_cfg_v1250_s {
  // member variables
  bool ul_extended_rlc_li_field_r12 = false;
  bool dl_extended_rlc_li_field_r12 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLC-Config-v1310 ::= SEQUENCE
struct rlc_cfg_v1310_s {
  // member variables
  bool             poll_pdu_v1310_present    = false;
  bool             ul_extended_rlc_am_sn_r13 = false;
  bool             dl_extended_rlc_am_sn_r13 = false;
  poll_pdu_v1310_e poll_pdu_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLC-Config-v1430 ::= CHOICE
struct rlc_cfg_v1430_c {
  struct setup_s_ {
    // member variables
    poll_byte_r14_e poll_byte_r14;
  };
  typedef setup_e types;

  // choice methods
  rlc_cfg_v1430_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RLC-Config-v1430");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RLC-Config-v1430");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RLC-Config-v1510 ::= SEQUENCE
struct rlc_cfg_v1510_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLC-Config-v1530 ::= CHOICE
struct rlc_cfg_v1530_c {
  struct setup_s_ {
  };
  typedef setup_e types;

  // choice methods
  rlc_cfg_v1530_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RLC-Config-v1530");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RLC-Config-v1530");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RRCConnectionReject-v1320-IEs ::= SEQUENCE
struct rrc_conn_reject_v1320_ies_s {
  // member variables
  bool rrc_suspend_ind_r13_present = false;
  bool non_crit_ext_present        = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SPDCCH-Config-r15 ::= CHOICE
struct spdcch_cfg_r15_c {
  struct setup_s_ {
    struct spdcch_l1_reuse_ind_r15_opts {
      enum options { n0, n1, n2, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<spdcch_l1_reuse_ind_r15_opts> spdcch_l1_reuse_ind_r15_e_;

    // member variables
    bool                       spdcch_l1_reuse_ind_r15_present = false;
    bool                       spdcch_set_cfg_r15_present      = false;
    spdcch_l1_reuse_ind_r15_e_ spdcch_l1_reuse_ind_r15;
    spdcch_set_r15_l           spdcch_set_cfg_r15;
  };
  typedef setup_e types;

  // choice methods
  spdcch_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPDCCH-Config-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPDCCH-Config-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SPS-ConfigSL-r14 ::= SEQUENCE
struct sps_cfg_sl_r14_s {
  struct semi_persist_sched_interv_sl_r14_opts {
    enum options {
      sf20,
      sf50,
      sf100,
      sf200,
      sf300,
      sf400,
      sf500,
      sf600,
      sf700,
      sf800,
      sf900,
      sf1000,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<semi_persist_sched_interv_sl_r14_opts> semi_persist_sched_interv_sl_r14_e_;

  // member variables
  uint8_t                             sps_cfg_idx_r14 = 1;
  semi_persist_sched_interv_sl_r14_e_ semi_persist_sched_interv_sl_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SPS-ConfigUL ::= CHOICE
struct sps_cfg_ul_c {
  struct setup_s_ {
    struct semi_persist_sched_interv_ul_opts {
      enum options {
        sf10,
        sf20,
        sf32,
        sf40,
        sf64,
        sf80,
        sf128,
        sf160,
        sf320,
        sf640,
        sf1_v1430,
        sf2_v1430,
        sf3_v1430,
        sf4_v1430,
        sf5_v1430,
        spare1,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<semi_persist_sched_interv_ul_opts> semi_persist_sched_interv_ul_e_;
    struct implicit_release_after_opts {
      enum options { e2, e3, e4, e8, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<implicit_release_after_opts> implicit_release_after_e_;
    struct p0_persistent_s_ {
      // member variables
      int8_t p0_nominal_pusch_persistent = -126;
      int8_t p0_ue_pusch_persistent      = -8;
    };
    struct p0_persistent_sf_set2_r12_c_ {
      struct setup_s_ {
        // member variables
        int8_t p0_nominal_pusch_persistent_sf_set2_r12 = -126;
        int8_t p0_ue_pusch_persistent_sf_set2_r12      = -8;
      };
      typedef setup_e types;

      // choice methods
      p0_persistent_sf_set2_r12_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "p0-PersistentSubframeSet2-r12");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "p0-PersistentSubframeSet2-r12");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };
    struct semi_persist_sched_interv_ul_v1430_opts {
      enum options {
        sf50,
        sf100,
        sf200,
        sf300,
        sf400,
        sf500,
        sf600,
        sf700,
        sf800,
        sf900,
        sf1000,
        spare5,
        spare4,
        spare3,
        spare2,
        spare1,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<semi_persist_sched_interv_ul_v1430_opts> semi_persist_sched_interv_ul_v1430_e_;
    struct cyclic_shift_sps_r15_opts {
      enum options { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<cyclic_shift_sps_r15_opts> cyclic_shift_sps_r15_e_;
    struct rv_sps_ul_repeats_r15_opts {
      enum options { ulrvseq1, ulrvseq2, ulrvseq3, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<rv_sps_ul_repeats_r15_opts> rv_sps_ul_repeats_r15_e_;
    struct total_num_pusch_sps_ul_repeats_r15_opts {
      enum options { n2, n3, n4, n6, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<total_num_pusch_sps_ul_repeats_r15_opts> total_num_pusch_sps_ul_repeats_r15_e_;

    // member variables
    bool                            ext                     = false;
    bool                            p0_persistent_present   = false;
    bool                            two_intervs_cfg_present = false;
    semi_persist_sched_interv_ul_e_ semi_persist_sched_interv_ul;
    implicit_release_after_e_       implicit_release_after;
    p0_persistent_s_                p0_persistent;
    // ...
    // group 0
    bool                                   p0_persistent_sf_set2_r12_present = false;
    copy_ptr<p0_persistent_sf_set2_r12_c_> p0_persistent_sf_set2_r12;
    // group 1
    bool    nof_conf_ul_sps_processes_r13_present = false;
    uint8_t nof_conf_ul_sps_processes_r13         = 1;
    // group 2
    bool                                  fixed_rv_non_adaptive_r14_present          = false;
    bool                                  sps_cfg_idx_r14_present                    = false;
    bool                                  semi_persist_sched_interv_ul_v1430_present = false;
    uint8_t                               sps_cfg_idx_r14                            = 1;
    semi_persist_sched_interv_ul_v1430_e_ semi_persist_sched_interv_ul_v1430;
    // group 3
    bool                                  cyclic_shift_sps_r15_present               = false;
    bool                                  harq_proc_id_offset_r15_present            = false;
    bool                                  rv_sps_ul_repeats_r15_present              = false;
    bool                                  tpc_pdcch_cfg_pusch_sps_r15_present        = false;
    bool                                  total_num_pusch_sps_ul_repeats_r15_present = false;
    bool                                  sps_cfg_idx_r15_present                    = false;
    cyclic_shift_sps_r15_e_               cyclic_shift_sps_r15;
    uint8_t                               harq_proc_id_offset_r15 = 0;
    rv_sps_ul_repeats_r15_e_              rv_sps_ul_repeats_r15;
    copy_ptr<tpc_pdcch_cfg_c>             tpc_pdcch_cfg_pusch_sps_r15;
    total_num_pusch_sps_ul_repeats_r15_e_ total_num_pusch_sps_ul_repeats_r15;
    uint8_t                               sps_cfg_idx_r15 = 1;

    // sequence methods
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
  };
  typedef setup_e types;

  // choice methods
  sps_cfg_ul_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigUL");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigUL");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SPS-ConfigUL-STTI-r15 ::= CHOICE
struct sps_cfg_ul_stti_r15_c {
  struct setup_s_ {
    struct semi_persist_sched_interv_ul_stti_r15_opts {
      enum options {
        s_tti1,
        s_tti2,
        s_tti3,
        s_tti4,
        s_tti6,
        s_tti8,
        s_tti12,
        s_tti16,
        s_tti20,
        s_tti40,
        s_tti60,
        s_tti80,
        s_tti120,
        s_tti240,
        spare2,
        spare1,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<semi_persist_sched_interv_ul_stti_r15_opts> semi_persist_sched_interv_ul_stti_r15_e_;
    struct implicit_release_after_opts {
      enum options { e2, e3, e4, e8, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<implicit_release_after_opts> implicit_release_after_e_;
    struct p0_persistent_r15_s_ {
      // member variables
      int8_t p0_nominal_spusch_persistent_r15 = -126;
      int8_t p0_ue_spusch_persistent_r15      = -8;
    };
    struct p0_persistent_sf_set2_r15_c_ {
      struct setup_s_ {
        // member variables
        int8_t p0_nominal_spusch_persistent_sf_set2_r15 = -126;
        int8_t p0_ue_spusch_persistent_sf_set2_r15      = -8;
      };
      typedef setup_e types;

      // choice methods
      p0_persistent_sf_set2_r15_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "p0-PersistentSubframeSet2-r15");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "p0-PersistentSubframeSet2-r15");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };
    struct cyclic_shift_sps_s_tti_r15_opts {
      enum options { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<cyclic_shift_sps_s_tti_r15_opts> cyclic_shift_sps_s_tti_r15_e_;
    struct rv_sps_stti_ul_repeats_r15_opts {
      enum options { ulrvseq1, ulrvseq2, ulrvseq3, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<rv_sps_stti_ul_repeats_r15_opts> rv_sps_stti_ul_repeats_r15_e_;
    struct tbs_scaling_factor_subslot_sps_ul_repeats_r15_opts {
      enum options { n6, n12, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tbs_scaling_factor_subslot_sps_ul_repeats_r15_opts>
        tbs_scaling_factor_subslot_sps_ul_repeats_r15_e_;
    struct total_num_pusch_sps_stti_ul_repeats_r15_opts {
      enum options { n2, n3, n4, n6, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<total_num_pusch_sps_stti_ul_repeats_r15_opts> total_num_pusch_sps_stti_ul_repeats_r15_e_;

    // member variables
    bool                                             ext                                                   = false;
    bool                                             p0_persistent_r15_present                             = false;
    bool                                             two_intervs_cfg_r15_present                           = false;
    bool                                             p0_persistent_sf_set2_r15_present                     = false;
    bool                                             nof_conf_ul_sps_processes_stti_r15_present            = false;
    bool                                             tpc_pdcch_cfg_pusch_sps_r15_present                   = false;
    bool                                             cyclic_shift_sps_s_tti_r15_present                    = false;
    bool                                             ifdma_cfg_sps_r15_present                             = false;
    bool                                             harq_proc_id_offset_r15_present                       = false;
    bool                                             rv_sps_stti_ul_repeats_r15_present                    = false;
    bool                                             sps_cfg_idx_r15_present                               = false;
    bool                                             tbs_scaling_factor_subslot_sps_ul_repeats_r15_present = false;
    bool                                             total_num_pusch_sps_stti_ul_repeats_r15_present       = false;
    semi_persist_sched_interv_ul_stti_r15_e_         semi_persist_sched_interv_ul_stti_r15;
    implicit_release_after_e_                        implicit_release_after;
    p0_persistent_r15_s_                             p0_persistent_r15;
    p0_persistent_sf_set2_r15_c_                     p0_persistent_sf_set2_r15;
    uint8_t                                          nof_conf_ul_sps_processes_stti_r15 = 1;
    uint8_t                                          s_tti_start_time_ul_r15            = 0;
    tpc_pdcch_cfg_c                                  tpc_pdcch_cfg_pusch_sps_r15;
    cyclic_shift_sps_s_tti_r15_e_                    cyclic_shift_sps_s_tti_r15;
    bool                                             ifdma_cfg_sps_r15       = false;
    uint8_t                                          harq_proc_id_offset_r15 = 0;
    rv_sps_stti_ul_repeats_r15_e_                    rv_sps_stti_ul_repeats_r15;
    uint8_t                                          sps_cfg_idx_r15 = 1;
    tbs_scaling_factor_subslot_sps_ul_repeats_r15_e_ tbs_scaling_factor_subslot_sps_ul_repeats_r15;
    total_num_pusch_sps_stti_ul_repeats_r15_e_       total_num_pusch_sps_stti_ul_repeats_r15;
    // ...
  };
  typedef setup_e types;

  // choice methods
  sps_cfg_ul_stti_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigUL-STTI-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigUL-STTI-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SPUCCH-Config-r15 ::= CHOICE
struct spucch_cfg_r15_c {
  struct setup_s_ {
    struct two_ant_port_activ_spucch_format3_r15_s_ {
      typedef bounded_array<uint16_t, 4> n3_spucch_an_list_r15_l_;

      // member variables
      n3_spucch_an_list_r15_l_ n3_spucch_an_list_r15;
    };

    // member variables
    bool                                     spucch_set_r15_present                           = false;
    bool                                     two_ant_port_activ_spucch_format1a1b_r15_present = false;
    spucch_set_r15_l                         spucch_set_r15;
    two_ant_port_activ_spucch_format3_r15_s_ two_ant_port_activ_spucch_format3_r15;
  };
  typedef setup_e types;

  // choice methods
  spucch_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPUCCH-Config-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPUCCH-Config-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SRS-CC-SetIndex-r14 ::= SEQUENCE
struct srs_cc_set_idx_r14_s {
  // member variables
  uint8_t cc_set_idx_r14           = 0;
  uint8_t cc_idx_in_one_cc_set_r14 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRS-ConfigAp-r10 ::= SEQUENCE
struct srs_cfg_ap_r10_s {
  struct srs_bw_ap_r10_opts {
    enum options { bw0, bw1, bw2, bw3, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<srs_bw_ap_r10_opts> srs_bw_ap_r10_e_;
  struct cyclic_shift_ap_r10_opts {
    enum options { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<cyclic_shift_ap_r10_opts> cyclic_shift_ap_r10_e_;

  // member variables
  srs_ant_port_e         srs_ant_port_ap_r10;
  srs_bw_ap_r10_e_       srs_bw_ap_r10;
  uint8_t                freq_domain_position_ap_r10 = 0;
  uint8_t                tx_comb_ap_r10              = 0;
  cyclic_shift_ap_r10_e_ cyclic_shift_ap_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRS-ConfigAp-r13 ::= SEQUENCE
struct srs_cfg_ap_r13_s {
  struct srs_bw_ap_r13_opts {
    enum options { bw0, bw1, bw2, bw3, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<srs_bw_ap_r13_opts> srs_bw_ap_r13_e_;
  struct cyclic_shift_ap_r13_opts {
    enum options { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, cs8, cs9, cs10, cs11, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<cyclic_shift_ap_r13_opts> cyclic_shift_ap_r13_e_;
  struct tx_comb_num_r13_opts {
    enum options { n2, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<tx_comb_num_r13_opts> tx_comb_num_r13_e_;

  // member variables
  srs_ant_port_e         srs_ant_port_ap_r13;
  srs_bw_ap_r13_e_       srs_bw_ap_r13;
  uint8_t                freq_domain_position_ap_r13 = 0;
  uint8_t                tx_comb_ap_r13              = 0;
  cyclic_shift_ap_r13_e_ cyclic_shift_ap_r13;
  tx_comb_num_r13_e_     tx_comb_num_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRS-ConfigAp-v1310 ::= SEQUENCE
struct srs_cfg_ap_v1310_s {
  struct cyclic_shift_ap_v1310_opts {
    enum options { cs8, cs9, cs10, cs11, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<cyclic_shift_ap_v1310_opts> cyclic_shift_ap_v1310_e_;
  struct tx_comb_num_r13_opts {
    enum options { n2, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<tx_comb_num_r13_opts> tx_comb_num_r13_e_;

  // member variables
  bool                     tx_comb_ap_v1310_present      = false;
  bool                     cyclic_shift_ap_v1310_present = false;
  bool                     tx_comb_num_r13_present       = false;
  uint8_t                  tx_comb_ap_v1310              = 2;
  cyclic_shift_ap_v1310_e_ cyclic_shift_ap_v1310;
  tx_comb_num_r13_e_       tx_comb_num_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// STAG-ToAddMod-r11 ::= SEQUENCE
struct stag_to_add_mod_r11_s {
  // member variables
  bool               ext         = false;
  uint8_t            stag_id_r11 = 1;
  time_align_timer_e time_align_timer_stag_r11;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SchedulingRequestConfig-v1530 ::= CHOICE
struct sched_request_cfg_v1530_c {
  struct setup_s_ {
    struct dssr_trans_max_r15_opts {
      enum options { n4, n8, n16, n32, n64, spare3, spare2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<dssr_trans_max_r15_opts> dssr_trans_max_r15_e_;

    // member variables
    bool                             sr_slot_spucch_idx_fh_r15_present      = false;
    bool                             sr_slot_spucch_idx_no_fh_r15_present   = false;
    bool                             sr_subslot_spucch_res_list_r15_present = false;
    bool                             sr_cfg_idx_slot_r15_present            = false;
    bool                             sr_cfg_idx_subslot_r15_present         = false;
    uint16_t                         sr_slot_spucch_idx_fh_r15              = 0;
    uint16_t                         sr_slot_spucch_idx_no_fh_r15           = 0;
    sr_subslot_spucch_res_list_r15_l sr_subslot_spucch_res_list_r15;
    uint8_t                          sr_cfg_idx_slot_r15    = 0;
    uint8_t                          sr_cfg_idx_subslot_r15 = 0;
    dssr_trans_max_r15_e_            dssr_trans_max_r15;
  };
  typedef setup_e types;

  // choice methods
  sched_request_cfg_v1530_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SchedulingRequestConfig-v1530");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SchedulingRequestConfig-v1530");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// ShortTTI-r15 ::= SEQUENCE
struct short_tti_r15_s {
  // member variables
  bool                dl_stti_len_r15_present = false;
  bool                ul_stti_len_r15_present = false;
  short_tti_len_r15_e dl_stti_len_r15;
  short_tti_len_r15_e ul_stti_len_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SlotOrSubslotPDSCH-Config-r15 ::= CHOICE
struct slot_or_subslot_pdsch_cfg_r15_c {
  struct setup_s_ {
    struct alt_cqi_table_stti_r15_opts {
      enum options { all_sfs, csi_sf_set1, csi_sf_set2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<alt_cqi_table_stti_r15_opts> alt_cqi_table_stti_r15_e_;
    struct alt_cqi_table1024_qam_stti_r15_opts {
      enum options { all_sfs, csi_sf_set1, csi_sf_set2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<alt_cqi_table1024_qam_stti_r15_opts> alt_cqi_table1024_qam_stti_r15_e_;
    struct res_alloc_r15_opts {
      enum options { res_alloc_type0, res_alloc_type2, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<res_alloc_r15_opts> res_alloc_r15_e_;

    // member variables
    bool                              ext                                    = false;
    bool                              alt_cqi_table_stti_r15_present         = false;
    bool                              alt_cqi_table1024_qam_stti_r15_present = false;
    bool                              res_alloc_r15_present                  = false;
    bool                              tbs_idx_alt_stti_r15_present           = false;
    bool                              tbs_idx_alt2_stti_r15_present          = false;
    bool                              tbs_idx_alt3_stti_r15_present          = false;
    alt_cqi_table_stti_r15_e_         alt_cqi_table_stti_r15;
    alt_cqi_table1024_qam_stti_r15_e_ alt_cqi_table1024_qam_stti_r15;
    res_alloc_r15_e_                  res_alloc_r15;
    // ...
  };
  typedef setup_e types;

  // choice methods
  slot_or_subslot_pdsch_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SlotOrSubslotPDSCH-Config-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SlotOrSubslotPDSCH-Config-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SlotOrSubslotPUSCH-Config-r15 ::= CHOICE
struct slot_or_subslot_pusch_cfg_r15_c {
  struct setup_s_ {
    typedef bounded_array<uint8_t, 2> beta_offset_subslot_ack_idx_r15_l_;
    typedef bounded_array<uint8_t, 2> beta_offset2_subslot_ack_idx_r15_l_;
    typedef bounded_array<uint8_t, 2> beta_offset_subslot_ri_idx_r15_l_;

    // member variables
    bool                                ext                                       = false;
    bool                                beta_offset_slot_ack_idx_r15_present      = false;
    bool                                beta_offset2_slot_ack_idx_r15_present     = false;
    bool                                beta_offset_subslot_ack_idx_r15_present   = false;
    bool                                beta_offset2_subslot_ack_idx_r15_present  = false;
    bool                                beta_offset_slot_ri_idx_r15_present       = false;
    bool                                beta_offset_subslot_ri_idx_r15_present    = false;
    bool                                beta_offset_slot_cqi_idx_r15_present      = false;
    bool                                beta_offset_subslot_cqi_idx_r15_present   = false;
    bool                                enable256_qam_slot_or_subslot_r15_present = false;
    bool                                res_alloc_offset_r15_present              = false;
    uint8_t                             beta_offset_slot_ack_idx_r15              = 0;
    uint8_t                             beta_offset2_slot_ack_idx_r15             = 0;
    beta_offset_subslot_ack_idx_r15_l_  beta_offset_subslot_ack_idx_r15;
    beta_offset2_subslot_ack_idx_r15_l_ beta_offset2_subslot_ack_idx_r15;
    uint8_t                             beta_offset_slot_ri_idx_r15 = 0;
    beta_offset_subslot_ri_idx_r15_l_   beta_offset_subslot_ri_idx_r15;
    uint8_t                             beta_offset_slot_cqi_idx_r15    = 0;
    uint8_t                             beta_offset_subslot_cqi_idx_r15 = 0;
    enable256_qam_r14_c                 enable256_qam_slot_or_subslot_r15;
    uint8_t                             res_alloc_offset_r15              = 1;
    bool                                ul_dmrs_ifdma_slot_or_subslot_r15 = false;
    // ...
  };
  typedef setup_e types;

  // choice methods
  slot_or_subslot_pusch_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SlotOrSubslotPUSCH-Config-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SlotOrSubslotPUSCH-Config-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// TDD-PUSCH-UpPTS-r14 ::= CHOICE
struct tdd_pusch_up_pts_r14_c {
  struct setup_s_ {
    struct sym_pusch_up_pts_r14_opts {
      enum options { sym1, sym2, sym3, sym4, sym5, sym6, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<sym_pusch_up_pts_r14_opts> sym_pusch_up_pts_r14_e_;

    // member variables
    bool                    sym_pusch_up_pts_r14_present     = false;
    bool                    dmrs_less_up_pts_cfg_r14_present = false;
    sym_pusch_up_pts_r14_e_ sym_pusch_up_pts_r14;
  };
  typedef setup_e types;

  // choice methods
  tdd_pusch_up_pts_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "TDD-PUSCH-UpPTS-r14");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "TDD-PUSCH-UpPTS-r14");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// UplinkPowerControlDedicatedSTTI-r15 ::= SEQUENCE
struct ul_pwr_ctrl_ded_stti_r15_s {
  // member variables
  bool                                delta_tx_d_offset_list_spucch_r15_present = false;
  bool                                accumulation_enabled_stti_r15             = false;
  delta_tx_d_offset_list_spucch_r15_s delta_tx_d_offset_list_spucch_r15;
  bool                                ul_pwr_csi_payload = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoDedicated ::= SEQUENCE
struct ant_info_ded_s {
  struct tx_mode_opts {
    enum options { tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8_v920, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<tx_mode_opts> tx_mode_e_;
  struct codebook_subset_restrict_c_ {
    struct types_opts {
      enum options {
        n2_tx_ant_tm3,
        n4_tx_ant_tm3,
        n2_tx_ant_tm4,
        n4_tx_ant_tm4,
        n2_tx_ant_tm5,
        n4_tx_ant_tm5,
        n2_tx_ant_tm6,
        n4_tx_ant_tm6,
        nulltype
      } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    codebook_subset_restrict_c_() = default;
    codebook_subset_restrict_c_(const codebook_subset_restrict_c_& other);
    codebook_subset_restrict_c_& operator=(const codebook_subset_restrict_c_& other);
    ~codebook_subset_restrict_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<2>& n2_tx_ant_tm3()
    {
      assert_choice_type("n2TxAntenna-tm3", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<2> >();
    }
    fixed_bitstring<4>& n4_tx_ant_tm3()
    {
      assert_choice_type("n4TxAntenna-tm3", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<4> >();
    }
    fixed_bitstring<6>& n2_tx_ant_tm4()
    {
      assert_choice_type("n2TxAntenna-tm4", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<6> >();
    }
    fixed_bitstring<64>& n4_tx_ant_tm4()
    {
      assert_choice_type("n4TxAntenna-tm4", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<64> >();
    }
    fixed_bitstring<4>& n2_tx_ant_tm5()
    {
      assert_choice_type("n2TxAntenna-tm5", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<4> >();
    }
    fixed_bitstring<16>& n4_tx_ant_tm5()
    {
      assert_choice_type("n4TxAntenna-tm5", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<16> >();
    }
    fixed_bitstring<4>& n2_tx_ant_tm6()
    {
      assert_choice_type("n2TxAntenna-tm6", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<4> >();
    }
    fixed_bitstring<16>& n4_tx_ant_tm6()
    {
      assert_choice_type("n4TxAntenna-tm6", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<16> >();
    }
    const fixed_bitstring<2>& n2_tx_ant_tm3() const
    {
      assert_choice_type("n2TxAntenna-tm3", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<2> >();
    }
    const fixed_bitstring<4>& n4_tx_ant_tm3() const
    {
      assert_choice_type("n4TxAntenna-tm3", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<4> >();
    }
    const fixed_bitstring<6>& n2_tx_ant_tm4() const
    {
      assert_choice_type("n2TxAntenna-tm4", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<6> >();
    }
    const fixed_bitstring<64>& n4_tx_ant_tm4() const
    {
      assert_choice_type("n4TxAntenna-tm4", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<64> >();
    }
    const fixed_bitstring<4>& n2_tx_ant_tm5() const
    {
      assert_choice_type("n2TxAntenna-tm5", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<4> >();
    }
    const fixed_bitstring<16>& n4_tx_ant_tm5() const
    {
      assert_choice_type("n4TxAntenna-tm5", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<16> >();
    }
    const fixed_bitstring<4>& n2_tx_ant_tm6() const
    {
      assert_choice_type("n2TxAntenna-tm6", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<4> >();
    }
    const fixed_bitstring<16>& n4_tx_ant_tm6() const
    {
      assert_choice_type("n4TxAntenna-tm6", type_.to_string(), "codebookSubsetRestriction");
      return c.get<fixed_bitstring<16> >();
    }
    fixed_bitstring<2>& set_n2_tx_ant_tm3()
    {
      set(types::n2_tx_ant_tm3);
      return c.get<fixed_bitstring<2> >();
    }
    fixed_bitstring<4>& set_n4_tx_ant_tm3()
    {
      set(types::n4_tx_ant_tm3);
      return c.get<fixed_bitstring<4> >();
    }
    fixed_bitstring<6>& set_n2_tx_ant_tm4()
    {
      set(types::n2_tx_ant_tm4);
      return c.get<fixed_bitstring<6> >();
    }
    fixed_bitstring<64>& set_n4_tx_ant_tm4()
    {
      set(types::n4_tx_ant_tm4);
      return c.get<fixed_bitstring<64> >();
    }
    fixed_bitstring<4>& set_n2_tx_ant_tm5()
    {
      set(types::n2_tx_ant_tm5);
      return c.get<fixed_bitstring<4> >();
    }
    fixed_bitstring<16>& set_n4_tx_ant_tm5()
    {
      set(types::n4_tx_ant_tm5);
      return c.get<fixed_bitstring<16> >();
    }
    fixed_bitstring<4>& set_n2_tx_ant_tm6()
    {
      set(types::n2_tx_ant_tm6);
      return c.get<fixed_bitstring<4> >();
    }
    fixed_bitstring<16>& set_n4_tx_ant_tm6()
    {
      set(types::n4_tx_ant_tm6);
      return c.get<fixed_bitstring<16> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<64>)> c;

    void destroy_();
  };
  struct ue_tx_ant_sel_c_ {
    struct setup_opts {
      enum options { closed_loop, open_loop, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<setup_opts> setup_e_;
    typedef setup_e                types;

    // choice methods
    ue_tx_ant_sel_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_e_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ue-TransmitAntennaSelection");
      return c;
    }
    const setup_e_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ue-TransmitAntennaSelection");
      return c;
    }
    setup_e_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_e_ c;
  };

  // member variables
  bool                        codebook_subset_restrict_present = false;
  tx_mode_e_                  tx_mode;
  codebook_subset_restrict_c_ codebook_subset_restrict;
  ue_tx_ant_sel_c_            ue_tx_ant_sel;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoDedicated-r10 ::= SEQUENCE
struct ant_info_ded_r10_s {
  struct tx_mode_r10_opts {
    enum options {
      tm1,
      tm2,
      tm3,
      tm4,
      tm5,
      tm6,
      tm7,
      tm8_v920,
      tm9_v1020,
      tm10_v1130,
      spare6,
      spare5,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<tx_mode_r10_opts> tx_mode_r10_e_;
  struct ue_tx_ant_sel_c_ {
    struct setup_opts {
      enum options { closed_loop, open_loop, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<setup_opts> setup_e_;
    typedef setup_e                types;

    // choice methods
    ue_tx_ant_sel_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_e_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ue-TransmitAntennaSelection");
      return c;
    }
    const setup_e_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ue-TransmitAntennaSelection");
      return c;
    }
    setup_e_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_e_ c;
  };

  // member variables
  bool             codebook_subset_restrict_r10_present = false;
  tx_mode_r10_e_   tx_mode_r10;
  dyn_bitstring    codebook_subset_restrict_r10;
  ue_tx_ant_sel_c_ ue_tx_ant_sel;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoDedicated-v1250 ::= SEQUENCE
struct ant_info_ded_v1250_s {
  // member variables
  bool alternative_codebook_enabled_for4_tx_r12 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoDedicated-v1430 ::= SEQUENCE
struct ant_info_ded_v1430_s {
  // member variables
  bool ce_ue_tx_ant_sel_cfg_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoDedicated-v1530 ::= CHOICE
struct ant_info_ded_v1530_c {
  struct setup_c_ {
    struct ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15_opts {
      enum options { two, three, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15_opts>
        ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15_e_;
    struct types_opts {
      enum options {
        ue_tx_ant_sel_srs_minus1_t4_r_cfg_r15,
        ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15,
        nulltype
      } value;
      typedef int8_t number_type;

      std::string to_string() const;
      int8_t      to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    setup_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15_e_& ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15()
    {
      assert_choice_type("ue-TxAntennaSelection-SRS-2T4R-NrOfPairs-r15", type_.to_string(), "setup");
      return c;
    }
    const ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15_e_& ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15() const
    {
      assert_choice_type("ue-TxAntennaSelection-SRS-2T4R-NrOfPairs-r15", type_.to_string(), "setup");
      return c;
    }
    ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15_e_& set_ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15()
    {
      set(types::ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15);
      return c;
    }

  private:
    types                                            type_;
    ue_tx_ant_sel_srs_minus2_t4_r_nr_of_pairs_r15_e_ c;
  };
  typedef setup_e types;

  // choice methods
  ant_info_ded_v1530_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_c_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "AntennaInfoDedicated-v1530");
    return c;
  }
  const setup_c_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "AntennaInfoDedicated-v1530");
    return c;
  }
  setup_c_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_c_ c;
};

// AntennaInfoDedicated-v920 ::= SEQUENCE
struct ant_info_ded_v920_s {
  struct codebook_subset_restrict_v920_c_ {
    struct types_opts {
      enum options { n2_tx_ant_tm8_r9, n4_tx_ant_tm8_r9, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    codebook_subset_restrict_v920_c_() = default;
    codebook_subset_restrict_v920_c_(const codebook_subset_restrict_v920_c_& other);
    codebook_subset_restrict_v920_c_& operator=(const codebook_subset_restrict_v920_c_& other);
    ~codebook_subset_restrict_v920_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<6>& n2_tx_ant_tm8_r9()
    {
      assert_choice_type("n2TxAntenna-tm8-r9", type_.to_string(), "codebookSubsetRestriction-v920");
      return c.get<fixed_bitstring<6> >();
    }
    fixed_bitstring<32>& n4_tx_ant_tm8_r9()
    {
      assert_choice_type("n4TxAntenna-tm8-r9", type_.to_string(), "codebookSubsetRestriction-v920");
      return c.get<fixed_bitstring<32> >();
    }
    const fixed_bitstring<6>& n2_tx_ant_tm8_r9() const
    {
      assert_choice_type("n2TxAntenna-tm8-r9", type_.to_string(), "codebookSubsetRestriction-v920");
      return c.get<fixed_bitstring<6> >();
    }
    const fixed_bitstring<32>& n4_tx_ant_tm8_r9() const
    {
      assert_choice_type("n4TxAntenna-tm8-r9", type_.to_string(), "codebookSubsetRestriction-v920");
      return c.get<fixed_bitstring<32> >();
    }
    fixed_bitstring<6>& set_n2_tx_ant_tm8_r9()
    {
      set(types::n2_tx_ant_tm8_r9);
      return c.get<fixed_bitstring<6> >();
    }
    fixed_bitstring<32>& set_n4_tx_ant_tm8_r9()
    {
      set(types::n4_tx_ant_tm8_r9);
      return c.get<fixed_bitstring<32> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<32>)> c;

    void destroy_();
  };

  // member variables
  bool                             codebook_subset_restrict_v920_present = false;
  codebook_subset_restrict_v920_c_ codebook_subset_restrict_v920;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoUL-r10 ::= SEQUENCE
struct ant_info_ul_r10_s {
  struct tx_mode_ul_r10_opts {
    enum options { tm1, tm2, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<tx_mode_ul_r10_opts> tx_mode_ul_r10_e_;

  // member variables
  bool              tx_mode_ul_r10_present          = false;
  bool              four_ant_port_activ_r10_present = false;
  tx_mode_ul_r10_e_ tx_mode_ul_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandClassPriority1XRTT ::= SEQUENCE
struct band_class_prio1_xrtt_s {
  // member variables
  bandclass_cdma2000_e band_class;
  uint8_t              cell_resel_prio = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandClassPriorityHRPD ::= SEQUENCE
struct band_class_prio_hrpd_s {
  // member variables
  bandclass_cdma2000_e band_class;
  uint8_t              cell_resel_prio = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CFI-Config-r15 ::= SEQUENCE
struct cfi_cfg_r15_s {
  // member variables
  bool    cfi_sf_non_mbsfn_r15_present           = false;
  bool    cfi_slot_subslot_non_mbsfn_r15_present = false;
  bool    cfi_sf_mbsfn_r15_present               = false;
  bool    cfi_slot_subslot_mbsfn_r15_present     = false;
  uint8_t cfi_sf_non_mbsfn_r15                   = 1;
  uint8_t cfi_slot_subslot_non_mbsfn_r15         = 1;
  uint8_t cfi_sf_mbsfn_r15                       = 1;
  uint8_t cfi_slot_subslot_mbsfn_r15             = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CFI-PatternConfig-r15 ::= SEQUENCE
struct cfi_pattern_cfg_r15_s {
  typedef fixed_array<uint8_t, 10> cfi_pattern_sf_r15_l_;
  typedef fixed_array<uint8_t, 10> cfi_pattern_slot_subslot_r15_l_;

  // member variables
  bool                            cfi_pattern_sf_r15_present           = false;
  bool                            cfi_pattern_slot_subslot_r15_present = false;
  cfi_pattern_sf_r15_l_           cfi_pattern_sf_r15;
  cfi_pattern_slot_subslot_r15_l_ cfi_pattern_slot_subslot_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig ::= SEQUENCE
struct cqi_report_cfg_s {
  // member variables
  bool                        cqi_report_mode_aperiodic_present = false;
  bool                        cqi_report_periodic_present       = false;
  cqi_report_mode_aperiodic_e cqi_report_mode_aperiodic;
  int8_t                      nom_pdsch_rs_epre_offset = -1;
  cqi_report_periodic_c       cqi_report_periodic;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-v1530 ::= SEQUENCE
struct cqi_report_cfg_v1530_s {
  struct alt_cqi_table_minus1024_qam_r15_opts {
    enum options { all_sfs, csi_sf_set1, csi_sf_set2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<alt_cqi_table_minus1024_qam_r15_opts> alt_cqi_table_minus1024_qam_r15_e_;

  // member variables
  bool                               alt_cqi_table_minus1024_qam_r15_present = false;
  alt_cqi_table_minus1024_qam_r15_e_ alt_cqi_table_minus1024_qam_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfig-v920 ::= SEQUENCE
struct cqi_report_cfg_v920_s {
  // member variables
  bool cqi_mask_r9_present      = false;
  bool pmi_ri_report_r9_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CRS-AssistanceInfoList-r11 ::= SEQUENCE (SIZE (1..maxCellReport)) OF CRS-AssistanceInfo-r11
typedef dyn_array<crs_assist_info_r11_s> crs_assist_info_list_r11_l;

// CRS-AssistanceInfoList-r13 ::= SEQUENCE (SIZE (1..maxCellReport)) OF CRS-AssistanceInfo-r13
typedef dyn_array<crs_assist_info_r13_s> crs_assist_info_list_r13_l;

// CRS-AssistanceInfoList-r15 ::= SEQUENCE (SIZE (1..maxCellReport)) OF CRS-AssistanceInfo-r15
typedef dyn_array<crs_assist_info_r15_s> crs_assist_info_list_r15_l;

// CSI-RS-Config-v1480 ::= SEQUENCE
struct csi_rs_cfg_v1480_s {
  // member variables
  bool                     e_mimo_type_v1480_present = false;
  csi_rs_cfg_emimo_v1480_c e_mimo_type_v1480;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-Config-v1530 ::= SEQUENCE
struct csi_rs_cfg_v1530_s {
  // member variables
  bool                     e_mimo_type_v1530_present = false;
  csi_rs_cfg_emimo_v1530_c e_mimo_type_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-ConfigNZPToAddModList-r11 ::= SEQUENCE (SIZE (1..maxCSI-RS-NZP-r11)) OF CSI-RS-ConfigNZP-r11
typedef dyn_array<csi_rs_cfg_nzp_r11_s> csi_rs_cfg_nzp_to_add_mod_list_r11_l;

// CSI-RS-ConfigNZPToAddModListExt-r13 ::= SEQUENCE (SIZE (1..maxCSI-RS-NZP-v1310)) OF CSI-RS-ConfigNZP-r11
typedef dyn_array<csi_rs_cfg_nzp_r11_s> csi_rs_cfg_nzp_to_add_mod_list_ext_r13_l;

// CSI-RS-ConfigNZPToReleaseList-r11 ::= SEQUENCE (SIZE (1..maxCSI-RS-NZP-r11)) OF INTEGER
typedef bounded_array<uint8_t, 3> csi_rs_cfg_nzp_to_release_list_r11_l;

// CSI-RS-ConfigNZPToReleaseListExt-r13 ::= SEQUENCE (SIZE (1..maxCSI-RS-NZP-v1310)) OF INTEGER
typedef bounded_array<uint8_t, 21> csi_rs_cfg_nzp_to_release_list_ext_r13_l;

// DRB-ToAddMod ::= SEQUENCE
struct drb_to_add_mod_s {
  struct drb_type_lwip_r13_opts {
    enum options { lwip, lwip_dl_only, lwip_ul_only, eutran, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<drb_type_lwip_r13_opts> drb_type_lwip_r13_e_;
  struct lwa_wlan_ac_r14_opts {
    enum options { ac_bk, ac_be, ac_vi, ac_vo, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<lwa_wlan_ac_r14_opts> lwa_wlan_ac_r14_e_;

  // member variables
  bool        ext                   = false;
  bool        eps_bearer_id_present = false;
  bool        pdcp_cfg_present      = false;
  bool        rlc_cfg_present       = false;
  bool        lc_ch_id_present      = false;
  bool        lc_ch_cfg_present     = false;
  uint8_t     eps_bearer_id         = 0;
  uint8_t     drb_id                = 1;
  pdcp_cfg_s  pdcp_cfg;
  rlc_cfg_c   rlc_cfg;
  uint8_t     lc_ch_id = 3;
  lc_ch_cfg_s lc_ch_cfg;
  // ...
  // group 0
  bool                      drb_type_change_r12_present = false;
  bool                      rlc_cfg_v1250_present       = false;
  copy_ptr<rlc_cfg_v1250_s> rlc_cfg_v1250;
  // group 1
  bool                      rlc_cfg_v1310_present     = false;
  bool                      drb_type_lwa_r13_present  = false;
  bool                      drb_type_lwip_r13_present = false;
  copy_ptr<rlc_cfg_v1310_s> rlc_cfg_v1310;
  bool                      drb_type_lwa_r13 = false;
  drb_type_lwip_r13_e_      drb_type_lwip_r13;
  // group 2
  bool                      rlc_cfg_v1430_present           = false;
  bool                      lwip_ul_aggregation_r14_present = false;
  bool                      lwip_dl_aggregation_r14_present = false;
  bool                      lwa_wlan_ac_r14_present         = false;
  copy_ptr<rlc_cfg_v1430_c> rlc_cfg_v1430;
  bool                      lwip_ul_aggregation_r14 = false;
  bool                      lwip_dl_aggregation_r14 = false;
  lwa_wlan_ac_r14_e_        lwa_wlan_ac_r14;
  // group 3
  bool                      rlc_cfg_v1510_present = false;
  copy_ptr<rlc_cfg_v1510_s> rlc_cfg_v1510;
  // group 4
  bool                           rlc_cfg_v1530_present           = false;
  bool                           rlc_bearer_cfg_dupl_r15_present = false;
  bool                           lc_ch_id_r15_present            = false;
  copy_ptr<rlc_cfg_v1530_c>      rlc_cfg_v1530;
  copy_ptr<rlc_bearer_cfg_r15_c> rlc_bearer_cfg_dupl_r15;
  uint8_t                        lc_ch_id_r15 = 32;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRX-Config ::= CHOICE
struct drx_cfg_c {
  struct setup_s_ {
    struct on_dur_timer_opts {
      enum options {
        psf1,
        psf2,
        psf3,
        psf4,
        psf5,
        psf6,
        psf8,
        psf10,
        psf20,
        psf30,
        psf40,
        psf50,
        psf60,
        psf80,
        psf100,
        psf200,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<on_dur_timer_opts> on_dur_timer_e_;
    struct drx_inactivity_timer_opts {
      enum options {
        psf1,
        psf2,
        psf3,
        psf4,
        psf5,
        psf6,
        psf8,
        psf10,
        psf20,
        psf30,
        psf40,
        psf50,
        psf60,
        psf80,
        psf100,
        psf200,
        psf300,
        psf500,
        psf750,
        psf1280,
        psf1920,
        psf2560,
        psf0_v1020,
        spare9,
        spare8,
        spare7,
        spare6,
        spare5,
        spare4,
        spare3,
        spare2,
        spare1,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<drx_inactivity_timer_opts> drx_inactivity_timer_e_;
    struct drx_retx_timer_opts {
      enum options { psf1, psf2, psf4, psf6, psf8, psf16, psf24, psf33, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<drx_retx_timer_opts> drx_retx_timer_e_;
    struct long_drx_cycle_start_offset_c_ {
      struct types_opts {
        enum options {
          sf10,
          sf20,
          sf32,
          sf40,
          sf64,
          sf80,
          sf128,
          sf160,
          sf256,
          sf320,
          sf512,
          sf640,
          sf1024,
          sf1280,
          sf2048,
          sf2560,
          nulltype
        } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      long_drx_cycle_start_offset_c_() = default;
      long_drx_cycle_start_offset_c_(const long_drx_cycle_start_offset_c_& other);
      long_drx_cycle_start_offset_c_& operator=(const long_drx_cycle_start_offset_c_& other);
      ~long_drx_cycle_start_offset_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint8_t& sf10()
      {
        assert_choice_type("sf10", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf20()
      {
        assert_choice_type("sf20", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf32()
      {
        assert_choice_type("sf32", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf40()
      {
        assert_choice_type("sf40", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf64()
      {
        assert_choice_type("sf64", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf80()
      {
        assert_choice_type("sf80", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf128()
      {
        assert_choice_type("sf128", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf160()
      {
        assert_choice_type("sf160", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint8_t& sf256()
      {
        assert_choice_type("sf256", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      uint16_t& sf320()
      {
        assert_choice_type("sf320", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      uint16_t& sf512()
      {
        assert_choice_type("sf512", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      uint16_t& sf640()
      {
        assert_choice_type("sf640", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      uint16_t& sf1024()
      {
        assert_choice_type("sf1024", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      uint16_t& sf1280()
      {
        assert_choice_type("sf1280", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      uint16_t& sf2048()
      {
        assert_choice_type("sf2048", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      uint16_t& sf2560()
      {
        assert_choice_type("sf2560", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      const uint8_t& sf10() const
      {
        assert_choice_type("sf10", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf20() const
      {
        assert_choice_type("sf20", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf32() const
      {
        assert_choice_type("sf32", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf40() const
      {
        assert_choice_type("sf40", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf64() const
      {
        assert_choice_type("sf64", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf80() const
      {
        assert_choice_type("sf80", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf128() const
      {
        assert_choice_type("sf128", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf160() const
      {
        assert_choice_type("sf160", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& sf256() const
      {
        assert_choice_type("sf256", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint8_t>();
      }
      const uint16_t& sf320() const
      {
        assert_choice_type("sf320", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& sf512() const
      {
        assert_choice_type("sf512", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& sf640() const
      {
        assert_choice_type("sf640", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& sf1024() const
      {
        assert_choice_type("sf1024", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& sf1280() const
      {
        assert_choice_type("sf1280", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& sf2048() const
      {
        assert_choice_type("sf2048", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& sf2560() const
      {
        assert_choice_type("sf2560", type_.to_string(), "longDRX-CycleStartOffset");
        return c.get<uint16_t>();
      }
      uint8_t& set_sf10()
      {
        set(types::sf10);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf20()
      {
        set(types::sf20);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf32()
      {
        set(types::sf32);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf40()
      {
        set(types::sf40);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf64()
      {
        set(types::sf64);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf80()
      {
        set(types::sf80);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf128()
      {
        set(types::sf128);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf160()
      {
        set(types::sf160);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf256()
      {
        set(types::sf256);
        return c.get<uint8_t>();
      }
      uint16_t& set_sf320()
      {
        set(types::sf320);
        return c.get<uint16_t>();
      }
      uint16_t& set_sf512()
      {
        set(types::sf512);
        return c.get<uint16_t>();
      }
      uint16_t& set_sf640()
      {
        set(types::sf640);
        return c.get<uint16_t>();
      }
      uint16_t& set_sf1024()
      {
        set(types::sf1024);
        return c.get<uint16_t>();
      }
      uint16_t& set_sf1280()
      {
        set(types::sf1280);
        return c.get<uint16_t>();
      }
      uint16_t& set_sf2048()
      {
        set(types::sf2048);
        return c.get<uint16_t>();
      }
      uint16_t& set_sf2560()
      {
        set(types::sf2560);
        return c.get<uint16_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };
    struct short_drx_s_ {
      struct short_drx_cycle_opts {
        enum options {
          sf2,
          sf5,
          sf8,
          sf10,
          sf16,
          sf20,
          sf32,
          sf40,
          sf64,
          sf80,
          sf128,
          sf160,
          sf256,
          sf320,
          sf512,
          sf640,
          nulltype
        } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<short_drx_cycle_opts> short_drx_cycle_e_;

      // member variables
      short_drx_cycle_e_ short_drx_cycle;
      uint8_t            drx_short_cycle_timer = 1;
    };

    // member variables
    bool                           short_drx_present = false;
    on_dur_timer_e_                on_dur_timer;
    drx_inactivity_timer_e_        drx_inactivity_timer;
    drx_retx_timer_e_              drx_retx_timer;
    long_drx_cycle_start_offset_c_ long_drx_cycle_start_offset;
    short_drx_s_                   short_drx;
  };
  typedef setup_e types;

  // choice methods
  drx_cfg_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "DRX-Config");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "DRX-Config");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// DRX-Config-r13 ::= SEQUENCE
struct drx_cfg_r13_s {
  struct on_dur_timer_v1310_opts {
    enum options { psf300, psf400, psf500, psf600, psf800, psf1000, psf1200, psf1600, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<on_dur_timer_v1310_opts> on_dur_timer_v1310_e_;
  struct drx_retx_timer_v1310_opts {
    enum options { psf40, psf64, psf80, psf96, psf112, psf128, psf160, psf320, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<drx_retx_timer_v1310_opts> drx_retx_timer_v1310_e_;
  struct drx_ul_retx_timer_r13_opts {
    enum options {
      psf0,
      psf1,
      psf2,
      psf4,
      psf6,
      psf8,
      psf16,
      psf24,
      psf33,
      psf40,
      psf64,
      psf80,
      psf96,
      psf112,
      psf128,
      psf160,
      psf320,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<drx_ul_retx_timer_r13_opts> drx_ul_retx_timer_r13_e_;

  // member variables
  bool                     on_dur_timer_v1310_present    = false;
  bool                     drx_retx_timer_v1310_present  = false;
  bool                     drx_ul_retx_timer_r13_present = false;
  on_dur_timer_v1310_e_    on_dur_timer_v1310;
  drx_retx_timer_v1310_e_  drx_retx_timer_v1310;
  drx_ul_retx_timer_r13_e_ drx_ul_retx_timer_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRX-Config-r15 ::= SEQUENCE
struct drx_cfg_r15_s {
  struct drx_retx_timer_short_tti_r15_opts {
    enum options { tti10, tti20, tti40, tti64, tti80, tti96, tti112, tti128, tti160, tti320, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<drx_retx_timer_short_tti_r15_opts> drx_retx_timer_short_tti_r15_e_;
  struct drx_ul_retx_timer_short_tti_r15_opts {
    enum options {
      tti0,
      tti1,
      tti2,
      tti4,
      tti6,
      tti8,
      tti16,
      tti24,
      tti33,
      tti40,
      tti64,
      tti80,
      tti96,
      tti112,
      tti128,
      tti160,
      tti320,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<drx_ul_retx_timer_short_tti_r15_opts> drx_ul_retx_timer_short_tti_r15_e_;

  // member variables
  bool                               drx_retx_timer_short_tti_r15_present    = false;
  bool                               drx_ul_retx_timer_short_tti_r15_present = false;
  drx_retx_timer_short_tti_r15_e_    drx_retx_timer_short_tti_r15;
  drx_ul_retx_timer_short_tti_r15_e_ drx_ul_retx_timer_short_tti_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRX-Config-v1130 ::= SEQUENCE
struct drx_cfg_v1130_s {
  struct long_drx_cycle_start_offset_v1130_c_ {
    struct types_opts {
      enum options { sf60_v1130, sf70_v1130, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    long_drx_cycle_start_offset_v1130_c_() = default;
    long_drx_cycle_start_offset_v1130_c_(const long_drx_cycle_start_offset_v1130_c_& other);
    long_drx_cycle_start_offset_v1130_c_& operator=(const long_drx_cycle_start_offset_v1130_c_& other);
    ~long_drx_cycle_start_offset_v1130_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& sf60_v1130()
    {
      assert_choice_type("sf60-v1130", type_.to_string(), "longDRX-CycleStartOffset-v1130");
      return c.get<uint8_t>();
    }
    uint8_t& sf70_v1130()
    {
      assert_choice_type("sf70-v1130", type_.to_string(), "longDRX-CycleStartOffset-v1130");
      return c.get<uint8_t>();
    }
    const uint8_t& sf60_v1130() const
    {
      assert_choice_type("sf60-v1130", type_.to_string(), "longDRX-CycleStartOffset-v1130");
      return c.get<uint8_t>();
    }
    const uint8_t& sf70_v1130() const
    {
      assert_choice_type("sf70-v1130", type_.to_string(), "longDRX-CycleStartOffset-v1130");
      return c.get<uint8_t>();
    }
    uint8_t& set_sf60_v1130()
    {
      set(types::sf60_v1130);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf70_v1130()
    {
      set(types::sf70_v1130);
      return c.get<uint8_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool                                 drx_retx_timer_v1130_present              = false;
  bool                                 long_drx_cycle_start_offset_v1130_present = false;
  bool                                 short_drx_cycle_v1130_present             = false;
  long_drx_cycle_start_offset_v1130_c_ long_drx_cycle_start_offset_v1130;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRX-Config-v1310 ::= SEQUENCE
struct drx_cfg_v1310_s {
  struct long_drx_cycle_start_offset_v1310_s_ {
    // member variables
    uint8_t sf60_v1310 = 0;
  };

  // member variables
  bool                                 long_drx_cycle_start_offset_v1310_present = false;
  long_drx_cycle_start_offset_v1310_s_ long_drx_cycle_start_offset_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DataInactivityTimer-r14 ::= ENUMERATED
struct data_inactivity_timer_r14_opts {
  enum options { s1, s2, s3, s5, s7, s10, s15, s20, s40, s50, s60, s80, s100, s120, s150, s180, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<data_inactivity_timer_r14_opts> data_inactivity_timer_r14_e;

// EPDCCH-Config-r11 ::= SEQUENCE
struct epdcch_cfg_r11_s {
  struct cfg_r11_c_ {
    struct setup_s_ {
      struct sf_pattern_cfg_r11_c_ {
        struct setup_s_ {
          // member variables
          meas_sf_pattern_r10_c sf_pattern_r11;
        };
        typedef setup_e types;

        // choice methods
        sf_pattern_cfg_r11_c_() = default;
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        setup_s_& setup()
        {
          assert_choice_type("setup", type_.to_string(), "subframePatternConfig-r11");
          return c;
        }
        const setup_s_& setup() const
        {
          assert_choice_type("setup", type_.to_string(), "subframePatternConfig-r11");
          return c;
        }
        setup_s_& set_setup()
        {
          set(types::setup);
          return c;
        }

      private:
        types    type_;
        setup_s_ c;
      };

      // member variables
      bool                                 sf_pattern_cfg_r11_present          = false;
      bool                                 start_symbol_r11_present            = false;
      bool                                 set_cfg_to_release_list_r11_present = false;
      bool                                 set_cfg_to_add_mod_list_r11_present = false;
      sf_pattern_cfg_r11_c_                sf_pattern_cfg_r11;
      uint8_t                              start_symbol_r11 = 1;
      epdcch_set_cfg_to_release_list_r11_l set_cfg_to_release_list_r11;
      epdcch_set_cfg_to_add_mod_list_r11_l set_cfg_to_add_mod_list_r11;
    };
    typedef setup_e types;

    // choice methods
    cfg_r11_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "config-r11");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "config-r11");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  cfg_r11_c_ cfg_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqPriorityEUTRA ::= SEQUENCE
struct freq_prio_eutra_s {
  // member variables
  uint16_t carrier_freq    = 0;
  uint8_t  cell_resel_prio = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqPriorityEUTRA-r12 ::= SEQUENCE
struct freq_prio_eutra_r12_s {
  // member variables
  uint32_t carrier_freq_r12    = 0;
  uint8_t  cell_resel_prio_r12 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqPriorityEUTRA-v1310 ::= SEQUENCE
struct freq_prio_eutra_v1310_s {
  // member variables
  bool                      cell_resel_sub_prio_r13_present = false;
  cell_resel_sub_prio_r13_e cell_resel_sub_prio_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqPriorityNR-r15 ::= SEQUENCE
struct freq_prio_nr_r15_s {
  // member variables
  bool                      cell_resel_sub_prio_r15_present = false;
  uint32_t                  carrier_freq_r15                = 0;
  uint8_t                   cell_resel_prio_r15             = 0;
  cell_resel_sub_prio_r13_e cell_resel_sub_prio_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqPriorityUTRA-FDD ::= SEQUENCE
struct freq_prio_utra_fdd_s {
  // member variables
  uint16_t carrier_freq    = 0;
  uint8_t  cell_resel_prio = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqPriorityUTRA-TDD ::= SEQUENCE
struct freq_prio_utra_tdd_s {
  // member variables
  uint16_t carrier_freq    = 0;
  uint8_t  cell_resel_prio = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqsPriorityGERAN ::= SEQUENCE
struct freqs_prio_geran_s {
  // member variables
  carrier_freqs_geran_s carrier_freqs;
  uint8_t               cell_resel_prio = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighCellsToAddModList-r12 ::= SEQUENCE (SIZE (1..maxNeighCell-r12)) OF NeighCellsInfo-r12
typedef dyn_array<neigh_cells_info_r12_s> neigh_cells_to_add_mod_list_r12_l;

// NeighCellsToReleaseList-r12 ::= SEQUENCE (SIZE (1..maxNeighCell-r12)) OF INTEGER
typedef bounded_array<uint16_t, 8> neigh_cells_to_release_list_r12_l;

// PDCCH-CandidateReductions-r13 ::= CHOICE
struct pdcch_candidate_reductions_r13_c {
  struct setup_s_ {
    // member variables
    pdcch_candidate_reduction_value_r13_e pdcch_candidate_reduction_al1_r13;
    pdcch_candidate_reduction_value_r13_e pdcch_candidate_reduction_al2_r13;
    pdcch_candidate_reduction_value_r13_e pdcch_candidate_reduction_al3_r13;
    pdcch_candidate_reduction_value_r13_e pdcch_candidate_reduction_al4_r13;
    pdcch_candidate_reduction_value_r13_e pdcch_candidate_reduction_al5_r13;
  };
  typedef setup_e types;

  // choice methods
  pdcch_candidate_reductions_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "PDCCH-CandidateReductions-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "PDCCH-CandidateReductions-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// PDSCH-ConfigDedicated ::= SEQUENCE
struct pdsch_cfg_ded_s {
  struct p_a_opts {
    enum options { db_minus6, db_minus4dot77, db_minus3, db_minus1dot77, db0, db1, db2, db3, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<p_a_opts> p_a_e_;

  // member variables
  p_a_e_ p_a;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigDedicated-v1130 ::= SEQUENCE
struct pdsch_cfg_ded_v1130_s {
  struct qcl_operation_opts {
    enum options { type_a, type_b, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<qcl_operation_opts> qcl_operation_e_;

  // member variables
  bool                                 dmrs_cfg_pdsch_r11_present                 = false;
  bool                                 qcl_operation_present                      = false;
  bool                                 re_map_qcl_cfg_to_release_list_r11_present = false;
  bool                                 re_map_qcl_cfg_to_add_mod_list_r11_present = false;
  dmrs_cfg_r11_c                       dmrs_cfg_pdsch_r11;
  qcl_operation_e_                     qcl_operation;
  re_map_qcl_cfg_to_release_list_r11_l re_map_qcl_cfg_to_release_list_r11;
  re_map_qcl_cfg_to_add_mod_list_r11_l re_map_qcl_cfg_to_add_mod_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigDedicated-v1280 ::= SEQUENCE
struct pdsch_cfg_ded_v1280_s {
  struct tbs_idx_alt_r12_opts {
    enum options { a26, a33, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<tbs_idx_alt_r12_opts> tbs_idx_alt_r12_e_;

  // member variables
  bool               tbs_idx_alt_r12_present = false;
  tbs_idx_alt_r12_e_ tbs_idx_alt_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigDedicated-v1310 ::= SEQUENCE
struct pdsch_cfg_ded_v1310_s {
  // member variables
  bool             dmrs_cfg_pdsch_v1310_present = false;
  dmrs_cfg_v1310_s dmrs_cfg_pdsch_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigDedicated-v1430 ::= SEQUENCE
struct pdsch_cfg_ded_v1430_s {
  struct ce_pdsch_max_bw_r14_opts {
    enum options { bw5, bw20, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ce_pdsch_max_bw_r14_opts> ce_pdsch_max_bw_r14_e_;
  struct ce_sched_enhancement_r14_opts {
    enum options { range1, range2, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ce_sched_enhancement_r14_opts> ce_sched_enhancement_r14_e_;

  // member variables
  bool                        ce_pdsch_max_bw_r14_present        = false;
  bool                        ce_pdsch_ten_processes_r14_present = false;
  bool                        ce_harq_ack_bundling_r14_present   = false;
  bool                        ce_sched_enhancement_r14_present   = false;
  bool                        tbs_idx_alt2_r14_present           = false;
  ce_pdsch_max_bw_r14_e_      ce_pdsch_max_bw_r14;
  ce_sched_enhancement_r14_e_ ce_sched_enhancement_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigDedicated-v1530 ::= SEQUENCE
struct pdsch_cfg_ded_v1530_s {
  struct alt_mcs_table_scaling_cfg_r15_opts {
    enum options { o_dot5, o_dot625, o_dot75, o_dot875, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<alt_mcs_table_scaling_cfg_r15_opts> alt_mcs_table_scaling_cfg_r15_e_;

  // member variables
  bool                             qcl_operation_v1530_present                   = false;
  bool                             tbs_idx_alt3_r15_present                      = false;
  bool                             ce_cqi_alternative_table_cfg_r15_present      = false;
  bool                             ce_pdsch_minus64_qam_cfg_r15_present          = false;
  bool                             ce_pdsch_flex_start_prb_alloc_cfg_r15_present = false;
  bool                             alt_mcs_table_scaling_cfg_r15_present         = false;
  alt_mcs_table_scaling_cfg_r15_e_ alt_mcs_table_scaling_cfg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated ::= SEQUENCE
struct pucch_cfg_ded_s {
  struct ack_nack_repeat_c_ {
    struct setup_s_ {
      struct repeat_factor_opts {
        enum options { n2, n4, n6, spare1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<repeat_factor_opts> repeat_factor_e_;

      // member variables
      repeat_factor_e_ repeat_factor;
      uint16_t         n1_pucch_an_rep = 0;
    };
    typedef setup_e types;

    // choice methods
    ack_nack_repeat_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ackNackRepetition");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ackNackRepetition");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct tdd_ack_nack_feedback_mode_opts {
    enum options { bundling, mux, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<tdd_ack_nack_feedback_mode_opts> tdd_ack_nack_feedback_mode_e_;

  // member variables
  bool                          tdd_ack_nack_feedback_mode_present = false;
  ack_nack_repeat_c_            ack_nack_repeat;
  tdd_ack_nack_feedback_mode_e_ tdd_ack_nack_feedback_mode;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated-r13 ::= SEQUENCE
struct pucch_cfg_ded_r13_s {
  struct ack_nack_repeat_r13_c_ {
    struct setup_s_ {
      struct repeat_factor_r13_opts {
        enum options { n2, n4, n6, spare1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<repeat_factor_r13_opts> repeat_factor_r13_e_;

      // member variables
      repeat_factor_r13_e_ repeat_factor_r13;
      uint16_t             n1_pucch_an_rep_r13 = 0;
    };
    typedef setup_e types;

    // choice methods
    ack_nack_repeat_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ackNackRepetition-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ackNackRepetition-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct tdd_ack_nack_feedback_mode_r13_opts {
    enum options { bundling, mux, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<tdd_ack_nack_feedback_mode_r13_opts> tdd_ack_nack_feedback_mode_r13_e_;
  struct pucch_format_r13_c_ {
    struct format3_r13_s_ {
      typedef bounded_array<uint16_t, 4> n3_pucch_an_list_r13_l_;
      struct two_ant_port_activ_pucch_format3_r13_c_ {
        struct setup_s_ {
          typedef bounded_array<uint16_t, 4> n3_pucch_an_list_p1_r13_l_;

          // member variables
          n3_pucch_an_list_p1_r13_l_ n3_pucch_an_list_p1_r13;
        };
        typedef setup_e types;

        // choice methods
        two_ant_port_activ_pucch_format3_r13_c_() = default;
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        setup_s_& setup()
        {
          assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivatedPUCCH-Format3-r13");
          return c;
        }
        const setup_s_& setup() const
        {
          assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivatedPUCCH-Format3-r13");
          return c;
        }
        setup_s_& set_setup()
        {
          set(types::setup);
          return c;
        }

      private:
        types    type_;
        setup_s_ c;
      };

      // member variables
      bool                                    n3_pucch_an_list_r13_present                 = false;
      bool                                    two_ant_port_activ_pucch_format3_r13_present = false;
      n3_pucch_an_list_r13_l_                 n3_pucch_an_list_r13;
      two_ant_port_activ_pucch_format3_r13_c_ two_ant_port_activ_pucch_format3_r13;
    };
    struct ch_sel_r13_s_ {
      struct n1_pucch_an_cs_r13_c_ {
        struct setup_s_ {
          typedef dyn_array<n1_pucch_an_cs_r10_l> n1_pucch_an_cs_list_r13_l_;
          typedef bounded_array<uint16_t, 4>      n1_pucch_an_cs_list_p1_r13_l_;

          // member variables
          n1_pucch_an_cs_list_r13_l_    n1_pucch_an_cs_list_r13;
          n1_pucch_an_cs_list_p1_r13_l_ n1_pucch_an_cs_list_p1_r13;
        };
        typedef setup_e types;

        // choice methods
        n1_pucch_an_cs_r13_c_() = default;
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        setup_s_& setup()
        {
          assert_choice_type("setup", type_.to_string(), "n1PUCCH-AN-CS-r13");
          return c;
        }
        const setup_s_& setup() const
        {
          assert_choice_type("setup", type_.to_string(), "n1PUCCH-AN-CS-r13");
          return c;
        }
        setup_s_& set_setup()
        {
          set(types::setup);
          return c;
        }

      private:
        types    type_;
        setup_s_ c;
      };

      // member variables
      bool                  n1_pucch_an_cs_r13_present = false;
      n1_pucch_an_cs_r13_c_ n1_pucch_an_cs_r13;
    };
    struct format4_r13_s_ {
      typedef fixed_array<format4_res_r13_s, 4> format4_res_cfg_r13_l_;
      typedef dyn_array<format4_res_r13_s>      format4_multi_csi_res_cfg_r13_l_;

      // member variables
      bool                             format4_multi_csi_res_cfg_r13_present = false;
      format4_res_cfg_r13_l_           format4_res_cfg_r13;
      format4_multi_csi_res_cfg_r13_l_ format4_multi_csi_res_cfg_r13;
    };
    struct format5_r13_s_ {
      typedef fixed_array<format5_res_r13_s, 4> format5_res_cfg_r13_l_;

      // member variables
      bool                   format5_multi_csi_res_cfg_r13_present = false;
      format5_res_cfg_r13_l_ format5_res_cfg_r13;
      format5_res_r13_s      format5_multi_csi_res_cfg_r13;
    };
    struct types_opts {
      enum options { format3_r13, ch_sel_r13, format4_r13, format5_r13, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    pucch_format_r13_c_() = default;
    pucch_format_r13_c_(const pucch_format_r13_c_& other);
    pucch_format_r13_c_& operator=(const pucch_format_r13_c_& other);
    ~pucch_format_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    format3_r13_s_& format3_r13()
    {
      assert_choice_type("format3-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<format3_r13_s_>();
    }
    ch_sel_r13_s_& ch_sel_r13()
    {
      assert_choice_type("channelSelection-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<ch_sel_r13_s_>();
    }
    format4_r13_s_& format4_r13()
    {
      assert_choice_type("format4-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<format4_r13_s_>();
    }
    format5_r13_s_& format5_r13()
    {
      assert_choice_type("format5-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<format5_r13_s_>();
    }
    const format3_r13_s_& format3_r13() const
    {
      assert_choice_type("format3-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<format3_r13_s_>();
    }
    const ch_sel_r13_s_& ch_sel_r13() const
    {
      assert_choice_type("channelSelection-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<ch_sel_r13_s_>();
    }
    const format4_r13_s_& format4_r13() const
    {
      assert_choice_type("format4-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<format4_r13_s_>();
    }
    const format5_r13_s_& format5_r13() const
    {
      assert_choice_type("format5-r13", type_.to_string(), "pucch-Format-r13");
      return c.get<format5_r13_s_>();
    }
    format3_r13_s_& set_format3_r13()
    {
      set(types::format3_r13);
      return c.get<format3_r13_s_>();
    }
    ch_sel_r13_s_& set_ch_sel_r13()
    {
      set(types::ch_sel_r13);
      return c.get<ch_sel_r13_s_>();
    }
    format4_r13_s_& set_format4_r13()
    {
      set(types::format4_r13);
      return c.get<format4_r13_s_>();
    }
    format5_r13_s_& set_format5_r13()
    {
      set(types::format5_r13);
      return c.get<format5_r13_s_>();
    }

  private:
    types type_;
    choice_buffer_t<MAX4(sizeof(ch_sel_r13_s_), sizeof(format3_r13_s_), sizeof(format4_r13_s_), sizeof(format5_r13_s_))>
        c;

    void destroy_();
  };
  struct n_pucch_param_r13_c_ {
    struct setup_s_ {
      // member variables
      uint16_t n_pucch_id_r13  = 0;
      uint16_t n1_pucch_an_r13 = 0;
    };
    typedef setup_e types;

    // choice methods
    n_pucch_param_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "nPUCCH-Param-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "nPUCCH-Param-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct nka_pucch_param_r13_c_ {
    struct setup_s_ {
      // member variables
      uint16_t nka_pucch_an_r13 = 0;
    };
    typedef setup_e types;

    // choice methods
    nka_pucch_param_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "nkaPUCCH-Param-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "nkaPUCCH-Param-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct codebooksize_determination_r13_opts {
    enum options { dai, cc, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<codebooksize_determination_r13_opts> codebooksize_determination_r13_e_;
  struct pucch_num_repeat_ce_r13_c_ {
    struct setup_c_ {
      struct mode_a_s_ {
        struct pucch_num_repeat_ce_format1_r13_opts {
          enum options { r1, r2, r4, r8, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<pucch_num_repeat_ce_format1_r13_opts> pucch_num_repeat_ce_format1_r13_e_;
        struct pucch_num_repeat_ce_format2_r13_opts {
          enum options { r1, r2, r4, r8, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<pucch_num_repeat_ce_format2_r13_opts> pucch_num_repeat_ce_format2_r13_e_;

        // member variables
        pucch_num_repeat_ce_format1_r13_e_ pucch_num_repeat_ce_format1_r13;
        pucch_num_repeat_ce_format2_r13_e_ pucch_num_repeat_ce_format2_r13;
      };
      struct mode_b_s_ {
        struct pucch_num_repeat_ce_format1_r13_opts {
          enum options { r4, r8, r16, r32, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<pucch_num_repeat_ce_format1_r13_opts> pucch_num_repeat_ce_format1_r13_e_;
        struct pucch_num_repeat_ce_format2_r13_opts {
          enum options { r4, r8, r16, r32, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<pucch_num_repeat_ce_format2_r13_opts> pucch_num_repeat_ce_format2_r13_e_;

        // member variables
        pucch_num_repeat_ce_format1_r13_e_ pucch_num_repeat_ce_format1_r13;
        pucch_num_repeat_ce_format2_r13_e_ pucch_num_repeat_ce_format2_r13;
      };
      struct types_opts {
        enum options { mode_a, mode_b, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      mode_a_s_& mode_a()
      {
        assert_choice_type("modeA", type_.to_string(), "setup");
        return c.get<mode_a_s_>();
      }
      mode_b_s_& mode_b()
      {
        assert_choice_type("modeB", type_.to_string(), "setup");
        return c.get<mode_b_s_>();
      }
      const mode_a_s_& mode_a() const
      {
        assert_choice_type("modeA", type_.to_string(), "setup");
        return c.get<mode_a_s_>();
      }
      const mode_b_s_& mode_b() const
      {
        assert_choice_type("modeB", type_.to_string(), "setup");
        return c.get<mode_b_s_>();
      }
      mode_a_s_& set_mode_a()
      {
        set(types::mode_a);
        return c.get<mode_a_s_>();
      }
      mode_b_s_& set_mode_b()
      {
        set(types::mode_b);
        return c.get<mode_b_s_>();
      }

    private:
      types                                                       type_;
      choice_buffer_t<MAX2(sizeof(mode_a_s_), sizeof(mode_b_s_))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    pucch_num_repeat_ce_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "pucch-NumRepetitionCE-r13");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "pucch-NumRepetitionCE-r13");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };

  // member variables
  bool                              tdd_ack_nack_feedback_mode_r13_present          = false;
  bool                              pucch_format_r13_present                        = false;
  bool                              two_ant_port_activ_pucch_format1a1b_r13_present = false;
  bool                              simul_pucch_pusch_r13_present                   = false;
  bool                              n1_pucch_an_rep_p1_r13_present                  = false;
  bool                              n_pucch_param_r13_present                       = false;
  bool                              nka_pucch_param_r13_present                     = false;
  bool                              codebooksize_determination_r13_present          = false;
  bool                              maximum_payload_coderate_r13_present            = false;
  bool                              pucch_num_repeat_ce_r13_present                 = false;
  ack_nack_repeat_r13_c_            ack_nack_repeat_r13;
  tdd_ack_nack_feedback_mode_r13_e_ tdd_ack_nack_feedback_mode_r13;
  pucch_format_r13_c_               pucch_format_r13;
  uint16_t                          n1_pucch_an_rep_p1_r13 = 0;
  n_pucch_param_r13_c_              n_pucch_param_r13;
  nka_pucch_param_r13_c_            nka_pucch_param_r13;
  bool                              spatial_bundling_pucch_r13 = false;
  bool                              spatial_bundling_pusch_r13 = false;
  bool                              harq_timing_tdd_r13        = false;
  codebooksize_determination_r13_e_ codebooksize_determination_r13;
  uint8_t                           maximum_payload_coderate_r13 = 0;
  pucch_num_repeat_ce_r13_c_        pucch_num_repeat_ce_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated-v1020 ::= SEQUENCE
struct pucch_cfg_ded_v1020_s {
  struct pucch_format_r10_c_ {
    struct ch_sel_r10_s_ {
      struct n1_pucch_an_cs_r10_c_ {
        struct setup_s_ {
          typedef dyn_array<n1_pucch_an_cs_r10_l> n1_pucch_an_cs_list_r10_l_;

          // member variables
          n1_pucch_an_cs_list_r10_l_ n1_pucch_an_cs_list_r10;
        };
        typedef setup_e types;

        // choice methods
        n1_pucch_an_cs_r10_c_() = default;
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        setup_s_& setup()
        {
          assert_choice_type("setup", type_.to_string(), "n1PUCCH-AN-CS-r10");
          return c;
        }
        const setup_s_& setup() const
        {
          assert_choice_type("setup", type_.to_string(), "n1PUCCH-AN-CS-r10");
          return c;
        }
        setup_s_& set_setup()
        {
          set(types::setup);
          return c;
        }

      private:
        types    type_;
        setup_s_ c;
      };

      // member variables
      bool                  n1_pucch_an_cs_r10_present = false;
      n1_pucch_an_cs_r10_c_ n1_pucch_an_cs_r10;
    };
    struct types_opts {
      enum options { format3_r10, ch_sel_r10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    pucch_format_r10_c_() = default;
    pucch_format_r10_c_(const pucch_format_r10_c_& other);
    pucch_format_r10_c_& operator=(const pucch_format_r10_c_& other);
    ~pucch_format_r10_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    pucch_format3_conf_r13_s& format3_r10()
    {
      assert_choice_type("format3-r10", type_.to_string(), "pucch-Format-r10");
      return c.get<pucch_format3_conf_r13_s>();
    }
    ch_sel_r10_s_& ch_sel_r10()
    {
      assert_choice_type("channelSelection-r10", type_.to_string(), "pucch-Format-r10");
      return c.get<ch_sel_r10_s_>();
    }
    const pucch_format3_conf_r13_s& format3_r10() const
    {
      assert_choice_type("format3-r10", type_.to_string(), "pucch-Format-r10");
      return c.get<pucch_format3_conf_r13_s>();
    }
    const ch_sel_r10_s_& ch_sel_r10() const
    {
      assert_choice_type("channelSelection-r10", type_.to_string(), "pucch-Format-r10");
      return c.get<ch_sel_r10_s_>();
    }
    pucch_format3_conf_r13_s& set_format3_r10()
    {
      set(types::format3_r10);
      return c.get<pucch_format3_conf_r13_s>();
    }
    ch_sel_r10_s_& set_ch_sel_r10()
    {
      set(types::ch_sel_r10);
      return c.get<ch_sel_r10_s_>();
    }

  private:
    types                                                                          type_;
    choice_buffer_t<MAX2(sizeof(ch_sel_r10_s_), sizeof(pucch_format3_conf_r13_s))> c;

    void destroy_();
  };

  // member variables
  bool                pucch_format_r10_present                        = false;
  bool                two_ant_port_activ_pucch_format1a1b_r10_present = false;
  bool                simul_pucch_pusch_r10_present                   = false;
  bool                n1_pucch_an_rep_p1_r10_present                  = false;
  pucch_format_r10_c_ pucch_format_r10;
  uint16_t            n1_pucch_an_rep_p1_r10 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated-v1130 ::= SEQUENCE
struct pucch_cfg_ded_v1130_s {
  struct n1_pucch_an_cs_v1130_c_ {
    struct setup_s_ {
      typedef bounded_array<uint16_t, 4> n1_pucch_an_cs_list_p1_r11_l_;

      // member variables
      n1_pucch_an_cs_list_p1_r11_l_ n1_pucch_an_cs_list_p1_r11;
    };
    typedef setup_e types;

    // choice methods
    n1_pucch_an_cs_v1130_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "n1PUCCH-AN-CS-v1130");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "n1PUCCH-AN-CS-v1130");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct n_pucch_param_r11_c_ {
    struct setup_s_ {
      // member variables
      uint16_t n_pucch_id_r11  = 0;
      uint16_t n1_pucch_an_r11 = 0;
    };
    typedef setup_e types;

    // choice methods
    n_pucch_param_r11_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "nPUCCH-Param-r11");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "nPUCCH-Param-r11");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                    n1_pucch_an_cs_v1130_present = false;
  bool                    n_pucch_param_r11_present    = false;
  n1_pucch_an_cs_v1130_c_ n1_pucch_an_cs_v1130;
  n_pucch_param_r11_c_    n_pucch_param_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated-v1250 ::= SEQUENCE
struct pucch_cfg_ded_v1250_s {
  struct nka_pucch_param_r12_c_ {
    struct setup_s_ {
      // member variables
      uint16_t nka_pucch_an_r12 = 0;
    };
    typedef setup_e types;

    // choice methods
    nka_pucch_param_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "nkaPUCCH-Param-r12");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "nkaPUCCH-Param-r12");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  nka_pucch_param_r12_c_ nka_pucch_param_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated-v1430 ::= SEQUENCE
struct pucch_cfg_ded_v1430_s {
  struct pucch_num_repeat_ce_format1_r14_opts {
    enum options { r64, r128, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pucch_num_repeat_ce_format1_r14_opts> pucch_num_repeat_ce_format1_r14_e_;

  // member variables
  bool                               pucch_num_repeat_ce_format1_r14_present = false;
  pucch_num_repeat_ce_format1_r14_e_ pucch_num_repeat_ce_format1_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicated ::= SEQUENCE
struct pusch_cfg_ded_s {
  // member variables
  uint8_t beta_offset_ack_idx = 0;
  uint8_t beta_offset_ri_idx  = 0;
  uint8_t beta_offset_cqi_idx = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicated-r13 ::= SEQUENCE
struct pusch_cfg_ded_r13_s {
  struct beta_offset_mc_r13_s_ {
    // member variables
    bool    beta_offset2_ack_idx_mc_r13_present = false;
    uint8_t beta_offset_ack_idx_mc_r13          = 0;
    uint8_t beta_offset2_ack_idx_mc_r13         = 0;
    uint8_t beta_offset_ri_idx_mc_r13           = 0;
    uint8_t beta_offset_cqi_idx_mc_r13          = 0;
  };
  struct pusch_dmrs_r11_c_ {
    struct setup_s_ {
      // member variables
      uint16_t n_pusch_id_r13    = 0;
      uint16_t n_dmrs_csh_id_r13 = 0;
    };
    typedef setup_e types;

    // choice methods
    pusch_dmrs_r11_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "pusch-DMRS-r11");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "pusch-DMRS-r11");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct uci_on_pusch_c_ {
    struct setup_s_ {
      struct beta_offset_mc_r12_s_ {
        // member variables
        bool    beta_offset2_ack_idx_mc_sf_set2_r13_present = false;
        uint8_t beta_offset_ack_idx_mc_sf_set2_r13          = 0;
        uint8_t beta_offset2_ack_idx_mc_sf_set2_r13         = 0;
        uint8_t beta_offset_ri_idx_mc_sf_set2_r13           = 0;
        uint8_t beta_offset_cqi_idx_mc_sf_set2_r13          = 0;
      };

      // member variables
      bool                  beta_offset2_ack_idx_sf_set2_r13_present = false;
      bool                  beta_offset_mc_r12_present               = false;
      uint8_t               beta_offset_ack_idx_sf_set2_r13          = 0;
      uint8_t               beta_offset2_ack_idx_sf_set2_r13         = 0;
      uint8_t               beta_offset_ri_idx_sf_set2_r13           = 0;
      uint8_t               beta_offset_cqi_idx_sf_set2_r13          = 0;
      beta_offset_mc_r12_s_ beta_offset_mc_r12;
    };
    typedef setup_e types;

    // choice methods
    uci_on_pusch_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "uciOnPUSCH");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "uciOnPUSCH");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                  beta_offset2_ack_idx_r13_present = false;
  bool                  beta_offset_mc_r13_present       = false;
  bool                  group_hop_disabled_r13_present   = false;
  bool                  dmrs_with_occ_activ_r13_present  = false;
  bool                  pusch_dmrs_r11_present           = false;
  bool                  uci_on_pusch_present             = false;
  bool                  pusch_hop_cfg_r13_present        = false;
  uint8_t               beta_offset_ack_idx_r13          = 0;
  uint8_t               beta_offset2_ack_idx_r13         = 0;
  uint8_t               beta_offset_ri_idx_r13           = 0;
  uint8_t               beta_offset_cqi_idx_r13          = 0;
  beta_offset_mc_r13_s_ beta_offset_mc_r13;
  pusch_dmrs_r11_c_     pusch_dmrs_r11;
  uci_on_pusch_c_       uci_on_pusch;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicated-v1020 ::= SEQUENCE
struct pusch_cfg_ded_v1020_s {
  struct beta_offset_mc_r10_s_ {
    // member variables
    uint8_t beta_offset_ack_idx_mc_r10 = 0;
    uint8_t beta_offset_ri_idx_mc_r10  = 0;
    uint8_t beta_offset_cqi_idx_mc_r10 = 0;
  };

  // member variables
  bool                  beta_offset_mc_r10_present      = false;
  bool                  group_hop_disabled_r10_present  = false;
  bool                  dmrs_with_occ_activ_r10_present = false;
  beta_offset_mc_r10_s_ beta_offset_mc_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicated-v1130 ::= SEQUENCE
struct pusch_cfg_ded_v1130_s {
  struct pusch_dmrs_r11_c_ {
    struct setup_s_ {
      // member variables
      uint16_t n_pusch_id_r11    = 0;
      uint16_t n_dmrs_csh_id_r11 = 0;
    };
    typedef setup_e types;

    // choice methods
    pusch_dmrs_r11_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "pusch-DMRS-r11");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "pusch-DMRS-r11");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  pusch_dmrs_r11_c_ pusch_dmrs_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicated-v1250 ::= SEQUENCE
struct pusch_cfg_ded_v1250_s {
  struct uci_on_pusch_c_ {
    struct setup_s_ {
      struct beta_offset_mc_r12_s_ {
        // member variables
        uint8_t beta_offset_ack_idx_mc_sf_set2_r12 = 0;
        uint8_t beta_offset_ri_idx_mc_sf_set2_r12  = 0;
        uint8_t beta_offset_cqi_idx_mc_sf_set2_r12 = 0;
      };

      // member variables
      bool                  beta_offset_mc_r12_present      = false;
      uint8_t               beta_offset_ack_idx_sf_set2_r12 = 0;
      uint8_t               beta_offset_ri_idx_sf_set2_r12  = 0;
      uint8_t               beta_offset_cqi_idx_sf_set2_r12 = 0;
      beta_offset_mc_r12_s_ beta_offset_mc_r12;
    };
    typedef setup_e types;

    // choice methods
    uci_on_pusch_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "uciOnPUSCH");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "uciOnPUSCH");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  uci_on_pusch_c_ uci_on_pusch;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicated-v1430 ::= SEQUENCE
struct pusch_cfg_ded_v1430_s {
  // member variables
  bool                   ce_pusch_nb_max_tbs_r14_present = false;
  bool                   ce_pusch_max_bw_r14_present     = false;
  bool                   tdd_pusch_up_pts_r14_present    = false;
  bool                   enable256_qam_r14_present       = false;
  tdd_pusch_up_pts_r14_c tdd_pusch_up_pts_r14;
  bool                   ul_dmrs_ifdma_r14 = false;
  enable256_qam_r14_c    enable256_qam_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicated-v1530 ::= SEQUENCE
struct pusch_cfg_ded_v1530_s {
  struct ce_pusch_flex_start_prb_alloc_cfg_r15_c_ {
    struct setup_s_ {
      // member variables
      bool   offset_ce_mode_b_r15_present = false;
      int8_t offset_ce_mode_b_r15         = -1;
    };
    typedef setup_e types;

    // choice methods
    ce_pusch_flex_start_prb_alloc_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ce-PUSCH-FlexibleStartPRB-AllocConfig-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ce-PUSCH-FlexibleStartPRB-AllocConfig-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct ce_pusch_sub_prb_cfg_r15_c_ {
    struct setup_s_ {
      // member variables
      bool    location_ce_mode_b_r15_present = false;
      uint8_t location_ce_mode_b_r15         = 0;
      uint8_t six_tone_cyclic_shift_r15      = 0;
      uint8_t three_tone_cyclic_shift_r15    = 0;
    };
    typedef setup_e types;

    // choice methods
    ce_pusch_sub_prb_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ce-PUSCH-SubPRB-Config-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ce-PUSCH-SubPRB-Config-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                                     ce_pusch_sub_prb_cfg_r15_present = false;
  ce_pusch_flex_start_prb_alloc_cfg_r15_c_ ce_pusch_flex_start_prb_alloc_cfg_r15;
  ce_pusch_sub_prb_cfg_r15_c_              ce_pusch_sub_prb_cfg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-EnhancementsConfig-r14 ::= CHOICE
struct pusch_enhance_cfg_r14_c {
  struct setup_s_ {
    struct interv_ul_hop_pusch_enh_r14_c_ {
      struct interv_fdd_pusch_enh_r14_opts {
        enum options { int1, int2, int4, int8, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<interv_fdd_pusch_enh_r14_opts> interv_fdd_pusch_enh_r14_e_;
      struct interv_tdd_pusch_enh_r14_opts {
        enum options { int1, int5, int10, int20, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<interv_tdd_pusch_enh_r14_opts> interv_tdd_pusch_enh_r14_e_;
      struct types_opts {
        enum options { interv_fdd_pusch_enh_r14, interv_tdd_pusch_enh_r14, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      interv_ul_hop_pusch_enh_r14_c_() = default;
      interv_ul_hop_pusch_enh_r14_c_(const interv_ul_hop_pusch_enh_r14_c_& other);
      interv_ul_hop_pusch_enh_r14_c_& operator=(const interv_ul_hop_pusch_enh_r14_c_& other);
      ~interv_ul_hop_pusch_enh_r14_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      interv_fdd_pusch_enh_r14_e_& interv_fdd_pusch_enh_r14()
      {
        assert_choice_type("interval-FDD-PUSCH-Enh-r14", type_.to_string(), "interval-ULHoppingPUSCH-Enh-r14");
        return c.get<interv_fdd_pusch_enh_r14_e_>();
      }
      interv_tdd_pusch_enh_r14_e_& interv_tdd_pusch_enh_r14()
      {
        assert_choice_type("interval-TDD-PUSCH-Enh-r14", type_.to_string(), "interval-ULHoppingPUSCH-Enh-r14");
        return c.get<interv_tdd_pusch_enh_r14_e_>();
      }
      const interv_fdd_pusch_enh_r14_e_& interv_fdd_pusch_enh_r14() const
      {
        assert_choice_type("interval-FDD-PUSCH-Enh-r14", type_.to_string(), "interval-ULHoppingPUSCH-Enh-r14");
        return c.get<interv_fdd_pusch_enh_r14_e_>();
      }
      const interv_tdd_pusch_enh_r14_e_& interv_tdd_pusch_enh_r14() const
      {
        assert_choice_type("interval-TDD-PUSCH-Enh-r14", type_.to_string(), "interval-ULHoppingPUSCH-Enh-r14");
        return c.get<interv_tdd_pusch_enh_r14_e_>();
      }
      interv_fdd_pusch_enh_r14_e_& set_interv_fdd_pusch_enh_r14()
      {
        set(types::interv_fdd_pusch_enh_r14);
        return c.get<interv_fdd_pusch_enh_r14_e_>();
      }
      interv_tdd_pusch_enh_r14_e_& set_interv_tdd_pusch_enh_r14()
      {
        set(types::interv_tdd_pusch_enh_r14);
        return c.get<interv_tdd_pusch_enh_r14_e_>();
      }

    private:
      types                                                                                           type_;
      choice_buffer_t<MAX2(sizeof(interv_fdd_pusch_enh_r14_e_), sizeof(interv_tdd_pusch_enh_r14_e_))> c;

      void destroy_();
    };

    // member variables
    bool                           pusch_hop_offset_pusch_enh_r14_present = false;
    bool                           interv_ul_hop_pusch_enh_r14_present    = false;
    uint8_t                        pusch_hop_offset_pusch_enh_r14         = 1;
    interv_ul_hop_pusch_enh_r14_c_ interv_ul_hop_pusch_enh_r14;
  };
  typedef setup_e types;

  // choice methods
  pusch_enhance_cfg_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "PUSCH-EnhancementsConfig-r14");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "PUSCH-EnhancementsConfig-r14");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// PeriodicBSR-Timer-r12 ::= ENUMERATED
struct periodic_bsr_timer_r12_opts {
  enum options {
    sf5,
    sf10,
    sf16,
    sf20,
    sf32,
    sf40,
    sf64,
    sf80,
    sf128,
    sf160,
    sf320,
    sf640,
    sf1280,
    sf2560,
    infinity,
    spare1,
    nulltype
  } value;
  typedef int16_t number_type;

  std::string to_string() const;
  int16_t     to_number() const;
};
typedef enumerated<periodic_bsr_timer_r12_opts> periodic_bsr_timer_r12_e;

// PhysicalConfigDedicatedSTTI-r15 ::= CHOICE
struct phys_cfg_ded_stti_r15_c {
  struct setup_s_ {
    // member variables
    bool                                 ant_info_ded_stti_r15_present              = false;
    bool                                 ant_info_ul_stti_r15_present               = false;
    bool                                 pucch_cfg_ded_v1530_present                = false;
    bool                                 sched_request_cfg_v1530_present            = false;
    bool                                 ul_pwr_ctrl_ded_stti_r15_present           = false;
    bool                                 cqi_report_cfg_r15_present                 = false;
    bool                                 csi_rs_cfg_r15_present                     = false;
    bool                                 csi_rs_cfg_nzp_to_release_list_r15_present = false;
    bool                                 csi_rs_cfg_nzp_to_add_mod_list_r15_present = false;
    bool                                 csi_rs_cfg_zp_to_release_list_r15_present  = false;
    bool                                 csi_rs_cfg_zp_to_add_mod_list_r11_present  = false;
    bool                                 csi_rs_cfg_zp_ap_list_r15_present          = false;
    bool                                 eimta_main_cfg_r12_present                 = false;
    bool                                 eimta_main_cfg_serv_cell_r15_present       = false;
    bool                                 slot_or_subslot_pdsch_cfg_r15_present      = false;
    bool                                 slot_or_subslot_pusch_cfg_r15_present      = false;
    bool                                 spdcch_cfg_r15_present                     = false;
    bool                                 spucch_cfg_r15_present                     = false;
    bool                                 short_tti_r15_present                      = false;
    ant_info_ded_stti_r15_c              ant_info_ded_stti_r15;
    ant_info_ul_stti_r15_s               ant_info_ul_stti_r15;
    pucch_cfg_ded_v1530_s                pucch_cfg_ded_v1530;
    sched_request_cfg_v1530_c            sched_request_cfg_v1530;
    ul_pwr_ctrl_ded_stti_r15_s           ul_pwr_ctrl_ded_stti_r15;
    cqi_report_cfg_r15_c                 cqi_report_cfg_r15;
    csi_rs_cfg_r15_c                     csi_rs_cfg_r15;
    csi_rs_cfg_nzp_to_release_list_r15_l csi_rs_cfg_nzp_to_release_list_r15;
    csi_rs_cfg_nzp_to_add_mod_list_r15_l csi_rs_cfg_nzp_to_add_mod_list_r15;
    csi_rs_cfg_zp_to_release_list_r11_l  csi_rs_cfg_zp_to_release_list_r15;
    csi_rs_cfg_zp_to_add_mod_list_r11_l  csi_rs_cfg_zp_to_add_mod_list_r11;
    csi_rs_cfg_zp_ap_list_r14_c          csi_rs_cfg_zp_ap_list_r15;
    eimta_main_cfg_r12_c                 eimta_main_cfg_r12;
    eimta_main_cfg_serv_cell_r12_c       eimta_main_cfg_serv_cell_r15;
    bool                                 semi_open_loop_stti_r15 = false;
    slot_or_subslot_pdsch_cfg_r15_c      slot_or_subslot_pdsch_cfg_r15;
    slot_or_subslot_pusch_cfg_r15_c      slot_or_subslot_pusch_cfg_r15;
    spdcch_cfg_r15_c                     spdcch_cfg_r15;
    spucch_cfg_r15_c                     spucch_cfg_r15;
    bool                                 srs_dci7_triggering_cfg_r15 = false;
    bool                                 short_processing_time_r15   = false;
    short_tti_r15_s                      short_tti_r15;
  };
  typedef setup_e types;

  // choice methods
  phys_cfg_ded_stti_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "PhysicalConfigDedicatedSTTI-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "PhysicalConfigDedicatedSTTI-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RRCConnectionReject-v1130-IEs ::= SEQUENCE
struct rrc_conn_reject_v1130_ies_s {
  struct depriorit_req_r11_s_ {
    struct depriorit_type_r11_opts {
      enum options { freq, e_utra, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<depriorit_type_r11_opts> depriorit_type_r11_e_;
    struct depriorit_timer_r11_opts {
      enum options { min5, min10, min15, min30, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<depriorit_timer_r11_opts> depriorit_timer_r11_e_;

    // member variables
    depriorit_type_r11_e_  depriorit_type_r11;
    depriorit_timer_r11_e_ depriorit_timer_r11;
  };

  // member variables
  bool                        depriorit_req_r11_present = false;
  bool                        non_crit_ext_present      = false;
  depriorit_req_r11_s_        depriorit_req_r11;
  rrc_conn_reject_v1320_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RetxBSR-Timer-r12 ::= ENUMERATED
struct retx_bsr_timer_r12_opts {
  enum options { sf320, sf640, sf1280, sf2560, sf5120, sf10240, spare2, spare1, nulltype } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<retx_bsr_timer_r12_opts> retx_bsr_timer_r12_e;

// SPS-ConfigDL ::= CHOICE
struct sps_cfg_dl_c {
  struct setup_s_ {
    struct semi_persist_sched_interv_dl_opts {
      enum options {
        sf10,
        sf20,
        sf32,
        sf40,
        sf64,
        sf80,
        sf128,
        sf160,
        sf320,
        sf640,
        spare6,
        spare5,
        spare4,
        spare3,
        spare2,
        spare1,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<semi_persist_sched_interv_dl_opts> semi_persist_sched_interv_dl_e_;
    struct two_ant_port_activ_r10_c_ {
      struct setup_s_ {
        // member variables
        n1_pucch_an_persistent_list_l n1_pucch_an_persistent_list_p1_r10;
      };
      typedef setup_e types;

      // choice methods
      two_ant_port_activ_r10_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivated-r10");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivated-r10");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                            ext = false;
    semi_persist_sched_interv_dl_e_ semi_persist_sched_interv_dl;
    uint8_t                         nof_conf_sps_processes = 1;
    n1_pucch_an_persistent_list_l   n1_pucch_an_persistent_list;
    // ...
    // group 0
    bool                                two_ant_port_activ_r10_present = false;
    copy_ptr<two_ant_port_activ_r10_c_> two_ant_port_activ_r10;

    // sequence methods
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
  };
  typedef setup_e types;

  // choice methods
  sps_cfg_dl_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigDL");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigDL");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SPS-ConfigSL-ToAddModList-r14 ::= SEQUENCE (SIZE (1..maxConfigSPS-r14)) OF SPS-ConfigSL-r14
typedef dyn_array<sps_cfg_sl_r14_s> sps_cfg_sl_to_add_mod_list_r14_l;

// SPS-ConfigSL-ToReleaseList-r14 ::= SEQUENCE (SIZE (1..maxConfigSPS-r14)) OF INTEGER
typedef bounded_array<uint8_t, 8> sps_cfg_sl_to_release_list_r14_l;

// SPS-ConfigUL-STTI-ToAddModList-r15 ::= SEQUENCE (SIZE (1..maxConfigSPS-r15)) OF SPS-ConfigUL-STTI-r15
typedef dyn_array<sps_cfg_ul_stti_r15_c> sps_cfg_ul_stti_to_add_mod_list_r15_l;

// SPS-ConfigUL-STTI-ToReleaseList-r15 ::= SEQUENCE (SIZE (1..maxConfigSPS-r15)) OF INTEGER
typedef bounded_array<uint8_t, 6> sps_cfg_ul_stti_to_release_list_r15_l;

// SPS-ConfigUL-ToAddModList-r14 ::= SEQUENCE (SIZE (1..maxConfigSPS-r14)) OF SPS-ConfigUL
typedef dyn_array<sps_cfg_ul_c> sps_cfg_ul_to_add_mod_list_r14_l;

// SPS-ConfigUL-ToAddModList-r15 ::= SEQUENCE (SIZE (1..maxConfigSPS-r15)) OF SPS-ConfigUL
typedef dyn_array<sps_cfg_ul_c> sps_cfg_ul_to_add_mod_list_r15_l;

// SPS-ConfigUL-ToReleaseList-r14 ::= SEQUENCE (SIZE (1..maxConfigSPS-r14)) OF INTEGER
typedef bounded_array<uint8_t, 8> sps_cfg_ul_to_release_list_r14_l;

// SPS-ConfigUL-ToReleaseList-r15 ::= SEQUENCE (SIZE (1..maxConfigSPS-r15)) OF INTEGER
typedef bounded_array<uint8_t, 6> sps_cfg_ul_to_release_list_r15_l;

// SRB-ToAddMod ::= SEQUENCE
struct srb_to_add_mod_s {
  struct rlc_cfg_c_ {
    struct types_opts {
      enum options { explicit_value, default_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    rlc_cfg_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rlc_cfg_c& explicit_value()
    {
      assert_choice_type("explicitValue", type_.to_string(), "rlc-Config");
      return c;
    }
    const rlc_cfg_c& explicit_value() const
    {
      assert_choice_type("explicitValue", type_.to_string(), "rlc-Config");
      return c;
    }
    rlc_cfg_c& set_explicit_value()
    {
      set(types::explicit_value);
      return c;
    }

  private:
    types     type_;
    rlc_cfg_c c;
  };
  struct lc_ch_cfg_c_ {
    struct types_opts {
      enum options { explicit_value, default_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    lc_ch_cfg_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    lc_ch_cfg_s& explicit_value()
    {
      assert_choice_type("explicitValue", type_.to_string(), "logicalChannelConfig");
      return c;
    }
    const lc_ch_cfg_s& explicit_value() const
    {
      assert_choice_type("explicitValue", type_.to_string(), "logicalChannelConfig");
      return c;
    }
    lc_ch_cfg_s& set_explicit_value()
    {
      set(types::explicit_value);
      return c;
    }

  private:
    types       type_;
    lc_ch_cfg_s c;
  };

  // member variables
  bool         ext               = false;
  bool         rlc_cfg_present   = false;
  bool         lc_ch_cfg_present = false;
  uint8_t      srb_id            = 1;
  rlc_cfg_c_   rlc_cfg;
  lc_ch_cfg_c_ lc_ch_cfg;
  // ...
  // group 0
  bool                           pdcp_ver_change_r15_present     = false;
  bool                           rlc_cfg_v1530_present           = false;
  bool                           rlc_bearer_cfg_dupl_r15_present = false;
  bool                           srb_id_v1530_present            = false;
  copy_ptr<rlc_cfg_v1530_c>      rlc_cfg_v1530;
  copy_ptr<rlc_bearer_cfg_r15_c> rlc_bearer_cfg_dupl_r15;
  uint8_t                        srb_id_v1530 = 4;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRS-TPC-PDCCH-Config-r14 ::= CHOICE
struct srs_tpc_pdcch_cfg_r14_c {
  struct setup_s_ {
    typedef dyn_array<srs_cc_set_idx_r14_s> srs_cc_set_idxlist_r14_l_;

    // member variables
    bool                      srs_cc_set_idxlist_r14_present = false;
    fixed_bitstring<16>       srs_tpc_rnti_r14;
    uint8_t                   start_bit_of_format3_b_r14 = 0;
    uint8_t                   field_type_format3_b_r14   = 1;
    srs_cc_set_idxlist_r14_l_ srs_cc_set_idxlist_r14;
  };
  typedef setup_e types;

  // choice methods
  srs_tpc_pdcch_cfg_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SRS-TPC-PDCCH-Config-r14");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SRS-TPC-PDCCH-Config-r14");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// STAG-ToAddModList-r11 ::= SEQUENCE (SIZE (1..maxSTAG-r11)) OF STAG-ToAddMod-r11
typedef dyn_array<stag_to_add_mod_r11_s> stag_to_add_mod_list_r11_l;

// STAG-ToReleaseList-r11 ::= SEQUENCE (SIZE (1..maxSTAG-r11)) OF INTEGER
typedef bounded_array<uint8_t, 3> stag_to_release_list_r11_l;

// SchedulingRequestConfig ::= CHOICE
struct sched_request_cfg_c {
  struct setup_s_ {
    struct dsr_trans_max_opts {
      enum options { n4, n8, n16, n32, n64, spare3, spare2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<dsr_trans_max_opts> dsr_trans_max_e_;

    // member variables
    uint16_t         sr_pucch_res_idx = 0;
    uint8_t          sr_cfg_idx       = 0;
    dsr_trans_max_e_ dsr_trans_max;
  };
  typedef setup_e types;

  // choice methods
  sched_request_cfg_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SchedulingRequestConfig");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SchedulingRequestConfig");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SchedulingRequestConfig-v1020 ::= SEQUENCE
struct sched_request_cfg_v1020_s {
  // member variables
  bool     sr_pucch_res_idx_p1_r10_present = false;
  uint16_t sr_pucch_res_idx_p1_r10         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SoundingRS-UL-ConfigDedicated ::= CHOICE
struct srs_ul_cfg_ded_c {
  struct setup_s_ {
    struct srs_bw_opts {
      enum options { bw0, bw1, bw2, bw3, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_bw_opts> srs_bw_e_;
    struct srs_hop_bw_opts {
      enum options { hbw0, hbw1, hbw2, hbw3, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_hop_bw_opts> srs_hop_bw_e_;
    struct cyclic_shift_opts {
      enum options { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<cyclic_shift_opts> cyclic_shift_e_;

    // member variables
    srs_bw_e_       srs_bw;
    srs_hop_bw_e_   srs_hop_bw;
    uint8_t         freq_domain_position = 0;
    bool            dur                  = false;
    uint16_t        srs_cfg_idx          = 0;
    uint8_t         tx_comb              = 0;
    cyclic_shift_e_ cyclic_shift;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_ded_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicated");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicated");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SoundingRS-UL-ConfigDedicated-v1020 ::= SEQUENCE
struct srs_ul_cfg_ded_v1020_s {
  // member variables
  srs_ant_port_e srs_ant_port_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SoundingRS-UL-ConfigDedicated-v1310 ::= CHOICE
struct srs_ul_cfg_ded_v1310_c {
  struct setup_s_ {
    struct cyclic_shift_v1310_opts {
      enum options { cs8, cs9, cs10, cs11, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<cyclic_shift_v1310_opts> cyclic_shift_v1310_e_;
    struct tx_comb_num_r13_opts {
      enum options { n2, n4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tx_comb_num_r13_opts> tx_comb_num_r13_e_;

    // member variables
    bool                  tx_comb_v1310_present      = false;
    bool                  cyclic_shift_v1310_present = false;
    bool                  tx_comb_num_r13_present    = false;
    uint8_t               tx_comb_v1310              = 2;
    cyclic_shift_v1310_e_ cyclic_shift_v1310;
    tx_comb_num_r13_e_    tx_comb_num_r13;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_ded_v1310_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicated-v1310");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicated-v1310");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SoundingRS-UL-ConfigDedicatedAperiodic-r10 ::= CHOICE
struct srs_ul_cfg_ded_aperiodic_r10_c {
  struct setup_s_ {
    typedef dyn_array<srs_cfg_ap_r10_s> srs_cfg_ap_dci_format4_r10_l_;
    struct srs_activ_ap_r10_c_ {
      struct setup_s_ {
        // member variables
        bool             ext = false;
        srs_cfg_ap_r10_s srs_cfg_ap_dci_format0_r10;
        srs_cfg_ap_r10_s srs_cfg_ap_dci_format1a2b2c_r10;
        // ...
      };
      typedef setup_e types;

      // choice methods
      srs_activ_ap_r10_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "srs-ActivateAp-r10");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "srs-ActivateAp-r10");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                          srs_cfg_ap_dci_format4_r10_present = false;
    bool                          srs_activ_ap_r10_present           = false;
    uint8_t                       srs_cfg_idx_ap_r10                 = 0;
    srs_cfg_ap_dci_format4_r10_l_ srs_cfg_ap_dci_format4_r10;
    srs_activ_ap_r10_c_           srs_activ_ap_r10;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_ded_aperiodic_r10_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodic-r10");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodic-r10");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SoundingRS-UL-ConfigDedicatedAperiodic-v1310 ::= CHOICE
struct srs_ul_cfg_ded_aperiodic_v1310_c {
  struct setup_s_ {
    typedef dyn_array<srs_cfg_ap_v1310_s> srs_cfg_ap_dci_format4_v1310_l_;
    struct srs_activ_ap_v1310_c_ {
      struct setup_s_ {
        // member variables
        bool               srs_cfg_ap_dci_format0_v1310_present      = false;
        bool               srs_cfg_ap_dci_format1a2b2c_v1310_present = false;
        srs_cfg_ap_v1310_s srs_cfg_ap_dci_format0_v1310;
        srs_cfg_ap_v1310_s srs_cfg_ap_dci_format1a2b2c_v1310;
      };
      typedef setup_e types;

      // choice methods
      srs_activ_ap_v1310_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "srs-ActivateAp-v1310");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "srs-ActivateAp-v1310");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                            srs_cfg_ap_dci_format4_v1310_present = false;
    bool                            srs_activ_ap_v1310_present           = false;
    srs_cfg_ap_dci_format4_v1310_l_ srs_cfg_ap_dci_format4_v1310;
    srs_activ_ap_v1310_c_           srs_activ_ap_v1310;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_ded_aperiodic_v1310_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodic-v1310");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodic-v1310");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SoundingRS-UL-ConfigDedicatedAperiodicUpPTsExt-r13 ::= CHOICE
struct srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_c {
  struct setup_s_ {
    struct srs_up_pts_add_r13_opts {
      enum options { sym2, sym4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_up_pts_add_r13_opts> srs_up_pts_add_r13_e_;
    typedef dyn_array<srs_cfg_ap_r13_s>         srs_cfg_ap_dci_format4_r13_l_;
    struct srs_activ_ap_r13_c_ {
      struct setup_s_ {
        // member variables
        srs_cfg_ap_r13_s srs_cfg_ap_dci_format0_r13;
        srs_cfg_ap_r13_s srs_cfg_ap_dci_format1a2b2c_r13;
      };
      typedef setup_e types;

      // choice methods
      srs_activ_ap_r13_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "srs-ActivateAp-r13");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "srs-ActivateAp-r13");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                          srs_cfg_ap_dci_format4_r13_present = false;
    bool                          srs_activ_ap_r13_present           = false;
    srs_up_pts_add_r13_e_         srs_up_pts_add_r13;
    uint8_t                       srs_cfg_idx_ap_r13 = 0;
    srs_cfg_ap_dci_format4_r13_l_ srs_cfg_ap_dci_format4_r13;
    srs_activ_ap_r13_c_           srs_activ_ap_r13;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodicUpPTsExt-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodicUpPTsExt-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SoundingRS-UL-ConfigDedicatedUpPTsExt-r13 ::= CHOICE
struct srs_ul_cfg_ded_up_pts_ext_r13_c {
  struct setup_s_ {
    struct srs_up_pts_add_r13_opts {
      enum options { sym2, sym4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_up_pts_add_r13_opts> srs_up_pts_add_r13_e_;
    struct srs_bw_r13_opts {
      enum options { bw0, bw1, bw2, bw3, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_bw_r13_opts> srs_bw_r13_e_;
    struct srs_hop_bw_r13_opts {
      enum options { hbw0, hbw1, hbw2, hbw3, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<srs_hop_bw_r13_opts> srs_hop_bw_r13_e_;
    struct cyclic_shift_r13_opts {
      enum options { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, cs8, cs9, cs10, cs11, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<cyclic_shift_r13_opts> cyclic_shift_r13_e_;
    struct tx_comb_num_r13_opts {
      enum options { n2, n4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tx_comb_num_r13_opts> tx_comb_num_r13_e_;

    // member variables
    srs_up_pts_add_r13_e_ srs_up_pts_add_r13;
    srs_bw_r13_e_         srs_bw_r13;
    srs_hop_bw_r13_e_     srs_hop_bw_r13;
    uint8_t               freq_domain_position_r13 = 0;
    bool                  dur_r13                  = false;
    uint16_t              srs_cfg_idx_r13          = 0;
    uint8_t               tx_comb_r13              = 0;
    cyclic_shift_r13_e_   cyclic_shift_r13;
    srs_ant_port_e        srs_ant_port_r13;
    tx_comb_num_r13_e_    tx_comb_num_r13;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_ded_up_pts_ext_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedUpPTsExt-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedUpPTsExt-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// UplinkPowerControlDedicated ::= SEQUENCE
struct ul_pwr_ctrl_ded_s {
  struct delta_mcs_enabled_opts {
    enum options { en0, en1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_mcs_enabled_opts> delta_mcs_enabled_e_;

  // member variables
  bool                 filt_coef_present = false;
  int8_t               p0_ue_pusch       = -8;
  delta_mcs_enabled_e_ delta_mcs_enabled;
  bool                 accumulation_enabled = false;
  int8_t               p0_ue_pucch          = -8;
  uint8_t              p_srs_offset         = 0;
  filt_coef_e          filt_coef;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlDedicated-v1020 ::= SEQUENCE
struct ul_pwr_ctrl_ded_v1020_s {
  // member variables
  bool                               delta_tx_d_offset_list_pucch_r10_present = false;
  bool                               p_srs_offset_ap_r10_present              = false;
  delta_tx_d_offset_list_pucch_r10_s delta_tx_d_offset_list_pucch_r10;
  uint8_t                            p_srs_offset_ap_r10 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlDedicated-v1130 ::= SEQUENCE
struct ul_pwr_ctrl_ded_v1130_s {
  // member variables
  bool                                 p_srs_offset_v1130_present                 = false;
  bool                                 p_srs_offset_ap_v1130_present              = false;
  bool                                 delta_tx_d_offset_list_pucch_v1130_present = false;
  uint8_t                              p_srs_offset_v1130                         = 16;
  uint8_t                              p_srs_offset_ap_v1130                      = 16;
  delta_tx_d_offset_list_pucch_v1130_s delta_tx_d_offset_list_pucch_v1130;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlDedicated-v1250 ::= SEQUENCE
struct ul_pwr_ctrl_ded_v1250_s {
  struct set2_pwr_ctrl_param_c_ {
    struct setup_s_ {
      // member variables
      fixed_bitstring<10> tpc_sf_set_r12;
      int8_t              p0_nominal_pusch_sf_set2_r12 = -126;
      alpha_r12_e         alpha_sf_set2_r12;
      int8_t              p0_ue_pusch_sf_set2_r12 = -8;
    };
    typedef setup_e types;

    // choice methods
    set2_pwr_ctrl_param_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "set2PowerControlParameter");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "set2PowerControlParameter");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  set2_pwr_ctrl_param_c_ set2_pwr_ctrl_param;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlDedicated-v1530 ::= SEQUENCE
struct ul_pwr_ctrl_ded_v1530_s {
  // member variables
  bool        alpha_ue_r15_present    = false;
  bool        p0_ue_pusch_r15_present = false;
  alpha_r12_e alpha_ue_r15;
  int8_t      p0_ue_pusch_r15 = -16;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandClassPriorityList1XRTT ::= SEQUENCE (SIZE (1..maxCDMA-BandClass)) OF BandClassPriority1XRTT
typedef dyn_array<band_class_prio1_xrtt_s> band_class_prio_list1_xrtt_l;

// BandClassPriorityListHRPD ::= SEQUENCE (SIZE (1..maxCDMA-BandClass)) OF BandClassPriorityHRPD
typedef dyn_array<band_class_prio_hrpd_s> band_class_prio_list_hrpd_l;

// CarrierFreqCDMA2000 ::= SEQUENCE
struct carrier_freq_cdma2000_s {
  // member variables
  bandclass_cdma2000_e band_class;
  uint16_t             arfcn = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqListUTRA-TDD-r10 ::= SEQUENCE (SIZE (1..maxFreqUTRA-TDD-r10)) OF INTEGER
typedef bounded_array<uint16_t, 6> carrier_freq_list_utra_tdd_r10_l;

// DRB-ToAddModList ::= SEQUENCE (SIZE (1..maxDRB)) OF DRB-ToAddMod
typedef dyn_array<drb_to_add_mod_s> drb_to_add_mod_list_l;

// DRB-ToAddModList-r15 ::= SEQUENCE (SIZE (1..maxDRB-r15)) OF DRB-ToAddMod
typedef dyn_array<drb_to_add_mod_s> drb_to_add_mod_list_r15_l;

// DRB-ToReleaseList ::= SEQUENCE (SIZE (1..maxDRB)) OF INTEGER
typedef bounded_array<uint8_t, 11> drb_to_release_list_l;

// DRB-ToReleaseList-r15 ::= SEQUENCE (SIZE (1..maxDRB-r15)) OF INTEGER
typedef bounded_array<uint8_t, 15> drb_to_release_list_r15_l;

// FreqPriorityEUTRA-v9e0 ::= SEQUENCE
struct freq_prio_eutra_v9e0_s {
  // member variables
  bool     carrier_freq_v9e0_present = false;
  uint32_t carrier_freq_v9e0         = 65536;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqPriorityListEUTRA ::= SEQUENCE (SIZE (1..maxFreq)) OF FreqPriorityEUTRA
typedef dyn_array<freq_prio_eutra_s> freq_prio_list_eutra_l;

// FreqPriorityListEUTRA-v1310 ::= SEQUENCE (SIZE (1..maxFreq)) OF FreqPriorityEUTRA-v1310
typedef dyn_array<freq_prio_eutra_v1310_s> freq_prio_list_eutra_v1310_l;

// FreqPriorityListExtEUTRA-r12 ::= SEQUENCE (SIZE (1..maxFreq)) OF FreqPriorityEUTRA-r12
typedef dyn_array<freq_prio_eutra_r12_s> freq_prio_list_ext_eutra_r12_l;

// FreqPriorityListExtEUTRA-v1310 ::= SEQUENCE (SIZE (1..maxFreq)) OF FreqPriorityEUTRA-v1310
typedef dyn_array<freq_prio_eutra_v1310_s> freq_prio_list_ext_eutra_v1310_l;

// FreqPriorityListNR-r15 ::= SEQUENCE (SIZE (1..maxFreq)) OF FreqPriorityNR-r15
typedef dyn_array<freq_prio_nr_r15_s> freq_prio_list_nr_r15_l;

// FreqPriorityListUTRA-FDD ::= SEQUENCE (SIZE (1..maxUTRA-FDD-Carrier)) OF FreqPriorityUTRA-FDD
typedef dyn_array<freq_prio_utra_fdd_s> freq_prio_list_utra_fdd_l;

// FreqPriorityListUTRA-TDD ::= SEQUENCE (SIZE (1..maxUTRA-TDD-Carrier)) OF FreqPriorityUTRA-TDD
typedef dyn_array<freq_prio_utra_tdd_s> freq_prio_list_utra_tdd_l;

// FreqsPriorityListGERAN ::= SEQUENCE (SIZE (1..maxGNFG)) OF FreqsPriorityGERAN
typedef dyn_array<freqs_prio_geran_s> freqs_prio_list_geran_l;

// MAC-MainConfig ::= SEQUENCE
struct mac_main_cfg_s {
  struct ul_sch_cfg_s_ {
    struct max_harq_tx_opts {
      enum options { n1, n2, n3, n4, n5, n6, n7, n8, n10, n12, n16, n20, n24, n28, spare2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<max_harq_tx_opts> max_harq_tx_e_;

    // member variables
    bool                     max_harq_tx_present        = false;
    bool                     periodic_bsr_timer_present = false;
    max_harq_tx_e_           max_harq_tx;
    periodic_bsr_timer_r12_e periodic_bsr_timer;
    retx_bsr_timer_r12_e     retx_bsr_timer;
    bool                     tti_bundling = false;
  };
  struct phr_cfg_c_ {
    struct setup_s_ {
      struct periodic_phr_timer_opts {
        enum options { sf10, sf20, sf50, sf100, sf200, sf500, sf1000, infinity, nulltype } value;
        typedef int16_t number_type;

        std::string to_string() const;
        int16_t     to_number() const;
      };
      typedef enumerated<periodic_phr_timer_opts> periodic_phr_timer_e_;
      struct prohibit_phr_timer_opts {
        enum options { sf0, sf10, sf20, sf50, sf100, sf200, sf500, sf1000, nulltype } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<prohibit_phr_timer_opts> prohibit_phr_timer_e_;
      struct dl_pathloss_change_opts {
        enum options { db1, db3, db6, infinity, nulltype } value;
        typedef int8_t number_type;

        std::string to_string() const;
        int8_t      to_number() const;
      };
      typedef enumerated<dl_pathloss_change_opts> dl_pathloss_change_e_;

      // member variables
      periodic_phr_timer_e_ periodic_phr_timer;
      prohibit_phr_timer_e_ prohibit_phr_timer;
      dl_pathloss_change_e_ dl_pathloss_change;
    };
    typedef setup_e types;

    // choice methods
    phr_cfg_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "phr-Config");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "phr-Config");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct mac_main_cfg_v1020_s_ {
    struct s_cell_deactivation_timer_r10_opts {
      enum options { rf2, rf4, rf8, rf16, rf32, rf64, rf128, spare, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<s_cell_deactivation_timer_r10_opts> s_cell_deactivation_timer_r10_e_;

    // member variables
    bool                             s_cell_deactivation_timer_r10_present = false;
    bool                             extended_bsr_sizes_r10_present        = false;
    bool                             extended_phr_r10_present              = false;
    s_cell_deactivation_timer_r10_e_ s_cell_deactivation_timer_r10;
  };
  struct dual_connect_phr_c_ {
    struct setup_s_ {
      struct phr_mode_other_cg_r12_opts {
        enum options { real, virtual_type, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<phr_mode_other_cg_r12_opts> phr_mode_other_cg_r12_e_;

      // member variables
      phr_mode_other_cg_r12_e_ phr_mode_other_cg_r12;
    };
    typedef setup_e types;

    // choice methods
    dual_connect_phr_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "dualConnectivityPHR");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "dualConnectivityPHR");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct lc_ch_sr_cfg_r12_c_ {
    struct setup_s_ {
      struct lc_ch_sr_prohibit_timer_r12_opts {
        enum options { sf20, sf40, sf64, sf128, sf512, sf1024, sf2560, spare1, nulltype } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<lc_ch_sr_prohibit_timer_r12_opts> lc_ch_sr_prohibit_timer_r12_e_;

      // member variables
      lc_ch_sr_prohibit_timer_r12_e_ lc_ch_sr_prohibit_timer_r12;
    };
    typedef setup_e types;

    // choice methods
    lc_ch_sr_cfg_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "logicalChannelSR-Config-r12");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "logicalChannelSR-Config-r12");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct e_drx_cfg_cycle_start_offset_r13_c_ {
    struct setup_c_ {
      struct types_opts {
        enum options { sf5120, sf10240, nulltype } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint8_t& sf5120()
      {
        assert_choice_type("sf5120", type_.to_string(), "setup");
        return c.get<uint8_t>();
      }
      uint8_t& sf10240()
      {
        assert_choice_type("sf10240", type_.to_string(), "setup");
        return c.get<uint8_t>();
      }
      const uint8_t& sf5120() const
      {
        assert_choice_type("sf5120", type_.to_string(), "setup");
        return c.get<uint8_t>();
      }
      const uint8_t& sf10240() const
      {
        assert_choice_type("sf10240", type_.to_string(), "setup");
        return c.get<uint8_t>();
      }
      uint8_t& set_sf5120()
      {
        set(types::sf5120);
        return c.get<uint8_t>();
      }
      uint8_t& set_sf10240()
      {
        set(types::sf10240);
        return c.get<uint8_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    e_drx_cfg_cycle_start_offset_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "eDRX-Config-CycleStartOffset-r13");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "eDRX-Config-CycleStartOffset-r13");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };
  struct drx_cfg_r13_c_ {
    typedef setup_e types;

    // choice methods
    drx_cfg_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drx_cfg_r13_s& setup()
    {
      assert_choice_type("setup", type_.to_string(), "drx-Config-r13");
      return c;
    }
    const drx_cfg_r13_s& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "drx-Config-r13");
      return c;
    }
    drx_cfg_r13_s& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types         type_;
    drx_cfg_r13_s c;
  };
  struct skip_ul_tx_r14_c_ {
    struct setup_s_ {
      // member variables
      bool skip_ul_tx_sps_r14_present     = false;
      bool skip_ul_tx_dynamic_r14_present = false;
    };
    typedef setup_e types;

    // choice methods
    skip_ul_tx_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "skipUplinkTx-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "skipUplinkTx-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct data_inactivity_timer_cfg_r14_c_ {
    struct setup_s_ {
      // member variables
      data_inactivity_timer_r14_e data_inactivity_timer_r14;
    };
    typedef setup_e types;

    // choice methods
    data_inactivity_timer_cfg_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "dataInactivityTimerConfig-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "dataInactivityTimerConfig-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct short_tti_and_spt_r15_c_ {
    struct setup_s_ {
      struct periodic_bsr_timer_r15_opts {
        enum options {
          sf1,
          sf5,
          sf10,
          sf16,
          sf20,
          sf32,
          sf40,
          sf64,
          sf80,
          sf128,
          sf160,
          sf320,
          sf640,
          sf1280,
          sf2560,
          infinity,
          nulltype
        } value;
        typedef int16_t number_type;

        std::string to_string() const;
        int16_t     to_number() const;
      };
      typedef enumerated<periodic_bsr_timer_r15_opts> periodic_bsr_timer_r15_e_;
      struct proc_timeline_r15_opts {
        enum options { nplus4set1, nplus6set1, nplus6set2, nplus8set2, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<proc_timeline_r15_opts> proc_timeline_r15_e_;

      // member variables
      bool                      drx_cfg_r15_present            = false;
      bool                      periodic_bsr_timer_r15_present = false;
      bool                      proc_timeline_r15_present      = false;
      bool                      ssr_prohibit_timer_r15_present = false;
      drx_cfg_r15_s             drx_cfg_r15;
      periodic_bsr_timer_r15_e_ periodic_bsr_timer_r15;
      proc_timeline_r15_e_      proc_timeline_r15;
      uint8_t                   ssr_prohibit_timer_r15 = 0;
    };
    typedef setup_e types;

    // choice methods
    short_tti_and_spt_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "shortTTI-AndSPT-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "shortTTI-AndSPT-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct dormant_state_timers_r15_c_ {
    struct setup_s_ {
      struct s_cell_hibernation_timer_r15_opts {
        enum options { rf2, rf4, rf8, rf16, rf32, rf64, rf128, spare, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<s_cell_hibernation_timer_r15_opts> s_cell_hibernation_timer_r15_e_;
      struct dormant_scell_deactivation_timer_r15_opts {
        enum options {
          rf2,
          rf4,
          rf8,
          rf16,
          rf32,
          rf64,
          rf128,
          rf320,
          rf640,
          rf1280,
          rf2560,
          rf5120,
          rf10240,
          spare3,
          spare2,
          spare1,
          nulltype
        } value;
        typedef uint16_t number_type;

        std::string to_string() const;
        uint16_t    to_number() const;
      };
      typedef enumerated<dormant_scell_deactivation_timer_r15_opts> dormant_scell_deactivation_timer_r15_e_;

      // member variables
      bool                                    s_cell_hibernation_timer_r15_present         = false;
      bool                                    dormant_scell_deactivation_timer_r15_present = false;
      s_cell_hibernation_timer_r15_e_         s_cell_hibernation_timer_r15;
      dormant_scell_deactivation_timer_r15_e_ dormant_scell_deactivation_timer_r15;
    };
    typedef setup_e types;

    // choice methods
    dormant_state_timers_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "dormantStateTimers-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "dormantStateTimers-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool               ext                = false;
  bool               ul_sch_cfg_present = false;
  bool               drx_cfg_present    = false;
  bool               phr_cfg_present    = false;
  ul_sch_cfg_s_      ul_sch_cfg;
  drx_cfg_c          drx_cfg;
  time_align_timer_e time_align_timer_ded;
  phr_cfg_c_         phr_cfg;
  // ...
  // group 0
  bool    sr_prohibit_timer_r9_present = false;
  uint8_t sr_prohibit_timer_r9         = 0;
  // group 1
  bool                            mac_main_cfg_v1020_present = false;
  copy_ptr<mac_main_cfg_v1020_s_> mac_main_cfg_v1020;
  // group 2
  bool                                 stag_to_release_list_r11_present = false;
  bool                                 stag_to_add_mod_list_r11_present = false;
  bool                                 drx_cfg_v1130_present            = false;
  copy_ptr<stag_to_release_list_r11_l> stag_to_release_list_r11;
  copy_ptr<stag_to_add_mod_list_r11_l> stag_to_add_mod_list_r11;
  copy_ptr<drx_cfg_v1130_s>            drx_cfg_v1130;
  // group 3
  bool                          e_harq_pattern_r12_present = false;
  bool                          dual_connect_phr_present   = false;
  bool                          lc_ch_sr_cfg_r12_present   = false;
  bool                          e_harq_pattern_r12         = false;
  copy_ptr<dual_connect_phr_c_> dual_connect_phr;
  copy_ptr<lc_ch_sr_cfg_r12_c_> lc_ch_sr_cfg_r12;
  // group 4
  bool                                          drx_cfg_v1310_present                    = false;
  bool                                          extended_phr2_r13_present                = false;
  bool                                          e_drx_cfg_cycle_start_offset_r13_present = false;
  copy_ptr<drx_cfg_v1310_s>                     drx_cfg_v1310;
  bool                                          extended_phr2_r13 = false;
  copy_ptr<e_drx_cfg_cycle_start_offset_r13_c_> e_drx_cfg_cycle_start_offset_r13;
  // group 5
  bool                     drx_cfg_r13_present = false;
  copy_ptr<drx_cfg_r13_c_> drx_cfg_r13;
  // group 6
  bool                                       skip_ul_tx_r14_present                = false;
  bool                                       data_inactivity_timer_cfg_r14_present = false;
  copy_ptr<skip_ul_tx_r14_c_>                skip_ul_tx_r14;
  copy_ptr<data_inactivity_timer_cfg_r14_c_> data_inactivity_timer_cfg_r14;
  // group 7
  bool rai_activation_r14_present = false;
  // group 8
  bool                                  short_tti_and_spt_r15_present               = false;
  bool                                  mpdcch_ul_harq_ack_feedback_cfg_r15_present = false;
  bool                                  dormant_state_timers_r15_present            = false;
  copy_ptr<short_tti_and_spt_r15_c_>    short_tti_and_spt_r15;
  bool                                  mpdcch_ul_harq_ack_feedback_cfg_r15 = false;
  copy_ptr<dormant_state_timers_r15_c_> dormant_state_timers_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasSubframePatternPCell-r10 ::= CHOICE
struct meas_sf_pattern_pcell_r10_c {
  typedef setup_e types;

  // choice methods
  meas_sf_pattern_pcell_r10_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  meas_sf_pattern_r10_c& setup()
  {
    assert_choice_type("setup", type_.to_string(), "MeasSubframePatternPCell-r10");
    return c;
  }
  const meas_sf_pattern_r10_c& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "MeasSubframePatternPCell-r10");
    return c;
  }
  meas_sf_pattern_r10_c& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types                 type_;
  meas_sf_pattern_r10_c c;
};

// NAICS-AssistanceInfo-r12 ::= CHOICE
struct naics_assist_info_r12_c {
  struct setup_s_ {
    // member variables
    bool                              neigh_cells_to_release_list_r12_present = false;
    bool                              neigh_cells_to_add_mod_list_r12_present = false;
    bool                              serv_cellp_a_r12_present                = false;
    neigh_cells_to_release_list_r12_l neigh_cells_to_release_list_r12;
    neigh_cells_to_add_mod_list_r12_l neigh_cells_to_add_mod_list_r12;
    p_a_e                             serv_cellp_a_r12;
  };
  typedef setup_e types;

  // choice methods
  naics_assist_info_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "NAICS-AssistanceInfo-r12");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "NAICS-AssistanceInfo-r12");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// NeighCellsCRS-Info-r11 ::= CHOICE
struct neigh_cells_crs_info_r11_c {
  typedef setup_e types;

  // choice methods
  neigh_cells_crs_info_r11_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  crs_assist_info_list_r11_l& setup()
  {
    assert_choice_type("setup", type_.to_string(), "NeighCellsCRS-Info-r11");
    return c;
  }
  const crs_assist_info_list_r11_l& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "NeighCellsCRS-Info-r11");
    return c;
  }
  crs_assist_info_list_r11_l& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types                      type_;
  crs_assist_info_list_r11_l c;
};

// NeighCellsCRS-Info-r13 ::= CHOICE
struct neigh_cells_crs_info_r13_c {
  typedef setup_e types;

  // choice methods
  neigh_cells_crs_info_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  crs_assist_info_list_r13_l& setup()
  {
    assert_choice_type("setup", type_.to_string(), "NeighCellsCRS-Info-r13");
    return c;
  }
  const crs_assist_info_list_r13_l& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "NeighCellsCRS-Info-r13");
    return c;
  }
  crs_assist_info_list_r13_l& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types                      type_;
  crs_assist_info_list_r13_l c;
};

// NeighCellsCRS-Info-r15 ::= CHOICE
struct neigh_cells_crs_info_r15_c {
  typedef setup_e types;

  // choice methods
  neigh_cells_crs_info_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  crs_assist_info_list_r15_l& setup()
  {
    assert_choice_type("setup", type_.to_string(), "NeighCellsCRS-Info-r15");
    return c;
  }
  const crs_assist_info_list_r15_l& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "NeighCellsCRS-Info-r15");
    return c;
  }
  crs_assist_info_list_r15_l& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types                      type_;
  crs_assist_info_list_r15_l c;
};

// PhysicalConfigDedicated ::= SEQUENCE
struct phys_cfg_ded_s {
  struct ant_info_c_ {
    struct types_opts {
      enum options { explicit_value, default_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ant_info_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ant_info_ded_s& explicit_value()
    {
      assert_choice_type("explicitValue", type_.to_string(), "antennaInfo");
      return c;
    }
    const ant_info_ded_s& explicit_value() const
    {
      assert_choice_type("explicitValue", type_.to_string(), "antennaInfo");
      return c;
    }
    ant_info_ded_s& set_explicit_value()
    {
      set(types::explicit_value);
      return c;
    }

  private:
    types          type_;
    ant_info_ded_s c;
  };
  struct ant_info_r10_c_ {
    struct types_opts {
      enum options { explicit_value_r10, default_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ant_info_r10_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ant_info_ded_r10_s& explicit_value_r10()
    {
      assert_choice_type("explicitValue-r10", type_.to_string(), "antennaInfo-r10");
      return c;
    }
    const ant_info_ded_r10_s& explicit_value_r10() const
    {
      assert_choice_type("explicitValue-r10", type_.to_string(), "antennaInfo-r10");
      return c;
    }
    ant_info_ded_r10_s& set_explicit_value_r10()
    {
      set(types::explicit_value_r10);
      return c;
    }

  private:
    types              type_;
    ant_info_ded_r10_s c;
  };
  struct add_spec_emission_ca_r10_c_ {
    struct setup_s_ {
      // member variables
      uint8_t add_spec_emission_pcell_r10 = 1;
    };
    typedef setup_e types;

    // choice methods
    add_spec_emission_ca_r10_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "additionalSpectrumEmissionCA-r10");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "additionalSpectrumEmissionCA-r10");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct ce_mode_r13_c_ {
    struct setup_opts {
      enum options { ce_mode_a, ce_mode_b, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<setup_opts> setup_e_;
    typedef setup_e                types;

    // choice methods
    ce_mode_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_e_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "ce-Mode-r13");
      return c;
    }
    const setup_e_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "ce-Mode-r13");
      return c;
    }
    setup_e_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_e_ c;
  };
  struct type_a_srs_tpc_pdcch_group_r14_c_ {
    typedef dyn_array<srs_tpc_pdcch_cfg_r14_c> setup_l_;
    typedef setup_e                            types;

    // choice methods
    type_a_srs_tpc_pdcch_group_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_l_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "typeA-SRS-TPC-PDCCH-Group-r14");
      return c;
    }
    const setup_l_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "typeA-SRS-TPC-PDCCH-Group-r14");
      return c;
    }
    setup_l_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_l_ c;
  };
  struct must_cfg_r14_c_ {
    struct setup_s_ {
      struct k_max_r14_opts {
        enum options { l1, l3, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<k_max_r14_opts> k_max_r14_e_;
      struct p_a_must_r14_opts {
        enum options { db_minus6, db_minus4dot77, db_minus3, db_minus1dot77, db0, db1, db2, db3, nulltype } value;
        typedef float number_type;

        std::string to_string() const;
        float       to_number() const;
        std::string to_number_string() const;
      };
      typedef enumerated<p_a_must_r14_opts> p_a_must_r14_e_;

      // member variables
      bool            p_a_must_r14_present = false;
      k_max_r14_e_    k_max_r14;
      p_a_must_r14_e_ p_a_must_r14;
    };
    typedef setup_e types;

    // choice methods
    must_cfg_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "must-Config-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "must-Config-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  typedef dyn_array<srs_ul_cfg_ded_c>                          srs_ul_periodic_cfg_ded_list_r14_l_;
  typedef dyn_array<srs_ul_cfg_ded_up_pts_ext_r13_c>           srs_ul_periodic_cfg_ded_up_pts_ext_list_r14_l_;
  typedef dyn_array<srs_ul_cfg_ded_aperiodic_r10_c>            srs_ul_aperiodic_cfg_ded_list_r14_l_;
  typedef dyn_array<srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_c> srs_ul_cfg_ded_ap_up_pts_ext_list_r14_l_;
  struct semi_static_cfi_cfg_r15_c_ {
    struct setup_c_ {
      struct types_opts {
        enum options { cfi_cfg_r15, cfi_pattern_cfg_r15, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      cfi_cfg_r15_s& cfi_cfg_r15()
      {
        assert_choice_type("cfi-Config-r15", type_.to_string(), "setup");
        return c.get<cfi_cfg_r15_s>();
      }
      cfi_pattern_cfg_r15_s& cfi_pattern_cfg_r15()
      {
        assert_choice_type("cfi-PatternConfig-r15", type_.to_string(), "setup");
        return c.get<cfi_pattern_cfg_r15_s>();
      }
      const cfi_cfg_r15_s& cfi_cfg_r15() const
      {
        assert_choice_type("cfi-Config-r15", type_.to_string(), "setup");
        return c.get<cfi_cfg_r15_s>();
      }
      const cfi_pattern_cfg_r15_s& cfi_pattern_cfg_r15() const
      {
        assert_choice_type("cfi-PatternConfig-r15", type_.to_string(), "setup");
        return c.get<cfi_pattern_cfg_r15_s>();
      }
      cfi_cfg_r15_s& set_cfi_cfg_r15()
      {
        set(types::cfi_cfg_r15);
        return c.get<cfi_cfg_r15_s>();
      }
      cfi_pattern_cfg_r15_s& set_cfi_pattern_cfg_r15()
      {
        set(types::cfi_pattern_cfg_r15);
        return c.get<cfi_pattern_cfg_r15_s>();
      }

    private:
      types                                                                       type_;
      choice_buffer_t<MAX2(sizeof(cfi_cfg_r15_s), sizeof(cfi_pattern_cfg_r15_s))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    semi_static_cfi_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "semiStaticCFI-Config-r15");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "semiStaticCFI-Config-r15");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };
  struct blind_pdsch_repeat_cfg_r15_c_ {
    struct setup_s_ {
      struct max_num_sf_pdsch_repeats_r15_opts {
        enum options { n4, n6, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<max_num_sf_pdsch_repeats_r15_opts> max_num_sf_pdsch_repeats_r15_e_;
      struct max_num_slot_subslot_pdsch_repeats_r15_opts {
        enum options { n4, n6, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<max_num_slot_subslot_pdsch_repeats_r15_opts> max_num_slot_subslot_pdsch_repeats_r15_e_;
      struct rv_sf_pdsch_repeats_r15_opts {
        enum options { dlrvseq1, dlrvseq2, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<rv_sf_pdsch_repeats_r15_opts> rv_sf_pdsch_repeats_r15_e_;
      struct rv_slotsublot_pdsch_repeats_r15_opts {
        enum options { dlrvseq1, dlrvseq2, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<rv_slotsublot_pdsch_repeats_r15_opts> rv_slotsublot_pdsch_repeats_r15_e_;
      struct mcs_restrict_sf_pdsch_repeats_r15_opts {
        enum options { n0, n1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<mcs_restrict_sf_pdsch_repeats_r15_opts> mcs_restrict_sf_pdsch_repeats_r15_e_;
      struct mcs_restrict_slot_subslot_pdsch_repeats_r15_opts {
        enum options { n0, n1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<mcs_restrict_slot_subslot_pdsch_repeats_r15_opts>
          mcs_restrict_slot_subslot_pdsch_repeats_r15_e_;

      // member variables
      bool                                           max_num_sf_pdsch_repeats_r15_present                 = false;
      bool                                           max_num_slot_subslot_pdsch_repeats_r15_present       = false;
      bool                                           rv_sf_pdsch_repeats_r15_present                      = false;
      bool                                           rv_slotsublot_pdsch_repeats_r15_present              = false;
      bool                                           nof_processes_sf_pdsch_repeats_r15_present           = false;
      bool                                           nof_processes_slot_subslot_pdsch_repeats_r15_present = false;
      bool                                           mcs_restrict_sf_pdsch_repeats_r15_present            = false;
      bool                                           mcs_restrict_slot_subslot_pdsch_repeats_r15_present  = false;
      bool                                           blind_sf_pdsch_repeats_r15                           = false;
      bool                                           blind_slot_subslot_pdsch_repeats_r15                 = false;
      max_num_sf_pdsch_repeats_r15_e_                max_num_sf_pdsch_repeats_r15;
      max_num_slot_subslot_pdsch_repeats_r15_e_      max_num_slot_subslot_pdsch_repeats_r15;
      rv_sf_pdsch_repeats_r15_e_                     rv_sf_pdsch_repeats_r15;
      rv_slotsublot_pdsch_repeats_r15_e_             rv_slotsublot_pdsch_repeats_r15;
      uint8_t                                        nof_processes_sf_pdsch_repeats_r15           = 1;
      uint8_t                                        nof_processes_slot_subslot_pdsch_repeats_r15 = 1;
      mcs_restrict_sf_pdsch_repeats_r15_e_           mcs_restrict_sf_pdsch_repeats_r15;
      mcs_restrict_slot_subslot_pdsch_repeats_r15_e_ mcs_restrict_slot_subslot_pdsch_repeats_r15;
    };
    typedef setup_e types;

    // choice methods
    blind_pdsch_repeat_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "blindPDSCH-Repetition-Config-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "blindPDSCH-Repetition-Config-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                ext                         = false;
  bool                pdsch_cfg_ded_present       = false;
  bool                pucch_cfg_ded_present       = false;
  bool                pusch_cfg_ded_present       = false;
  bool                ul_pwr_ctrl_ded_present     = false;
  bool                tpc_pdcch_cfg_pucch_present = false;
  bool                tpc_pdcch_cfg_pusch_present = false;
  bool                cqi_report_cfg_present      = false;
  bool                srs_ul_cfg_ded_present      = false;
  bool                ant_info_present            = false;
  bool                sched_request_cfg_present   = false;
  pdsch_cfg_ded_s     pdsch_cfg_ded;
  pucch_cfg_ded_s     pucch_cfg_ded;
  pusch_cfg_ded_s     pusch_cfg_ded;
  ul_pwr_ctrl_ded_s   ul_pwr_ctrl_ded;
  tpc_pdcch_cfg_c     tpc_pdcch_cfg_pucch;
  tpc_pdcch_cfg_c     tpc_pdcch_cfg_pusch;
  cqi_report_cfg_s    cqi_report_cfg;
  srs_ul_cfg_ded_c    srs_ul_cfg_ded;
  ant_info_c_         ant_info;
  sched_request_cfg_c sched_request_cfg;
  // ...
  // group 0
  bool                            cqi_report_cfg_v920_present = false;
  bool                            ant_info_v920_present       = false;
  copy_ptr<cqi_report_cfg_v920_s> cqi_report_cfg_v920;
  copy_ptr<ant_info_ded_v920_s>   ant_info_v920;
  // group 1
  bool                                     ant_info_r10_present                 = false;
  bool                                     ant_info_ul_r10_present              = false;
  bool                                     cif_presence_r10_present             = false;
  bool                                     cqi_report_cfg_r10_present           = false;
  bool                                     csi_rs_cfg_r10_present               = false;
  bool                                     pucch_cfg_ded_v1020_present          = false;
  bool                                     pusch_cfg_ded_v1020_present          = false;
  bool                                     sched_request_cfg_v1020_present      = false;
  bool                                     srs_ul_cfg_ded_v1020_present         = false;
  bool                                     srs_ul_cfg_ded_aperiodic_r10_present = false;
  bool                                     ul_pwr_ctrl_ded_v1020_present        = false;
  copy_ptr<ant_info_r10_c_>                ant_info_r10;
  copy_ptr<ant_info_ul_r10_s>              ant_info_ul_r10;
  bool                                     cif_presence_r10 = false;
  copy_ptr<cqi_report_cfg_r10_s>           cqi_report_cfg_r10;
  copy_ptr<csi_rs_cfg_r10_s>               csi_rs_cfg_r10;
  copy_ptr<pucch_cfg_ded_v1020_s>          pucch_cfg_ded_v1020;
  copy_ptr<pusch_cfg_ded_v1020_s>          pusch_cfg_ded_v1020;
  copy_ptr<sched_request_cfg_v1020_s>      sched_request_cfg_v1020;
  copy_ptr<srs_ul_cfg_ded_v1020_s>         srs_ul_cfg_ded_v1020;
  copy_ptr<srs_ul_cfg_ded_aperiodic_r10_c> srs_ul_cfg_ded_aperiodic_r10;
  copy_ptr<ul_pwr_ctrl_ded_v1020_s>        ul_pwr_ctrl_ded_v1020;
  // group 2
  bool                                  add_spec_emission_ca_r10_present = false;
  copy_ptr<add_spec_emission_ca_r10_c_> add_spec_emission_ca_r10;
  // group 3
  bool                                           csi_rs_cfg_nzp_to_release_list_r11_present = false;
  bool                                           csi_rs_cfg_nzp_to_add_mod_list_r11_present = false;
  bool                                           csi_rs_cfg_zp_to_release_list_r11_present  = false;
  bool                                           csi_rs_cfg_zp_to_add_mod_list_r11_present  = false;
  bool                                           epdcch_cfg_r11_present                     = false;
  bool                                           pdsch_cfg_ded_v1130_present                = false;
  bool                                           cqi_report_cfg_v1130_present               = false;
  bool                                           pucch_cfg_ded_v1130_present                = false;
  bool                                           pusch_cfg_ded_v1130_present                = false;
  bool                                           ul_pwr_ctrl_ded_v1130_present              = false;
  copy_ptr<csi_rs_cfg_nzp_to_release_list_r11_l> csi_rs_cfg_nzp_to_release_list_r11;
  copy_ptr<csi_rs_cfg_nzp_to_add_mod_list_r11_l> csi_rs_cfg_nzp_to_add_mod_list_r11;
  copy_ptr<csi_rs_cfg_zp_to_release_list_r11_l>  csi_rs_cfg_zp_to_release_list_r11;
  copy_ptr<csi_rs_cfg_zp_to_add_mod_list_r11_l>  csi_rs_cfg_zp_to_add_mod_list_r11;
  copy_ptr<epdcch_cfg_r11_s>                     epdcch_cfg_r11;
  copy_ptr<pdsch_cfg_ded_v1130_s>                pdsch_cfg_ded_v1130;
  copy_ptr<cqi_report_cfg_v1130_s>               cqi_report_cfg_v1130;
  copy_ptr<pucch_cfg_ded_v1130_s>                pucch_cfg_ded_v1130;
  copy_ptr<pusch_cfg_ded_v1130_s>                pusch_cfg_ded_v1130;
  copy_ptr<ul_pwr_ctrl_ded_v1130_s>              ul_pwr_ctrl_ded_v1130;
  // group 4
  bool                                     ant_info_v1250_present             = false;
  bool                                     eimta_main_cfg_r12_present         = false;
  bool                                     eimta_main_cfg_pcell_r12_present   = false;
  bool                                     pucch_cfg_ded_v1250_present        = false;
  bool                                     cqi_report_cfg_pcell_v1250_present = false;
  bool                                     ul_pwr_ctrl_ded_v1250_present      = false;
  bool                                     pusch_cfg_ded_v1250_present        = false;
  bool                                     csi_rs_cfg_v1250_present           = false;
  copy_ptr<ant_info_ded_v1250_s>           ant_info_v1250;
  copy_ptr<eimta_main_cfg_r12_c>           eimta_main_cfg_r12;
  copy_ptr<eimta_main_cfg_serv_cell_r12_c> eimta_main_cfg_pcell_r12;
  copy_ptr<pucch_cfg_ded_v1250_s>          pucch_cfg_ded_v1250;
  copy_ptr<cqi_report_cfg_v1250_s>         cqi_report_cfg_pcell_v1250;
  copy_ptr<ul_pwr_ctrl_ded_v1250_s>        ul_pwr_ctrl_ded_v1250;
  copy_ptr<pusch_cfg_ded_v1250_s>          pusch_cfg_ded_v1250;
  copy_ptr<csi_rs_cfg_v1250_s>             csi_rs_cfg_v1250;
  // group 5
  bool                            pdsch_cfg_ded_v1280_present = false;
  copy_ptr<pdsch_cfg_ded_v1280_s> pdsch_cfg_ded_v1280;
  // group 6
  bool                                                pdsch_cfg_ded_v1310_present                     = false;
  bool                                                pucch_cfg_ded_r13_present                       = false;
  bool                                                pusch_cfg_ded_r13_present                       = false;
  bool                                                pdcch_candidate_reductions_r13_present          = false;
  bool                                                cqi_report_cfg_v1310_present                    = false;
  bool                                                srs_ul_cfg_ded_v1310_present                    = false;
  bool                                                srs_ul_cfg_ded_up_pts_ext_r13_present           = false;
  bool                                                srs_ul_cfg_ded_aperiodic_v1310_present          = false;
  bool                                                srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_present = false;
  bool                                                csi_rs_cfg_v1310_present                        = false;
  bool                                                ce_mode_r13_present                             = false;
  bool                                                csi_rs_cfg_nzp_to_add_mod_list_ext_r13_present  = false;
  bool                                                csi_rs_cfg_nzp_to_release_list_ext_r13_present  = false;
  copy_ptr<pdsch_cfg_ded_v1310_s>                     pdsch_cfg_ded_v1310;
  copy_ptr<pucch_cfg_ded_r13_s>                       pucch_cfg_ded_r13;
  copy_ptr<pusch_cfg_ded_r13_s>                       pusch_cfg_ded_r13;
  copy_ptr<pdcch_candidate_reductions_r13_c>          pdcch_candidate_reductions_r13;
  copy_ptr<cqi_report_cfg_v1310_s>                    cqi_report_cfg_v1310;
  copy_ptr<srs_ul_cfg_ded_v1310_c>                    srs_ul_cfg_ded_v1310;
  copy_ptr<srs_ul_cfg_ded_up_pts_ext_r13_c>           srs_ul_cfg_ded_up_pts_ext_r13;
  copy_ptr<srs_ul_cfg_ded_aperiodic_v1310_c>          srs_ul_cfg_ded_aperiodic_v1310;
  copy_ptr<srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_c> srs_ul_cfg_ded_aperiodic_up_pts_ext_r13;
  copy_ptr<csi_rs_cfg_v1310_s>                        csi_rs_cfg_v1310;
  copy_ptr<ce_mode_r13_c_>                            ce_mode_r13;
  copy_ptr<csi_rs_cfg_nzp_to_add_mod_list_ext_r13_l>  csi_rs_cfg_nzp_to_add_mod_list_ext_r13;
  copy_ptr<csi_rs_cfg_nzp_to_release_list_ext_r13_l>  csi_rs_cfg_nzp_to_release_list_ext_r13;
  // group 7
  bool                             cqi_report_cfg_v1320_present = false;
  copy_ptr<cqi_report_cfg_v1320_s> cqi_report_cfg_v1320;
  // group 8
  bool                                                     type_a_srs_tpc_pdcch_group_r14_present              = false;
  bool                                                     must_cfg_r14_present                                = false;
  bool                                                     pusch_enhance_cfg_r14_present                       = false;
  bool                                                     ce_pdsch_pusch_enhancement_cfg_r14_present          = false;
  bool                                                     ant_info_v1430_present                              = false;
  bool                                                     pucch_cfg_ded_v1430_present                         = false;
  bool                                                     pdsch_cfg_ded_v1430_present                         = false;
  bool                                                     pusch_cfg_ded_v1430_present                         = false;
  bool                                                     srs_ul_periodic_cfg_ded_list_r14_present            = false;
  bool                                                     srs_ul_periodic_cfg_ded_up_pts_ext_list_r14_present = false;
  bool                                                     srs_ul_aperiodic_cfg_ded_list_r14_present           = false;
  bool                                                     srs_ul_cfg_ded_ap_up_pts_ext_list_r14_present       = false;
  bool                                                     csi_rs_cfg_v1430_present                            = false;
  bool                                                     csi_rs_cfg_zp_ap_list_r14_present                   = false;
  bool                                                     cqi_report_cfg_v1430_present                        = false;
  bool                                                     semi_open_loop_r14_present                          = false;
  copy_ptr<type_a_srs_tpc_pdcch_group_r14_c_>              type_a_srs_tpc_pdcch_group_r14;
  copy_ptr<must_cfg_r14_c_>                                must_cfg_r14;
  copy_ptr<pusch_enhance_cfg_r14_c>                        pusch_enhance_cfg_r14;
  copy_ptr<ant_info_ded_v1430_s>                           ant_info_v1430;
  copy_ptr<pucch_cfg_ded_v1430_s>                          pucch_cfg_ded_v1430;
  copy_ptr<pdsch_cfg_ded_v1430_s>                          pdsch_cfg_ded_v1430;
  copy_ptr<pusch_cfg_ded_v1430_s>                          pusch_cfg_ded_v1430;
  copy_ptr<srs_ul_periodic_cfg_ded_list_r14_l_>            srs_ul_periodic_cfg_ded_list_r14;
  copy_ptr<srs_ul_periodic_cfg_ded_up_pts_ext_list_r14_l_> srs_ul_periodic_cfg_ded_up_pts_ext_list_r14;
  copy_ptr<srs_ul_aperiodic_cfg_ded_list_r14_l_>           srs_ul_aperiodic_cfg_ded_list_r14;
  copy_ptr<srs_ul_cfg_ded_ap_up_pts_ext_list_r14_l_>       srs_ul_cfg_ded_ap_up_pts_ext_list_r14;
  copy_ptr<csi_rs_cfg_v1430_s>                             csi_rs_cfg_v1430;
  copy_ptr<csi_rs_cfg_zp_ap_list_r14_c>                    csi_rs_cfg_zp_ap_list_r14;
  copy_ptr<cqi_report_cfg_v1430_s>                         cqi_report_cfg_v1430;
  bool                                                     semi_open_loop_r14 = false;
  // group 9
  bool                         csi_rs_cfg_v1480_present = false;
  copy_ptr<csi_rs_cfg_v1480_s> csi_rs_cfg_v1480;
  // group 10
  bool                                    phys_cfg_ded_stti_r15_present      = false;
  bool                                    pdsch_cfg_ded_v1530_present        = false;
  bool                                    pusch_cfg_ded_v1530_present        = false;
  bool                                    cqi_report_cfg_v1530_present       = false;
  bool                                    ant_info_v1530_present             = false;
  bool                                    csi_rs_cfg_v1530_present           = false;
  bool                                    ul_pwr_ctrl_ded_v1530_present      = false;
  bool                                    semi_static_cfi_cfg_r15_present    = false;
  bool                                    blind_pdsch_repeat_cfg_r15_present = false;
  copy_ptr<phys_cfg_ded_stti_r15_c>       phys_cfg_ded_stti_r15;
  copy_ptr<pdsch_cfg_ded_v1530_s>         pdsch_cfg_ded_v1530;
  copy_ptr<pusch_cfg_ded_v1530_s>         pusch_cfg_ded_v1530;
  copy_ptr<cqi_report_cfg_v1530_s>        cqi_report_cfg_v1530;
  copy_ptr<ant_info_ded_v1530_c>          ant_info_v1530;
  copy_ptr<csi_rs_cfg_v1530_s>            csi_rs_cfg_v1530;
  copy_ptr<ul_pwr_ctrl_ded_v1530_s>       ul_pwr_ctrl_ded_v1530;
  copy_ptr<semi_static_cfi_cfg_r15_c_>    semi_static_cfi_cfg_r15;
  copy_ptr<blind_pdsch_repeat_cfg_r15_c_> blind_pdsch_repeat_cfg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLF-TimersAndConstants-r13 ::= CHOICE
struct rlf_timers_and_consts_r13_c {
  struct setup_s_ {
    struct t301_v1310_opts {
      enum options { ms2500, ms3000, ms3500, ms4000, ms5000, ms6000, ms8000, ms10000, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<t301_v1310_opts> t301_v1310_e_;
    struct t310_v1330_opts {
      enum options { ms4000, ms6000, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<t310_v1330_opts> t310_v1330_e_;

    // member variables
    bool          ext = false;
    t301_v1310_e_ t301_v1310;
    // ...
    // group 0
    bool          t310_v1330_present = false;
    t310_v1330_e_ t310_v1330;

    // sequence methods
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
  };
  typedef setup_e types;

  // choice methods
  rlf_timers_and_consts_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RLF-TimersAndConstants-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RLF-TimersAndConstants-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RLF-TimersAndConstants-r9 ::= CHOICE
struct rlf_timers_and_consts_r9_c {
  struct setup_s_ {
    struct t301_r9_opts {
      enum options { ms100, ms200, ms300, ms400, ms600, ms1000, ms1500, ms2000, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<t301_r9_opts> t301_r9_e_;
    struct t310_r9_opts {
      enum options { ms0, ms50, ms100, ms200, ms500, ms1000, ms2000, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<t310_r9_opts> t310_r9_e_;
    struct n310_r9_opts {
      enum options { n1, n2, n3, n4, n6, n8, n10, n20, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<n310_r9_opts> n310_r9_e_;
    struct t311_r9_opts {
      enum options { ms1000, ms3000, ms5000, ms10000, ms15000, ms20000, ms30000, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<t311_r9_opts> t311_r9_e_;
    struct n311_r9_opts {
      enum options { n1, n2, n3, n4, n5, n6, n8, n10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<n311_r9_opts> n311_r9_e_;

    // member variables
    bool       ext = false;
    t301_r9_e_ t301_r9;
    t310_r9_e_ t310_r9;
    n310_r9_e_ n310_r9;
    t311_r9_e_ t311_r9;
    n311_r9_e_ n311_r9;
    // ...
  };
  typedef setup_e types;

  // choice methods
  rlf_timers_and_consts_r9_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RLF-TimersAndConstants-r9");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RLF-TimersAndConstants-r9");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RRCConnectionReject-v1020-IEs ::= SEQUENCE
struct rrc_conn_reject_v1020_ies_s {
  // member variables
  bool                        extended_wait_time_r10_present = false;
  bool                        non_crit_ext_present           = false;
  uint16_t                    extended_wait_time_r10         = 1;
  rrc_conn_reject_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SPS-Config ::= SEQUENCE
struct sps_cfg_s {
  // member variables
  bool                semi_persist_sched_c_rnti_present = false;
  bool                sps_cfg_dl_present                = false;
  bool                sps_cfg_ul_present                = false;
  fixed_bitstring<16> semi_persist_sched_c_rnti;
  sps_cfg_dl_c        sps_cfg_dl;
  sps_cfg_ul_c        sps_cfg_ul;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SPS-Config-v1430 ::= SEQUENCE
struct sps_cfg_v1430_s {
  // member variables
  bool                             ul_sps_v_rnti_r14_present              = false;
  bool                             sl_sps_v_rnti_r14_present              = false;
  bool                             sps_cfg_ul_to_add_mod_list_r14_present = false;
  bool                             sps_cfg_ul_to_release_list_r14_present = false;
  bool                             sps_cfg_sl_to_add_mod_list_r14_present = false;
  bool                             sps_cfg_sl_to_release_list_r14_present = false;
  fixed_bitstring<16>              ul_sps_v_rnti_r14;
  fixed_bitstring<16>              sl_sps_v_rnti_r14;
  sps_cfg_ul_to_add_mod_list_r14_l sps_cfg_ul_to_add_mod_list_r14;
  sps_cfg_ul_to_release_list_r14_l sps_cfg_ul_to_release_list_r14;
  sps_cfg_sl_to_add_mod_list_r14_l sps_cfg_sl_to_add_mod_list_r14;
  sps_cfg_sl_to_release_list_r14_l sps_cfg_sl_to_release_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SPS-Config-v1530 ::= SEQUENCE
struct sps_cfg_v1530_s {
  // member variables
  bool                                  semi_persist_sched_c_rnti_r15_present       = false;
  bool                                  sps_cfg_dl_present                          = false;
  bool                                  sps_cfg_ul_stti_to_add_mod_list_r15_present = false;
  bool                                  sps_cfg_ul_stti_to_release_list_r15_present = false;
  bool                                  sps_cfg_ul_to_add_mod_list_r15_present      = false;
  bool                                  sps_cfg_ul_to_release_list_r15_present      = false;
  fixed_bitstring<16>                   semi_persist_sched_c_rnti_r15;
  sps_cfg_dl_c                          sps_cfg_dl;
  sps_cfg_ul_stti_to_add_mod_list_r15_l sps_cfg_ul_stti_to_add_mod_list_r15;
  sps_cfg_ul_stti_to_release_list_r15_l sps_cfg_ul_stti_to_release_list_r15;
  sps_cfg_ul_to_add_mod_list_r15_l      sps_cfg_ul_to_add_mod_list_r15;
  sps_cfg_ul_to_release_list_r15_l      sps_cfg_ul_to_release_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRB-ToAddModExtList-r15 ::= SEQUENCE (SIZE (1)) OF SRB-ToAddMod
typedef fixed_array<srb_to_add_mod_s, 1> srb_to_add_mod_ext_list_r15_l;

// SRB-ToAddModList ::= SEQUENCE (SIZE (1..2)) OF SRB-ToAddMod
typedef dyn_array<srb_to_add_mod_s> srb_to_add_mod_list_l;

// SRB-ToReleaseListDupl-r15 ::= SEQUENCE (SIZE (1..2)) OF INTEGER
typedef bounded_array<uint8_t, 2> srb_to_release_list_dupl_r15_l;

// IdleModeMobilityControlInfo ::= SEQUENCE
struct idle_mode_mob_ctrl_info_s {
  struct t320_opts {
    enum options { min5, min10, min20, min30, min60, min120, min180, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<t320_opts> t320_e_;

  // member variables
  bool                         ext                                = false;
  bool                         freq_prio_list_eutra_present       = false;
  bool                         freq_prio_list_geran_present       = false;
  bool                         freq_prio_list_utra_fdd_present    = false;
  bool                         freq_prio_list_utra_tdd_present    = false;
  bool                         band_class_prio_list_hrpd_present  = false;
  bool                         band_class_prio_list1_xrtt_present = false;
  bool                         t320_present                       = false;
  freq_prio_list_eutra_l       freq_prio_list_eutra;
  freqs_prio_list_geran_l      freq_prio_list_geran;
  freq_prio_list_utra_fdd_l    freq_prio_list_utra_fdd;
  freq_prio_list_utra_tdd_l    freq_prio_list_utra_tdd;
  band_class_prio_list_hrpd_l  band_class_prio_list_hrpd;
  band_class_prio_list1_xrtt_l band_class_prio_list1_xrtt;
  t320_e_                      t320;
  // ...
  // group 0
  bool                                     freq_prio_list_ext_eutra_r12_present = false;
  copy_ptr<freq_prio_list_ext_eutra_r12_l> freq_prio_list_ext_eutra_r12;
  // group 1
  bool                                       freq_prio_list_eutra_v1310_present     = false;
  bool                                       freq_prio_list_ext_eutra_v1310_present = false;
  copy_ptr<freq_prio_list_eutra_v1310_l>     freq_prio_list_eutra_v1310;
  copy_ptr<freq_prio_list_ext_eutra_v1310_l> freq_prio_list_ext_eutra_v1310;
  // group 2
  bool                              freq_prio_list_nr_r15_present = false;
  copy_ptr<freq_prio_list_nr_r15_l> freq_prio_list_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IdleModeMobilityControlInfo-v9e0 ::= SEQUENCE
struct idle_mode_mob_ctrl_info_v9e0_s {
  typedef dyn_array<freq_prio_eutra_v9e0_s> freq_prio_list_eutra_v9e0_l_;

  // member variables
  freq_prio_list_eutra_v9e0_l_ freq_prio_list_eutra_v9e0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishment-v8a0-IEs ::= SEQUENCE
struct rrc_conn_reest_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentReject-v8a0-IEs ::= SEQUENCE
struct rrc_conn_reest_reject_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReject-v8a0-IEs ::= SEQUENCE
struct rrc_conn_reject_v8a0_ies_s {
  // member variables
  bool                        late_non_crit_ext_present = false;
  bool                        non_crit_ext_present      = false;
  dyn_octstring               late_non_crit_ext;
  rrc_conn_reject_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetup-v8a0-IEs ::= SEQUENCE
struct rrc_conn_setup_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigDedicated ::= SEQUENCE
struct rr_cfg_ded_s {
  struct mac_main_cfg_c_ {
    struct types_opts {
      enum options { explicit_value, default_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    mac_main_cfg_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    mac_main_cfg_s& explicit_value()
    {
      assert_choice_type("explicitValue", type_.to_string(), "mac-MainConfig");
      return c;
    }
    const mac_main_cfg_s& explicit_value() const
    {
      assert_choice_type("explicitValue", type_.to_string(), "mac-MainConfig");
      return c;
    }
    mac_main_cfg_s& set_explicit_value()
    {
      set(types::explicit_value);
      return c;
    }

  private:
    types          type_;
    mac_main_cfg_s c;
  };
  struct crs_intf_mitig_cfg_r15_c_ {
    struct setup_c_ {
      struct crs_intf_mitig_num_prbs_r15_opts {
        enum options { n6, n24, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<crs_intf_mitig_num_prbs_r15_opts> crs_intf_mitig_num_prbs_r15_e_;
      struct types_opts {
        enum options { crs_intf_mitig_enabled_minus15, crs_intf_mitig_num_prbs_r15, nulltype } value;
        typedef int8_t number_type;

        std::string to_string() const;
        int8_t      to_number() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      crs_intf_mitig_num_prbs_r15_e_& crs_intf_mitig_num_prbs_r15()
      {
        assert_choice_type("crs-IntfMitigNumPRBs-r15", type_.to_string(), "setup");
        return c;
      }
      const crs_intf_mitig_num_prbs_r15_e_& crs_intf_mitig_num_prbs_r15() const
      {
        assert_choice_type("crs-IntfMitigNumPRBs-r15", type_.to_string(), "setup");
        return c;
      }
      crs_intf_mitig_num_prbs_r15_e_& set_crs_intf_mitig_num_prbs_r15()
      {
        set(types::crs_intf_mitig_num_prbs_r15);
        return c;
      }

    private:
      types                          type_;
      crs_intf_mitig_num_prbs_r15_e_ c;
    };
    typedef setup_e types;

    // choice methods
    crs_intf_mitig_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "crs-IntfMitigConfig-r15");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "crs-IntfMitigConfig-r15");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };

  // member variables
  bool                  ext                         = false;
  bool                  srb_to_add_mod_list_present = false;
  bool                  drb_to_add_mod_list_present = false;
  bool                  drb_to_release_list_present = false;
  bool                  mac_main_cfg_present        = false;
  bool                  sps_cfg_present             = false;
  bool                  phys_cfg_ded_present        = false;
  srb_to_add_mod_list_l srb_to_add_mod_list;
  drb_to_add_mod_list_l drb_to_add_mod_list;
  drb_to_release_list_l drb_to_release_list;
  mac_main_cfg_c_       mac_main_cfg;
  sps_cfg_s             sps_cfg;
  phys_cfg_ded_s        phys_cfg_ded;
  // ...
  // group 0
  bool                                 rlf_timers_and_consts_r9_present = false;
  copy_ptr<rlf_timers_and_consts_r9_c> rlf_timers_and_consts_r9;
  // group 1
  bool                                  meas_sf_pattern_pcell_r10_present = false;
  copy_ptr<meas_sf_pattern_pcell_r10_c> meas_sf_pattern_pcell_r10;
  // group 2
  bool                                 neigh_cells_crs_info_r11_present = false;
  copy_ptr<neigh_cells_crs_info_r11_c> neigh_cells_crs_info_r11;
  // group 3
  bool                              naics_info_r12_present = false;
  copy_ptr<naics_assist_info_r12_c> naics_info_r12;
  // group 4
  bool                                  neigh_cells_crs_info_r13_present  = false;
  bool                                  rlf_timers_and_consts_r13_present = false;
  copy_ptr<neigh_cells_crs_info_r13_c>  neigh_cells_crs_info_r13;
  copy_ptr<rlf_timers_and_consts_r13_c> rlf_timers_and_consts_r13;
  // group 5
  bool                      sps_cfg_v1430_present = false;
  copy_ptr<sps_cfg_v1430_s> sps_cfg_v1430;
  // group 6
  bool                                     srb_to_add_mod_ext_list_r15_present  = false;
  bool                                     srb_to_release_ext_list_r15_present  = false;
  bool                                     sps_cfg_v1530_present                = false;
  bool                                     crs_intf_mitig_cfg_r15_present       = false;
  bool                                     neigh_cells_crs_info_r15_present     = false;
  bool                                     drb_to_add_mod_list_r15_present      = false;
  bool                                     drb_to_release_list_r15_present      = false;
  bool                                     srb_to_release_list_dupl_r15_present = false;
  copy_ptr<srb_to_add_mod_ext_list_r15_l>  srb_to_add_mod_ext_list_r15;
  uint8_t                                  srb_to_release_ext_list_r15 = 4;
  copy_ptr<sps_cfg_v1530_s>                sps_cfg_v1530;
  copy_ptr<crs_intf_mitig_cfg_r15_c_>      crs_intf_mitig_cfg_r15;
  copy_ptr<neigh_cells_crs_info_r15_c>     neigh_cells_crs_info_r15;
  copy_ptr<drb_to_add_mod_list_r15_l>      drb_to_add_mod_list_r15;
  copy_ptr<drb_to_release_list_r15_l>      drb_to_release_list_r15;
  copy_ptr<srb_to_release_list_dupl_r15_l> srb_to_release_list_dupl_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RedirectedCarrierInfo-r15-IEs ::= CHOICE
struct redirected_carrier_info_r15_ies_c {
  struct types_opts {
    enum options {
      eutra_r15,
      geran_r15,
      utra_fdd_r15,
      cdma2000_hrpd_r15,
      cdma2000_minus1x_rtt_r15,
      utra_tdd_r15,
      nulltype
    } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  redirected_carrier_info_r15_ies_c() = default;
  redirected_carrier_info_r15_ies_c(const redirected_carrier_info_r15_ies_c& other);
  redirected_carrier_info_r15_ies_c& operator=(const redirected_carrier_info_r15_ies_c& other);
  ~redirected_carrier_info_r15_ies_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint32_t& eutra_r15()
  {
    assert_choice_type("eutra-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<uint32_t>();
  }
  carrier_freqs_geran_s& geran_r15()
  {
    assert_choice_type("geran-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freqs_geran_s>();
  }
  uint16_t& utra_fdd_r15()
  {
    assert_choice_type("utra-FDD-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<uint16_t>();
  }
  carrier_freq_cdma2000_s& cdma2000_hrpd_r15()
  {
    assert_choice_type("cdma2000-HRPD-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_cdma2000_s& cdma2000_minus1x_rtt_r15()
  {
    assert_choice_type("cdma2000-1xRTT-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_list_utra_tdd_r10_l& utra_tdd_r15()
  {
    assert_choice_type("utra-TDD-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freq_list_utra_tdd_r10_l>();
  }
  const uint32_t& eutra_r15() const
  {
    assert_choice_type("eutra-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<uint32_t>();
  }
  const carrier_freqs_geran_s& geran_r15() const
  {
    assert_choice_type("geran-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freqs_geran_s>();
  }
  const uint16_t& utra_fdd_r15() const
  {
    assert_choice_type("utra-FDD-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<uint16_t>();
  }
  const carrier_freq_cdma2000_s& cdma2000_hrpd_r15() const
  {
    assert_choice_type("cdma2000-HRPD-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freq_cdma2000_s>();
  }
  const carrier_freq_cdma2000_s& cdma2000_minus1x_rtt_r15() const
  {
    assert_choice_type("cdma2000-1xRTT-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freq_cdma2000_s>();
  }
  const carrier_freq_list_utra_tdd_r10_l& utra_tdd_r15() const
  {
    assert_choice_type("utra-TDD-r15", type_.to_string(), "RedirectedCarrierInfo-r15-IEs");
    return c.get<carrier_freq_list_utra_tdd_r10_l>();
  }
  uint32_t& set_eutra_r15()
  {
    set(types::eutra_r15);
    return c.get<uint32_t>();
  }
  carrier_freqs_geran_s& set_geran_r15()
  {
    set(types::geran_r15);
    return c.get<carrier_freqs_geran_s>();
  }
  uint16_t& set_utra_fdd_r15()
  {
    set(types::utra_fdd_r15);
    return c.get<uint16_t>();
  }
  carrier_freq_cdma2000_s& set_cdma2000_hrpd_r15()
  {
    set(types::cdma2000_hrpd_r15);
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_cdma2000_s& set_cdma2000_minus1x_rtt_r15()
  {
    set(types::cdma2000_minus1x_rtt_r15);
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_list_utra_tdd_r10_l& set_utra_tdd_r15()
  {
    set(types::utra_tdd_r15);
    return c.get<carrier_freq_list_utra_tdd_r10_l>();
  }

private:
  types type_;
  choice_buffer_t<MAX4(
      sizeof(carrier_freq_cdma2000_s), sizeof(carrier_freq_list_utra_tdd_r10_l), sizeof(carrier_freqs_geran_s), 0)>
      c;

  void destroy_();
};

// RRCConnectionReestablishment-r8-IEs ::= SEQUENCE
struct rrc_conn_reest_r8_ies_s {
  // member variables
  bool                      non_crit_ext_present = false;
  rr_cfg_ded_s              rr_cfg_ded;
  uint8_t                   next_hop_chaining_count = 0;
  rrc_conn_reest_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentReject-r8-IEs ::= SEQUENCE
struct rrc_conn_reest_reject_r8_ies_s {
  // member variables
  bool                             non_crit_ext_present = false;
  rrc_conn_reest_reject_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReject-r8-IEs ::= SEQUENCE
struct rrc_conn_reject_r8_ies_s {
  // member variables
  bool                       non_crit_ext_present = false;
  uint8_t                    wait_time            = 1;
  rrc_conn_reject_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetup-r8-IEs ::= SEQUENCE
struct rrc_conn_setup_r8_ies_s {
  // member variables
  bool                      non_crit_ext_present = false;
  rr_cfg_ded_s              rr_cfg_ded;
  rrc_conn_setup_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCEarlyDataComplete-r15-IEs ::= SEQUENCE
struct rrc_early_data_complete_r15_ies_s {
  // member variables
  bool                              ded_info_nas_r15_present                = false;
  bool                              extended_wait_time_r15_present          = false;
  bool                              idle_mode_mob_ctrl_info_r15_present     = false;
  bool                              idle_mode_mob_ctrl_info_ext_r15_present = false;
  bool                              redirected_carrier_info_r15_present     = false;
  bool                              non_crit_ext_present                    = false;
  dyn_octstring                     ded_info_nas_r15;
  uint16_t                          extended_wait_time_r15 = 1;
  idle_mode_mob_ctrl_info_s         idle_mode_mob_ctrl_info_r15;
  idle_mode_mob_ctrl_info_v9e0_s    idle_mode_mob_ctrl_info_ext_r15;
  redirected_carrier_info_r15_ies_c redirected_carrier_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct c1_or_crit_ext_opts {
  enum options { c1, crit_exts_future, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<c1_or_crit_ext_opts> c1_or_crit_ext_e;

// RRCConnectionReestablishment ::= SEQUENCE
struct rrc_conn_reest_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rrc_conn_reest_r8, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_reest_r8_ies_s& rrc_conn_reest_r8()
      {
        assert_choice_type("rrcConnectionReestablishment-r8", type_.to_string(), "c1");
        return c;
      }
      const rrc_conn_reest_r8_ies_s& rrc_conn_reest_r8() const
      {
        assert_choice_type("rrcConnectionReestablishment-r8", type_.to_string(), "c1");
        return c;
      }
      rrc_conn_reest_r8_ies_s& set_rrc_conn_reest_r8()
      {
        set(types::rrc_conn_reest_r8);
        return c;
      }

    private:
      types                   type_;
      rrc_conn_reest_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentReject ::= SEQUENCE
struct rrc_conn_reest_reject_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_conn_reest_reject_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_reest_reject_r8_ies_s& rrc_conn_reest_reject_r8()
    {
      assert_choice_type("rrcConnectionReestablishmentReject-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_reest_reject_r8_ies_s>();
    }
    const rrc_conn_reest_reject_r8_ies_s& rrc_conn_reest_reject_r8() const
    {
      assert_choice_type("rrcConnectionReestablishmentReject-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_reest_reject_r8_ies_s>();
    }
    rrc_conn_reest_reject_r8_ies_s& set_rrc_conn_reest_reject_r8()
    {
      set(types::rrc_conn_reest_reject_r8);
      return c.get<rrc_conn_reest_reject_r8_ies_s>();
    }

  private:
    types                                                   type_;
    choice_buffer_t<sizeof(rrc_conn_reest_reject_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReject ::= SEQUENCE
struct rrc_conn_reject_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rrc_conn_reject_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_reject_r8_ies_s& rrc_conn_reject_r8()
      {
        assert_choice_type("rrcConnectionReject-r8", type_.to_string(), "c1");
        return c;
      }
      const rrc_conn_reject_r8_ies_s& rrc_conn_reject_r8() const
      {
        assert_choice_type("rrcConnectionReject-r8", type_.to_string(), "c1");
        return c;
      }
      rrc_conn_reject_r8_ies_s& set_rrc_conn_reject_r8()
      {
        set(types::rrc_conn_reject_r8);
        return c;
      }

    private:
      types                    type_;
      rrc_conn_reject_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetup ::= SEQUENCE
struct rrc_conn_setup_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rrc_conn_setup_r8, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_setup_r8_ies_s& rrc_conn_setup_r8()
      {
        assert_choice_type("rrcConnectionSetup-r8", type_.to_string(), "c1");
        return c;
      }
      const rrc_conn_setup_r8_ies_s& rrc_conn_setup_r8() const
      {
        assert_choice_type("rrcConnectionSetup-r8", type_.to_string(), "c1");
        return c;
      }
      rrc_conn_setup_r8_ies_s& set_rrc_conn_setup_r8()
      {
        set(types::rrc_conn_setup_r8);
        return c;
      }

    private:
      types                   type_;
      rrc_conn_setup_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCEarlyDataComplete-r15 ::= SEQUENCE
struct rrc_early_data_complete_r15_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_early_data_complete_r15, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_early_data_complete_r15_ies_s& rrc_early_data_complete_r15()
    {
      assert_choice_type("rrcEarlyDataComplete-r15", type_.to_string(), "criticalExtensions");
      return c.get<rrc_early_data_complete_r15_ies_s>();
    }
    const rrc_early_data_complete_r15_ies_s& rrc_early_data_complete_r15() const
    {
      assert_choice_type("rrcEarlyDataComplete-r15", type_.to_string(), "criticalExtensions");
      return c.get<rrc_early_data_complete_r15_ies_s>();
    }
    rrc_early_data_complete_r15_ies_s& set_rrc_early_data_complete_r15()
    {
      set(types::rrc_early_data_complete_r15);
      return c.get<rrc_early_data_complete_r15_ies_s>();
    }

  private:
    types                                                      type_;
    choice_buffer_t<sizeof(rrc_early_data_complete_r15_ies_s)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-CCCH-MessageType ::= CHOICE
struct dl_ccch_msg_type_c {
  struct c1_c_ {
    struct types_opts {
      enum options { rrc_conn_reest, rrc_conn_reest_reject, rrc_conn_reject, rrc_conn_setup, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    c1_c_() = default;
    c1_c_(const c1_c_& other);
    c1_c_& operator=(const c1_c_& other);
    ~c1_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_reest_s& rrc_conn_reest()
    {
      assert_choice_type("rrcConnectionReestablishment", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_s>();
    }
    rrc_conn_reest_reject_s& rrc_conn_reest_reject()
    {
      assert_choice_type("rrcConnectionReestablishmentReject", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_reject_s>();
    }
    rrc_conn_reject_s& rrc_conn_reject()
    {
      assert_choice_type("rrcConnectionReject", type_.to_string(), "c1");
      return c.get<rrc_conn_reject_s>();
    }
    rrc_conn_setup_s& rrc_conn_setup()
    {
      assert_choice_type("rrcConnectionSetup", type_.to_string(), "c1");
      return c.get<rrc_conn_setup_s>();
    }
    const rrc_conn_reest_s& rrc_conn_reest() const
    {
      assert_choice_type("rrcConnectionReestablishment", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_s>();
    }
    const rrc_conn_reest_reject_s& rrc_conn_reest_reject() const
    {
      assert_choice_type("rrcConnectionReestablishmentReject", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_reject_s>();
    }
    const rrc_conn_reject_s& rrc_conn_reject() const
    {
      assert_choice_type("rrcConnectionReject", type_.to_string(), "c1");
      return c.get<rrc_conn_reject_s>();
    }
    const rrc_conn_setup_s& rrc_conn_setup() const
    {
      assert_choice_type("rrcConnectionSetup", type_.to_string(), "c1");
      return c.get<rrc_conn_setup_s>();
    }
    rrc_conn_reest_s& set_rrc_conn_reest()
    {
      set(types::rrc_conn_reest);
      return c.get<rrc_conn_reest_s>();
    }
    rrc_conn_reest_reject_s& set_rrc_conn_reest_reject()
    {
      set(types::rrc_conn_reest_reject);
      return c.get<rrc_conn_reest_reject_s>();
    }
    rrc_conn_reject_s& set_rrc_conn_reject()
    {
      set(types::rrc_conn_reject);
      return c.get<rrc_conn_reject_s>();
    }
    rrc_conn_setup_s& set_rrc_conn_setup()
    {
      set(types::rrc_conn_setup);
      return c.get<rrc_conn_setup_s>();
    }

  private:
    types type_;
    choice_buffer_t<MAX4(
        sizeof(rrc_conn_reest_reject_s), sizeof(rrc_conn_reest_s), sizeof(rrc_conn_reject_s), sizeof(rrc_conn_setup_s))>
        c;

    void destroy_();
  };
  struct msg_class_ext_c_ {
    struct c2_c_ {
      struct types_opts {
        enum options { rrc_early_data_complete_r15, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c2_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_early_data_complete_r15_s& rrc_early_data_complete_r15()
      {
        assert_choice_type("rrcEarlyDataComplete-r15", type_.to_string(), "c2");
        return c;
      }
      const rrc_early_data_complete_r15_s& rrc_early_data_complete_r15() const
      {
        assert_choice_type("rrcEarlyDataComplete-r15", type_.to_string(), "c2");
        return c;
      }
      rrc_early_data_complete_r15_s& set_rrc_early_data_complete_r15()
      {
        set(types::rrc_early_data_complete_r15);
        return c;
      }

    private:
      types                         type_;
      rrc_early_data_complete_r15_s c;
    };
    struct types_opts {
      enum options { c2, msg_class_ext_future_r15, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    msg_class_ext_c_() = default;
    msg_class_ext_c_(const msg_class_ext_c_& other);
    msg_class_ext_c_& operator=(const msg_class_ext_c_& other);
    ~msg_class_ext_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c2_c_& c2()
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    const c2_c_& c2() const
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    c2_c_& set_c2()
    {
      set(types::c2);
      return c.get<c2_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c2_c_)> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  dl_ccch_msg_type_c() = default;
  dl_ccch_msg_type_c(const dl_ccch_msg_type_c& other);
  dl_ccch_msg_type_c& operator=(const dl_ccch_msg_type_c& other);
  ~dl_ccch_msg_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "DL-CCCH-MessageType");
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& msg_class_ext()
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "DL-CCCH-MessageType");
    return c.get<msg_class_ext_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "DL-CCCH-MessageType");
    return c.get<c1_c_>();
  }
  const msg_class_ext_c_& msg_class_ext() const
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "DL-CCCH-MessageType");
    return c.get<msg_class_ext_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& set_msg_class_ext()
  {
    set(types::msg_class_ext);
    return c.get<msg_class_ext_c_>();
  }

private:
  types                                                          type_;
  choice_buffer_t<MAX2(sizeof(c1_c_), sizeof(msg_class_ext_c_))> c;

  void destroy_();
};

// DL-CCCH-Message ::= SEQUENCE
struct dl_ccch_msg_s {
  // member variables
  dl_ccch_msg_type_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCCH-CandidateReductionValue-r14 ::= ENUMERATED
struct pdcch_candidate_reduction_value_r14_opts {
  enum options { n0, n50, n100, n150, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<pdcch_candidate_reduction_value_r14_opts> pdcch_candidate_reduction_value_r14_e;

// PDCCH-CandidateReductionsLAA-UL-r14 ::= CHOICE
struct pdcch_candidate_reductions_laa_ul_r14_c {
  struct setup_s_ {
    // member variables
    pdcch_candidate_reduction_value_r13_e pdcch_candidate_reduction_al1_r14;
    pdcch_candidate_reduction_value_r13_e pdcch_candidate_reduction_al2_r14;
    pdcch_candidate_reduction_value_r14_e pdcch_candidate_reduction_al3_r14;
    pdcch_candidate_reduction_value_r14_e pdcch_candidate_reduction_al4_r14;
    pdcch_candidate_reduction_value_r14_e pdcch_candidate_reduction_al5_r14;
  };
  typedef setup_e types;

  // choice methods
  pdcch_candidate_reductions_laa_ul_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "PDCCH-CandidateReductionsLAA-UL-r14");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "PDCCH-CandidateReductionsLAA-UL-r14");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// AUL-Config-r15 ::= CHOICE
struct aul_cfg_r15_c {
  struct setup_s_ {
    struct tx_mode_ul_aul_r15_opts {
      enum options { tm1, tm2, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tx_mode_ul_aul_r15_opts> tx_mode_ul_aul_r15_e_;
    struct aul_start_partial_bw_inside_mcot_r15_opts {
      enum options { o34, o43, o52, o61, o_os1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<aul_start_partial_bw_inside_mcot_r15_opts> aul_start_partial_bw_inside_mcot_r15_e_;
    struct aul_start_partial_bw_outside_mcot_r15_opts {
      enum options { o16, o25, o34, o43, o52, o61, o_os1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<aul_start_partial_bw_outside_mcot_r15_opts> aul_start_partial_bw_outside_mcot_r15_e_;
    struct aul_retx_timer_r15_opts {
      enum options {
        psf4,
        psf5,
        psf6,
        psf8,
        psf10,
        psf12,
        psf20,
        psf28,
        psf37,
        psf44,
        psf68,
        psf84,
        psf100,
        psf116,
        psf132,
        psf164,
        psf324,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<aul_retx_timer_r15_opts> aul_retx_timer_r15_e_;
    struct contention_win_size_timer_r15_opts {
      enum options { n0, n5, n10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<contention_win_size_timer_r15_opts> contention_win_size_timer_r15_e_;

    // member variables
    fixed_bitstring<16>                      aul_crnti_r15;
    fixed_bitstring<40>                      aul_sfs_r15;
    uint8_t                                  aul_harq_processes_r15 = 1;
    tx_mode_ul_aul_r15_e_                    tx_mode_ul_aul_r15;
    fixed_bitstring<5>                       aul_start_full_bw_inside_mcot_r15;
    fixed_bitstring<7>                       aul_start_full_bw_outside_mcot_r15;
    aul_start_partial_bw_inside_mcot_r15_e_  aul_start_partial_bw_inside_mcot_r15;
    aul_start_partial_bw_outside_mcot_r15_e_ aul_start_partial_bw_outside_mcot_r15;
    aul_retx_timer_r15_e_                    aul_retx_timer_r15;
    uint8_t                                  ending_symbol_aul_r15     = 12;
    uint8_t                                  sf_offset_cot_sharing_r15 = 2;
    contention_win_size_timer_r15_e_         contention_win_size_timer_r15;
  };
  typedef setup_e types;

  // choice methods
  aul_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "AUL-Config-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "AUL-Config-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CQI-ReportPeriodicSCell-r15 ::= CHOICE
struct cqi_report_periodic_scell_r15_c {
  struct setup_s_ {
    struct csi_sf_pattern_dormant_r15_c_ {
      struct setup_s_ {
        // member variables
        meas_sf_pattern_r10_c csi_meas_sf_set1_r15;
        meas_sf_pattern_r10_c csi_meas_sf_set2_r15;
      };
      typedef setup_e types;

      // choice methods
      csi_sf_pattern_dormant_r15_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "csi-SubframePatternDormant-r15");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "csi-SubframePatternDormant-r15");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };
    struct cqi_format_ind_dormant_r15_c_ {
      struct wideband_cqi_r15_s_ {
        struct csi_report_mode_r15_opts {
          enum options { submode1, submode2, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<csi_report_mode_r15_opts> csi_report_mode_r15_e_;

        // member variables
        bool                   csi_report_mode_r15_present = false;
        csi_report_mode_r15_e_ csi_report_mode_r15;
      };
      struct subband_cqi_r15_s_ {
        struct periodicity_factor_r15_opts {
          enum options { n2, n4, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<periodicity_factor_r15_opts> periodicity_factor_r15_e_;

        // member variables
        uint8_t                   k_r15 = 1;
        periodicity_factor_r15_e_ periodicity_factor_r15;
      };
      struct types_opts {
        enum options { wideband_cqi_r15, subband_cqi_r15, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      cqi_format_ind_dormant_r15_c_() = default;
      cqi_format_ind_dormant_r15_c_(const cqi_format_ind_dormant_r15_c_& other);
      cqi_format_ind_dormant_r15_c_& operator=(const cqi_format_ind_dormant_r15_c_& other);
      ~cqi_format_ind_dormant_r15_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      wideband_cqi_r15_s_& wideband_cqi_r15()
      {
        assert_choice_type("widebandCQI-r15", type_.to_string(), "cqi-FormatIndicatorDormant-r15");
        return c.get<wideband_cqi_r15_s_>();
      }
      subband_cqi_r15_s_& subband_cqi_r15()
      {
        assert_choice_type("subbandCQI-r15", type_.to_string(), "cqi-FormatIndicatorDormant-r15");
        return c.get<subband_cqi_r15_s_>();
      }
      const wideband_cqi_r15_s_& wideband_cqi_r15() const
      {
        assert_choice_type("widebandCQI-r15", type_.to_string(), "cqi-FormatIndicatorDormant-r15");
        return c.get<wideband_cqi_r15_s_>();
      }
      const subband_cqi_r15_s_& subband_cqi_r15() const
      {
        assert_choice_type("subbandCQI-r15", type_.to_string(), "cqi-FormatIndicatorDormant-r15");
        return c.get<subband_cqi_r15_s_>();
      }
      wideband_cqi_r15_s_& set_wideband_cqi_r15()
      {
        set(types::wideband_cqi_r15);
        return c.get<wideband_cqi_r15_s_>();
      }
      subband_cqi_r15_s_& set_subband_cqi_r15()
      {
        set(types::subband_cqi_r15);
        return c.get<subband_cqi_r15_s_>();
      }

    private:
      types                                                                          type_;
      choice_buffer_t<MAX2(sizeof(subband_cqi_r15_s_), sizeof(wideband_cqi_r15_s_))> c;

      void destroy_();
    };

    // member variables
    bool                          ri_cfg_idx_dormant_r15_present     = false;
    bool                          csi_sf_pattern_dormant_r15_present = false;
    bool                          cqi_format_ind_dormant_r15_present = false;
    uint16_t                      cqi_pmi_cfg_idx_dormant_r15        = 0;
    uint16_t                      ri_cfg_idx_dormant_r15             = 0;
    csi_sf_pattern_dormant_r15_c_ csi_sf_pattern_dormant_r15;
    cqi_format_ind_dormant_r15_c_ cqi_format_ind_dormant_r15;
  };
  typedef setup_e types;

  // choice methods
  cqi_report_periodic_scell_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportPeriodicSCell-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ReportPeriodicSCell-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CrossCarrierSchedulingConfigLAA-UL-r14 ::= SEQUENCE
struct cross_carrier_sched_cfg_laa_ul_r14_s {
  // member variables
  uint8_t sched_cell_id_r14     = 0;
  uint8_t cif_in_sched_cell_r14 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LBT-Config-r14 ::= CHOICE
struct lbt_cfg_r14_c {
  struct types_opts {
    enum options { max_energy_detection_thres_r14, energy_detection_thres_offset_r14, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  lbt_cfg_r14_c() = default;
  lbt_cfg_r14_c(const lbt_cfg_r14_c& other);
  lbt_cfg_r14_c& operator=(const lbt_cfg_r14_c& other);
  ~lbt_cfg_r14_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  int8_t& max_energy_detection_thres_r14()
  {
    assert_choice_type("maxEnergyDetectionThreshold-r14", type_.to_string(), "LBT-Config-r14");
    return c.get<int8_t>();
  }
  int8_t& energy_detection_thres_offset_r14()
  {
    assert_choice_type("energyDetectionThresholdOffset-r14", type_.to_string(), "LBT-Config-r14");
    return c.get<int8_t>();
  }
  const int8_t& max_energy_detection_thres_r14() const
  {
    assert_choice_type("maxEnergyDetectionThreshold-r14", type_.to_string(), "LBT-Config-r14");
    return c.get<int8_t>();
  }
  const int8_t& energy_detection_thres_offset_r14() const
  {
    assert_choice_type("energyDetectionThresholdOffset-r14", type_.to_string(), "LBT-Config-r14");
    return c.get<int8_t>();
  }
  int8_t& set_max_energy_detection_thres_r14()
  {
    set(types::max_energy_detection_thres_r14);
    return c.get<int8_t>();
  }
  int8_t& set_energy_detection_thres_offset_r14()
  {
    set(types::energy_detection_thres_offset_r14);
    return c.get<int8_t>();
  }

private:
  types              type_;
  choice_buffer_t<8> c;

  void destroy_();
};

// PDCCH-ConfigLAA-r14 ::= SEQUENCE
struct pdcch_cfg_laa_r14_s {
  struct max_nof_sched_sfs_format0_b_r14_opts {
    enum options { sf2, sf3, sf4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<max_nof_sched_sfs_format0_b_r14_opts> max_nof_sched_sfs_format0_b_r14_e_;
  struct max_nof_sched_sfs_format4_b_r14_opts {
    enum options { sf2, sf3, sf4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<max_nof_sched_sfs_format4_b_r14_opts> max_nof_sched_sfs_format4_b_r14_e_;

  // member variables
  bool                                    max_nof_sched_sfs_format0_b_r14_present          = false;
  bool                                    max_nof_sched_sfs_format4_b_r14_present          = false;
  bool                                    skip_monitoring_dci_format0_a_r14_present        = false;
  bool                                    skip_monitoring_dci_format4_a_r14_present        = false;
  bool                                    pdcch_candidate_reductions_format0_a_r14_present = false;
  bool                                    pdcch_candidate_reductions_format4_a_r14_present = false;
  bool                                    pdcch_candidate_reductions_format0_b_r14_present = false;
  bool                                    pdcch_candidate_reductions_format4_b_r14_present = false;
  max_nof_sched_sfs_format0_b_r14_e_      max_nof_sched_sfs_format0_b_r14;
  max_nof_sched_sfs_format4_b_r14_e_      max_nof_sched_sfs_format4_b_r14;
  pdcch_candidate_reductions_r13_c        pdcch_candidate_reductions_format0_a_r14;
  pdcch_candidate_reductions_laa_ul_r14_c pdcch_candidate_reductions_format4_a_r14;
  pdcch_candidate_reductions_laa_ul_r14_c pdcch_candidate_reductions_format0_b_r14;
  pdcch_candidate_reductions_laa_ul_r14_c pdcch_candidate_reductions_format4_b_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ModeConfigLAA-r15 ::= SEQUENCE
struct pusch_mode_cfg_laa_r15_s {
  // member variables
  bool laa_pusch_mode1 = false;
  bool laa_pusch_mode2 = false;
  bool laa_pusch_mode3 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SoundingRS-UL-ConfigDedicatedAperiodic-v1430 ::= CHOICE
struct srs_ul_cfg_ded_aperiodic_v1430_c {
  struct setup_s_ {
    // member variables
    bool    srs_sf_ind_r14_present = false;
    uint8_t srs_sf_ind_r14         = 1;
  };
  typedef setup_e types;

  // choice methods
  srs_ul_cfg_ded_aperiodic_v1430_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodic-v1430");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SoundingRS-UL-ConfigDedicatedAperiodic-v1430");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CQI-ReportConfigSCell-r10 ::= SEQUENCE
struct cqi_report_cfg_scell_r10_s {
  // member variables
  bool                        cqi_report_mode_aperiodic_r10_present = false;
  bool                        cqi_report_periodic_scell_r10_present = false;
  bool                        pmi_ri_report_r10_present             = false;
  cqi_report_mode_aperiodic_e cqi_report_mode_aperiodic_r10;
  int8_t                      nom_pdsch_rs_epre_offset_r10 = -1;
  cqi_report_periodic_r10_c   cqi_report_periodic_scell_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ReportConfigSCell-r15 ::= SEQUENCE
struct cqi_report_cfg_scell_r15_s {
  struct alt_cqi_table_minus1024_qam_r15_opts {
    enum options { all_sfs, csi_sf_set1, csi_sf_set2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<alt_cqi_table_minus1024_qam_r15_opts> alt_cqi_table_minus1024_qam_r15_e_;

  // member variables
  bool                               cqi_report_periodic_scell_r15_present   = false;
  bool                               alt_cqi_table_minus1024_qam_r15_present = false;
  cqi_report_periodic_scell_r15_c    cqi_report_periodic_scell_r15;
  alt_cqi_table_minus1024_qam_r15_e_ alt_cqi_table_minus1024_qam_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CQI-ShortConfigSCell-r15 ::= CHOICE
struct cqi_short_cfg_scell_r15_c {
  struct setup_s_ {
    struct cqi_format_ind_short_r15_c_ {
      struct wideband_cqi_short_r15_s_ {
        struct csi_report_mode_short_r15_opts {
          enum options { submode1, submode2, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<csi_report_mode_short_r15_opts> csi_report_mode_short_r15_e_;

        // member variables
        bool                         csi_report_mode_short_r15_present = false;
        csi_report_mode_short_r15_e_ csi_report_mode_short_r15;
      };
      struct subband_cqi_short_r15_s_ {
        struct periodicity_factor_r15_opts {
          enum options { n2, n4, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<periodicity_factor_r15_opts> periodicity_factor_r15_e_;

        // member variables
        uint8_t                   k_r15 = 1;
        periodicity_factor_r15_e_ periodicity_factor_r15;
      };
      struct types_opts {
        enum options { wideband_cqi_short_r15, subband_cqi_short_r15, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      cqi_format_ind_short_r15_c_() = default;
      cqi_format_ind_short_r15_c_(const cqi_format_ind_short_r15_c_& other);
      cqi_format_ind_short_r15_c_& operator=(const cqi_format_ind_short_r15_c_& other);
      ~cqi_format_ind_short_r15_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      wideband_cqi_short_r15_s_& wideband_cqi_short_r15()
      {
        assert_choice_type("widebandCQI-Short-r15", type_.to_string(), "cqi-FormatIndicatorShort-r15");
        return c.get<wideband_cqi_short_r15_s_>();
      }
      subband_cqi_short_r15_s_& subband_cqi_short_r15()
      {
        assert_choice_type("subbandCQI-Short-r15", type_.to_string(), "cqi-FormatIndicatorShort-r15");
        return c.get<subband_cqi_short_r15_s_>();
      }
      const wideband_cqi_short_r15_s_& wideband_cqi_short_r15() const
      {
        assert_choice_type("widebandCQI-Short-r15", type_.to_string(), "cqi-FormatIndicatorShort-r15");
        return c.get<wideband_cqi_short_r15_s_>();
      }
      const subband_cqi_short_r15_s_& subband_cqi_short_r15() const
      {
        assert_choice_type("subbandCQI-Short-r15", type_.to_string(), "cqi-FormatIndicatorShort-r15");
        return c.get<subband_cqi_short_r15_s_>();
      }
      wideband_cqi_short_r15_s_& set_wideband_cqi_short_r15()
      {
        set(types::wideband_cqi_short_r15);
        return c.get<wideband_cqi_short_r15_s_>();
      }
      subband_cqi_short_r15_s_& set_subband_cqi_short_r15()
      {
        set(types::subband_cqi_short_r15);
        return c.get<subband_cqi_short_r15_s_>();
      }

    private:
      types                                                                                      type_;
      choice_buffer_t<MAX2(sizeof(subband_cqi_short_r15_s_), sizeof(wideband_cqi_short_r15_s_))> c;

      void destroy_();
    };

    // member variables
    bool                        ri_cfg_idx_short_r15_present     = false;
    bool                        cqi_format_ind_short_r15_present = false;
    uint16_t                    cqi_pmi_cfg_idx_short_r15        = 0;
    uint16_t                    ri_cfg_idx_short_r15             = 0;
    cqi_format_ind_short_r15_c_ cqi_format_ind_short_r15;
  };
  typedef setup_e types;

  // choice methods
  cqi_short_cfg_scell_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ShortConfigSCell-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "CQI-ShortConfigSCell-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// CrossCarrierSchedulingConfig-r10 ::= SEQUENCE
struct cross_carrier_sched_cfg_r10_s {
  struct sched_cell_info_r10_c_ {
    struct own_r10_s_ {
      // member variables
      bool cif_presence_r10 = false;
    };
    struct other_r10_s_ {
      // member variables
      uint8_t sched_cell_id_r10 = 0;
      uint8_t pdsch_start_r10   = 1;
    };
    struct types_opts {
      enum options { own_r10, other_r10, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sched_cell_info_r10_c_() = default;
    sched_cell_info_r10_c_(const sched_cell_info_r10_c_& other);
    sched_cell_info_r10_c_& operator=(const sched_cell_info_r10_c_& other);
    ~sched_cell_info_r10_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    own_r10_s_& own_r10()
    {
      assert_choice_type("own-r10", type_.to_string(), "schedulingCellInfo-r10");
      return c.get<own_r10_s_>();
    }
    other_r10_s_& other_r10()
    {
      assert_choice_type("other-r10", type_.to_string(), "schedulingCellInfo-r10");
      return c.get<other_r10_s_>();
    }
    const own_r10_s_& own_r10() const
    {
      assert_choice_type("own-r10", type_.to_string(), "schedulingCellInfo-r10");
      return c.get<own_r10_s_>();
    }
    const other_r10_s_& other_r10() const
    {
      assert_choice_type("other-r10", type_.to_string(), "schedulingCellInfo-r10");
      return c.get<other_r10_s_>();
    }
    own_r10_s_& set_own_r10()
    {
      set(types::own_r10);
      return c.get<own_r10_s_>();
    }
    other_r10_s_& set_other_r10()
    {
      set(types::other_r10);
      return c.get<other_r10_s_>();
    }

  private:
    types                                                           type_;
    choice_buffer_t<MAX2(sizeof(other_r10_s_), sizeof(own_r10_s_))> c;

    void destroy_();
  };

  // member variables
  sched_cell_info_r10_c_ sched_cell_info_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CrossCarrierSchedulingConfig-r13 ::= SEQUENCE
struct cross_carrier_sched_cfg_r13_s {
  struct sched_cell_info_r13_c_ {
    struct own_r13_s_ {
      // member variables
      bool cif_presence_r13 = false;
    };
    struct other_r13_s_ {
      // member variables
      uint8_t sched_cell_id_r13     = 0;
      uint8_t pdsch_start_r13       = 1;
      uint8_t cif_in_sched_cell_r13 = 1;
    };
    struct types_opts {
      enum options { own_r13, other_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sched_cell_info_r13_c_() = default;
    sched_cell_info_r13_c_(const sched_cell_info_r13_c_& other);
    sched_cell_info_r13_c_& operator=(const sched_cell_info_r13_c_& other);
    ~sched_cell_info_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    own_r13_s_& own_r13()
    {
      assert_choice_type("own-r13", type_.to_string(), "schedulingCellInfo-r13");
      return c.get<own_r13_s_>();
    }
    other_r13_s_& other_r13()
    {
      assert_choice_type("other-r13", type_.to_string(), "schedulingCellInfo-r13");
      return c.get<other_r13_s_>();
    }
    const own_r13_s_& own_r13() const
    {
      assert_choice_type("own-r13", type_.to_string(), "schedulingCellInfo-r13");
      return c.get<own_r13_s_>();
    }
    const other_r13_s_& other_r13() const
    {
      assert_choice_type("other-r13", type_.to_string(), "schedulingCellInfo-r13");
      return c.get<other_r13_s_>();
    }
    own_r13_s_& set_own_r13()
    {
      set(types::own_r13);
      return c.get<own_r13_s_>();
    }
    other_r13_s_& set_other_r13()
    {
      set(types::other_r13);
      return c.get<other_r13_s_>();
    }

  private:
    types                                                           type_;
    choice_buffer_t<MAX2(sizeof(other_r13_s_), sizeof(own_r13_s_))> c;

    void destroy_();
  };

  // member variables
  sched_cell_info_r13_c_ sched_cell_info_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DeltaFList-SPUCCH-r15 ::= CHOICE
struct delta_flist_spucch_r15_c {
  struct setup_s_ {
    struct delta_f_slot_spucch_format1_r15_opts {
      enum options {
        delta_f_minus1,
        delta_f0,
        delta_f1,
        delta_f2,
        delta_f3,
        delta_f4,
        delta_f5,
        delta_f6,
        nulltype
      } value;
      typedef int8_t number_type;

      std::string to_string() const;
      int8_t      to_number() const;
    };
    typedef enumerated<delta_f_slot_spucch_format1_r15_opts> delta_f_slot_spucch_format1_r15_e_;
    struct delta_f_slot_spucch_format1a_r15_opts {
      enum options { delta_f1, delta_f2, delta_f3, delta_f4, delta_f5, delta_f6, delta_f7, delta_f8, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_slot_spucch_format1a_r15_opts> delta_f_slot_spucch_format1a_r15_e_;
    struct delta_f_slot_spucch_format1b_r15_opts {
      enum options { delta_f3, delta_f4, delta_f5, delta_f6, delta_f7, delta_f8, delta_f9, delta_f10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_slot_spucch_format1b_r15_opts> delta_f_slot_spucch_format1b_r15_e_;
    struct delta_f_slot_spucch_format3_r15_opts {
      enum options { delta_f4, delta_f5, delta_f6, delta_f7, delta_f8, delta_f9, delta_f10, delta_f11, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_slot_spucch_format3_r15_opts> delta_f_slot_spucch_format3_r15_e_;
    struct delta_f_slot_spucch_rm_format4_r15_opts {
      enum options {
        delta_f13,
        delta_f14,
        delta_f15,
        delta_f16,
        delta_f17,
        delta_f18,
        delta_f19,
        delta_f20,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_slot_spucch_rm_format4_r15_opts> delta_f_slot_spucch_rm_format4_r15_e_;
    struct delta_f_slot_spucch_tbcc_format4_r15_opts {
      enum options {
        delta_f10,
        delta_f11,
        delta_f12,
        delta_f13,
        delta_f14,
        delta_f15,
        delta_f16,
        delta_f17,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_slot_spucch_tbcc_format4_r15_opts> delta_f_slot_spucch_tbcc_format4_r15_e_;
    struct delta_f_subslot_spucch_format1and1a_r15_opts {
      enum options {
        delta_f5,
        delta_f6,
        delta_f7,
        delta_f8,
        delta_f9,
        delta_f10,
        delta_f11,
        delta_f12,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_subslot_spucch_format1and1a_r15_opts> delta_f_subslot_spucch_format1and1a_r15_e_;
    struct delta_f_subslot_spucch_format1b_r15_opts {
      enum options {
        delta_f6,
        delta_f7,
        delta_f8,
        delta_f9,
        delta_f10,
        delta_f11,
        delta_f12,
        delta_f13,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_subslot_spucch_format1b_r15_opts> delta_f_subslot_spucch_format1b_r15_e_;
    struct delta_f_subslot_spucch_rm_format4_r15_opts {
      enum options {
        delta_f15,
        delta_f16,
        delta_f17,
        delta_f18,
        delta_f19,
        delta_f20,
        delta_f21,
        delta_f22,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_subslot_spucch_rm_format4_r15_opts> delta_f_subslot_spucch_rm_format4_r15_e_;
    struct delta_f_subslot_spucch_tbcc_format4_r15_opts {
      enum options {
        delta_f10,
        delta_f11,
        delta_f12,
        delta_f13,
        delta_f14,
        delta_f15,
        delta_f16,
        delta_f17,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<delta_f_subslot_spucch_tbcc_format4_r15_opts> delta_f_subslot_spucch_tbcc_format4_r15_e_;

    // member variables
    bool                                       ext                                             = false;
    bool                                       delta_f_slot_spucch_format1_r15_present         = false;
    bool                                       delta_f_slot_spucch_format1a_r15_present        = false;
    bool                                       delta_f_slot_spucch_format1b_r15_present        = false;
    bool                                       delta_f_slot_spucch_format3_r15_present         = false;
    bool                                       delta_f_slot_spucch_rm_format4_r15_present      = false;
    bool                                       delta_f_slot_spucch_tbcc_format4_r15_present    = false;
    bool                                       delta_f_subslot_spucch_format1and1a_r15_present = false;
    bool                                       delta_f_subslot_spucch_format1b_r15_present     = false;
    bool                                       delta_f_subslot_spucch_rm_format4_r15_present   = false;
    bool                                       delta_f_subslot_spucch_tbcc_format4_r15_present = false;
    delta_f_slot_spucch_format1_r15_e_         delta_f_slot_spucch_format1_r15;
    delta_f_slot_spucch_format1a_r15_e_        delta_f_slot_spucch_format1a_r15;
    delta_f_slot_spucch_format1b_r15_e_        delta_f_slot_spucch_format1b_r15;
    delta_f_slot_spucch_format3_r15_e_         delta_f_slot_spucch_format3_r15;
    delta_f_slot_spucch_rm_format4_r15_e_      delta_f_slot_spucch_rm_format4_r15;
    delta_f_slot_spucch_tbcc_format4_r15_e_    delta_f_slot_spucch_tbcc_format4_r15;
    delta_f_subslot_spucch_format1and1a_r15_e_ delta_f_subslot_spucch_format1and1a_r15;
    delta_f_subslot_spucch_format1b_r15_e_     delta_f_subslot_spucch_format1b_r15;
    delta_f_subslot_spucch_rm_format4_r15_e_   delta_f_subslot_spucch_rm_format4_r15;
    delta_f_subslot_spucch_tbcc_format4_r15_e_ delta_f_subslot_spucch_tbcc_format4_r15;
    // ...
  };
  typedef setup_e types;

  // choice methods
  delta_flist_spucch_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "DeltaFList-SPUCCH-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "DeltaFList-SPUCCH-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// LAA-SCellConfiguration-r13 ::= SEQUENCE
struct laa_scell_cfg_r13_s {
  struct sf_start_position_r13_opts {
    enum options { s0, s07, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<sf_start_position_r13_opts> sf_start_position_r13_e_;

  // member variables
  sf_start_position_r13_e_ sf_start_position_r13;
  fixed_bitstring<8>       laa_scell_sf_cfg_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LAA-SCellConfiguration-v1430 ::= SEQUENCE
struct laa_scell_cfg_v1430_s {
  struct cross_carrier_sched_cfg_ul_r14_c_ {
    struct setup_s_ {
      // member variables
      cross_carrier_sched_cfg_laa_ul_r14_s cross_carrier_sched_cfg_laa_ul_r14;
    };
    typedef setup_e types;

    // choice methods
    cross_carrier_sched_cfg_ul_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "crossCarrierSchedulingConfig-UL-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "crossCarrierSchedulingConfig-UL-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                              cross_carrier_sched_cfg_ul_r14_present      = false;
  bool                              lbt_cfg_r14_present                         = false;
  bool                              pdcch_cfg_laa_r14_present                   = false;
  bool                              absence_of_any_other_technology_r14_present = false;
  bool                              srs_ul_cfg_ded_aperiodic_v1430_present      = false;
  cross_carrier_sched_cfg_ul_r14_c_ cross_carrier_sched_cfg_ul_r14;
  lbt_cfg_r14_c                     lbt_cfg_r14;
  pdcch_cfg_laa_r14_s               pdcch_cfg_laa_r14;
  srs_ul_cfg_ded_aperiodic_v1430_c  srs_ul_cfg_ded_aperiodic_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LAA-SCellConfiguration-v1530 ::= SEQUENCE
struct laa_scell_cfg_v1530_s {
  // member variables
  bool                     aul_cfg_r15_present            = false;
  bool                     pusch_mode_cfg_laa_r15_present = false;
  aul_cfg_r15_c            aul_cfg_r15;
  pusch_mode_cfg_laa_r15_s pusch_mode_cfg_laa_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCCH-ConfigSCell-r13 ::= SEQUENCE
struct pdcch_cfg_scell_r13_s {
  // member variables
  bool skip_monitoring_dci_format0_minus1_a_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDSCH-ConfigDedicatedSCell-v1430 ::= SEQUENCE
struct pdsch_cfg_ded_scell_v1430_s {
  // member variables
  bool tbs_idx_alt2_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUCCH-ConfigDedicated-v1370 ::= SEQUENCE
struct pucch_cfg_ded_v1370_s {
  struct pucch_format_v1370_c_ {
    typedef setup_e types;

    // choice methods
    pucch_format_v1370_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    pucch_format3_conf_r13_s& setup()
    {
      assert_choice_type("setup", type_.to_string(), "pucch-Format-v1370");
      return c;
    }
    const pucch_format3_conf_r13_s& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "pucch-Format-v1370");
      return c;
    }
    pucch_format3_conf_r13_s& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types                    type_;
    pucch_format3_conf_r13_s c;
  };

  // member variables
  pucch_format_v1370_c_ pucch_format_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicatedSCell-r10 ::= SEQUENCE
struct pusch_cfg_ded_scell_r10_s {
  // member variables
  bool group_hop_disabled_r10_present  = false;
  bool dmrs_with_occ_activ_r10_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicatedSCell-v1430 ::= SEQUENCE
struct pusch_cfg_ded_scell_v1430_s {
  // member variables
  bool                enable256_qam_r14_present = false;
  enable256_qam_r14_c enable256_qam_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PUSCH-ConfigDedicatedScell-v1530 ::= SEQUENCE
struct pusch_cfg_ded_scell_v1530_s {
  struct uci_on_pusch_r15_c_ {
    struct setup_s_ {
      // member variables
      uint8_t beta_offset_aul_r15 = 0;
    };
    typedef setup_e types;

    // choice methods
    uci_on_pusch_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "uci-OnPUSCH-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "uci-OnPUSCH-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  uci_on_pusch_r15_c_ uci_on_pusch_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SchedulingRequestConfigSCell-r13 ::= CHOICE
struct sched_request_cfg_scell_r13_c {
  struct setup_s_ {
    struct dsr_trans_max_r13_opts {
      enum options { n4, n8, n16, n32, n64, spare3, spare2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<dsr_trans_max_r13_opts> dsr_trans_max_r13_e_;

    // member variables
    bool                 sr_pucch_res_idx_p1_r13_present = false;
    uint16_t             sr_pucch_res_idx_r13            = 0;
    uint16_t             sr_pucch_res_idx_p1_r13         = 0;
    uint8_t              sr_cfg_idx_r13                  = 0;
    dsr_trans_max_r13_e_ dsr_trans_max_r13;
  };
  typedef setup_e types;

  // choice methods
  sched_request_cfg_scell_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SchedulingRequestConfigSCell-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SchedulingRequestConfigSCell-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SoundingRS-AperiodicSet-r14 ::= SEQUENCE
struct srs_aperiodic_set_r14_s {
  typedef dyn_array<srs_cc_set_idx_r14_s> srs_cc_set_idx_list_r14_l_;

  // member variables
  bool                           srs_cc_set_idx_list_r14_present = false;
  srs_cc_set_idx_list_r14_l_     srs_cc_set_idx_list_r14;
  srs_ul_cfg_ded_aperiodic_r10_c srs_ul_cfg_ded_aperiodic_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SoundingRS-AperiodicSetUpPTsExt-r14 ::= SEQUENCE
struct srs_aperiodic_set_up_pts_ext_r14_s {
  typedef dyn_array<srs_cc_set_idx_r14_s> srs_cc_set_idx_list_r14_l_;

  // member variables
  bool                                      srs_cc_set_idx_list_r14_present = false;
  srs_cc_set_idx_list_r14_l_                srs_cc_set_idx_list_r14;
  srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_c srs_ul_cfg_ded_aperiodic_up_pts_ext_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TPC-PDCCH-ConfigSCell-r13 ::= CHOICE
struct tpc_pdcch_cfg_scell_r13_c {
  struct setup_s_ {
    // member variables
    tpc_idx_c tpc_idx_pucch_scell_r13;
  };
  typedef setup_e types;

  // choice methods
  tpc_pdcch_cfg_scell_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "TPC-PDCCH-ConfigSCell-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "TPC-PDCCH-ConfigSCell-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// UplinkPUSCH-LessPowerControlDedicated-v1430 ::= SEQUENCE
struct ul_pusch_less_pwr_ctrl_ded_v1430_s {
  // member variables
  bool   p0_ue_periodic_srs_r14_present  = false;
  bool   p0_ue_aperiodic_srs_r14_present = false;
  int8_t p0_ue_periodic_srs_r14          = -8;
  int8_t p0_ue_aperiodic_srs_r14         = -8;
  bool   accumulation_enabled_r14        = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlDedicatedSCell-r10 ::= SEQUENCE
struct ul_pwr_ctrl_ded_scell_r10_s {
  struct delta_mcs_enabled_r10_opts {
    enum options { en0, en1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_mcs_enabled_r10_opts> delta_mcs_enabled_r10_e_;
  struct pathloss_ref_linking_r10_opts {
    enum options { p_cell, s_cell, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<pathloss_ref_linking_r10_opts> pathloss_ref_linking_r10_e_;

  // member variables
  bool                        p_srs_offset_ap_r10_present = false;
  bool                        filt_coef_r10_present       = false;
  int8_t                      p0_ue_pusch_r10             = -8;
  delta_mcs_enabled_r10_e_    delta_mcs_enabled_r10;
  bool                        accumulation_enabled_r10 = false;
  uint8_t                     p_srs_offset_r10         = 0;
  uint8_t                     p_srs_offset_ap_r10      = 0;
  filt_coef_e                 filt_coef_r10;
  pathloss_ref_linking_r10_e_ pathloss_ref_linking_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlDedicatedSCell-v1310 ::= SEQUENCE
struct ul_pwr_ctrl_ded_scell_v1310_s {
  // member variables
  bool                               delta_tx_d_offset_list_pucch_r10_present = false;
  int8_t                             p0_ue_pucch                              = -8;
  delta_tx_d_offset_list_pucch_r10_s delta_tx_d_offset_list_pucch_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoCommon ::= SEQUENCE
struct ant_info_common_s {
  struct ant_ports_count_opts {
    enum options { an1, an2, an4, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ant_ports_count_opts> ant_ports_count_e_;

  // member variables
  ant_ports_count_e_ ant_ports_count;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HighSpeedConfigSCell-r14 ::= SEQUENCE
struct high_speed_cfg_scell_r14_s {
  // member variables
  bool high_speed_enhanced_demod_flag_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MAC-MainConfigSCell-r11 ::= SEQUENCE
struct mac_main_cfg_scell_r11_s {
  // member variables
  bool    ext                 = false;
  bool    stag_id_r11_present = false;
  uint8_t stag_id_r11         = 1;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRACH-Config ::= SEQUENCE
struct prach_cfg_s {
  // member variables
  bool             prach_cfg_info_present = false;
  uint16_t         root_seq_idx           = 0;
  prach_cfg_info_s prach_cfg_info;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRACH-ConfigSCell-r10 ::= SEQUENCE
struct prach_cfg_scell_r10_s {
  // member variables
  uint8_t prach_cfg_idx_r10 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhysicalConfigDedicatedSCell-r10 ::= SEQUENCE
struct phys_cfg_ded_scell_r10_s {
  struct non_ul_cfg_r10_s_ {
    // member variables
    bool                          ant_info_r10_present                = false;
    bool                          cross_carrier_sched_cfg_r10_present = false;
    bool                          csi_rs_cfg_r10_present              = false;
    bool                          pdsch_cfg_ded_r10_present           = false;
    ant_info_ded_r10_s            ant_info_r10;
    cross_carrier_sched_cfg_r10_s cross_carrier_sched_cfg_r10;
    csi_rs_cfg_r10_s              csi_rs_cfg_r10;
    pdsch_cfg_ded_s               pdsch_cfg_ded_r10;
  };
  struct ul_cfg_r10_s_ {
    // member variables
    bool                           ant_info_ul_r10_present              = false;
    bool                           pusch_cfg_ded_scell_r10_present      = false;
    bool                           ul_pwr_ctrl_ded_scell_r10_present    = false;
    bool                           cqi_report_cfg_scell_r10_present     = false;
    bool                           srs_ul_cfg_ded_r10_present           = false;
    bool                           srs_ul_cfg_ded_v1020_present         = false;
    bool                           srs_ul_cfg_ded_aperiodic_r10_present = false;
    ant_info_ul_r10_s              ant_info_ul_r10;
    pusch_cfg_ded_scell_r10_s      pusch_cfg_ded_scell_r10;
    ul_pwr_ctrl_ded_scell_r10_s    ul_pwr_ctrl_ded_scell_r10;
    cqi_report_cfg_scell_r10_s     cqi_report_cfg_scell_r10;
    srs_ul_cfg_ded_c               srs_ul_cfg_ded_r10;
    srs_ul_cfg_ded_v1020_s         srs_ul_cfg_ded_v1020;
    srs_ul_cfg_ded_aperiodic_r10_c srs_ul_cfg_ded_aperiodic_r10;
  };
  struct pucch_scell_c_ {
    struct setup_s_ {
      // member variables
      bool                          pucch_cfg_ded_r13_present             = false;
      bool                          sched_request_cfg_r13_present         = false;
      bool                          tpc_pdcch_cfg_pucch_scell_r13_present = false;
      bool                          pusch_cfg_ded_r13_present             = false;
      bool                          ul_pwr_ctrl_ded_r13_present           = false;
      pucch_cfg_ded_r13_s           pucch_cfg_ded_r13;
      sched_request_cfg_scell_r13_c sched_request_cfg_r13;
      tpc_pdcch_cfg_scell_r13_c     tpc_pdcch_cfg_pucch_scell_r13;
      pusch_cfg_ded_r13_s           pusch_cfg_ded_r13;
      ul_pwr_ctrl_ded_scell_v1310_s ul_pwr_ctrl_ded_r13;
    };
    typedef setup_e types;

    // choice methods
    pucch_scell_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "pucch-SCell");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "pucch-SCell");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  typedef dyn_array<srs_ul_cfg_ded_c>                   srs_ul_periodic_cfg_ded_list_r14_l_;
  typedef dyn_array<srs_ul_cfg_ded_up_pts_ext_r13_c>    srs_ul_periodic_cfg_ded_up_pts_ext_list_r14_l_;
  typedef dyn_array<srs_aperiodic_set_r14_s>            srs_ul_aperiodic_cfg_ded_list_r14_l_;
  typedef dyn_array<srs_aperiodic_set_up_pts_ext_r14_s> srs_ul_cfg_ded_ap_up_pts_ext_list_r14_l_;
  struct must_cfg_r14_c_ {
    struct setup_s_ {
      struct k_max_r14_opts {
        enum options { l1, l3, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<k_max_r14_opts> k_max_r14_e_;
      struct p_a_must_r14_opts {
        enum options { db_minus6, db_minus4dot77, db_minus3, db_minus1dot77, db0, db1, db2, db3, nulltype } value;
        typedef float number_type;

        std::string to_string() const;
        float       to_number() const;
        std::string to_number_string() const;
      };
      typedef enumerated<p_a_must_r14_opts> p_a_must_r14_e_;

      // member variables
      bool            p_a_must_r14_present = false;
      k_max_r14_e_    k_max_r14;
      p_a_must_r14_e_ p_a_must_r14;
    };
    typedef setup_e types;

    // choice methods
    must_cfg_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "must-Config-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "must-Config-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct semi_static_cfi_cfg_r15_c_ {
    struct setup_c_ {
      struct types_opts {
        enum options { cfi_cfg_r15, cfi_pattern_cfg_r15, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      cfi_cfg_r15_s& cfi_cfg_r15()
      {
        assert_choice_type("cfi-Config-r15", type_.to_string(), "setup");
        return c.get<cfi_cfg_r15_s>();
      }
      cfi_pattern_cfg_r15_s& cfi_pattern_cfg_r15()
      {
        assert_choice_type("cfi-PatternConfig-r15", type_.to_string(), "setup");
        return c.get<cfi_pattern_cfg_r15_s>();
      }
      const cfi_cfg_r15_s& cfi_cfg_r15() const
      {
        assert_choice_type("cfi-Config-r15", type_.to_string(), "setup");
        return c.get<cfi_cfg_r15_s>();
      }
      const cfi_pattern_cfg_r15_s& cfi_pattern_cfg_r15() const
      {
        assert_choice_type("cfi-PatternConfig-r15", type_.to_string(), "setup");
        return c.get<cfi_pattern_cfg_r15_s>();
      }
      cfi_cfg_r15_s& set_cfi_cfg_r15()
      {
        set(types::cfi_cfg_r15);
        return c.get<cfi_cfg_r15_s>();
      }
      cfi_pattern_cfg_r15_s& set_cfi_pattern_cfg_r15()
      {
        set(types::cfi_pattern_cfg_r15);
        return c.get<cfi_pattern_cfg_r15_s>();
      }

    private:
      types                                                                       type_;
      choice_buffer_t<MAX2(sizeof(cfi_cfg_r15_s), sizeof(cfi_pattern_cfg_r15_s))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    semi_static_cfi_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "semiStaticCFI-Config-r15");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "semiStaticCFI-Config-r15");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };
  struct blind_pdsch_repeat_cfg_r15_c_ {
    struct setup_s_ {
      struct max_num_sf_pdsch_repeats_r15_opts {
        enum options { n4, n6, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<max_num_sf_pdsch_repeats_r15_opts> max_num_sf_pdsch_repeats_r15_e_;
      struct max_num_slot_subslot_pdsch_repeats_r15_opts {
        enum options { n4, n6, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<max_num_slot_subslot_pdsch_repeats_r15_opts> max_num_slot_subslot_pdsch_repeats_r15_e_;
      struct rv_sf_pdsch_repeats_r15_opts {
        enum options { dlrvseq1, dlrvseq2, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<rv_sf_pdsch_repeats_r15_opts> rv_sf_pdsch_repeats_r15_e_;
      struct rv_slotsublot_pdsch_repeats_r15_opts {
        enum options { dlrvseq1, dlrvseq2, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<rv_slotsublot_pdsch_repeats_r15_opts> rv_slotsublot_pdsch_repeats_r15_e_;
      struct mcs_restrict_sf_pdsch_repeats_r15_opts {
        enum options { n0, n1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<mcs_restrict_sf_pdsch_repeats_r15_opts> mcs_restrict_sf_pdsch_repeats_r15_e_;
      struct mcs_restrict_slot_subslot_pdsch_repeats_r15_opts {
        enum options { n0, n1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<mcs_restrict_slot_subslot_pdsch_repeats_r15_opts>
          mcs_restrict_slot_subslot_pdsch_repeats_r15_e_;

      // member variables
      bool                                           max_num_sf_pdsch_repeats_r15_present                 = false;
      bool                                           max_num_slot_subslot_pdsch_repeats_r15_present       = false;
      bool                                           rv_sf_pdsch_repeats_r15_present                      = false;
      bool                                           rv_slotsublot_pdsch_repeats_r15_present              = false;
      bool                                           nof_processes_sf_pdsch_repeats_r15_present           = false;
      bool                                           nof_processes_slot_subslot_pdsch_repeats_r15_present = false;
      bool                                           mcs_restrict_sf_pdsch_repeats_r15_present            = false;
      bool                                           mcs_restrict_slot_subslot_pdsch_repeats_r15_present  = false;
      bool                                           blind_sf_pdsch_repeats_r15                           = false;
      bool                                           blind_slot_subslot_pdsch_repeats_r15                 = false;
      max_num_sf_pdsch_repeats_r15_e_                max_num_sf_pdsch_repeats_r15;
      max_num_slot_subslot_pdsch_repeats_r15_e_      max_num_slot_subslot_pdsch_repeats_r15;
      rv_sf_pdsch_repeats_r15_e_                     rv_sf_pdsch_repeats_r15;
      rv_slotsublot_pdsch_repeats_r15_e_             rv_slotsublot_pdsch_repeats_r15;
      uint8_t                                        nof_processes_sf_pdsch_repeats_r15           = 1;
      uint8_t                                        nof_processes_slot_subslot_pdsch_repeats_r15 = 1;
      mcs_restrict_sf_pdsch_repeats_r15_e_           mcs_restrict_sf_pdsch_repeats_r15;
      mcs_restrict_slot_subslot_pdsch_repeats_r15_e_ mcs_restrict_slot_subslot_pdsch_repeats_r15;
    };
    typedef setup_e types;

    // choice methods
    blind_pdsch_repeat_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "blindPDSCH-Repetition-Config-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "blindPDSCH-Repetition-Config-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool              ext                    = false;
  bool              non_ul_cfg_r10_present = false;
  bool              ul_cfg_r10_present     = false;
  non_ul_cfg_r10_s_ non_ul_cfg_r10;
  ul_cfg_r10_s_     ul_cfg_r10;
  // ...
  // group 0
  bool                                           csi_rs_cfg_nzp_to_release_list_r11_present = false;
  bool                                           csi_rs_cfg_nzp_to_add_mod_list_r11_present = false;
  bool                                           csi_rs_cfg_zp_to_release_list_r11_present  = false;
  bool                                           csi_rs_cfg_zp_to_add_mod_list_r11_present  = false;
  bool                                           epdcch_cfg_r11_present                     = false;
  bool                                           pdsch_cfg_ded_v1130_present                = false;
  bool                                           cqi_report_cfg_v1130_present               = false;
  bool                                           pusch_cfg_ded_v1130_present                = false;
  bool                                           ul_pwr_ctrl_ded_scell_v1130_present        = false;
  copy_ptr<csi_rs_cfg_nzp_to_release_list_r11_l> csi_rs_cfg_nzp_to_release_list_r11;
  copy_ptr<csi_rs_cfg_nzp_to_add_mod_list_r11_l> csi_rs_cfg_nzp_to_add_mod_list_r11;
  copy_ptr<csi_rs_cfg_zp_to_release_list_r11_l>  csi_rs_cfg_zp_to_release_list_r11;
  copy_ptr<csi_rs_cfg_zp_to_add_mod_list_r11_l>  csi_rs_cfg_zp_to_add_mod_list_r11;
  copy_ptr<epdcch_cfg_r11_s>                     epdcch_cfg_r11;
  copy_ptr<pdsch_cfg_ded_v1130_s>                pdsch_cfg_ded_v1130;
  copy_ptr<cqi_report_cfg_v1130_s>               cqi_report_cfg_v1130;
  copy_ptr<pusch_cfg_ded_v1130_s>                pusch_cfg_ded_v1130;
  copy_ptr<ul_pwr_ctrl_ded_v1130_s>              ul_pwr_ctrl_ded_scell_v1130;
  // group 1
  bool                                     ant_info_v1250_present              = false;
  bool                                     eimta_main_cfg_scell_r12_present    = false;
  bool                                     cqi_report_cfg_scell_v1250_present  = false;
  bool                                     ul_pwr_ctrl_ded_scell_v1250_present = false;
  bool                                     csi_rs_cfg_v1250_present            = false;
  copy_ptr<ant_info_ded_v1250_s>           ant_info_v1250;
  copy_ptr<eimta_main_cfg_serv_cell_r12_c> eimta_main_cfg_scell_r12;
  copy_ptr<cqi_report_cfg_v1250_s>         cqi_report_cfg_scell_v1250;
  copy_ptr<ul_pwr_ctrl_ded_v1250_s>        ul_pwr_ctrl_ded_scell_v1250;
  copy_ptr<csi_rs_cfg_v1250_s>             csi_rs_cfg_v1250;
  // group 2
  bool                            pdsch_cfg_ded_v1280_present = false;
  copy_ptr<pdsch_cfg_ded_v1280_s> pdsch_cfg_ded_v1280;
  // group 3
  bool                                                pucch_cell_r13_present                          = false;
  bool                                                pucch_scell_present                             = false;
  bool                                                cross_carrier_sched_cfg_r13_present             = false;
  bool                                                pdcch_cfg_scell_r13_present                     = false;
  bool                                                cqi_report_cfg_v1310_present                    = false;
  bool                                                pdsch_cfg_ded_v1310_present                     = false;
  bool                                                srs_ul_cfg_ded_v1310_present                    = false;
  bool                                                srs_ul_cfg_ded_up_pts_ext_r13_present           = false;
  bool                                                srs_ul_cfg_ded_aperiodic_v1310_present          = false;
  bool                                                srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_present = false;
  bool                                                csi_rs_cfg_v1310_present                        = false;
  bool                                                laa_scell_cfg_r13_present                       = false;
  bool                                                csi_rs_cfg_nzp_to_add_mod_list_ext_r13_present  = false;
  bool                                                csi_rs_cfg_nzp_to_release_list_ext_r13_present  = false;
  copy_ptr<pucch_scell_c_>                            pucch_scell;
  copy_ptr<cross_carrier_sched_cfg_r13_s>             cross_carrier_sched_cfg_r13;
  copy_ptr<pdcch_cfg_scell_r13_s>                     pdcch_cfg_scell_r13;
  copy_ptr<cqi_report_cfg_v1310_s>                    cqi_report_cfg_v1310;
  copy_ptr<pdsch_cfg_ded_v1310_s>                     pdsch_cfg_ded_v1310;
  copy_ptr<srs_ul_cfg_ded_v1310_c>                    srs_ul_cfg_ded_v1310;
  copy_ptr<srs_ul_cfg_ded_up_pts_ext_r13_c>           srs_ul_cfg_ded_up_pts_ext_r13;
  copy_ptr<srs_ul_cfg_ded_aperiodic_v1310_c>          srs_ul_cfg_ded_aperiodic_v1310;
  copy_ptr<srs_ul_cfg_ded_aperiodic_up_pts_ext_r13_c> srs_ul_cfg_ded_aperiodic_up_pts_ext_r13;
  copy_ptr<csi_rs_cfg_v1310_s>                        csi_rs_cfg_v1310;
  copy_ptr<laa_scell_cfg_r13_s>                       laa_scell_cfg_r13;
  copy_ptr<csi_rs_cfg_nzp_to_add_mod_list_ext_r13_l>  csi_rs_cfg_nzp_to_add_mod_list_ext_r13;
  copy_ptr<csi_rs_cfg_nzp_to_release_list_ext_r13_l>  csi_rs_cfg_nzp_to_release_list_ext_r13;
  // group 4
  bool                             cqi_report_cfg_v1320_present = false;
  copy_ptr<cqi_report_cfg_v1320_s> cqi_report_cfg_v1320;
  // group 5
  bool                                                     laa_scell_cfg_v1430_present                         = false;
  bool                                                     type_b_srs_tpc_pdcch_cfg_r14_present                = false;
  bool                                                     ul_pusch_less_pwr_ctrl_ded_v1430_present            = false;
  bool                                                     srs_ul_periodic_cfg_ded_list_r14_present            = false;
  bool                                                     srs_ul_periodic_cfg_ded_up_pts_ext_list_r14_present = false;
  bool                                                     srs_ul_aperiodic_cfg_ded_list_r14_present           = false;
  bool                                                     srs_ul_cfg_ded_ap_up_pts_ext_list_r14_present       = false;
  bool                                                     must_cfg_r14_present                                = false;
  bool                                                     pusch_cfg_ded_v1430_present                         = false;
  bool                                                     csi_rs_cfg_v1430_present                            = false;
  bool                                                     csi_rs_cfg_zp_ap_list_r14_present                   = false;
  bool                                                     cqi_report_cfg_v1430_present                        = false;
  bool                                                     semi_open_loop_r14_present                          = false;
  bool                                                     pdsch_cfg_ded_scell_v1430_present                   = false;
  copy_ptr<laa_scell_cfg_v1430_s>                          laa_scell_cfg_v1430;
  copy_ptr<srs_tpc_pdcch_cfg_r14_c>                        type_b_srs_tpc_pdcch_cfg_r14;
  copy_ptr<ul_pusch_less_pwr_ctrl_ded_v1430_s>             ul_pusch_less_pwr_ctrl_ded_v1430;
  copy_ptr<srs_ul_periodic_cfg_ded_list_r14_l_>            srs_ul_periodic_cfg_ded_list_r14;
  copy_ptr<srs_ul_periodic_cfg_ded_up_pts_ext_list_r14_l_> srs_ul_periodic_cfg_ded_up_pts_ext_list_r14;
  copy_ptr<srs_ul_aperiodic_cfg_ded_list_r14_l_>           srs_ul_aperiodic_cfg_ded_list_r14;
  copy_ptr<srs_ul_cfg_ded_ap_up_pts_ext_list_r14_l_>       srs_ul_cfg_ded_ap_up_pts_ext_list_r14;
  copy_ptr<must_cfg_r14_c_>                                must_cfg_r14;
  copy_ptr<pusch_cfg_ded_scell_v1430_s>                    pusch_cfg_ded_v1430;
  copy_ptr<csi_rs_cfg_v1430_s>                             csi_rs_cfg_v1430;
  copy_ptr<csi_rs_cfg_zp_ap_list_r14_c>                    csi_rs_cfg_zp_ap_list_r14;
  copy_ptr<cqi_report_cfg_v1430_s>                         cqi_report_cfg_v1430;
  bool                                                     semi_open_loop_r14 = false;
  copy_ptr<pdsch_cfg_ded_scell_v1430_s>                    pdsch_cfg_ded_scell_v1430;
  // group 6
  bool                         csi_rs_cfg_v1480_present = false;
  copy_ptr<csi_rs_cfg_v1480_s> csi_rs_cfg_v1480;
  // group 7
  bool                                    phys_cfg_ded_stti_r15_present       = false;
  bool                                    pdsch_cfg_ded_v1530_present         = false;
  bool                                    cqi_report_cfg_v1530_present        = false;
  bool                                    cqi_report_cfg_scell_r15_present    = false;
  bool                                    cqi_short_cfg_scell_r15_present     = false;
  bool                                    csi_rs_cfg_v1530_present            = false;
  bool                                    ul_pwr_ctrl_ded_scell_v1530_present = false;
  bool                                    laa_scell_cfg_v1530_present         = false;
  bool                                    pusch_cfg_ded_v1530_present         = false;
  bool                                    semi_static_cfi_cfg_r15_present     = false;
  bool                                    blind_pdsch_repeat_cfg_r15_present  = false;
  copy_ptr<phys_cfg_ded_stti_r15_c>       phys_cfg_ded_stti_r15;
  copy_ptr<pdsch_cfg_ded_v1530_s>         pdsch_cfg_ded_v1530;
  copy_ptr<cqi_report_cfg_v1530_s>        cqi_report_cfg_v1530;
  copy_ptr<cqi_report_cfg_scell_r15_s>    cqi_report_cfg_scell_r15;
  copy_ptr<cqi_short_cfg_scell_r15_c>     cqi_short_cfg_scell_r15;
  copy_ptr<csi_rs_cfg_v1530_s>            csi_rs_cfg_v1530;
  copy_ptr<ul_pwr_ctrl_ded_v1530_s>       ul_pwr_ctrl_ded_scell_v1530;
  copy_ptr<laa_scell_cfg_v1530_s>         laa_scell_cfg_v1530;
  copy_ptr<pusch_cfg_ded_scell_v1530_s>   pusch_cfg_ded_v1530;
  copy_ptr<semi_static_cfi_cfg_r15_c_>    semi_static_cfi_cfg_r15;
  copy_ptr<blind_pdsch_repeat_cfg_r15_c_> blind_pdsch_repeat_cfg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhysicalConfigDedicatedSCell-v1370 ::= SEQUENCE
struct phys_cfg_ded_scell_v1370_s {
  struct pucch_scell_v1370_c_ {
    struct setup_s_ {
      // member variables
      bool                  pucch_cfg_ded_v1370_present = false;
      pucch_cfg_ded_v1370_s pucch_cfg_ded_v1370;
    };
    typedef setup_e types;

    // choice methods
    pucch_scell_v1370_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "pucch-SCell-v1370");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "pucch-SCell-v1370");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  pucch_scell_v1370_c_ pucch_scell_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RACH-ConfigCommonSCell-r11 ::= SEQUENCE
struct rach_cfg_common_scell_r11_s {
  struct ra_supervision_info_r11_s_ {
    // member variables
    preamb_trans_max_e preamb_trans_max_r11;
  };

  // member variables
  bool                       ext = false;
  pwr_ramp_params_s          pwr_ramp_params_r11;
  ra_supervision_info_r11_s_ ra_supervision_info_r11;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommon-v1530 ::= SEQUENCE
struct ul_pwr_ctrl_common_v1530_s {
  // member variables
  delta_flist_spucch_r15_c delta_flist_spucch_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommonPUSCH-LessCell-v1430 ::= SEQUENCE
struct ul_pwr_ctrl_common_pusch_less_cell_v1430_s {
  // member variables
  bool        p0_nominal_periodic_srs_r14_present  = false;
  bool        p0_nominal_aperiodic_srs_r14_present = false;
  bool        alpha_srs_r14_present                = false;
  int8_t      p0_nominal_periodic_srs_r14          = -126;
  int8_t      p0_nominal_aperiodic_srs_r14         = -126;
  alpha_r12_e alpha_srs_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommonSCell-r10 ::= SEQUENCE
struct ul_pwr_ctrl_common_scell_r10_s {
  // member variables
  int8_t      p0_nominal_pusch_r10 = -126;
  alpha_r12_e alpha_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommonSCell-v1130 ::= SEQUENCE
struct ul_pwr_ctrl_common_scell_v1130_s {
  // member variables
  int8_t delta_preamb_msg3_r11 = -1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommonSCell-v1310 ::= SEQUENCE
struct ul_pwr_ctrl_common_scell_v1310_s {
  struct delta_f_pucch_format3_r12_opts {
    enum options {
      delta_f_minus1,
      delta_f0,
      delta_f1,
      delta_f2,
      delta_f3,
      delta_f4,
      delta_f5,
      delta_f6,
      nulltype
    } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_f_pucch_format3_r12_opts> delta_f_pucch_format3_r12_e_;
  struct delta_f_pucch_format1b_cs_r12_opts {
    enum options { delta_f1, delta_f2, spare2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format1b_cs_r12_opts> delta_f_pucch_format1b_cs_r12_e_;
  struct delta_f_pucch_format4_r13_opts {
    enum options {
      delta_f16,
      delta_f15,
      delta_f14,
      delta_f13,
      delta_f12,
      delta_f11,
      delta_f10,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format4_r13_opts> delta_f_pucch_format4_r13_e_;
  struct delta_f_pucch_format5_minus13_opts {
    enum options { delta_f13, delta_f12, delta_f11, delta_f10, delta_f9, delta_f8, delta_f7, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format5_minus13_opts> delta_f_pucch_format5_minus13_e_;

  // member variables
  bool                             delta_f_pucch_format3_r12_present     = false;
  bool                             delta_f_pucch_format1b_cs_r12_present = false;
  bool                             delta_f_pucch_format4_r13_present     = false;
  bool                             delta_f_pucch_format5_minus13_present = false;
  int8_t                           p0_nominal_pucch                      = -127;
  delta_flist_pucch_s              delta_flist_pucch;
  delta_f_pucch_format3_r12_e_     delta_f_pucch_format3_r12;
  delta_f_pucch_format1b_cs_r12_e_ delta_f_pucch_format1b_cs_r12;
  delta_f_pucch_format4_r13_e_     delta_f_pucch_format4_r13;
  delta_f_pucch_format5_minus13_e_ delta_f_pucch_format5_minus13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AntennaInfoDedicated-v10i0 ::= SEQUENCE
struct ant_info_ded_v10i0_s {
  struct max_layers_mimo_r10_opts {
    enum options { two_layers, four_layers, eight_layers, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<max_layers_mimo_r10_opts> max_layers_mimo_r10_e_;

  // member variables
  bool                   max_layers_mimo_r10_present = false;
  max_layers_mimo_r10_e_ max_layers_mimo_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigCommonSCell-r10 ::= SEQUENCE
struct rr_cfg_common_scell_r10_s {
  struct non_ul_cfg_r10_s_ {
    struct dl_bw_r10_opts {
      enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<dl_bw_r10_opts> dl_bw_r10_e_;

    // member variables
    bool                mbsfn_sf_cfg_list_r10_present = false;
    bool                tdd_cfg_r10_present           = false;
    dl_bw_r10_e_        dl_bw_r10;
    ant_info_common_s   ant_info_common_r10;
    mbsfn_sf_cfg_list_l mbsfn_sf_cfg_list_r10;
    phich_cfg_s         phich_cfg_r10;
    pdsch_cfg_common_s  pdsch_cfg_common_r10;
    tdd_cfg_s           tdd_cfg_r10;
  };
  struct ul_cfg_r10_s_ {
    struct ul_freq_info_r10_s_ {
      struct ul_bw_r10_opts {
        enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<ul_bw_r10_opts> ul_bw_r10_e_;

      // member variables
      bool         ul_carrier_freq_r10_present = false;
      bool         ul_bw_r10_present           = false;
      uint16_t     ul_carrier_freq_r10         = 0;
      ul_bw_r10_e_ ul_bw_r10;
      uint8_t      add_spec_emission_scell_r10 = 1;
    };

    // member variables
    bool                           p_max_r10_present           = false;
    bool                           prach_cfg_scell_r10_present = false;
    ul_freq_info_r10_s_            ul_freq_info_r10;
    int8_t                         p_max_r10 = -30;
    ul_pwr_ctrl_common_scell_r10_s ul_pwr_ctrl_common_scell_r10;
    srs_ul_cfg_common_c            srs_ul_cfg_common_r10;
    ul_cp_len_e                    ul_cp_len_r10;
    prach_cfg_scell_r10_s          prach_cfg_scell_r10;
    pusch_cfg_common_s             pusch_cfg_common_r10;
  };
  struct ul_cfg_r14_s_ {
    struct ul_freq_info_r14_s_ {
      struct ul_bw_r14_opts {
        enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<ul_bw_r14_opts> ul_bw_r14_e_;

      // member variables
      bool         ul_carrier_freq_r14_present = false;
      bool         ul_bw_r14_present           = false;
      uint32_t     ul_carrier_freq_r14         = 0;
      ul_bw_r14_e_ ul_bw_r14;
      uint8_t      add_spec_emission_scell_r14 = 1;
    };

    // member variables
    bool                                       p_max_r14_present                                = false;
    bool                                       prach_cfg_scell_r14_present                      = false;
    bool                                       ul_pwr_ctrl_common_pusch_less_cell_v1430_present = false;
    ul_freq_info_r14_s_                        ul_freq_info_r14;
    int8_t                                     p_max_r14 = -30;
    srs_ul_cfg_common_c                        srs_ul_cfg_common_r14;
    ul_cp_len_e                                ul_cp_len_r14;
    prach_cfg_scell_r10_s                      prach_cfg_scell_r14;
    ul_pwr_ctrl_common_pusch_less_cell_v1430_s ul_pwr_ctrl_common_pusch_less_cell_v1430;
  };
  struct harq_ref_cfg_r14_opts {
    enum options { sa2, sa4, sa5, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<harq_ref_cfg_r14_opts> harq_ref_cfg_r14_e_;

  // member variables
  bool              ext                = false;
  bool              ul_cfg_r10_present = false;
  non_ul_cfg_r10_s_ non_ul_cfg_r10;
  ul_cfg_r10_s_     ul_cfg_r10;
  // ...
  // group 0
  bool     ul_carrier_freq_v1090_present = false;
  uint32_t ul_carrier_freq_v1090         = 65536;
  // group 1
  bool                                       rach_cfg_common_scell_r11_present      = false;
  bool                                       prach_cfg_scell_r11_present            = false;
  bool                                       tdd_cfg_v1130_present                  = false;
  bool                                       ul_pwr_ctrl_common_scell_v1130_present = false;
  copy_ptr<rach_cfg_common_scell_r11_s>      rach_cfg_common_scell_r11;
  copy_ptr<prach_cfg_s>                      prach_cfg_scell_r11;
  copy_ptr<tdd_cfg_v1130_s>                  tdd_cfg_v1130;
  copy_ptr<ul_pwr_ctrl_common_scell_v1130_s> ul_pwr_ctrl_common_scell_v1130;
  // group 2
  bool                               pusch_cfg_common_v1270_present = false;
  copy_ptr<pusch_cfg_common_v1270_s> pusch_cfg_common_v1270;
  // group 3
  bool                                       pucch_cfg_common_r13_present           = false;
  bool                                       ul_pwr_ctrl_common_scell_v1310_present = false;
  copy_ptr<pucch_cfg_common_s>               pucch_cfg_common_r13;
  copy_ptr<ul_pwr_ctrl_common_scell_v1310_s> ul_pwr_ctrl_common_scell_v1310;
  // group 4
  bool                                 high_speed_cfg_scell_r14_present = false;
  bool                                 prach_cfg_v1430_present          = false;
  bool                                 ul_cfg_r14_present               = false;
  bool                                 harq_ref_cfg_r14_present         = false;
  bool                                 srs_flex_timing_r14_present      = false;
  copy_ptr<high_speed_cfg_scell_r14_s> high_speed_cfg_scell_r14;
  copy_ptr<prach_cfg_v1430_s>          prach_cfg_v1430;
  copy_ptr<ul_cfg_r14_s_>              ul_cfg_r14;
  harq_ref_cfg_r14_e_                  harq_ref_cfg_r14;
  // group 5
  bool                                mbsfn_sf_cfg_list_v1430_present = false;
  copy_ptr<mbsfn_sf_cfg_list_v1430_l> mbsfn_sf_cfg_list_v1430;
  // group 6
  bool                                 ul_pwr_ctrl_common_scell_v1530_present = false;
  copy_ptr<ul_pwr_ctrl_common_v1530_s> ul_pwr_ctrl_common_scell_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigDedicatedSCell-r10 ::= SEQUENCE
struct rr_cfg_ded_scell_r10_s {
  // member variables
  bool                     ext                            = false;
  bool                     phys_cfg_ded_scell_r10_present = false;
  phys_cfg_ded_scell_r10_s phys_cfg_ded_scell_r10;
  // ...
  // group 0
  bool                               mac_main_cfg_scell_r11_present = false;
  copy_ptr<mac_main_cfg_scell_r11_s> mac_main_cfg_scell_r11;
  // group 1
  bool                              naics_info_r12_present = false;
  copy_ptr<naics_assist_info_r12_c> naics_info_r12;
  // group 2
  bool                                 neigh_cells_crs_info_scell_r13_present = false;
  copy_ptr<neigh_cells_crs_info_r13_c> neigh_cells_crs_info_scell_r13;
  // group 3
  bool                                 phys_cfg_ded_scell_v1370_present = false;
  copy_ptr<phys_cfg_ded_scell_v1370_s> phys_cfg_ded_scell_v1370;
  // group 4
  bool                                 crs_intf_mitig_enabled_r15_present = false;
  bool                                 neigh_cells_crs_info_r15_present   = false;
  bool                                 sps_cfg_v1530_present              = false;
  bool                                 crs_intf_mitig_enabled_r15         = false;
  copy_ptr<neigh_cells_crs_info_r15_c> neigh_cells_crs_info_r15;
  copy_ptr<sps_cfg_v1530_s>            sps_cfg_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddModExt-r13 ::= SEQUENCE
struct scell_to_add_mod_ext_r13_s {
  struct cell_identif_r13_s_ {
    // member variables
    uint16_t pci_r13             = 0;
    uint32_t dl_carrier_freq_r13 = 0;
  };

  // member variables
  bool                      cell_identif_r13_present        = false;
  bool                      rr_cfg_common_scell_r13_present = false;
  bool                      rr_cfg_ded_scell_r13_present    = false;
  bool                      ant_info_ded_scell_r13_present  = false;
  uint8_t                   s_cell_idx_r13                  = 1;
  cell_identif_r13_s_       cell_identif_r13;
  rr_cfg_common_scell_r10_s rr_cfg_common_scell_r13;
  rr_cfg_ded_scell_r10_s    rr_cfg_ded_scell_r13;
  ant_info_ded_v10i0_s      ant_info_ded_scell_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CipheringAlgorithm-r12 ::= ENUMERATED
struct ciphering_algorithm_r12_opts {
  enum options { eea0, eea1, eea2, eea3_v1130, spare4, spare3, spare2, spare1, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<ciphering_algorithm_r12_opts, true> ciphering_algorithm_r12_e;

// SCellConfigCommon-r15 ::= SEQUENCE
struct scell_cfg_common_r15_s {
  // member variables
  bool                      rr_cfg_common_scell_r15_present = false;
  bool                      rr_cfg_ded_scell_r15_present    = false;
  bool                      ant_info_ded_scell_r15_present  = false;
  rr_cfg_common_scell_r10_s rr_cfg_common_scell_r15;
  rr_cfg_ded_scell_r10_s    rr_cfg_ded_scell_r15;
  ant_info_ded_v10i0_s      ant_info_ded_scell_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddModListExt-r13 ::= SEQUENCE (SIZE (1..maxSCell-r13)) OF SCellToAddModExt-r13
typedef dyn_array<scell_to_add_mod_ext_r13_s> scell_to_add_mod_list_ext_r13_l;

// SCellToReleaseListExt-r13 ::= SEQUENCE (SIZE (1..maxSCell-r13)) OF INTEGER
typedef bounded_array<uint8_t, 31> scell_to_release_list_ext_r13_l;

// SL-DiscTxPoolToAddMod-r12 ::= SEQUENCE
struct sl_disc_tx_pool_to_add_mod_r12_s {
  // member variables
  uint8_t                pool_id_r12 = 1;
  sl_disc_res_pool_r12_s pool_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-TF-IndexPair-r12b ::= SEQUENCE
struct sl_tf_idx_pair_r12b_s {
  // member variables
  bool    disc_sf_idx_r12b_present  = false;
  bool    disc_prb_idx_r12b_present = false;
  uint8_t disc_sf_idx_r12b          = 0;
  uint8_t disc_prb_idx_r12b         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellGroupToAddMod-r15 ::= SEQUENCE
struct scell_group_to_add_mod_r15_s {
  // member variables
  bool                            s_cell_cfg_common_r15_present      = false;
  bool                            s_cell_to_release_list_r15_present = false;
  bool                            s_cell_to_add_mod_list_r15_present = false;
  uint8_t                         s_cell_group_idx_r15               = 1;
  scell_cfg_common_r15_s          s_cell_cfg_common_r15;
  scell_to_release_list_ext_r13_l s_cell_to_release_list_r15;
  scell_to_add_mod_list_ext_r13_l s_cell_to_add_mod_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscTxPoolToAddModList-r12 ::= SEQUENCE (SIZE (1..maxSL-TxPool-r12)) OF SL-DiscTxPoolToAddMod-r12
typedef dyn_array<sl_disc_tx_pool_to_add_mod_r12_s> sl_disc_tx_pool_to_add_mod_list_r12_l;

// SL-HoppingConfigDisc-r12 ::= SEQUENCE
struct sl_hop_cfg_disc_r12_s {
  struct c_r12_opts {
    enum options { n1, n5, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<c_r12_opts> c_r12_e_;

  // member variables
  uint8_t  a_r12 = 1;
  uint8_t  b_r12 = 1;
  c_r12_e_ c_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-TF-IndexPairList-r12b ::= SEQUENCE (SIZE (1..maxSL-TF-IndexPair-r12)) OF SL-TF-IndexPair-r12b
typedef dyn_array<sl_tf_idx_pair_r12b_s> sl_tf_idx_pair_list_r12b_l;

// SL-TxPoolToReleaseList-r12 ::= SEQUENCE (SIZE (1..maxSL-TxPool-r12)) OF INTEGER
typedef bounded_array<uint8_t, 4> sl_tx_pool_to_release_list_r12_l;

// SecurityAlgorithmConfig ::= SEQUENCE
struct security_algorithm_cfg_s {
  struct integrity_prot_algorithm_opts {
    enum options { eia0_v920, eia1, eia2, eia3_v1130, spare4, spare3, spare2, spare1, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<integrity_prot_algorithm_opts, true> integrity_prot_algorithm_e_;

  // member variables
  ciphering_algorithm_r12_e   ciphering_algorithm;
  integrity_prot_algorithm_e_ integrity_prot_algorithm;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-ToAddModSCG-r12 ::= SEQUENCE
struct drb_to_add_mod_scg_r12_s {
  struct drb_type_r12_c_ {
    struct scg_r12_s_ {
      // member variables
      bool       eps_bearer_id_r12_present = false;
      bool       pdcp_cfg_r12_present      = false;
      uint8_t    eps_bearer_id_r12         = 0;
      pdcp_cfg_s pdcp_cfg_r12;
    };
    struct types_opts {
      enum options { split_r12, scg_r12, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    drb_type_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    scg_r12_s_& scg_r12()
    {
      assert_choice_type("scg-r12", type_.to_string(), "drb-Type-r12");
      return c;
    }
    const scg_r12_s_& scg_r12() const
    {
      assert_choice_type("scg-r12", type_.to_string(), "drb-Type-r12");
      return c;
    }
    scg_r12_s_& set_scg_r12()
    {
      set(types::scg_r12);
      return c;
    }

  private:
    types      type_;
    scg_r12_s_ c;
  };

  // member variables
  bool            ext                       = false;
  bool            drb_type_r12_present      = false;
  bool            rlc_cfg_scg_r12_present   = false;
  bool            rlc_cfg_v1250_present     = false;
  bool            lc_ch_id_scg_r12_present  = false;
  bool            lc_ch_cfg_scg_r12_present = false;
  uint8_t         drb_id_r12                = 1;
  drb_type_r12_c_ drb_type_r12;
  rlc_cfg_c       rlc_cfg_scg_r12;
  rlc_cfg_v1250_s rlc_cfg_v1250;
  uint8_t         lc_ch_id_scg_r12 = 3;
  lc_ch_cfg_s     lc_ch_cfg_scg_r12;
  // ...
  // group 0
  bool                      rlc_cfg_v1430_present = false;
  copy_ptr<rlc_cfg_v1430_c> rlc_cfg_v1430;
  // group 1
  bool                           lc_ch_id_scg_r15_present        = false;
  bool                           rlc_cfg_v1530_present           = false;
  bool                           rlc_bearer_cfg_dupl_r15_present = false;
  uint8_t                        lc_ch_id_scg_r15                = 32;
  copy_ptr<rlc_cfg_v1530_c>      rlc_cfg_v1530;
  copy_ptr<rlc_bearer_cfg_r15_c> rlc_bearer_cfg_dupl_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IKE-Identity-r13 ::= SEQUENCE
struct ike_id_r13_s {
  // member variables
  dyn_octstring id_i_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IP-Address-r13 ::= CHOICE
struct ip_address_r13_c {
  struct types_opts {
    enum options { ipv4_r13, ipv6_r13, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ip_address_r13_c() = default;
  ip_address_r13_c(const ip_address_r13_c& other);
  ip_address_r13_c& operator=(const ip_address_r13_c& other);
  ~ip_address_r13_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<32>& ipv4_r13()
  {
    assert_choice_type("ipv4-r13", type_.to_string(), "IP-Address-r13");
    return c.get<fixed_bitstring<32> >();
  }
  fixed_bitstring<128>& ipv6_r13()
  {
    assert_choice_type("ipv6-r13", type_.to_string(), "IP-Address-r13");
    return c.get<fixed_bitstring<128> >();
  }
  const fixed_bitstring<32>& ipv4_r13() const
  {
    assert_choice_type("ipv4-r13", type_.to_string(), "IP-Address-r13");
    return c.get<fixed_bitstring<32> >();
  }
  const fixed_bitstring<128>& ipv6_r13() const
  {
    assert_choice_type("ipv6-r13", type_.to_string(), "IP-Address-r13");
    return c.get<fixed_bitstring<128> >();
  }
  fixed_bitstring<32>& set_ipv4_r13()
  {
    set(types::ipv4_r13);
    return c.get<fixed_bitstring<32> >();
  }
  fixed_bitstring<128>& set_ipv6_r13()
  {
    set(types::ipv6_r13);
    return c.get<fixed_bitstring<128> >();
  }

private:
  types                                         type_;
  choice_buffer_t<sizeof(fixed_bitstring<128>)> c;

  void destroy_();
};

// PhysicalConfigDedicated-v1370 ::= SEQUENCE
struct phys_cfg_ded_v1370_s {
  // member variables
  bool                  pucch_cfg_ded_v1370_present = false;
  pucch_cfg_ded_v1370_s pucch_cfg_ded_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RAN-AreaConfig-r15 ::= SEQUENCE
struct ran_area_cfg_r15_s {
  typedef bounded_array<uint8_t, 32> ran_area_code_list_r15_l_;

  // member variables
  bool                      ran_area_code_list_r15_present = false;
  fixed_bitstring<24>       tac_minus5_gc_r15;
  ran_area_code_list_r15_l_ ran_area_code_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigCommonSCell-v10l0 ::= SEQUENCE
struct rr_cfg_common_scell_v10l0_s {
  struct ul_cfg_v10l0_s_ {
    // member variables
    uint16_t add_spec_emission_scell_v10l0 = 33;
  };

  // member variables
  ul_cfg_v10l0_s_ ul_cfg_v10l0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigCommonSCell-v1440 ::= SEQUENCE
struct rr_cfg_common_scell_v1440_s {
  struct ul_cfg_v1440_s_ {
    struct ul_freq_info_v1440_s_ {
      // member variables
      uint16_t add_spec_emission_scell_v1440 = 33;
    };

    // member variables
    ul_freq_info_v1440_s_ ul_freq_info_v1440;
  };

  // member variables
  ul_cfg_v1440_s_ ul_cfg_v1440;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellGroupToAddModList-r15 ::= SEQUENCE (SIZE (1..maxSCellGroups-r15)) OF SCellGroupToAddMod-r15
typedef dyn_array<scell_group_to_add_mod_r15_s> scell_group_to_add_mod_list_r15_l;

// SCellGroupToReleaseList-r15 ::= SEQUENCE (SIZE (1..maxSCellGroups-r15)) OF INTEGER
typedef bounded_array<uint8_t, 4> scell_group_to_release_list_r15_l;

// SL-DiscTxConfigScheduled-r13 ::= SEQUENCE
struct sl_disc_tx_cfg_sched_r13_s {
  // member variables
  bool                       ext                          = false;
  bool                       disc_tx_cfg_r13_present      = false;
  bool                       disc_tf_idx_list_r13_present = false;
  bool                       disc_hop_cfg_r13_present     = false;
  sl_disc_res_pool_r12_s     disc_tx_cfg_r13;
  sl_tf_idx_pair_list_r12b_l disc_tf_idx_list_r13;
  sl_hop_cfg_disc_r12_s      disc_hop_cfg_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscTxPoolDedicated-r13 ::= SEQUENCE
struct sl_disc_tx_pool_ded_r13_s {
  // member variables
  bool                                  pool_to_release_list_r13_present = false;
  bool                                  pool_to_add_mod_list_r13_present = false;
  sl_tx_pool_to_release_list_r12_l      pool_to_release_list_r13;
  sl_disc_tx_pool_to_add_mod_list_r12_l pool_to_add_mod_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-ReliabilityList-r15 ::= SEQUENCE (SIZE (1..maxSL-Reliability-r15)) OF INTEGER
typedef bounded_array<uint8_t, 8> sl_reliability_list_r15_l;

// SL-TxPoolToAddMod-r14 ::= SEQUENCE
struct sl_tx_pool_to_add_mod_r14_s {
  // member variables
  uint8_t                    pool_id_r14 = 1;
  sl_comm_res_pool_v2x_r14_s pool_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityConfigHO-v1530 ::= SEQUENCE
struct security_cfg_ho_v1530_s {
  struct ho_type_v1530_c_ {
    struct intra5_gc_r15_s_ {
      // member variables
      bool                     security_algorithm_cfg_r15_present = false;
      bool                     nas_container_r15_present          = false;
      security_algorithm_cfg_s security_algorithm_cfg_r15;
      bool                     key_change_ind_r15          = false;
      uint8_t                  next_hop_chaining_count_r15 = 0;
      dyn_octstring            nas_container_r15;
    };
    struct ngc_to_epc_r15_s_ {
      // member variables
      security_algorithm_cfg_s security_algorithm_cfg_r15;
      uint8_t                  next_hop_chaining_count_r15 = 0;
    };
    struct epc_to_ngc_r15_s_ {
      // member variables
      security_algorithm_cfg_s security_algorithm_cfg_r15;
      dyn_octstring            nas_container_r15;
    };
    struct types_opts {
      enum options { intra5_gc_r15, ngc_to_epc_r15, epc_to_ngc_r15, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ho_type_v1530_c_() = default;
    ho_type_v1530_c_(const ho_type_v1530_c_& other);
    ho_type_v1530_c_& operator=(const ho_type_v1530_c_& other);
    ~ho_type_v1530_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    intra5_gc_r15_s_& intra5_gc_r15()
    {
      assert_choice_type("intra5GC-r15", type_.to_string(), "handoverType-v1530");
      return c.get<intra5_gc_r15_s_>();
    }
    ngc_to_epc_r15_s_& ngc_to_epc_r15()
    {
      assert_choice_type("ngc-ToEPC-r15", type_.to_string(), "handoverType-v1530");
      return c.get<ngc_to_epc_r15_s_>();
    }
    epc_to_ngc_r15_s_& epc_to_ngc_r15()
    {
      assert_choice_type("epc-ToNGC-r15", type_.to_string(), "handoverType-v1530");
      return c.get<epc_to_ngc_r15_s_>();
    }
    const intra5_gc_r15_s_& intra5_gc_r15() const
    {
      assert_choice_type("intra5GC-r15", type_.to_string(), "handoverType-v1530");
      return c.get<intra5_gc_r15_s_>();
    }
    const ngc_to_epc_r15_s_& ngc_to_epc_r15() const
    {
      assert_choice_type("ngc-ToEPC-r15", type_.to_string(), "handoverType-v1530");
      return c.get<ngc_to_epc_r15_s_>();
    }
    const epc_to_ngc_r15_s_& epc_to_ngc_r15() const
    {
      assert_choice_type("epc-ToNGC-r15", type_.to_string(), "handoverType-v1530");
      return c.get<epc_to_ngc_r15_s_>();
    }
    intra5_gc_r15_s_& set_intra5_gc_r15()
    {
      set(types::intra5_gc_r15);
      return c.get<intra5_gc_r15_s_>();
    }
    ngc_to_epc_r15_s_& set_ngc_to_epc_r15()
    {
      set(types::ngc_to_epc_r15);
      return c.get<ngc_to_epc_r15_s_>();
    }
    epc_to_ngc_r15_s_& set_epc_to_ngc_r15()
    {
      set(types::epc_to_ngc_r15);
      return c.get<epc_to_ngc_r15_s_>();
    }

  private:
    types                                                                                                    type_;
    choice_buffer_t<MAX4(sizeof(epc_to_ngc_r15_s_), sizeof(intra5_gc_r15_s_), sizeof(ngc_to_epc_r15_s_), 0)> c;

    void destroy_();
  };

  // member variables
  bool             ext = false;
  ho_type_v1530_c_ ho_type_v1530;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommon-v1310 ::= SEQUENCE
struct ul_pwr_ctrl_common_v1310_s {
  struct delta_f_pucch_format4_r13_opts {
    enum options {
      delta_f16,
      delta_f15,
      delta_f14,
      delta_f13,
      delta_f12,
      delta_f11,
      delta_f10,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format4_r13_opts> delta_f_pucch_format4_r13_e_;
  struct delta_f_pucch_format5_minus13_opts {
    enum options { delta_f13, delta_f12, delta_f11, delta_f10, delta_f9, delta_f8, delta_f7, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format5_minus13_opts> delta_f_pucch_format5_minus13_e_;

  // member variables
  bool                             delta_f_pucch_format4_r13_present     = false;
  bool                             delta_f_pucch_format5_minus13_present = false;
  delta_f_pucch_format4_r13_e_     delta_f_pucch_format4_r13;
  delta_f_pucch_format5_minus13_e_ delta_f_pucch_format5_minus13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UplinkPowerControlCommonPSCell-r12 ::= SEQUENCE
struct ul_pwr_ctrl_common_ps_cell_r12_s {
  struct delta_f_pucch_format3_r12_opts {
    enum options {
      delta_f_minus1,
      delta_f0,
      delta_f1,
      delta_f2,
      delta_f3,
      delta_f4,
      delta_f5,
      delta_f6,
      nulltype
    } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<delta_f_pucch_format3_r12_opts> delta_f_pucch_format3_r12_e_;
  struct delta_f_pucch_format1b_cs_r12_opts {
    enum options { delta_f1, delta_f2, spare2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<delta_f_pucch_format1b_cs_r12_opts> delta_f_pucch_format1b_cs_r12_e_;

  // member variables
  delta_f_pucch_format3_r12_e_     delta_f_pucch_format3_r12;
  delta_f_pucch_format1b_cs_r12_e_ delta_f_pucch_format1b_cs_r12;
  int8_t                           p0_nominal_pucch_r12 = -127;
  delta_flist_pucch_s              delta_flist_pucch_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-Id-List-r13 ::= SEQUENCE (SIZE (1..maxWLAN-Id-r13)) OF WLAN-Identifiers-r12
typedef dyn_array<wlan_ids_r12_s> wlan_id_list_r13_l;

// WLAN-SuspendConfig-r14 ::= SEQUENCE
struct wlan_suspend_cfg_r14_s {
  // member variables
  bool wlan_suspend_resume_allowed_r14_present         = false;
  bool wlan_suspend_triggers_status_report_r14_present = false;
  bool wlan_suspend_resume_allowed_r14                 = false;
  bool wlan_suspend_triggers_status_report_r14         = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-ToAddModListSCG-r12 ::= SEQUENCE (SIZE (1..maxDRB)) OF DRB-ToAddModSCG-r12
typedef dyn_array<drb_to_add_mod_scg_r12_s> drb_to_add_mod_list_scg_r12_l;

// DRB-ToAddModListSCG-r15 ::= SEQUENCE (SIZE (1..maxDRB-r15)) OF DRB-ToAddModSCG-r12
typedef dyn_array<drb_to_add_mod_scg_r12_s> drb_to_add_mod_list_scg_r15_l;

// LogicalChGroupInfoList-r13 ::= SEQUENCE (SIZE (1..maxLCG-r13)) OF SL-PriorityList-r13
typedef dyn_array<sl_prio_list_r13_l> lc_ch_group_info_list_r13_l;

// LogicalChGroupInfoList-v1530 ::= SEQUENCE (SIZE (1..maxLCG-r13)) OF SL-ReliabilityList-r15
typedef dyn_array<sl_reliability_list_r15_l> lc_ch_group_info_list_v1530_l;

// MAC-MainConfigSL-r12 ::= SEQUENCE
struct mac_main_cfg_sl_r12_s {
  // member variables
  bool                     periodic_bsr_timer_sl_present = false;
  periodic_bsr_timer_r12_e periodic_bsr_timer_sl;
  retx_bsr_timer_r12_e     retx_bsr_timer_sl;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-RAN-AreaCell-r15 ::= SEQUENCE
struct plmn_ran_area_cell_r15_s {
  typedef bounded_array<fixed_bitstring<28>, 32> ran_area_cells_r15_l_;

  // member variables
  bool                  plmn_id_r15_present = false;
  plmn_id_s             plmn_id_r15;
  ran_area_cells_r15_l_ ran_area_cells_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-RAN-AreaConfig-r15 ::= SEQUENCE
struct plmn_ran_area_cfg_r15_s {
  typedef dyn_array<ran_area_cfg_r15_s> ran_area_r15_l_;

  // member variables
  bool            plmn_id_r15_present = false;
  plmn_id_s       plmn_id_r15;
  ran_area_r15_l_ ran_area_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RACH-ConfigDedicated ::= SEQUENCE
struct rach_cfg_ded_s {
  // member variables
  uint8_t ra_preamb_idx     = 0;
  uint8_t ra_prach_mask_idx = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RACH-Skip-r14 ::= SEQUENCE
struct rach_skip_r14_s {
  struct target_ta_r14_c_ {
    struct types_opts {
      enum options { ta0_r14, mcg_ptag_r14, scg_ptag_r14, mcg_stag_r14, scg_stag_r14, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    target_ta_r14_c_() = default;
    target_ta_r14_c_(const target_ta_r14_c_& other);
    target_ta_r14_c_& operator=(const target_ta_r14_c_& other);
    ~target_ta_r14_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& mcg_stag_r14()
    {
      assert_choice_type("mcg-STAG-r14", type_.to_string(), "targetTA-r14");
      return c.get<uint8_t>();
    }
    uint8_t& scg_stag_r14()
    {
      assert_choice_type("scg-STAG-r14", type_.to_string(), "targetTA-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& mcg_stag_r14() const
    {
      assert_choice_type("mcg-STAG-r14", type_.to_string(), "targetTA-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& scg_stag_r14() const
    {
      assert_choice_type("scg-STAG-r14", type_.to_string(), "targetTA-r14");
      return c.get<uint8_t>();
    }
    uint8_t& set_mcg_stag_r14()
    {
      set(types::mcg_stag_r14);
      return c.get<uint8_t>();
    }
    uint8_t& set_scg_stag_r14()
    {
      set(types::scg_stag_r14);
      return c.get<uint8_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };
  struct ul_cfg_info_r14_s_ {
    struct ul_sched_interv_r14_opts {
      enum options { sf2, sf5, sf10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<ul_sched_interv_r14_opts> ul_sched_interv_r14_e_;

    // member variables
    uint8_t                nof_conf_ul_processes_r14 = 1;
    ul_sched_interv_r14_e_ ul_sched_interv_r14;
    uint8_t                ul_start_sf_r14 = 0;
    fixed_bitstring<16>    ul_grant_r14;
  };

  // member variables
  bool               ul_cfg_info_r14_present = false;
  target_ta_r14_c_   target_ta_r14;
  ul_cfg_info_r14_s_ ul_cfg_info_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLF-TimersAndConstantsSCG-r12 ::= CHOICE
struct rlf_timers_and_consts_scg_r12_c {
  struct setup_s_ {
    struct t313_r12_opts {
      enum options { ms0, ms50, ms100, ms200, ms500, ms1000, ms2000, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<t313_r12_opts> t313_r12_e_;
    struct n313_r12_opts {
      enum options { n1, n2, n3, n4, n6, n8, n10, n20, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<n313_r12_opts> n313_r12_e_;
    struct n314_r12_opts {
      enum options { n1, n2, n3, n4, n5, n6, n8, n10, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<n314_r12_opts> n314_r12_e_;

    // member variables
    bool        ext = false;
    t313_r12_e_ t313_r12;
    n313_r12_e_ n313_r12;
    n314_r12_e_ n314_r12;
    // ...
  };
  typedef setup_e types;

  // choice methods
  rlf_timers_and_consts_scg_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RLF-TimersAndConstantsSCG-r12");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RLF-TimersAndConstantsSCG-r12");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RRCConnectionReconfiguration-v1530-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1530_ies_s {
  typedef bounded_array<dyn_octstring, 15> ded_info_nas_list_r15_l_;

  // member variables
  bool                              security_cfg_ho_v1530_present            = false;
  bool                              s_cell_group_to_release_list_r15_present = false;
  bool                              s_cell_group_to_add_mod_list_r15_present = false;
  bool                              ded_info_nas_list_r15_present            = false;
  bool                              p_max_ue_fr1_r15_present                 = false;
  bool                              smtc_r15_present                         = false;
  bool                              non_crit_ext_present                     = false;
  security_cfg_ho_v1530_s           security_cfg_ho_v1530;
  scell_group_to_release_list_r15_l s_cell_group_to_release_list_r15;
  scell_group_to_add_mod_list_r15_l s_cell_group_to_add_mod_list_r15;
  ded_info_nas_list_r15_l_          ded_info_nas_list_r15;
  int8_t                            p_max_ue_fr1_r15 = -30;
  mtc_ssb_nr_r15_s                  smtc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigCommonPSCell-r12 ::= SEQUENCE
struct rr_cfg_common_ps_cell_r12_s {
  // member variables
  bool                             ext = false;
  rr_cfg_common_scell_r10_s        basic_fields_r12;
  pucch_cfg_common_s               pucch_cfg_common_r12;
  rach_cfg_common_s                rach_cfg_common_r12;
  ul_pwr_ctrl_common_ps_cell_r12_s ul_pwr_ctrl_common_ps_cell_r12;
  // ...
  // group 0
  bool                                 ul_pwr_ctrl_common_ps_cell_v1310_present = false;
  copy_ptr<ul_pwr_ctrl_common_v1310_s> ul_pwr_ctrl_common_ps_cell_v1310;
  // group 1
  bool                                 ul_pwr_ctrl_common_ps_cell_v1530_present = false;
  copy_ptr<ul_pwr_ctrl_common_v1530_s> ul_pwr_ctrl_common_ps_cell_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigCommonPSCell-v12f0 ::= SEQUENCE
struct rr_cfg_common_ps_cell_v12f0_s {
  // member variables
  rr_cfg_common_scell_v10l0_s basic_fields_v12f0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigCommonPSCell-v1440 ::= SEQUENCE
struct rr_cfg_common_ps_cell_v1440_s {
  // member variables
  rr_cfg_common_scell_v1440_s basic_fields_v1440;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigDedicatedPSCell-r12 ::= SEQUENCE
struct rr_cfg_ded_ps_cell_r12_s {
  // member variables
  bool                    ext                              = false;
  bool                    phys_cfg_ded_ps_cell_r12_present = false;
  bool                    sps_cfg_r12_present              = false;
  bool                    naics_info_r12_present           = false;
  phys_cfg_ded_s          phys_cfg_ded_ps_cell_r12;
  sps_cfg_s               sps_cfg_r12;
  naics_assist_info_r12_c naics_info_r12;
  // ...
  // group 0
  bool                                 neigh_cells_crs_info_ps_cell_r13_present = false;
  copy_ptr<neigh_cells_crs_info_r13_c> neigh_cells_crs_info_ps_cell_r13;
  // group 1
  bool                      sps_cfg_v1430_present = false;
  copy_ptr<sps_cfg_v1430_s> sps_cfg_v1430;
  // group 2
  bool                                 sps_cfg_v1530_present              = false;
  bool                                 crs_intf_mitig_enabled_r15_present = false;
  bool                                 neigh_cells_crs_info_r15_present   = false;
  copy_ptr<sps_cfg_v1530_s>            sps_cfg_v1530;
  bool                                 crs_intf_mitig_enabled_r15 = false;
  copy_ptr<neigh_cells_crs_info_r15_c> neigh_cells_crs_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigDedicatedPSCell-v1370 ::= SEQUENCE
struct rr_cfg_ded_ps_cell_v1370_s {
  // member variables
  bool                 phys_cfg_ded_ps_cell_v1370_present = false;
  phys_cfg_ded_v1370_s phys_cfg_ded_ps_cell_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddMod-r10 ::= SEQUENCE
struct scell_to_add_mod_r10_s {
  struct cell_identif_r10_s_ {
    // member variables
    uint16_t pci_r10             = 0;
    uint16_t dl_carrier_freq_r10 = 0;
  };
  struct s_cell_state_r15_opts {
    enum options { activ, dormant, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<s_cell_state_r15_opts> s_cell_state_r15_e_;

  // member variables
  bool                      ext                             = false;
  bool                      cell_identif_r10_present        = false;
  bool                      rr_cfg_common_scell_r10_present = false;
  bool                      rr_cfg_ded_scell_r10_present    = false;
  uint8_t                   s_cell_idx_r10                  = 1;
  cell_identif_r10_s_       cell_identif_r10;
  rr_cfg_common_scell_r10_s rr_cfg_common_scell_r10;
  rr_cfg_ded_scell_r10_s    rr_cfg_ded_scell_r10;
  // ...
  // group 0
  bool     dl_carrier_freq_v1090_present = false;
  uint32_t dl_carrier_freq_v1090         = 65536;
  // group 1
  bool                           ant_info_ded_scell_v10i0_present = false;
  copy_ptr<ant_info_ded_v10i0_s> ant_info_ded_scell_v10i0;
  // group 2
  bool    srs_switch_from_serv_cell_idx_r14_present = false;
  uint8_t srs_switch_from_serv_cell_idx_r14         = 0;
  // group 3
  bool                s_cell_state_r15_present = false;
  s_cell_state_r15_e_ s_cell_state_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddMod-v10l0 ::= SEQUENCE
struct scell_to_add_mod_v10l0_s {
  // member variables
  bool                        rr_cfg_common_scell_v10l0_present = false;
  rr_cfg_common_scell_v10l0_s rr_cfg_common_scell_v10l0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddModExt-v1370 ::= SEQUENCE
struct scell_to_add_mod_ext_v1370_s {
  // member variables
  bool                        rr_cfg_common_scell_v1370_present = false;
  rr_cfg_common_scell_v10l0_s rr_cfg_common_scell_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddModExt-v1430 ::= SEQUENCE
struct scell_to_add_mod_ext_v1430_s {
  struct s_cell_state_r15_opts {
    enum options { activ, dormant, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<s_cell_state_r15_opts> s_cell_state_r15_e_;

  // member variables
  bool    ext                                       = false;
  bool    srs_switch_from_serv_cell_idx_r14_present = false;
  uint8_t srs_switch_from_serv_cell_idx_r14         = 0;
  // ...
  // group 0
  bool                s_cell_state_r15_present = false;
  s_cell_state_r15_e_ s_cell_state_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscTxRefCarrierDedicated-r13 ::= CHOICE
struct sl_disc_tx_ref_carrier_ded_r13_c {
  struct types_opts {
    enum options { p_cell, s_cell, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sl_disc_tx_ref_carrier_ded_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& s_cell()
  {
    assert_choice_type("sCell", type_.to_string(), "SL-DiscTxRefCarrierDedicated-r13");
    return c;
  }
  const uint8_t& s_cell() const
  {
    assert_choice_type("sCell", type_.to_string(), "SL-DiscTxRefCarrierDedicated-r13");
    return c;
  }
  uint8_t& set_s_cell()
  {
    set(types::s_cell);
    return c;
  }

private:
  types   type_;
  uint8_t c;
};

// SL-DiscTxResource-r13 ::= CHOICE
struct sl_disc_tx_res_r13_c {
  struct setup_c_ {
    struct types_opts {
      enum options { sched_r13, ue_sel_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    setup_c_() = default;
    setup_c_(const setup_c_& other);
    setup_c_& operator=(const setup_c_& other);
    ~setup_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_disc_tx_cfg_sched_r13_s& sched_r13()
    {
      assert_choice_type("scheduled-r13", type_.to_string(), "setup");
      return c.get<sl_disc_tx_cfg_sched_r13_s>();
    }
    sl_disc_tx_pool_ded_r13_s& ue_sel_r13()
    {
      assert_choice_type("ue-Selected-r13", type_.to_string(), "setup");
      return c.get<sl_disc_tx_pool_ded_r13_s>();
    }
    const sl_disc_tx_cfg_sched_r13_s& sched_r13() const
    {
      assert_choice_type("scheduled-r13", type_.to_string(), "setup");
      return c.get<sl_disc_tx_cfg_sched_r13_s>();
    }
    const sl_disc_tx_pool_ded_r13_s& ue_sel_r13() const
    {
      assert_choice_type("ue-Selected-r13", type_.to_string(), "setup");
      return c.get<sl_disc_tx_pool_ded_r13_s>();
    }
    sl_disc_tx_cfg_sched_r13_s& set_sched_r13()
    {
      set(types::sched_r13);
      return c.get<sl_disc_tx_cfg_sched_r13_s>();
    }
    sl_disc_tx_pool_ded_r13_s& set_ue_sel_r13()
    {
      set(types::ue_sel_r13);
      return c.get<sl_disc_tx_pool_ded_r13_s>();
    }

  private:
    types                                                                                        type_;
    choice_buffer_t<MAX2(sizeof(sl_disc_tx_cfg_sched_r13_s), sizeof(sl_disc_tx_pool_ded_r13_s))> c;

    void destroy_();
  };
  typedef setup_e types;

  // choice methods
  sl_disc_tx_res_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_c_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SL-DiscTxResource-r13");
    return c;
  }
  const setup_c_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SL-DiscTxResource-r13");
    return c;
  }
  setup_c_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_c_ c;
};

// SL-GapPattern-r13 ::= SEQUENCE
struct sl_gap_pattern_r13_s {
  struct gap_period_r13_opts {
    enum options {
      sf40,
      sf60,
      sf70,
      sf80,
      sf120,
      sf140,
      sf160,
      sf240,
      sf280,
      sf320,
      sf640,
      sf1280,
      sf2560,
      sf5120,
      sf10240,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<gap_period_r13_opts> gap_period_r13_e_;

  // member variables
  bool                ext = false;
  gap_period_r13_e_   gap_period_r13;
  sl_offset_ind_r12_c gap_offset_r12;
  dyn_bitstring       gap_sf_bitmap_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-TxPoolToAddModListV2X-r14 ::= SEQUENCE (SIZE (1.. maxSL-V2X-TxPool-r14)) OF SL-TxPoolToAddMod-r14
typedef dyn_array<sl_tx_pool_to_add_mod_r14_s> sl_tx_pool_to_add_mod_list_v2x_r14_l;

// SL-TxPoolToReleaseListV2X-r14 ::= SEQUENCE (SIZE (1.. maxSL-V2X-TxPool-r14)) OF INTEGER
typedef bounded_array<uint8_t, 8> sl_tx_pool_to_release_list_v2x_r14_l;

// SubframeAssignment-r15 ::= ENUMERATED
struct sf_assign_r15_opts {
  enum options { sa0, sa1, sa2, sa3, sa4, sa5, sa6, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<sf_assign_r15_opts> sf_assign_r15_e;

// TunnelConfigLWIP-r13 ::= SEQUENCE
struct tunnel_cfg_lwip_r13_s {
  // member variables
  bool             ext = false;
  ip_address_r13_c ip_address_r13;
  ike_id_r13_s     ike_id_r13;
  // ...
  // group 0
  bool     lwip_counter_r13_present = false;
  uint16_t lwip_counter_r13         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-MobilityConfig-r13 ::= SEQUENCE
struct wlan_mob_cfg_r13_s {
  struct association_timer_r13_opts {
    enum options { s10, s30, s60, s120, s240, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<association_timer_r13_opts> association_timer_r13_e_;

  // member variables
  bool                     ext                                  = false;
  bool                     wlan_to_release_list_r13_present     = false;
  bool                     wlan_to_add_list_r13_present         = false;
  bool                     association_timer_r13_present        = false;
  bool                     success_report_requested_r13_present = false;
  wlan_id_list_r13_l       wlan_to_release_list_r13;
  wlan_id_list_r13_l       wlan_to_add_list_r13;
  association_timer_r13_e_ association_timer_r13;
  // ...
  // group 0
  bool                             wlan_suspend_cfg_r14_present = false;
  copy_ptr<wlan_suspend_cfg_r14_s> wlan_suspend_cfg_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CA-BandwidthClass-r10 ::= ENUMERATED
struct ca_bw_class_r10_opts {
  enum options { a, b, c, d, e, f, /*...*/ nulltype } value;

  std::string to_string() const;
};
typedef enumerated<ca_bw_class_r10_opts, true> ca_bw_class_r10_e;

// LWA-Config-r13 ::= SEQUENCE
struct lwa_cfg_r13_s {
  // member variables
  bool               ext                        = false;
  bool               lwa_mob_cfg_r13_present    = false;
  bool               lwa_wt_counter_r13_present = false;
  wlan_mob_cfg_r13_s lwa_mob_cfg_r13;
  uint16_t           lwa_wt_counter_r13 = 0;
  // ...
  // group 0
  bool               wt_mac_address_r14_present = false;
  fixed_octstring<6> wt_mac_address_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LWIP-Config-r13 ::= SEQUENCE
struct lwip_cfg_r13_s {
  // member variables
  bool                  ext                         = false;
  bool                  lwip_mob_cfg_r13_present    = false;
  bool                  tunnel_cfg_lwip_r13_present = false;
  wlan_mob_cfg_r13_s    lwip_mob_cfg_r13;
  tunnel_cfg_lwip_r13_s tunnel_cfg_lwip_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityControlInfoSCG-r12 ::= SEQUENCE
struct mob_ctrl_info_scg_r12_s {
  struct t307_r12_opts {
    enum options { ms50, ms100, ms150, ms200, ms500, ms1000, ms2000, spare1, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t307_r12_opts> t307_r12_e_;

  // member variables
  bool                      ext                                 = false;
  bool                      ue_id_scg_r12_present               = false;
  bool                      rach_cfg_ded_r12_present            = false;
  bool                      ciphering_algorithm_scg_r12_present = false;
  t307_r12_e_               t307_r12;
  fixed_bitstring<16>       ue_id_scg_r12;
  rach_cfg_ded_s            rach_cfg_ded_r12;
  ciphering_algorithm_r12_e ciphering_algorithm_scg_r12;
  // ...
  // group 0
  bool                      make_before_break_scg_r14_present = false;
  bool                      rach_skip_scg_r14_present         = false;
  copy_ptr<rach_skip_r14_s> rach_skip_scg_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-RAN-AreaCellList-r15 ::= SEQUENCE (SIZE (1..maxPLMN-r15)) OF PLMN-RAN-AreaCell-r15
typedef dyn_array<plmn_ran_area_cell_r15_s> plmn_ran_area_cell_list_r15_l;

// PLMN-RAN-AreaConfigList-r15 ::= SEQUENCE (SIZE (1..maxPLMN-r15)) OF PLMN-RAN-AreaConfig-r15
typedef dyn_array<plmn_ran_area_cfg_r15_s> plmn_ran_area_cfg_list_r15_l;

// PSCellToAddMod-r12 ::= SEQUENCE
struct ps_cell_to_add_mod_r12_s {
  struct cell_identif_r12_s_ {
    // member variables
    uint16_t pci_r12             = 0;
    uint32_t dl_carrier_freq_r12 = 0;
  };

  // member variables
  bool                        ext                               = false;
  bool                        cell_identif_r12_present          = false;
  bool                        rr_cfg_common_ps_cell_r12_present = false;
  bool                        rr_cfg_ded_ps_cell_r12_present    = false;
  uint8_t                     s_cell_idx_r12                    = 1;
  cell_identif_r12_s_         cell_identif_r12;
  rr_cfg_common_ps_cell_r12_s rr_cfg_common_ps_cell_r12;
  rr_cfg_ded_ps_cell_r12_s    rr_cfg_ded_ps_cell_r12;
  // ...
  // group 0
  bool                           ant_info_ded_ps_cell_v1280_present = false;
  copy_ptr<ant_info_ded_v10i0_s> ant_info_ded_ps_cell_v1280;
  // group 1
  bool    s_cell_idx_r13_present = false;
  uint8_t s_cell_idx_r13         = 1;
  // group 2
  bool                                 rr_cfg_ded_ps_cell_v1370_present = false;
  copy_ptr<rr_cfg_ded_ps_cell_v1370_s> rr_cfg_ded_ps_cell_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PSCellToAddMod-v12f0 ::= SEQUENCE
struct ps_cell_to_add_mod_v12f0_s {
  // member variables
  bool                          rr_cfg_common_ps_cell_r12_present = false;
  rr_cfg_common_ps_cell_v12f0_s rr_cfg_common_ps_cell_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PSCellToAddMod-v1440 ::= SEQUENCE
struct ps_cell_to_add_mod_v1440_s {
  // member variables
  bool                          rr_cfg_common_ps_cell_r14_present = false;
  rr_cfg_common_ps_cell_v1440_s rr_cfg_common_ps_cell_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RCLWI-Config-r13 ::= SEQUENCE
struct rclwi_cfg_r13_s {
  struct cmd_c_ {
    struct steer_to_wlan_r13_s_ {
      // member variables
      wlan_id_list_r12_l mob_cfg_r13;
    };
    struct types_opts {
      enum options { steer_to_wlan_r13, steer_to_lte_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    cmd_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    steer_to_wlan_r13_s_& steer_to_wlan_r13()
    {
      assert_choice_type("steerToWLAN-r13", type_.to_string(), "command");
      return c;
    }
    const steer_to_wlan_r13_s_& steer_to_wlan_r13() const
    {
      assert_choice_type("steerToWLAN-r13", type_.to_string(), "command");
      return c;
    }
    steer_to_wlan_r13_s_& set_steer_to_wlan_r13()
    {
      set(types::steer_to_wlan_r13);
      return c;
    }

  private:
    types                type_;
    steer_to_wlan_r13_s_ c;
  };

  // member variables
  bool   ext = false;
  cmd_c_ cmd;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v1510-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1510_ies_s {
  struct nr_cfg_r15_c_ {
    struct setup_s_ {
      // member variables
      bool          nr_secondary_cell_group_cfg_r15_present = false;
      bool          p_max_eutra_r15_present                 = false;
      bool          endc_release_and_add_r15                = false;
      dyn_octstring nr_secondary_cell_group_cfg_r15;
      int8_t        p_max_eutra_r15 = -30;
    };
    typedef setup_e types;

    // choice methods
    nr_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "nr-Config-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "nr-Config-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct tdm_pattern_cfg_r15_c_ {
    struct setup_s_ {
      // member variables
      sf_assign_r15_e sf_assign_r15;
      uint8_t         harq_offset_r15 = 0;
    };
    typedef setup_e types;

    // choice methods
    tdm_pattern_cfg_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "tdm-PatternConfig-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "tdm-PatternConfig-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                       nr_cfg_r15_present               = false;
  bool                       sk_counter_r15_present           = false;
  bool                       nr_radio_bearer_cfg1_r15_present = false;
  bool                       nr_radio_bearer_cfg2_r15_present = false;
  bool                       tdm_pattern_cfg_r15_present      = false;
  bool                       non_crit_ext_present             = false;
  nr_cfg_r15_c_              nr_cfg_r15;
  uint16_t                   sk_counter_r15 = 0;
  dyn_octstring              nr_radio_bearer_cfg1_r15;
  dyn_octstring              nr_radio_bearer_cfg2_r15;
  tdm_pattern_cfg_r15_c_     tdm_pattern_cfg_r15;
  rrc_conn_recfg_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigDedicatedSCG-r12 ::= SEQUENCE
struct rr_cfg_ded_scg_r12_s {
  // member variables
  bool                            ext                                   = false;
  bool                            drb_to_add_mod_list_scg_r12_present   = false;
  bool                            mac_main_cfg_scg_r12_present          = false;
  bool                            rlf_timers_and_consts_scg_r12_present = false;
  drb_to_add_mod_list_scg_r12_l   drb_to_add_mod_list_scg_r12;
  mac_main_cfg_s                  mac_main_cfg_scg_r12;
  rlf_timers_and_consts_scg_r12_c rlf_timers_and_consts_scg_r12;
  // ...
  // group 0
  bool                                    drb_to_add_mod_list_scg_r15_present = false;
  copy_ptr<drb_to_add_mod_list_scg_r15_l> drb_to_add_mod_list_scg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddModList-r10 ::= SEQUENCE (SIZE (1..maxSCell-r10)) OF SCellToAddMod-r10
typedef dyn_array<scell_to_add_mod_r10_s> scell_to_add_mod_list_r10_l;

// SCellToAddModList-v10l0 ::= SEQUENCE (SIZE (1..maxSCell-r10)) OF SCellToAddMod-v10l0
typedef dyn_array<scell_to_add_mod_v10l0_s> scell_to_add_mod_list_v10l0_l;

// SCellToAddModListExt-v1370 ::= SEQUENCE (SIZE (1..maxSCell-r13)) OF SCellToAddModExt-v1370
typedef dyn_array<scell_to_add_mod_ext_v1370_s> scell_to_add_mod_list_ext_v1370_l;

// SCellToAddModListExt-v1430 ::= SEQUENCE (SIZE (1..maxSCell-r13)) OF SCellToAddModExt-v1430
typedef dyn_array<scell_to_add_mod_ext_v1430_s> scell_to_add_mod_list_ext_v1430_l;

// SCellToReleaseList-r10 ::= SEQUENCE (SIZE (1..maxSCell-r10)) OF INTEGER
typedef bounded_array<uint8_t, 4> scell_to_release_list_r10_l;

// SL-CommTxPoolToAddMod-r12 ::= SEQUENCE
struct sl_comm_tx_pool_to_add_mod_r12_s {
  // member variables
  uint8_t                pool_id_r12 = 1;
  sl_comm_res_pool_r12_s pool_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CommTxPoolToAddModExt-r13 ::= SEQUENCE
struct sl_comm_tx_pool_to_add_mod_ext_r13_s {
  // member variables
  uint8_t                pool_id_v1310 = 5;
  sl_comm_res_pool_r12_s pool_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscTxResourceInfoPerFreq-r13 ::= SEQUENCE
struct sl_disc_tx_res_info_per_freq_r13_s {
  // member variables
  bool                             ext                                 = false;
  bool                             disc_tx_res_r13_present             = false;
  bool                             disc_tx_res_ps_r13_present          = false;
  bool                             disc_tx_ref_carrier_ded_r13_present = false;
  bool                             disc_cell_sel_info_r13_present      = false;
  uint32_t                         disc_tx_carrier_freq_r13            = 0;
  sl_disc_tx_res_r13_c             disc_tx_res_r13;
  sl_disc_tx_res_r13_c             disc_tx_res_ps_r13;
  sl_disc_tx_ref_carrier_ded_r13_c disc_tx_ref_carrier_ded_r13;
  cell_sel_info_nfreq_r13_s        disc_cell_sel_info_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-GapPatternList-r13 ::= SEQUENCE (SIZE (1..maxSL-GP-r13)) OF SL-GapPattern-r13
typedef dyn_array<sl_gap_pattern_r13_s> sl_gap_pattern_list_r13_l;

// SL-TF-IndexPair-r12 ::= SEQUENCE
struct sl_tf_idx_pair_r12_s {
  // member variables
  bool    disc_sf_idx_r12_present  = false;
  bool    disc_prb_idx_r12_present = false;
  uint8_t disc_sf_idx_r12          = 1;
  uint8_t disc_prb_idx_r12         = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-ConfigDedicated-r14 ::= SEQUENCE
struct sl_v2x_cfg_ded_r14_s {
  struct comm_tx_res_r14_c_ {
    struct setup_c_ {
      struct sched_r14_s_ {
        // member variables
        bool                        v2x_sched_pool_r14_present = false;
        bool                        mcs_r14_present            = false;
        fixed_bitstring<16>         sl_v_rnti_r14;
        mac_main_cfg_sl_r12_s       mac_main_cfg_r14;
        sl_comm_res_pool_v2x_r14_s  v2x_sched_pool_r14;
        uint8_t                     mcs_r14 = 0;
        lc_ch_group_info_list_r13_l lc_ch_group_info_list_r14;
      };
      struct ue_sel_r14_s_ {
        struct v2x_comm_tx_pool_normal_ded_r14_s_ {
          // member variables
          bool                                 pool_to_release_list_r14_present         = false;
          bool                                 pool_to_add_mod_list_r14_present         = false;
          bool                                 v2x_comm_tx_pool_sensing_cfg_r14_present = false;
          sl_tx_pool_to_release_list_v2x_r14_l pool_to_release_list_r14;
          sl_tx_pool_to_add_mod_list_v2x_r14_l pool_to_add_mod_list_r14;
          sl_comm_tx_pool_sensing_cfg_r14_s    v2x_comm_tx_pool_sensing_cfg_r14;
        };

        // member variables
        v2x_comm_tx_pool_normal_ded_r14_s_ v2x_comm_tx_pool_normal_ded_r14;
      };
      struct types_opts {
        enum options { sched_r14, ue_sel_r14, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      sched_r14_s_& sched_r14()
      {
        assert_choice_type("scheduled-r14", type_.to_string(), "setup");
        return c.get<sched_r14_s_>();
      }
      ue_sel_r14_s_& ue_sel_r14()
      {
        assert_choice_type("ue-Selected-r14", type_.to_string(), "setup");
        return c.get<ue_sel_r14_s_>();
      }
      const sched_r14_s_& sched_r14() const
      {
        assert_choice_type("scheduled-r14", type_.to_string(), "setup");
        return c.get<sched_r14_s_>();
      }
      const ue_sel_r14_s_& ue_sel_r14() const
      {
        assert_choice_type("ue-Selected-r14", type_.to_string(), "setup");
        return c.get<ue_sel_r14_s_>();
      }
      sched_r14_s_& set_sched_r14()
      {
        set(types::sched_r14);
        return c.get<sched_r14_s_>();
      }
      ue_sel_r14_s_& set_ue_sel_r14()
      {
        set(types::ue_sel_r14);
        return c.get<ue_sel_r14_s_>();
      }

    private:
      types                                                              type_;
      choice_buffer_t<MAX2(sizeof(sched_r14_s_), sizeof(ue_sel_r14_s_))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    comm_tx_res_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-r14");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-r14");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };
  struct comm_tx_res_v1530_c_ {
    struct setup_c_ {
      struct sched_v1530_s_ {
        // member variables
        bool                          lc_ch_group_info_list_v1530_present = false;
        bool                          mcs_r15_present                     = false;
        lc_ch_group_info_list_v1530_l lc_ch_group_info_list_v1530;
        uint8_t                       mcs_r15 = 0;
      };
      struct ue_sel_v1530_s_ {
        // member variables
        bool                           v2x_freq_sel_cfg_list_r15_present = false;
        sl_v2x_freq_sel_cfg_list_r15_l v2x_freq_sel_cfg_list_r15;
      };
      struct types_opts {
        enum options { sched_v1530, ue_sel_v1530, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      sched_v1530_s_& sched_v1530()
      {
        assert_choice_type("scheduled-v1530", type_.to_string(), "setup");
        return c.get<sched_v1530_s_>();
      }
      ue_sel_v1530_s_& ue_sel_v1530()
      {
        assert_choice_type("ue-Selected-v1530", type_.to_string(), "setup");
        return c.get<ue_sel_v1530_s_>();
      }
      const sched_v1530_s_& sched_v1530() const
      {
        assert_choice_type("scheduled-v1530", type_.to_string(), "setup");
        return c.get<sched_v1530_s_>();
      }
      const ue_sel_v1530_s_& ue_sel_v1530() const
      {
        assert_choice_type("ue-Selected-v1530", type_.to_string(), "setup");
        return c.get<ue_sel_v1530_s_>();
      }
      sched_v1530_s_& set_sched_v1530()
      {
        set(types::sched_v1530);
        return c.get<sched_v1530_s_>();
      }
      ue_sel_v1530_s_& set_ue_sel_v1530()
      {
        set(types::ue_sel_v1530);
        return c.get<ue_sel_v1530_s_>();
      }

    private:
      types                                                                  type_;
      choice_buffer_t<MAX2(sizeof(sched_v1530_s_), sizeof(ue_sel_v1530_s_))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    comm_tx_res_v1530_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-v1530");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-v1530");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };

  // member variables
  bool                              ext                                    = false;
  bool                              comm_tx_res_r14_present                = false;
  bool                              v2x_inter_freq_info_list_r14_present   = false;
  bool                              thres_sl_tx_prioritization_r14_present = false;
  bool                              type_tx_sync_r14_present               = false;
  bool                              cbr_ded_tx_cfg_list_r14_present        = false;
  comm_tx_res_r14_c_                comm_tx_res_r14;
  sl_inter_freq_info_list_v2x_r14_l v2x_inter_freq_info_list_r14;
  uint8_t                           thres_sl_tx_prioritization_r14 = 1;
  sl_type_tx_sync_r14_e             type_tx_sync_r14;
  sl_cbr_common_tx_cfg_list_r14_s   cbr_ded_tx_cfg_list_r14;
  // ...
  // group 0
  bool                                   comm_tx_res_v1530_present       = false;
  bool                                   v2x_packet_dupl_cfg_r15_present = false;
  bool                                   sync_freq_list_r15_present      = false;
  bool                                   slss_tx_multi_freq_r15_present  = false;
  copy_ptr<comm_tx_res_v1530_c_>         comm_tx_res_v1530;
  copy_ptr<sl_v2x_packet_dupl_cfg_r15_s> v2x_packet_dupl_cfg_r15;
  copy_ptr<sl_v2x_sync_freq_list_r15_l>  sync_freq_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandIndication-r14 ::= SEQUENCE
struct band_ind_r14_s {
  // member variables
  bool              ca_bw_class_ul_r14_present = false;
  uint16_t          band_eutra_r14             = 1;
  ca_bw_class_r10_e ca_bw_class_dl_r14;
  ca_bw_class_r10_e ca_bw_class_ul_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LWA-Configuration-r13 ::= CHOICE
struct lwa_cfg_r13_c {
  struct setup_s_ {
    // member variables
    lwa_cfg_r13_s lwa_cfg_r13;
  };
  typedef setup_e types;

  // choice methods
  lwa_cfg_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "LWA-Configuration-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "LWA-Configuration-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// LWIP-Configuration-r13 ::= CHOICE
struct lwip_cfg_r13_c {
  struct setup_s_ {
    // member variables
    lwip_cfg_r13_s lwip_cfg_r13;
  };
  typedef setup_e types;

  // choice methods
  lwip_cfg_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "LWIP-Configuration-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "LWIP-Configuration-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// MeasCSI-RS-Config-r12 ::= SEQUENCE
struct meas_csi_rs_cfg_r12_s {
  // member variables
  bool             ext                = false;
  uint8_t          meas_csi_rs_id_r12 = 1;
  uint16_t         pci_r12            = 0;
  uint16_t         scrambling_id_r12  = 0;
  uint8_t          res_cfg_r12        = 0;
  uint8_t          sf_offset_r12      = 0;
  q_offset_range_e csi_rs_individual_offset_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhysCellIdRangeUTRA-FDD-r9 ::= SEQUENCE
struct pci_range_utra_fdd_r9_s {
  // member variables
  bool     range_r9_present = false;
  uint16_t start_r9         = 0;
  uint16_t range_r9         = 2;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PowerCoordinationInfo-r12 ::= SEQUENCE
struct pwr_coordination_info_r12_s {
  // member variables
  uint8_t p_me_nb_r12       = 1;
  uint8_t p_se_nb_r12       = 1;
  uint8_t pwr_ctrl_mode_r12 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RAN-NotificationAreaInfo-r15 ::= CHOICE
struct ran_notif_area_info_r15_c {
  struct types_opts {
    enum options { cell_list_r15, ran_area_cfg_list_r15, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ran_notif_area_info_r15_c() = default;
  ran_notif_area_info_r15_c(const ran_notif_area_info_r15_c& other);
  ran_notif_area_info_r15_c& operator=(const ran_notif_area_info_r15_c& other);
  ~ran_notif_area_info_r15_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  plmn_ran_area_cell_list_r15_l& cell_list_r15()
  {
    assert_choice_type("cellList-r15", type_.to_string(), "RAN-NotificationAreaInfo-r15");
    return c.get<plmn_ran_area_cell_list_r15_l>();
  }
  plmn_ran_area_cfg_list_r15_l& ran_area_cfg_list_r15()
  {
    assert_choice_type("ran-AreaConfigList-r15", type_.to_string(), "RAN-NotificationAreaInfo-r15");
    return c.get<plmn_ran_area_cfg_list_r15_l>();
  }
  const plmn_ran_area_cell_list_r15_l& cell_list_r15() const
  {
    assert_choice_type("cellList-r15", type_.to_string(), "RAN-NotificationAreaInfo-r15");
    return c.get<plmn_ran_area_cell_list_r15_l>();
  }
  const plmn_ran_area_cfg_list_r15_l& ran_area_cfg_list_r15() const
  {
    assert_choice_type("ran-AreaConfigList-r15", type_.to_string(), "RAN-NotificationAreaInfo-r15");
    return c.get<plmn_ran_area_cfg_list_r15_l>();
  }
  plmn_ran_area_cell_list_r15_l& set_cell_list_r15()
  {
    set(types::cell_list_r15);
    return c.get<plmn_ran_area_cell_list_r15_l>();
  }
  plmn_ran_area_cfg_list_r15_l& set_ran_area_cfg_list_r15()
  {
    set(types::ran_area_cfg_list_r15);
    return c.get<plmn_ran_area_cfg_list_r15_l>();
  }

private:
  types                                                                                              type_;
  choice_buffer_t<MAX2(sizeof(plmn_ran_area_cell_list_r15_l), sizeof(plmn_ran_area_cfg_list_r15_l))> c;

  void destroy_();
};

// RCLWI-Configuration-r13 ::= CHOICE
struct rclwi_cfg_r13_c {
  struct setup_s_ {
    // member variables
    rclwi_cfg_r13_s rclwi_cfg_r13;
  };
  typedef setup_e types;

  // choice methods
  rclwi_cfg_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RCLWI-Configuration-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RCLWI-Configuration-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RRCConnectionReconfiguration-v1430-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1430_ies_s {
  // member variables
  bool                              sl_v2x_cfg_ded_r14_present               = false;
  bool                              s_cell_to_add_mod_list_ext_v1430_present = false;
  bool                              per_cc_gap_ind_request_r14_present       = false;
  bool                              sib_type2_ded_r14_present                = false;
  bool                              non_crit_ext_present                     = false;
  sl_v2x_cfg_ded_r14_s              sl_v2x_cfg_ded_r14;
  scell_to_add_mod_list_ext_v1430_l s_cell_to_add_mod_list_ext_v1430;
  dyn_octstring                     sib_type2_ded_r14;
  rrc_conn_recfg_v1510_ies_s        non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigDedicated-v1370 ::= SEQUENCE
struct rr_cfg_ded_v1370_s {
  // member variables
  bool                 phys_cfg_ded_v1370_present = false;
  phys_cfg_ded_v1370_s phys_cfg_ded_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-ConfigPartSCG-r12 ::= SEQUENCE
struct scg_cfg_part_scg_r12_s {
  // member variables
  bool                        ext                                    = false;
  bool                        rr_cfg_ded_scg_r12_present             = false;
  bool                        s_cell_to_release_list_scg_r12_present = false;
  bool                        p_scell_to_add_mod_r12_present         = false;
  bool                        s_cell_to_add_mod_list_scg_r12_present = false;
  bool                        mob_ctrl_info_scg_r12_present          = false;
  rr_cfg_ded_scg_r12_s        rr_cfg_ded_scg_r12;
  scell_to_release_list_r10_l s_cell_to_release_list_scg_r12;
  ps_cell_to_add_mod_r12_s    p_scell_to_add_mod_r12;
  scell_to_add_mod_list_r10_l s_cell_to_add_mod_list_scg_r12;
  mob_ctrl_info_scg_r12_s     mob_ctrl_info_scg_r12;
  // ...
  // group 0
  bool                                      s_cell_to_release_list_scg_ext_r13_present = false;
  bool                                      s_cell_to_add_mod_list_scg_ext_r13_present = false;
  copy_ptr<scell_to_release_list_ext_r13_l> s_cell_to_release_list_scg_ext_r13;
  copy_ptr<scell_to_add_mod_list_ext_r13_l> s_cell_to_add_mod_list_scg_ext_r13;
  // group 1
  bool                                        s_cell_to_add_mod_list_scg_ext_v1370_present = false;
  copy_ptr<scell_to_add_mod_list_ext_v1370_l> s_cell_to_add_mod_list_scg_ext_v1370;
  // group 2
  bool                                 p_scell_to_add_mod_v1440_present = false;
  copy_ptr<ps_cell_to_add_mod_v1440_s> p_scell_to_add_mod_v1440;
  // group 3
  bool                                        s_cell_group_to_release_list_scg_r15_present = false;
  bool                                        s_cell_group_to_add_mod_list_scg_r15_present = false;
  copy_ptr<scell_group_to_release_list_r15_l> s_cell_group_to_release_list_scg_r15;
  copy_ptr<scell_group_to_add_mod_list_r15_l> s_cell_group_to_add_mod_list_scg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-ConfigPartSCG-v12f0 ::= SEQUENCE
struct scg_cfg_part_scg_v12f0_s {
  // member variables
  bool                          p_scell_to_add_mod_v12f0_present         = false;
  bool                          s_cell_to_add_mod_list_scg_v12f0_present = false;
  ps_cell_to_add_mod_v12f0_s    p_scell_to_add_mod_v12f0;
  scell_to_add_mod_list_v10l0_l s_cell_to_add_mod_list_scg_v12f0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CommTxPoolToAddModList-r12 ::= SEQUENCE (SIZE (1..maxSL-TxPool-r12)) OF SL-CommTxPoolToAddMod-r12
typedef dyn_array<sl_comm_tx_pool_to_add_mod_r12_s> sl_comm_tx_pool_to_add_mod_list_r12_l;

// SL-CommTxPoolToAddModListExt-r13 ::= SEQUENCE (SIZE (1..maxSL-TxPool-v1310)) OF SL-CommTxPoolToAddModExt-r13
typedef dyn_array<sl_comm_tx_pool_to_add_mod_ext_r13_s> sl_comm_tx_pool_to_add_mod_list_ext_r13_l;

// SL-DiscSysInfoToReportFreqList-r13 ::= SEQUENCE (SIZE (1..maxFreq)) OF INTEGER
typedef bounded_array<uint32_t, 8> sl_disc_sys_info_to_report_freq_list_r13_l;

// SL-DiscTxInfoInterFreqListAdd-r13 ::= SEQUENCE
struct sl_disc_tx_info_inter_freq_list_add_r13_s {
  typedef dyn_array<sl_disc_tx_res_info_per_freq_r13_s> disc_tx_freq_to_add_mod_list_r13_l_;
  typedef bounded_array<uint32_t, 8>                    disc_tx_freq_to_release_list_r13_l_;

  // member variables
  bool                                ext                                      = false;
  bool                                disc_tx_freq_to_add_mod_list_r13_present = false;
  bool                                disc_tx_freq_to_release_list_r13_present = false;
  disc_tx_freq_to_add_mod_list_r13_l_ disc_tx_freq_to_add_mod_list_r13;
  disc_tx_freq_to_release_list_r13_l_ disc_tx_freq_to_release_list_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-GapConfig-r13 ::= SEQUENCE
struct sl_gap_cfg_r13_s {
  // member variables
  sl_gap_pattern_list_r13_l gap_pattern_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-TF-IndexPairList-r12 ::= SEQUENCE (SIZE (1..maxSL-TF-IndexPair-r12)) OF SL-TF-IndexPair-r12
typedef dyn_array<sl_tf_idx_pair_r12_s> sl_tf_idx_pair_list_r12_l;

// SL-TxPoolToReleaseListExt-r13 ::= SEQUENCE (SIZE (1..maxSL-TxPool-v1310)) OF INTEGER
typedef bounded_array<uint8_t, 4> sl_tx_pool_to_release_list_ext_r13_l;

// AltTTT-CellsToAddMod-r12 ::= SEQUENCE
struct alt_ttt_cells_to_add_mod_r12_s {
  // member variables
  uint8_t     cell_idx_r12 = 1;
  pci_range_s pci_range_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BT-NameList-r15 ::= SEQUENCE (SIZE (1..maxBT-Name-r15)) OF OCTET STRING
typedef bounded_array<dyn_octstring, 4> bt_name_list_r15_l;

// BandCombination-r14 ::= SEQUENCE (SIZE (1..maxSimultaneousBands-r10)) OF BandIndication-r14
typedef dyn_array<band_ind_r14_s> band_combination_r14_l;

// BlackCellsToAddMod ::= SEQUENCE
struct black_cells_to_add_mod_s {
  // member variables
  uint8_t     cell_idx = 1;
  pci_range_s pci_range;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellsToAddMod ::= SEQUENCE
struct cells_to_add_mod_s {
  // member variables
  uint8_t          cell_idx = 1;
  uint16_t         pci      = 0;
  q_offset_range_e cell_individual_offset;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellsToAddModCDMA2000 ::= SEQUENCE
struct cells_to_add_mod_cdma2000_s {
  // member variables
  uint8_t  cell_idx = 1;
  uint16_t pci      = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellsToAddModNR-r15 ::= SEQUENCE
struct cells_to_add_mod_nr_r15_s {
  // member variables
  uint8_t  cell_idx_r15 = 1;
  uint16_t pci_r15      = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellsToAddModUTRA-FDD ::= SEQUENCE
struct cells_to_add_mod_utra_fdd_s {
  // member variables
  uint8_t  cell_idx = 1;
  uint16_t pci      = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellsToAddModUTRA-TDD ::= SEQUENCE
struct cells_to_add_mod_utra_tdd_s {
  // member variables
  uint8_t cell_idx = 1;
  uint8_t pci      = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FlightPathInfoReportConfig-r15 ::= SEQUENCE
struct flight_path_info_report_cfg_r15_s {
  // member variables
  bool    include_time_stamp_r15_present = false;
  uint8_t max_way_point_num_r15          = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasCSI-RS-ToAddModList-r12 ::= SEQUENCE (SIZE (1..maxCSI-RS-Meas-r12)) OF MeasCSI-RS-Config-r12
typedef dyn_array<meas_csi_rs_cfg_r12_s> meas_csi_rs_to_add_mod_list_r12_l;

// MeasCSI-RS-ToRemoveList-r12 ::= SEQUENCE (SIZE (1..maxCSI-RS-Meas-r12)) OF INTEGER
typedef dyn_array<uint8_t> meas_csi_rs_to_rem_list_r12_l;

// MeasIdleConfigDedicated-r15 ::= SEQUENCE
struct meas_idle_cfg_ded_r15_s {
  struct meas_idle_dur_r15_opts {
    enum options { sec10, sec30, sec60, sec120, sec180, sec240, sec300, spare, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<meas_idle_dur_r15_opts> meas_idle_dur_r15_e_;

  // member variables
  bool                     ext                                      = false;
  bool                     meas_idle_carrier_list_eutra_r15_present = false;
  eutra_carrier_list_r15_l meas_idle_carrier_list_eutra_r15;
  meas_idle_dur_r15_e_     meas_idle_dur_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasSubframeCellList-r10 ::= SEQUENCE (SIZE (1..maxCellMeas)) OF PhysCellIdRange
typedef dyn_array<pci_range_s> meas_sf_cell_list_r10_l;

// PhysCellIdRangeUTRA-FDDList-r9 ::= SEQUENCE (SIZE (1..maxPhysCellIdRange-r9)) OF PhysCellIdRangeUTRA-FDD-r9
typedef dyn_array<pci_range_utra_fdd_r9_s> pci_range_utra_fdd_list_r9_l;

// RRC-InactiveConfig-r15 ::= SEQUENCE
struct rrc_inactive_cfg_r15_s {
  struct ran_paging_cycle_r15_opts {
    enum options { rf32, rf64, rf128, rf256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<ran_paging_cycle_r15_opts> ran_paging_cycle_r15_e_;
  struct periodic_rnau_timer_r15_opts {
    enum options { min5, min10, min20, min30, min60, min120, min360, min720, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<periodic_rnau_timer_r15_opts> periodic_rnau_timer_r15_e_;

  // member variables
  bool                       ran_paging_cycle_r15_present        = false;
  bool                       ran_notif_area_info_r15_present     = false;
  bool                       periodic_rnau_timer_r15_present     = false;
  bool                       next_hop_chaining_count_r15_present = false;
  bool                       non_crit_ext_present                = false;
  fixed_bitstring<40>        full_i_rnti_r15;
  fixed_bitstring<24>        short_i_rnti_r15;
  ran_paging_cycle_r15_e_    ran_paging_cycle_r15;
  ran_notif_area_info_r15_c  ran_notif_area_info_r15;
  periodic_rnau_timer_r15_e_ periodic_rnau_timer_r15;
  uint8_t                    next_hop_chaining_count_r15 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v1310-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1310_ies_s {
  // member variables
  bool                            s_cell_to_release_list_ext_r13_present = false;
  bool                            s_cell_to_add_mod_list_ext_r13_present = false;
  bool                            lwa_cfg_r13_present                    = false;
  bool                            lwip_cfg_r13_present                   = false;
  bool                            rclwi_cfg_r13_present                  = false;
  bool                            non_crit_ext_present                   = false;
  scell_to_release_list_ext_r13_l s_cell_to_release_list_ext_r13;
  scell_to_add_mod_list_ext_r13_l s_cell_to_add_mod_list_ext_r13;
  lwa_cfg_r13_c                   lwa_cfg_r13;
  lwip_cfg_r13_c                  lwip_cfg_r13;
  rclwi_cfg_r13_c                 rclwi_cfg_r13;
  rrc_conn_recfg_v1430_ies_s      non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v1370-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1370_ies_s {
  // member variables
  bool                              rr_cfg_ded_v1370_present                 = false;
  bool                              s_cell_to_add_mod_list_ext_v1370_present = false;
  bool                              non_crit_ext_present                     = false;
  rr_cfg_ded_v1370_s                rr_cfg_ded_v1370;
  scell_to_add_mod_list_ext_v1370_l s_cell_to_add_mod_list_ext_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-Configuration-r12 ::= CHOICE
struct scg_cfg_r12_c {
  struct setup_s_ {
    struct scg_cfg_part_mcg_r12_s_ {
      // member variables
      bool                        ext                               = false;
      bool                        scg_counter_r12_present           = false;
      bool                        pwr_coordination_info_r12_present = false;
      uint16_t                    scg_counter_r12                   = 0;
      pwr_coordination_info_r12_s pwr_coordination_info_r12;
      // ...
    };

    // member variables
    bool                    scg_cfg_part_mcg_r12_present = false;
    bool                    scg_cfg_part_scg_r12_present = false;
    scg_cfg_part_mcg_r12_s_ scg_cfg_part_mcg_r12;
    scg_cfg_part_scg_r12_s  scg_cfg_part_scg_r12;
  };
  typedef setup_e types;

  // choice methods
  scg_cfg_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SCG-Configuration-r12");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SCG-Configuration-r12");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SCG-Configuration-v12f0 ::= CHOICE
struct scg_cfg_v12f0_c {
  struct setup_s_ {
    // member variables
    bool                     scg_cfg_part_scg_v12f0_present = false;
    scg_cfg_part_scg_v12f0_s scg_cfg_part_scg_v12f0;
  };
  typedef setup_e types;

  // choice methods
  scg_cfg_v12f0_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SCG-Configuration-v12f0");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SCG-Configuration-v12f0");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// SL-CommConfig-r12 ::= SEQUENCE
struct sl_comm_cfg_r12_s {
  struct comm_tx_res_r12_c_ {
    struct setup_c_ {
      struct sched_r12_s_ {
        // member variables
        bool                   mcs_r12_present = false;
        fixed_bitstring<16>    sl_rnti_r12;
        mac_main_cfg_sl_r12_s  mac_main_cfg_r12;
        sl_comm_res_pool_r12_s sc_comm_tx_cfg_r12;
        uint8_t                mcs_r12 = 0;
      };
      struct ue_sel_r12_s_ {
        struct comm_tx_pool_normal_ded_r12_s_ {
          // member variables
          bool                                  pool_to_release_list_r12_present = false;
          bool                                  pool_to_add_mod_list_r12_present = false;
          sl_tx_pool_to_release_list_r12_l      pool_to_release_list_r12;
          sl_comm_tx_pool_to_add_mod_list_r12_l pool_to_add_mod_list_r12;
        };

        // member variables
        comm_tx_pool_normal_ded_r12_s_ comm_tx_pool_normal_ded_r12;
      };
      struct types_opts {
        enum options { sched_r12, ue_sel_r12, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      sched_r12_s_& sched_r12()
      {
        assert_choice_type("scheduled-r12", type_.to_string(), "setup");
        return c.get<sched_r12_s_>();
      }
      ue_sel_r12_s_& ue_sel_r12()
      {
        assert_choice_type("ue-Selected-r12", type_.to_string(), "setup");
        return c.get<ue_sel_r12_s_>();
      }
      const sched_r12_s_& sched_r12() const
      {
        assert_choice_type("scheduled-r12", type_.to_string(), "setup");
        return c.get<sched_r12_s_>();
      }
      const ue_sel_r12_s_& ue_sel_r12() const
      {
        assert_choice_type("ue-Selected-r12", type_.to_string(), "setup");
        return c.get<ue_sel_r12_s_>();
      }
      sched_r12_s_& set_sched_r12()
      {
        set(types::sched_r12);
        return c.get<sched_r12_s_>();
      }
      ue_sel_r12_s_& set_ue_sel_r12()
      {
        set(types::ue_sel_r12);
        return c.get<ue_sel_r12_s_>();
      }

    private:
      types                                                              type_;
      choice_buffer_t<MAX2(sizeof(sched_r12_s_), sizeof(ue_sel_r12_s_))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    comm_tx_res_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-r12");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-r12");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };
  struct comm_tx_res_v1310_c_ {
    struct setup_c_ {
      struct sched_v1310_s_ {
        // member variables
        lc_ch_group_info_list_r13_l lc_ch_group_info_list_r13;
        bool                        multiple_tx_r13 = false;
      };
      struct ue_sel_v1310_s_ {
        struct comm_tx_pool_normal_ded_ext_r13_s_ {
          // member variables
          bool                                      pool_to_release_list_ext_r13_present = false;
          bool                                      pool_to_add_mod_list_ext_r13_present = false;
          sl_tx_pool_to_release_list_ext_r13_l      pool_to_release_list_ext_r13;
          sl_comm_tx_pool_to_add_mod_list_ext_r13_l pool_to_add_mod_list_ext_r13;
        };

        // member variables
        comm_tx_pool_normal_ded_ext_r13_s_ comm_tx_pool_normal_ded_ext_r13;
      };
      struct types_opts {
        enum options { sched_v1310, ue_sel_v1310, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      sched_v1310_s_& sched_v1310()
      {
        assert_choice_type("scheduled-v1310", type_.to_string(), "setup");
        return c.get<sched_v1310_s_>();
      }
      ue_sel_v1310_s_& ue_sel_v1310()
      {
        assert_choice_type("ue-Selected-v1310", type_.to_string(), "setup");
        return c.get<ue_sel_v1310_s_>();
      }
      const sched_v1310_s_& sched_v1310() const
      {
        assert_choice_type("scheduled-v1310", type_.to_string(), "setup");
        return c.get<sched_v1310_s_>();
      }
      const ue_sel_v1310_s_& ue_sel_v1310() const
      {
        assert_choice_type("ue-Selected-v1310", type_.to_string(), "setup");
        return c.get<ue_sel_v1310_s_>();
      }
      sched_v1310_s_& set_sched_v1310()
      {
        set(types::sched_v1310);
        return c.get<sched_v1310_s_>();
      }
      ue_sel_v1310_s_& set_ue_sel_v1310()
      {
        set(types::ue_sel_v1310);
        return c.get<ue_sel_v1310_s_>();
      }

    private:
      types                                                                  type_;
      choice_buffer_t<MAX2(sizeof(sched_v1310_s_), sizeof(ue_sel_v1310_s_))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    comm_tx_res_v1310_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-v1310");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "commTxResources-v1310");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };

  // member variables
  bool               ext                     = false;
  bool               comm_tx_res_r12_present = false;
  comm_tx_res_r12_c_ comm_tx_res_r12;
  // ...
  // group 0
  bool                           comm_tx_res_v1310_present           = false;
  bool                           comm_tx_allow_relay_ded_r13_present = false;
  copy_ptr<comm_tx_res_v1310_c_> comm_tx_res_v1310;
  bool                           comm_tx_allow_relay_ded_r13 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscConfig-r12 ::= SEQUENCE
struct sl_disc_cfg_r12_s {
  struct disc_tx_res_r12_c_ {
    struct setup_c_ {
      struct sched_r12_s_ {
        // member variables
        bool                      disc_tx_cfg_r12_present      = false;
        bool                      disc_tf_idx_list_r12_present = false;
        bool                      disc_hop_cfg_r12_present     = false;
        sl_disc_res_pool_r12_s    disc_tx_cfg_r12;
        sl_tf_idx_pair_list_r12_l disc_tf_idx_list_r12;
        sl_hop_cfg_disc_r12_s     disc_hop_cfg_r12;
      };
      struct ue_sel_r12_s_ {
        struct disc_tx_pool_ded_r12_s_ {
          // member variables
          bool                                  pool_to_release_list_r12_present = false;
          bool                                  pool_to_add_mod_list_r12_present = false;
          sl_tx_pool_to_release_list_r12_l      pool_to_release_list_r12;
          sl_disc_tx_pool_to_add_mod_list_r12_l pool_to_add_mod_list_r12;
        };

        // member variables
        bool                    disc_tx_pool_ded_r12_present = false;
        disc_tx_pool_ded_r12_s_ disc_tx_pool_ded_r12;
      };
      struct types_opts {
        enum options { sched_r12, ue_sel_r12, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      sched_r12_s_& sched_r12()
      {
        assert_choice_type("scheduled-r12", type_.to_string(), "setup");
        return c.get<sched_r12_s_>();
      }
      ue_sel_r12_s_& ue_sel_r12()
      {
        assert_choice_type("ue-Selected-r12", type_.to_string(), "setup");
        return c.get<ue_sel_r12_s_>();
      }
      const sched_r12_s_& sched_r12() const
      {
        assert_choice_type("scheduled-r12", type_.to_string(), "setup");
        return c.get<sched_r12_s_>();
      }
      const ue_sel_r12_s_& ue_sel_r12() const
      {
        assert_choice_type("ue-Selected-r12", type_.to_string(), "setup");
        return c.get<ue_sel_r12_s_>();
      }
      sched_r12_s_& set_sched_r12()
      {
        set(types::sched_r12);
        return c.get<sched_r12_s_>();
      }
      ue_sel_r12_s_& set_ue_sel_r12()
      {
        set(types::ue_sel_r12);
        return c.get<ue_sel_r12_s_>();
      }

    private:
      types                                                              type_;
      choice_buffer_t<MAX2(sizeof(sched_r12_s_), sizeof(ue_sel_r12_s_))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    disc_tx_res_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discTxResources-r12");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discTxResources-r12");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };
  struct disc_tf_idx_list_v1260_c_ {
    struct setup_s_ {
      // member variables
      sl_tf_idx_pair_list_r12b_l disc_tf_idx_list_r12b;
    };
    typedef setup_e types;

    // choice methods
    disc_tf_idx_list_v1260_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discTF-IndexList-v1260");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discTF-IndexList-v1260");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct disc_tx_res_ps_r13_c_ {
    struct setup_c_ {
      struct ue_sel_r13_s_ {
        // member variables
        sl_disc_tx_pool_ded_r13_s disc_tx_pool_ps_ded_r13;
      };
      struct types_opts {
        enum options { sched_r13, ue_sel_r13, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      setup_c_() = default;
      setup_c_(const setup_c_& other);
      setup_c_& operator=(const setup_c_& other);
      ~setup_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      sl_disc_tx_cfg_sched_r13_s& sched_r13()
      {
        assert_choice_type("scheduled-r13", type_.to_string(), "setup");
        return c.get<sl_disc_tx_cfg_sched_r13_s>();
      }
      ue_sel_r13_s_& ue_sel_r13()
      {
        assert_choice_type("ue-Selected-r13", type_.to_string(), "setup");
        return c.get<ue_sel_r13_s_>();
      }
      const sl_disc_tx_cfg_sched_r13_s& sched_r13() const
      {
        assert_choice_type("scheduled-r13", type_.to_string(), "setup");
        return c.get<sl_disc_tx_cfg_sched_r13_s>();
      }
      const ue_sel_r13_s_& ue_sel_r13() const
      {
        assert_choice_type("ue-Selected-r13", type_.to_string(), "setup");
        return c.get<ue_sel_r13_s_>();
      }
      sl_disc_tx_cfg_sched_r13_s& set_sched_r13()
      {
        set(types::sched_r13);
        return c.get<sl_disc_tx_cfg_sched_r13_s>();
      }
      ue_sel_r13_s_& set_ue_sel_r13()
      {
        set(types::ue_sel_r13);
        return c.get<ue_sel_r13_s_>();
      }

    private:
      types                                                                            type_;
      choice_buffer_t<MAX2(sizeof(sl_disc_tx_cfg_sched_r13_s), sizeof(ue_sel_r13_s_))> c;

      void destroy_();
    };
    typedef setup_e types;

    // choice methods
    disc_tx_res_ps_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_c_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discTxResourcesPS-r13");
      return c;
    }
    const setup_c_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discTxResourcesPS-r13");
      return c;
    }
    setup_c_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_c_ c;
  };
  struct disc_tx_inter_freq_info_r13_c_ {
    struct setup_s_ {
      // member variables
      bool                                      disc_tx_carrier_freq_r13_present             = false;
      bool                                      disc_tx_ref_carrier_ded_r13_present          = false;
      bool                                      disc_tx_info_inter_freq_list_add_r13_present = false;
      uint32_t                                  disc_tx_carrier_freq_r13                     = 0;
      sl_disc_tx_ref_carrier_ded_r13_c          disc_tx_ref_carrier_ded_r13;
      sl_disc_tx_info_inter_freq_list_add_r13_s disc_tx_info_inter_freq_list_add_r13;
    };
    typedef setup_e types;

    // choice methods
    disc_tx_inter_freq_info_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discTxInterFreqInfo-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discTxInterFreqInfo-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct disc_rx_gap_cfg_r13_c_ {
    typedef setup_e types;

    // choice methods
    disc_rx_gap_cfg_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_gap_cfg_r13_s& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discRxGapConfig-r13");
      return c;
    }
    const sl_gap_cfg_r13_s& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discRxGapConfig-r13");
      return c;
    }
    sl_gap_cfg_r13_s& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types            type_;
    sl_gap_cfg_r13_s c;
  };
  struct disc_tx_gap_cfg_r13_c_ {
    typedef setup_e types;

    // choice methods
    disc_tx_gap_cfg_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_gap_cfg_r13_s& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discTxGapConfig-r13");
      return c;
    }
    const sl_gap_cfg_r13_s& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discTxGapConfig-r13");
      return c;
    }
    sl_gap_cfg_r13_s& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types            type_;
    sl_gap_cfg_r13_s c;
  };
  struct disc_sys_info_to_report_cfg_r13_c_ {
    typedef setup_e types;

    // choice methods
    disc_sys_info_to_report_cfg_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_disc_sys_info_to_report_freq_list_r13_l& setup()
    {
      assert_choice_type("setup", type_.to_string(), "discSysInfoToReportConfig-r13");
      return c;
    }
    const sl_disc_sys_info_to_report_freq_list_r13_l& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "discSysInfoToReportConfig-r13");
      return c;
    }
    sl_disc_sys_info_to_report_freq_list_r13_l& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types                                      type_;
    sl_disc_sys_info_to_report_freq_list_r13_l c;
  };

  // member variables
  bool               ext                     = false;
  bool               disc_tx_res_r12_present = false;
  disc_tx_res_r12_c_ disc_tx_res_r12;
  // ...
  // group 0
  bool                                disc_tf_idx_list_v1260_present = false;
  copy_ptr<disc_tf_idx_list_v1260_c_> disc_tf_idx_list_v1260;
  // group 1
  bool                                         disc_tx_res_ps_r13_present              = false;
  bool                                         disc_tx_inter_freq_info_r13_present     = false;
  bool                                         gap_requests_allowed_ded_r13_present    = false;
  bool                                         disc_rx_gap_cfg_r13_present             = false;
  bool                                         disc_tx_gap_cfg_r13_present             = false;
  bool                                         disc_sys_info_to_report_cfg_r13_present = false;
  copy_ptr<disc_tx_res_ps_r13_c_>              disc_tx_res_ps_r13;
  copy_ptr<disc_tx_inter_freq_info_r13_c_>     disc_tx_inter_freq_info_r13;
  bool                                         gap_requests_allowed_ded_r13 = false;
  copy_ptr<disc_rx_gap_cfg_r13_c_>             disc_rx_gap_cfg_r13;
  copy_ptr<disc_tx_gap_cfg_r13_c_>             disc_tx_gap_cfg_r13;
  copy_ptr<disc_sys_info_to_report_cfg_r13_c_> disc_sys_info_to_report_cfg_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-SyncTxControl-r12 ::= SEQUENCE
struct sl_sync_tx_ctrl_r12_s {
  struct network_ctrl_sync_tx_r12_opts {
    enum options { on, off, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<network_ctrl_sync_tx_r12_opts> network_ctrl_sync_tx_r12_e_;

  // member variables
  bool                        network_ctrl_sync_tx_r12_present = false;
  network_ctrl_sync_tx_r12_e_ network_ctrl_sync_tx_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityEnquiry-v1530-IEs ::= SEQUENCE
struct ue_cap_enquiry_v1530_ies_s {
  // member variables
  bool request_stti_spt_cap_r15_present = false;
  bool eutra_nr_only_r15_present        = false;
  bool non_crit_ext_present             = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-ChannelList-r13 ::= SEQUENCE (SIZE (1..maxWLAN-Channels-r13)) OF INTEGER
typedef bounded_array<uint8_t, 16> wlan_ch_list_r13_l;

// WLAN-NameList-r15 ::= SEQUENCE (SIZE (1..maxWLAN-Name-r15)) OF OCTET STRING
typedef bounded_array<dyn_octstring, 4> wlan_name_list_r15_l;

// WhiteCellsToAddMod-r13 ::= SEQUENCE
struct white_cells_to_add_mod_r13_s {
  // member variables
  uint8_t     cell_idx_r13 = 1;
  pci_range_s pci_range_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AltTTT-CellsToAddModList-r12 ::= SEQUENCE (SIZE (1..maxCellMeas)) OF AltTTT-CellsToAddMod-r12
typedef dyn_array<alt_ttt_cells_to_add_mod_r12_s> alt_ttt_cells_to_add_mod_list_r12_l;

// BT-NameListConfig-r15 ::= CHOICE
struct bt_name_list_cfg_r15_c {
  typedef setup_e types;

  // choice methods
  bt_name_list_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  bt_name_list_r15_l& setup()
  {
    assert_choice_type("setup", type_.to_string(), "BT-NameListConfig-r15");
    return c;
  }
  const bt_name_list_r15_l& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "BT-NameListConfig-r15");
    return c;
  }
  bt_name_list_r15_l& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types              type_;
  bt_name_list_r15_l c;
};

// BandCombinationList-r14 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombination-r14
typedef dyn_array<band_combination_r14_l> band_combination_list_r14_l;

// BlackCellsToAddModList ::= SEQUENCE (SIZE (1..maxCellMeas)) OF BlackCellsToAddMod
typedef dyn_array<black_cells_to_add_mod_s> black_cells_to_add_mod_list_l;

// CDMA2000-Type ::= ENUMERATED
struct cdma2000_type_opts {
  enum options { type1_xrtt, type_hrpd, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<cdma2000_type_opts> cdma2000_type_e;

// CSG-AllowedReportingCells-r9 ::= SEQUENCE
struct csg_allowed_report_cells_r9_s {
  // member variables
  bool                         pci_range_utra_fdd_list_r9_present = false;
  pci_range_utra_fdd_list_r9_l pci_range_utra_fdd_list_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CandidateServingFreqListNR-r15 ::= SEQUENCE (SIZE (1..maxFreqIDC-r11)) OF INTEGER
typedef bounded_array<uint32_t, 32> candidate_serving_freq_list_nr_r15_l;

// CarrierFreqGERAN ::= SEQUENCE
struct carrier_freq_geran_s {
  // member variables
  uint16_t         arfcn = 0;
  band_ind_geran_e band_ind;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellIndexList ::= SEQUENCE (SIZE (1..maxCellMeas)) OF INTEGER
typedef bounded_array<uint8_t, 32> cell_idx_list_l;

// CellsToAddModList ::= SEQUENCE (SIZE (1..maxCellMeas)) OF CellsToAddMod
typedef dyn_array<cells_to_add_mod_s> cells_to_add_mod_list_l;

// CellsToAddModListCDMA2000 ::= SEQUENCE (SIZE (1..maxCellMeas)) OF CellsToAddModCDMA2000
typedef dyn_array<cells_to_add_mod_cdma2000_s> cells_to_add_mod_list_cdma2000_l;

// CellsToAddModListNR-r15 ::= SEQUENCE (SIZE (1..maxCellMeas)) OF CellsToAddModNR-r15
typedef dyn_array<cells_to_add_mod_nr_r15_s> cells_to_add_mod_list_nr_r15_l;

// CellsToAddModListUTRA-FDD ::= SEQUENCE (SIZE (1..maxCellMeas)) OF CellsToAddModUTRA-FDD
typedef dyn_array<cells_to_add_mod_utra_fdd_s> cells_to_add_mod_list_utra_fdd_l;

// CellsToAddModListUTRA-TDD ::= SEQUENCE (SIZE (1..maxCellMeas)) OF CellsToAddModUTRA-TDD
typedef dyn_array<cells_to_add_mod_utra_tdd_s> cells_to_add_mod_list_utra_tdd_l;

// MeasCycleSCell-r10 ::= ENUMERATED
struct meas_cycle_scell_r10_opts {
  enum options { sf160, sf256, sf320, sf512, sf640, sf1024, sf1280, spare1, nulltype } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<meas_cycle_scell_r10_opts> meas_cycle_scell_r10_e;

// MeasDS-Config-r12 ::= CHOICE
struct meas_ds_cfg_r12_c {
  struct setup_s_ {
    struct dmtc_period_offset_r12_c_ {
      struct types_opts {
        enum options { ms40_r12, ms80_r12, ms160_r12, /*...*/ nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<types_opts, true> types;

      // choice methods
      dmtc_period_offset_r12_c_() = default;
      dmtc_period_offset_r12_c_(const dmtc_period_offset_r12_c_& other);
      dmtc_period_offset_r12_c_& operator=(const dmtc_period_offset_r12_c_& other);
      ~dmtc_period_offset_r12_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint8_t& ms40_r12()
      {
        assert_choice_type("ms40-r12", type_.to_string(), "dmtc-PeriodOffset-r12");
        return c.get<uint8_t>();
      }
      uint8_t& ms80_r12()
      {
        assert_choice_type("ms80-r12", type_.to_string(), "dmtc-PeriodOffset-r12");
        return c.get<uint8_t>();
      }
      uint8_t& ms160_r12()
      {
        assert_choice_type("ms160-r12", type_.to_string(), "dmtc-PeriodOffset-r12");
        return c.get<uint8_t>();
      }
      const uint8_t& ms40_r12() const
      {
        assert_choice_type("ms40-r12", type_.to_string(), "dmtc-PeriodOffset-r12");
        return c.get<uint8_t>();
      }
      const uint8_t& ms80_r12() const
      {
        assert_choice_type("ms80-r12", type_.to_string(), "dmtc-PeriodOffset-r12");
        return c.get<uint8_t>();
      }
      const uint8_t& ms160_r12() const
      {
        assert_choice_type("ms160-r12", type_.to_string(), "dmtc-PeriodOffset-r12");
        return c.get<uint8_t>();
      }
      uint8_t& set_ms40_r12()
      {
        set(types::ms40_r12);
        return c.get<uint8_t>();
      }
      uint8_t& set_ms80_r12()
      {
        set(types::ms80_r12);
        return c.get<uint8_t>();
      }
      uint8_t& set_ms160_r12()
      {
        set(types::ms160_r12);
        return c.get<uint8_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };
    struct ds_occasion_dur_r12_c_ {
      struct types_opts {
        enum options { dur_fdd_r12, dur_tdd_r12, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      ds_occasion_dur_r12_c_() = default;
      ds_occasion_dur_r12_c_(const ds_occasion_dur_r12_c_& other);
      ds_occasion_dur_r12_c_& operator=(const ds_occasion_dur_r12_c_& other);
      ~ds_occasion_dur_r12_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint8_t& dur_fdd_r12()
      {
        assert_choice_type("durationFDD-r12", type_.to_string(), "ds-OccasionDuration-r12");
        return c.get<uint8_t>();
      }
      uint8_t& dur_tdd_r12()
      {
        assert_choice_type("durationTDD-r12", type_.to_string(), "ds-OccasionDuration-r12");
        return c.get<uint8_t>();
      }
      const uint8_t& dur_fdd_r12() const
      {
        assert_choice_type("durationFDD-r12", type_.to_string(), "ds-OccasionDuration-r12");
        return c.get<uint8_t>();
      }
      const uint8_t& dur_tdd_r12() const
      {
        assert_choice_type("durationTDD-r12", type_.to_string(), "ds-OccasionDuration-r12");
        return c.get<uint8_t>();
      }
      uint8_t& set_dur_fdd_r12()
      {
        set(types::dur_fdd_r12);
        return c.get<uint8_t>();
      }
      uint8_t& set_dur_tdd_r12()
      {
        set(types::dur_tdd_r12);
        return c.get<uint8_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };

    // member variables
    bool                              ext                                     = false;
    bool                              meas_csi_rs_to_rem_list_r12_present     = false;
    bool                              meas_csi_rs_to_add_mod_list_r12_present = false;
    dmtc_period_offset_r12_c_         dmtc_period_offset_r12;
    ds_occasion_dur_r12_c_            ds_occasion_dur_r12;
    meas_csi_rs_to_rem_list_r12_l     meas_csi_rs_to_rem_list_r12;
    meas_csi_rs_to_add_mod_list_r12_l meas_csi_rs_to_add_mod_list_r12;
    // ...
  };
  typedef setup_e types;

  // choice methods
  meas_ds_cfg_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "MeasDS-Config-r12");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "MeasDS-Config-r12");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// MeasGapConfig ::= CHOICE
struct meas_gap_cfg_c {
  struct setup_s_ {
    struct gap_offset_c_ {
      struct types_opts {
        enum options {
          gp0,
          gp1,
          // ...
          gp2_r14,
          gp3_r14,
          gp_ncsg0_r14,
          gp_ncsg1_r14,
          gp_ncsg2_r14,
          gp_ncsg3_r14,
          gp_non_uniform1_r14,
          gp_non_uniform2_r14,
          gp_non_uniform3_r14,
          gp_non_uniform4_r14,
          gp4_r15,
          gp5_r15,
          gp6_r15,
          gp7_r15,
          gp8_r15,
          gp9_r15,
          gp10_r15,
          gp11_r15,
          nulltype
        } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts, true, 18> types;

      // choice methods
      gap_offset_c_() = default;
      gap_offset_c_(const gap_offset_c_& other);
      gap_offset_c_& operator=(const gap_offset_c_& other);
      ~gap_offset_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint8_t& gp0()
      {
        assert_choice_type("gp0", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp1()
      {
        assert_choice_type("gp1", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp2_r14()
      {
        assert_choice_type("gp2-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp3_r14()
      {
        assert_choice_type("gp3-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp_ncsg0_r14()
      {
        assert_choice_type("gp-ncsg0-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp_ncsg1_r14()
      {
        assert_choice_type("gp-ncsg1-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp_ncsg2_r14()
      {
        assert_choice_type("gp-ncsg2-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp_ncsg3_r14()
      {
        assert_choice_type("gp-ncsg3-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint16_t& gp_non_uniform1_r14()
      {
        assert_choice_type("gp-nonUniform1-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      uint16_t& gp_non_uniform2_r14()
      {
        assert_choice_type("gp-nonUniform2-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      uint16_t& gp_non_uniform3_r14()
      {
        assert_choice_type("gp-nonUniform3-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      uint16_t& gp_non_uniform4_r14()
      {
        assert_choice_type("gp-nonUniform4-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      uint8_t& gp4_r15()
      {
        assert_choice_type("gp4-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp5_r15()
      {
        assert_choice_type("gp5-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp6_r15()
      {
        assert_choice_type("gp6-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp7_r15()
      {
        assert_choice_type("gp7-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp8_r15()
      {
        assert_choice_type("gp8-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp9_r15()
      {
        assert_choice_type("gp9-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp10_r15()
      {
        assert_choice_type("gp10-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& gp11_r15()
      {
        assert_choice_type("gp11-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp0() const
      {
        assert_choice_type("gp0", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp1() const
      {
        assert_choice_type("gp1", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp2_r14() const
      {
        assert_choice_type("gp2-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp3_r14() const
      {
        assert_choice_type("gp3-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp_ncsg0_r14() const
      {
        assert_choice_type("gp-ncsg0-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp_ncsg1_r14() const
      {
        assert_choice_type("gp-ncsg1-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp_ncsg2_r14() const
      {
        assert_choice_type("gp-ncsg2-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp_ncsg3_r14() const
      {
        assert_choice_type("gp-ncsg3-r14", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint16_t& gp_non_uniform1_r14() const
      {
        assert_choice_type("gp-nonUniform1-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& gp_non_uniform2_r14() const
      {
        assert_choice_type("gp-nonUniform2-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& gp_non_uniform3_r14() const
      {
        assert_choice_type("gp-nonUniform3-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      const uint16_t& gp_non_uniform4_r14() const
      {
        assert_choice_type("gp-nonUniform4-r14", type_.to_string(), "gapOffset");
        return c.get<uint16_t>();
      }
      const uint8_t& gp4_r15() const
      {
        assert_choice_type("gp4-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp5_r15() const
      {
        assert_choice_type("gp5-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp6_r15() const
      {
        assert_choice_type("gp6-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp7_r15() const
      {
        assert_choice_type("gp7-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp8_r15() const
      {
        assert_choice_type("gp8-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp9_r15() const
      {
        assert_choice_type("gp9-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp10_r15() const
      {
        assert_choice_type("gp10-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      const uint8_t& gp11_r15() const
      {
        assert_choice_type("gp11-r15", type_.to_string(), "gapOffset");
        return c.get<uint8_t>();
      }
      uint8_t& set_gp0()
      {
        set(types::gp0);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp1()
      {
        set(types::gp1);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp2_r14()
      {
        set(types::gp2_r14);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp3_r14()
      {
        set(types::gp3_r14);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp_ncsg0_r14()
      {
        set(types::gp_ncsg0_r14);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp_ncsg1_r14()
      {
        set(types::gp_ncsg1_r14);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp_ncsg2_r14()
      {
        set(types::gp_ncsg2_r14);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp_ncsg3_r14()
      {
        set(types::gp_ncsg3_r14);
        return c.get<uint8_t>();
      }
      uint16_t& set_gp_non_uniform1_r14()
      {
        set(types::gp_non_uniform1_r14);
        return c.get<uint16_t>();
      }
      uint16_t& set_gp_non_uniform2_r14()
      {
        set(types::gp_non_uniform2_r14);
        return c.get<uint16_t>();
      }
      uint16_t& set_gp_non_uniform3_r14()
      {
        set(types::gp_non_uniform3_r14);
        return c.get<uint16_t>();
      }
      uint16_t& set_gp_non_uniform4_r14()
      {
        set(types::gp_non_uniform4_r14);
        return c.get<uint16_t>();
      }
      uint8_t& set_gp4_r15()
      {
        set(types::gp4_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp5_r15()
      {
        set(types::gp5_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp6_r15()
      {
        set(types::gp6_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp7_r15()
      {
        set(types::gp7_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp8_r15()
      {
        set(types::gp8_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp9_r15()
      {
        set(types::gp9_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp10_r15()
      {
        set(types::gp10_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_gp11_r15()
      {
        set(types::gp11_r15);
        return c.get<uint8_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };

    // member variables
    gap_offset_c_ gap_offset;
  };
  typedef setup_e types;

  // choice methods
  meas_gap_cfg_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapConfig");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapConfig");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// MeasRSSI-ReportConfig-r13 ::= SEQUENCE
struct meas_rssi_report_cfg_r13_s {
  // member variables
  bool    ch_occupancy_thres_r13_present = false;
  uint8_t ch_occupancy_thres_r13         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasSensing-Config-r15 ::= SEQUENCE
struct meas_sensing_cfg_r15_s {
  struct sensing_periodicity_r15_opts {
    enum options { ms20, ms50, ms100, ms200, ms300, ms400, ms500, ms600, ms700, ms800, ms900, ms1000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<sensing_periodicity_r15_opts> sensing_periodicity_r15_e_;

  // member variables
  uint8_t                    sensing_subch_num_r15 = 1;
  sensing_periodicity_r15_e_ sensing_periodicity_r15;
  uint8_t                    sensing_resel_counter_r15 = 5;
  uint8_t                    sensing_prio_r15          = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasSubframePatternConfigNeigh-r10 ::= CHOICE
struct meas_sf_pattern_cfg_neigh_r10_c {
  struct setup_s_ {
    // member variables
    bool                    meas_sf_cell_list_r10_present = false;
    meas_sf_pattern_r10_c   meas_sf_pattern_neigh_r10;
    meas_sf_cell_list_r10_l meas_sf_cell_list_r10;
  };
  typedef setup_e types;

  // choice methods
  meas_sf_pattern_cfg_neigh_r10_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "MeasSubframePatternConfigNeigh-r10");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "MeasSubframePatternConfigNeigh-r10");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// MobilityControlInfo-v10l0 ::= SEQUENCE
struct mob_ctrl_info_v10l0_s {
  // member variables
  bool     add_spec_emission_v10l0_present = false;
  uint16_t add_spec_emission_v10l0         = 33;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhysCellIdGERAN ::= SEQUENCE
struct pci_geran_s {
  // member variables
  fixed_bitstring<3> network_colour_code;
  fixed_bitstring<3> base_station_colour_code;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigRS-NR-r15 ::= SEQUENCE
struct quant_cfg_rs_nr_r15_s {
  // member variables
  bool        filt_coeff_rsrp_r15_present = false;
  bool        filt_coeff_rsrq_r15_present = false;
  bool        filt_coef_sinr_r13_present  = false;
  filt_coef_e filt_coeff_rsrp_r15;
  filt_coef_e filt_coeff_rsrq_r15;
  filt_coef_e filt_coef_sinr_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RMTC-Config-r13 ::= CHOICE
struct rmtc_cfg_r13_c {
  struct setup_s_ {
    struct rmtc_period_r13_opts {
      enum options { ms40, ms80, ms160, ms320, ms640, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<rmtc_period_r13_opts> rmtc_period_r13_e_;
    struct meas_dur_r13_opts {
      enum options { sym1, sym14, sym28, sym42, sym70, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<meas_dur_r13_opts> meas_dur_r13_e_;

    // member variables
    bool               ext                        = false;
    bool               rmtc_sf_offset_r13_present = false;
    rmtc_period_r13_e_ rmtc_period_r13;
    uint16_t           rmtc_sf_offset_r13 = 0;
    meas_dur_r13_e_    meas_dur_r13;
    // ...
  };
  typedef setup_e types;

  // choice methods
  rmtc_cfg_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RMTC-Config-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RMTC-Config-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// RRCConnectionReconfiguration-v1250-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1250_ies_s {
  struct wlan_offload_info_r12_c_ {
    struct setup_s_ {
      struct t350_r12_opts {
        enum options { min5, min10, min20, min30, min60, min120, min180, spare1, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<t350_r12_opts> t350_r12_e_;

      // member variables
      bool                   t350_r12_present = false;
      wlan_offload_cfg_r12_s wlan_offload_cfg_ded_r12;
      t350_r12_e_            t350_r12;
    };
    typedef setup_e types;

    // choice methods
    wlan_offload_info_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "wlan-OffloadInfo-r12");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "wlan-OffloadInfo-r12");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                       wlan_offload_info_r12_present = false;
  bool                       scg_cfg_r12_present           = false;
  bool                       sl_sync_tx_ctrl_r12_present   = false;
  bool                       sl_disc_cfg_r12_present       = false;
  bool                       sl_comm_cfg_r12_present       = false;
  bool                       non_crit_ext_present          = false;
  wlan_offload_info_r12_c_   wlan_offload_info_r12;
  scg_cfg_r12_c              scg_cfg_r12;
  sl_sync_tx_ctrl_r12_s      sl_sync_tx_ctrl_r12;
  sl_disc_cfg_r12_s          sl_disc_cfg_r12;
  sl_comm_cfg_r12_s          sl_comm_cfg_r12;
  rrc_conn_recfg_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v12f0-IEs ::= SEQUENCE
struct rrc_conn_recfg_v12f0_ies_s {
  // member variables
  bool                       scg_cfg_v12f0_present     = false;
  bool                       late_non_crit_ext_present = false;
  bool                       non_crit_ext_present      = false;
  scg_cfg_v12f0_c            scg_cfg_v12f0;
  dyn_octstring              late_non_crit_ext;
  rrc_conn_recfg_v1370_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease-v1530-IEs ::= SEQUENCE
struct rrc_conn_release_v1530_ies_s {
  struct cn_type_r15_opts {
    enum options { epc, fivegc, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<cn_type_r15_opts> cn_type_r15_e_;

  // member variables
  bool                    drb_continue_rohc_r15_present       = false;
  bool                    next_hop_chaining_count_r15_present = false;
  bool                    meas_idle_cfg_r15_present           = false;
  bool                    rrc_inactive_cfg_r15_present        = false;
  bool                    cn_type_r15_present                 = false;
  bool                    non_crit_ext_present                = false;
  uint8_t                 next_hop_chaining_count_r15         = 0;
  meas_idle_cfg_ded_r15_s meas_idle_cfg_r15;
  rrc_inactive_cfg_r15_s  rrc_inactive_cfg_r15;
  cn_type_r15_e_          cn_type_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RS-ConfigSSB-NR-r15 ::= SEQUENCE
struct rs_cfg_ssb_nr_r15_s {
  struct subcarrier_spacing_ssb_r15_opts {
    enum options { k_hz15, k_hz30, k_hz120, k_hz240, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<subcarrier_spacing_ssb_r15_opts> subcarrier_spacing_ssb_r15_e_;

  // member variables
  bool                          ext = false;
  mtc_ssb_nr_r15_s              meas_timing_cfg_r15;
  subcarrier_spacing_ssb_r15_e_ subcarrier_spacing_ssb_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RSRQ-RangeConfig-r12 ::= CHOICE
struct rsrq_range_cfg_r12_c {
  typedef setup_e types;

  // choice methods
  rsrq_range_cfg_r12_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  int8_t& setup()
  {
    assert_choice_type("setup", type_.to_string(), "RSRQ-RangeConfig-r12");
    return c;
  }
  const int8_t& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "RSRQ-RangeConfig-r12");
    return c;
  }
  int8_t& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types  type_;
  int8_t c;
};

// ReportInterval ::= ENUMERATED
struct report_interv_opts {
  enum options {
    ms120,
    ms240,
    ms480,
    ms640,
    ms1024,
    ms2048,
    ms5120,
    ms10240,
    min1,
    min6,
    min12,
    min30,
    min60,
    spare3,
    spare2,
    spare1,
    nulltype
  } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<report_interv_opts> report_interv_e;

// ReportQuantityNR-r15 ::= SEQUENCE
struct report_quant_nr_r15_s {
  // member variables
  bool ss_rsrp = false;
  bool ss_rsrq = false;
  bool ss_sinr = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReportQuantityWLAN-r13 ::= SEQUENCE
struct report_quant_wlan_r13_s {
  // member variables
  bool ext                                                   = false;
  bool band_request_wlan_r13_present                         = false;
  bool carrier_info_request_wlan_r13_present                 = false;
  bool available_admission_capacity_request_wlan_r13_present = false;
  bool backhaul_dl_bw_request_wlan_r13_present               = false;
  bool backhaul_ul_bw_request_wlan_r13_present               = false;
  bool ch_utilization_request_wlan_r13_present               = false;
  bool station_count_request_wlan_r13_present                = false;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInfoListGERAN ::= SEQUENCE (SIZE (1..maxGERAN-SI)) OF OCTET STRING
typedef bounded_array<dyn_octstring, 10> sys_info_list_geran_l;

// TargetMBSFN-Area-r12 ::= SEQUENCE
struct target_mbsfn_area_r12_s {
  // member variables
  bool     ext                       = false;
  bool     mbsfn_area_id_r12_present = false;
  uint8_t  mbsfn_area_id_r12         = 0;
  uint32_t carrier_freq_r12          = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ThresholdEUTRA ::= CHOICE
struct thres_eutra_c {
  struct types_opts {
    enum options { thres_rsrp, thres_rsrq, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  thres_eutra_c() = default;
  thres_eutra_c(const thres_eutra_c& other);
  thres_eutra_c& operator=(const thres_eutra_c& other);
  ~thres_eutra_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& thres_rsrp()
  {
    assert_choice_type("threshold-RSRP", type_.to_string(), "ThresholdEUTRA");
    return c.get<uint8_t>();
  }
  uint8_t& thres_rsrq()
  {
    assert_choice_type("threshold-RSRQ", type_.to_string(), "ThresholdEUTRA");
    return c.get<uint8_t>();
  }
  const uint8_t& thres_rsrp() const
  {
    assert_choice_type("threshold-RSRP", type_.to_string(), "ThresholdEUTRA");
    return c.get<uint8_t>();
  }
  const uint8_t& thres_rsrq() const
  {
    assert_choice_type("threshold-RSRQ", type_.to_string(), "ThresholdEUTRA");
    return c.get<uint8_t>();
  }
  uint8_t& set_thres_rsrp()
  {
    set(types::thres_rsrp);
    return c.get<uint8_t>();
  }
  uint8_t& set_thres_rsrq()
  {
    set(types::thres_rsrq);
    return c.get<uint8_t>();
  }

private:
  types              type_;
  choice_buffer_t<8> c;

  void destroy_();
};

// ThresholdNR-r15 ::= CHOICE
struct thres_nr_r15_c {
  struct types_opts {
    enum options { nr_rsrp_r15, nr_rsrq_r15, nr_sinr_r15, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  thres_nr_r15_c() = default;
  thres_nr_r15_c(const thres_nr_r15_c& other);
  thres_nr_r15_c& operator=(const thres_nr_r15_c& other);
  ~thres_nr_r15_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& nr_rsrp_r15()
  {
    assert_choice_type("nr-RSRP-r15", type_.to_string(), "ThresholdNR-r15");
    return c.get<uint8_t>();
  }
  uint8_t& nr_rsrq_r15()
  {
    assert_choice_type("nr-RSRQ-r15", type_.to_string(), "ThresholdNR-r15");
    return c.get<uint8_t>();
  }
  uint8_t& nr_sinr_r15()
  {
    assert_choice_type("nr-SINR-r15", type_.to_string(), "ThresholdNR-r15");
    return c.get<uint8_t>();
  }
  const uint8_t& nr_rsrp_r15() const
  {
    assert_choice_type("nr-RSRP-r15", type_.to_string(), "ThresholdNR-r15");
    return c.get<uint8_t>();
  }
  const uint8_t& nr_rsrq_r15() const
  {
    assert_choice_type("nr-RSRQ-r15", type_.to_string(), "ThresholdNR-r15");
    return c.get<uint8_t>();
  }
  const uint8_t& nr_sinr_r15() const
  {
    assert_choice_type("nr-SINR-r15", type_.to_string(), "ThresholdNR-r15");
    return c.get<uint8_t>();
  }
  uint8_t& set_nr_rsrp_r15()
  {
    set(types::nr_rsrp_r15);
    return c.get<uint8_t>();
  }
  uint8_t& set_nr_rsrq_r15()
  {
    set(types::nr_rsrq_r15);
    return c.get<uint8_t>();
  }
  uint8_t& set_nr_sinr_r15()
  {
    set(types::nr_sinr_r15);
    return c.get<uint8_t>();
  }

private:
  types              type_;
  choice_buffer_t<8> c;

  void destroy_();
};

// ThresholdUTRA ::= CHOICE
struct thres_utra_c {
  struct types_opts {
    enum options { utra_rscp, utra_ec_n0, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  thres_utra_c() = default;
  thres_utra_c(const thres_utra_c& other);
  thres_utra_c& operator=(const thres_utra_c& other);
  ~thres_utra_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  int8_t& utra_rscp()
  {
    assert_choice_type("utra-RSCP", type_.to_string(), "ThresholdUTRA");
    return c.get<int8_t>();
  }
  uint8_t& utra_ec_n0()
  {
    assert_choice_type("utra-EcN0", type_.to_string(), "ThresholdUTRA");
    return c.get<uint8_t>();
  }
  const int8_t& utra_rscp() const
  {
    assert_choice_type("utra-RSCP", type_.to_string(), "ThresholdUTRA");
    return c.get<int8_t>();
  }
  const uint8_t& utra_ec_n0() const
  {
    assert_choice_type("utra-EcN0", type_.to_string(), "ThresholdUTRA");
    return c.get<uint8_t>();
  }
  int8_t& set_utra_rscp()
  {
    set(types::utra_rscp);
    return c.get<int8_t>();
  }
  uint8_t& set_utra_ec_n0()
  {
    set(types::utra_ec_n0);
    return c.get<uint8_t>();
  }

private:
  types              type_;
  choice_buffer_t<8> c;

  void destroy_();
};

// TimeToTrigger ::= ENUMERATED
struct time_to_trigger_opts {
  enum options {
    ms0,
    ms40,
    ms64,
    ms80,
    ms100,
    ms128,
    ms160,
    ms256,
    ms320,
    ms480,
    ms512,
    ms640,
    ms1024,
    ms1280,
    ms2560,
    ms5120,
    nulltype
  } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<time_to_trigger_opts> time_to_trigger_e;

// Tx-ResourcePoolMeasList-r14 ::= SEQUENCE (SIZE (1..maxSL-PoolToMeasure-r14)) OF INTEGER
typedef dyn_array<uint8_t> tx_res_pool_meas_list_r14_l;

// UECapabilityEnquiry-v1510-IEs ::= SEQUENCE
struct ue_cap_enquiry_v1510_ies_s {
  // member variables
  bool                       requested_freq_bands_nr_mrdc_r15_present = false;
  bool                       non_crit_ext_present                     = false;
  dyn_octstring              requested_freq_bands_nr_mrdc_r15;
  ue_cap_enquiry_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationRequest-v1530-IEs ::= SEQUENCE
struct ue_info_request_v1530_ies_s {
  // member variables
  bool                              idle_mode_meas_req_r15_present   = false;
  bool                              flight_path_info_req_r15_present = false;
  bool                              non_crit_ext_present             = false;
  flight_path_info_report_cfg_r15_s flight_path_info_req_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-DelayConfig-r13 ::= CHOICE
struct ul_delay_cfg_r13_c {
  struct setup_s_ {
    struct delay_thres_r13_opts {
      enum options {
        ms30,
        ms40,
        ms50,
        ms60,
        ms70,
        ms80,
        ms90,
        ms100,
        ms150,
        ms300,
        ms500,
        ms750,
        spare4,
        spare3,
        spare2,
        spare1,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<delay_thres_r13_opts> delay_thres_r13_e_;

    // member variables
    delay_thres_r13_e_ delay_thres_r13;
  };
  typedef setup_e types;

  // choice methods
  ul_delay_cfg_r13_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "UL-DelayConfig-r13");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "UL-DelayConfig-r13");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// WLAN-BandIndicator-r13 ::= ENUMERATED
struct wlan_band_ind_r13_opts {
  enum options { band2dot4, band5, band60_v1430, spare5, spare4, spare3, spare2, spare1, /*...*/ nulltype } value;
  typedef float number_type;

  std::string to_string() const;
  float       to_number() const;
  std::string to_number_string() const;
};
typedef enumerated<wlan_band_ind_r13_opts, true> wlan_band_ind_r13_e;

// WLAN-CarrierInfo-r13 ::= SEQUENCE
struct wlan_carrier_info_r13_s {
  struct country_code_r13_opts {
    enum options { united_states, europe, japan, global, /*...*/ nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<country_code_r13_opts, true> country_code_r13_e_;

  // member variables
  bool                ext                         = false;
  bool                operating_class_r13_present = false;
  bool                country_code_r13_present    = false;
  bool                ch_nums_r13_present         = false;
  uint8_t             operating_class_r13         = 0;
  country_code_r13_e_ country_code_r13;
  wlan_ch_list_r13_l  ch_nums_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-NameListConfig-r15 ::= CHOICE
struct wlan_name_list_cfg_r15_c {
  typedef setup_e types;

  // choice methods
  wlan_name_list_cfg_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  wlan_name_list_r15_l& setup()
  {
    assert_choice_type("setup", type_.to_string(), "WLAN-NameListConfig-r15");
    return c;
  }
  const wlan_name_list_r15_l& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "WLAN-NameListConfig-r15");
    return c;
  }
  wlan_name_list_r15_l& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types                type_;
  wlan_name_list_r15_l c;
};

// WhiteCellsToAddModList-r13 ::= SEQUENCE (SIZE (1..maxCellMeas)) OF WhiteCellsToAddMod-r13
typedef dyn_array<white_cells_to_add_mod_r13_s> white_cells_to_add_mod_list_r13_l;

// CellInfoGERAN-r9 ::= SEQUENCE
struct cell_info_geran_r9_s {
  // member variables
  pci_geran_s           pci_r9;
  carrier_freq_geran_s  carrier_freq_r9;
  sys_info_list_geran_l sys_info_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellInfoUTRA-FDD-r9 ::= SEQUENCE
struct cell_info_utra_fdd_r9_s {
  // member variables
  uint16_t      pci_r9 = 0;
  dyn_octstring utra_bcch_container_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellInfoUTRA-TDD-r10 ::= SEQUENCE
struct cell_info_utra_tdd_r10_s {
  // member variables
  uint8_t       pci_r10          = 0;
  uint16_t      carrier_freq_r10 = 0;
  dyn_octstring utra_bcch_container_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellInfoUTRA-TDD-r9 ::= SEQUENCE
struct cell_info_utra_tdd_r9_s {
  // member variables
  uint8_t       pci_r9 = 0;
  dyn_octstring utra_bcch_container_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-CountMSB-Info ::= SEQUENCE
struct drb_count_msb_info_s {
  // member variables
  uint8_t  drb_id       = 1;
  uint32_t count_msb_ul = 0;
  uint32_t count_msb_dl = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IDC-Config-r11 ::= SEQUENCE
struct idc_cfg_r11_s {
  struct autonomous_denial_params_r11_s_ {
    struct autonomous_denial_sfs_r11_opts {
      enum options { n2, n5, n10, n15, n20, n30, spare2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<autonomous_denial_sfs_r11_opts> autonomous_denial_sfs_r11_e_;
    struct autonomous_denial_validity_r11_opts {
      enum options { sf200, sf500, sf1000, sf2000, spare4, spare3, spare2, spare1, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<autonomous_denial_validity_r11_opts> autonomous_denial_validity_r11_e_;

    // member variables
    autonomous_denial_sfs_r11_e_      autonomous_denial_sfs_r11;
    autonomous_denial_validity_r11_e_ autonomous_denial_validity_r11;
  };
  struct idc_ind_mrdc_r15_c_ {
    typedef setup_e types;

    // choice methods
    idc_ind_mrdc_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    candidate_serving_freq_list_nr_r15_l& setup()
    {
      assert_choice_type("setup", type_.to_string(), "idc-Indication-MRDC-r15");
      return c;
    }
    const candidate_serving_freq_list_nr_r15_l& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "idc-Indication-MRDC-r15");
      return c;
    }
    candidate_serving_freq_list_nr_r15_l& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types                                type_;
    candidate_serving_freq_list_nr_r15_l c;
  };

  // member variables
  bool                            ext                                  = false;
  bool                            idc_ind_r11_present                  = false;
  bool                            autonomous_denial_params_r11_present = false;
  autonomous_denial_params_r11_s_ autonomous_denial_params_r11;
  // ...
  // group 0
  bool idc_ind_ul_ca_r11_present = false;
  // group 1
  bool idc_hardware_sharing_ind_r13_present = false;
  // group 2
  bool                          idc_ind_mrdc_r15_present = false;
  copy_ptr<idc_ind_mrdc_r15_c_> idc_ind_mrdc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoggedMeasurementConfiguration-v1530-IEs ::= SEQUENCE
struct logged_meas_cfg_v1530_ies_s {
  // member variables
  bool                 bt_name_list_r15_present   = false;
  bool                 wlan_name_list_r15_present = false;
  bool                 non_crit_ext_present       = false;
  bt_name_list_r15_l   bt_name_list_r15;
  wlan_name_list_r15_l wlan_name_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasGapConfigPerCC-r14 ::= SEQUENCE
struct meas_gap_cfg_per_cc_r14_s {
  // member variables
  uint8_t        serv_cell_id_r14 = 0;
  meas_gap_cfg_c meas_gap_cfg_cc_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectCDMA2000 ::= SEQUENCE
struct meas_obj_cdma2000_s {
  // member variables
  bool                             ext                                  = false;
  bool                             search_win_size_present              = false;
  bool                             offset_freq_present                  = false;
  bool                             cells_to_rem_list_present            = false;
  bool                             cells_to_add_mod_list_present        = false;
  bool                             cell_for_which_to_report_cgi_present = false;
  cdma2000_type_e                  cdma2000_type;
  carrier_freq_cdma2000_s          carrier_freq;
  uint8_t                          search_win_size = 0;
  int8_t                           offset_freq     = -15;
  cell_idx_list_l                  cells_to_rem_list;
  cells_to_add_mod_list_cdma2000_l cells_to_add_mod_list;
  uint16_t                         cell_for_which_to_report_cgi = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectEUTRA ::= SEQUENCE
struct meas_obj_eutra_s {
  struct t312_r12_c_ {
    struct setup_opts {
      enum options { ms0, ms50, ms100, ms200, ms300, ms400, ms500, ms1000, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<setup_opts> setup_e_;
    typedef setup_e                types;

    // choice methods
    t312_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_e_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "t312-r12");
      return c;
    }
    const setup_e_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "t312-r12");
      return c;
    }
    setup_e_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_e_ c;
  };

  // member variables
  bool                          ext                                  = false;
  bool                          offset_freq_present                  = false;
  bool                          cells_to_rem_list_present            = false;
  bool                          cells_to_add_mod_list_present        = false;
  bool                          black_cells_to_rem_list_present      = false;
  bool                          black_cells_to_add_mod_list_present  = false;
  bool                          cell_for_which_to_report_cgi_present = false;
  uint16_t                      carrier_freq                         = 0;
  allowed_meas_bw_e             allowed_meas_bw;
  bool                          presence_ant_port1 = false;
  fixed_bitstring<2>            neigh_cell_cfg;
  q_offset_range_e              offset_freq;
  cell_idx_list_l               cells_to_rem_list;
  cells_to_add_mod_list_l       cells_to_add_mod_list;
  cell_idx_list_l               black_cells_to_rem_list;
  black_cells_to_add_mod_list_l black_cells_to_add_mod_list;
  uint16_t                      cell_for_which_to_report_cgi = 0;
  // ...
  // group 0
  bool                                      meas_cycle_scell_r10_present          = false;
  bool                                      meas_sf_pattern_cfg_neigh_r10_present = false;
  meas_cycle_scell_r10_e                    meas_cycle_scell_r10;
  copy_ptr<meas_sf_pattern_cfg_neigh_r10_c> meas_sf_pattern_cfg_neigh_r10;
  // group 1
  bool wideband_rsrq_meas_r11_present = false;
  bool wideband_rsrq_meas_r11         = false;
  // group 2
  bool                                          alt_ttt_cells_to_rem_list_r12_present     = false;
  bool                                          alt_ttt_cells_to_add_mod_list_r12_present = false;
  bool                                          t312_r12_present                          = false;
  bool                                          reduced_meas_performance_r12_present      = false;
  bool                                          meas_ds_cfg_r12_present                   = false;
  copy_ptr<cell_idx_list_l>                     alt_ttt_cells_to_rem_list_r12;
  copy_ptr<alt_ttt_cells_to_add_mod_list_r12_l> alt_ttt_cells_to_add_mod_list_r12;
  copy_ptr<t312_r12_c_>                         t312_r12;
  bool                                          reduced_meas_performance_r12 = false;
  copy_ptr<meas_ds_cfg_r12_c>                   meas_ds_cfg_r12;
  // group 3
  bool                                        white_cells_to_rem_list_r13_present     = false;
  bool                                        white_cells_to_add_mod_list_r13_present = false;
  bool                                        rmtc_cfg_r13_present                    = false;
  bool                                        carrier_freq_r13_present                = false;
  copy_ptr<cell_idx_list_l>                   white_cells_to_rem_list_r13;
  copy_ptr<white_cells_to_add_mod_list_r13_l> white_cells_to_add_mod_list_r13;
  copy_ptr<rmtc_cfg_r13_c>                    rmtc_cfg_r13;
  uint32_t                                    carrier_freq_r13 = 65536;
  // group 4
  bool                                  tx_res_pool_to_rem_list_r14_present = false;
  bool                                  tx_res_pool_to_add_list_r14_present = false;
  bool                                  fembms_mixed_carrier_r14_present    = false;
  copy_ptr<tx_res_pool_meas_list_r14_l> tx_res_pool_to_rem_list_r14;
  copy_ptr<tx_res_pool_meas_list_r14_l> tx_res_pool_to_add_list_r14;
  bool                                  fembms_mixed_carrier_r14 = false;
  // group 5
  bool                             meas_sensing_cfg_r15_present = false;
  copy_ptr<meas_sensing_cfg_r15_s> meas_sensing_cfg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectEUTRA-v9e0 ::= SEQUENCE
struct meas_obj_eutra_v9e0_s {
  // member variables
  uint32_t carrier_freq_v9e0 = 65536;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectGERAN ::= SEQUENCE
struct meas_obj_geran_s {
  // member variables
  bool                  ext                                  = false;
  bool                  offset_freq_present                  = false;
  bool                  ncc_permitted_present                = false;
  bool                  cell_for_which_to_report_cgi_present = false;
  carrier_freqs_geran_s carrier_freqs;
  int8_t                offset_freq = -15;
  fixed_bitstring<8>    ncc_permitted;
  pci_geran_s           cell_for_which_to_report_cgi;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectNR-r15 ::= SEQUENCE
struct meas_obj_nr_r15_s {
  typedef bounded_array<uint16_t, 3> cells_for_which_to_report_sftd_r15_l_;
  struct band_nr_r15_c_ {
    typedef setup_e types;

    // choice methods
    band_nr_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t& setup()
    {
      assert_choice_type("setup", type_.to_string(), "bandNR-r15");
      return c;
    }
    const uint16_t& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "bandNR-r15");
      return c;
    }
    uint16_t& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    uint16_t c;
  };

  // member variables
  bool                                  ext                                        = false;
  bool                                  thresh_rs_idx_r15_present                  = false;
  bool                                  max_rs_idx_cell_qual_r15_present           = false;
  bool                                  offset_freq_r15_present                    = false;
  bool                                  black_cells_to_rem_list_r15_present        = false;
  bool                                  black_cells_to_add_mod_list_r15_present    = false;
  bool                                  cells_for_which_to_report_sftd_r15_present = false;
  uint32_t                              carrier_freq_r15                           = 0;
  rs_cfg_ssb_nr_r15_s                   rs_cfg_ssb_r15;
  thres_list_nr_r15_s                   thresh_rs_idx_r15;
  uint8_t                               max_rs_idx_cell_qual_r15 = 1;
  int8_t                                offset_freq_r15          = -15;
  cell_idx_list_l                       black_cells_to_rem_list_r15;
  cells_to_add_mod_list_nr_r15_l        black_cells_to_add_mod_list_r15;
  uint8_t                               quant_cfg_set_r15 = 1;
  cells_for_which_to_report_sftd_r15_l_ cells_for_which_to_report_sftd_r15;
  // ...
  // group 0
  bool                         cell_for_which_to_report_cgi_r15_present = false;
  bool                         derive_ssb_idx_from_cell_r15_present     = false;
  bool                         ss_rssi_meas_r15_present                 = false;
  bool                         band_nr_r15_present                      = false;
  uint16_t                     cell_for_which_to_report_cgi_r15         = 0;
  bool                         derive_ssb_idx_from_cell_r15             = false;
  copy_ptr<ss_rssi_meas_r15_s> ss_rssi_meas_r15;
  copy_ptr<band_nr_r15_c_>     band_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectUTRA ::= SEQUENCE
struct meas_obj_utra_s {
  struct cells_to_add_mod_list_c_ {
    struct types_opts {
      enum options { cells_to_add_mod_list_utra_fdd, cells_to_add_mod_list_utra_tdd, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    cells_to_add_mod_list_c_() = default;
    cells_to_add_mod_list_c_(const cells_to_add_mod_list_c_& other);
    cells_to_add_mod_list_c_& operator=(const cells_to_add_mod_list_c_& other);
    ~cells_to_add_mod_list_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_to_add_mod_list_utra_fdd_l& cells_to_add_mod_list_utra_fdd()
    {
      assert_choice_type("cellsToAddModListUTRA-FDD", type_.to_string(), "cellsToAddModList");
      return c.get<cells_to_add_mod_list_utra_fdd_l>();
    }
    cells_to_add_mod_list_utra_tdd_l& cells_to_add_mod_list_utra_tdd()
    {
      assert_choice_type("cellsToAddModListUTRA-TDD", type_.to_string(), "cellsToAddModList");
      return c.get<cells_to_add_mod_list_utra_tdd_l>();
    }
    const cells_to_add_mod_list_utra_fdd_l& cells_to_add_mod_list_utra_fdd() const
    {
      assert_choice_type("cellsToAddModListUTRA-FDD", type_.to_string(), "cellsToAddModList");
      return c.get<cells_to_add_mod_list_utra_fdd_l>();
    }
    const cells_to_add_mod_list_utra_tdd_l& cells_to_add_mod_list_utra_tdd() const
    {
      assert_choice_type("cellsToAddModListUTRA-TDD", type_.to_string(), "cellsToAddModList");
      return c.get<cells_to_add_mod_list_utra_tdd_l>();
    }
    cells_to_add_mod_list_utra_fdd_l& set_cells_to_add_mod_list_utra_fdd()
    {
      set(types::cells_to_add_mod_list_utra_fdd);
      return c.get<cells_to_add_mod_list_utra_fdd_l>();
    }
    cells_to_add_mod_list_utra_tdd_l& set_cells_to_add_mod_list_utra_tdd()
    {
      set(types::cells_to_add_mod_list_utra_tdd);
      return c.get<cells_to_add_mod_list_utra_tdd_l>();
    }

  private:
    types                                                                                                     type_;
    choice_buffer_t<MAX2(sizeof(cells_to_add_mod_list_utra_fdd_l), sizeof(cells_to_add_mod_list_utra_tdd_l))> c;

    void destroy_();
  };
  struct cell_for_which_to_report_cgi_c_ {
    struct types_opts {
      enum options { utra_fdd, utra_tdd, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    cell_for_which_to_report_cgi_c_() = default;
    cell_for_which_to_report_cgi_c_(const cell_for_which_to_report_cgi_c_& other);
    cell_for_which_to_report_cgi_c_& operator=(const cell_for_which_to_report_cgi_c_& other);
    ~cell_for_which_to_report_cgi_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t& utra_fdd()
    {
      assert_choice_type("utra-FDD", type_.to_string(), "cellForWhichToReportCGI");
      return c.get<uint16_t>();
    }
    uint8_t& utra_tdd()
    {
      assert_choice_type("utra-TDD", type_.to_string(), "cellForWhichToReportCGI");
      return c.get<uint8_t>();
    }
    const uint16_t& utra_fdd() const
    {
      assert_choice_type("utra-FDD", type_.to_string(), "cellForWhichToReportCGI");
      return c.get<uint16_t>();
    }
    const uint8_t& utra_tdd() const
    {
      assert_choice_type("utra-TDD", type_.to_string(), "cellForWhichToReportCGI");
      return c.get<uint8_t>();
    }
    uint16_t& set_utra_fdd()
    {
      set(types::utra_fdd);
      return c.get<uint16_t>();
    }
    uint8_t& set_utra_tdd()
    {
      set(types::utra_tdd);
      return c.get<uint8_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool                            ext                                  = false;
  bool                            offset_freq_present                  = false;
  bool                            cells_to_rem_list_present            = false;
  bool                            cells_to_add_mod_list_present        = false;
  bool                            cell_for_which_to_report_cgi_present = false;
  uint16_t                        carrier_freq                         = 0;
  int8_t                          offset_freq                          = -15;
  cell_idx_list_l                 cells_to_rem_list;
  cells_to_add_mod_list_c_        cells_to_add_mod_list;
  cell_for_which_to_report_cgi_c_ cell_for_which_to_report_cgi;
  // ...
  // group 0
  bool                                    csg_allowed_report_cells_v930_present = false;
  copy_ptr<csg_allowed_report_cells_r9_s> csg_allowed_report_cells_v930;
  // group 1
  bool reduced_meas_performance_r12_present = false;
  bool reduced_meas_performance_r12         = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectWLAN-r13 ::= SEQUENCE
struct meas_obj_wlan_r13_s {
  struct carrier_freq_r13_c_ {
    typedef bounded_array<wlan_band_ind_r13_e, 8> band_ind_list_wlan_r13_l_;
    typedef dyn_array<wlan_carrier_info_r13_s>    carrier_info_list_wlan_r13_l_;
    struct types_opts {
      enum options { band_ind_list_wlan_r13, carrier_info_list_wlan_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    carrier_freq_r13_c_() = default;
    carrier_freq_r13_c_(const carrier_freq_r13_c_& other);
    carrier_freq_r13_c_& operator=(const carrier_freq_r13_c_& other);
    ~carrier_freq_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    band_ind_list_wlan_r13_l_& band_ind_list_wlan_r13()
    {
      assert_choice_type("bandIndicatorListWLAN-r13", type_.to_string(), "carrierFreq-r13");
      return c.get<band_ind_list_wlan_r13_l_>();
    }
    carrier_info_list_wlan_r13_l_& carrier_info_list_wlan_r13()
    {
      assert_choice_type("carrierInfoListWLAN-r13", type_.to_string(), "carrierFreq-r13");
      return c.get<carrier_info_list_wlan_r13_l_>();
    }
    const band_ind_list_wlan_r13_l_& band_ind_list_wlan_r13() const
    {
      assert_choice_type("bandIndicatorListWLAN-r13", type_.to_string(), "carrierFreq-r13");
      return c.get<band_ind_list_wlan_r13_l_>();
    }
    const carrier_info_list_wlan_r13_l_& carrier_info_list_wlan_r13() const
    {
      assert_choice_type("carrierInfoListWLAN-r13", type_.to_string(), "carrierFreq-r13");
      return c.get<carrier_info_list_wlan_r13_l_>();
    }
    band_ind_list_wlan_r13_l_& set_band_ind_list_wlan_r13()
    {
      set(types::band_ind_list_wlan_r13);
      return c.get<band_ind_list_wlan_r13_l_>();
    }
    carrier_info_list_wlan_r13_l_& set_carrier_info_list_wlan_r13()
    {
      set(types::carrier_info_list_wlan_r13);
      return c.get<carrier_info_list_wlan_r13_l_>();
    }

  private:
    types                                                                                           type_;
    choice_buffer_t<MAX2(sizeof(band_ind_list_wlan_r13_l_), sizeof(carrier_info_list_wlan_r13_l_))> c;

    void destroy_();
  };

  // member variables
  bool                ext                              = false;
  bool                carrier_freq_r13_present         = false;
  bool                wlan_to_add_mod_list_r13_present = false;
  bool                wlan_to_rem_list_r13_present     = false;
  carrier_freq_r13_c_ carrier_freq_r13;
  wlan_id_list_r13_l  wlan_to_add_mod_list_r13;
  wlan_id_list_r13_l  wlan_to_rem_list_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ObtainLocationConfig-r11 ::= SEQUENCE
struct obtain_location_cfg_r11_s {
  // member variables
  bool obtain_location_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PowerPrefIndicationConfig-r11 ::= CHOICE
struct pwr_pref_ind_cfg_r11_c {
  struct setup_s_ {
    struct pwr_pref_ind_timer_r11_opts {
      enum options {
        s0,
        s0dot5,
        s1,
        s2,
        s5,
        s10,
        s20,
        s30,
        s60,
        s90,
        s120,
        s300,
        s600,
        spare3,
        spare2,
        spare1,
        nulltype
      } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<pwr_pref_ind_timer_r11_opts> pwr_pref_ind_timer_r11_e_;

    // member variables
    pwr_pref_ind_timer_r11_e_ pwr_pref_ind_timer_r11;
  };
  typedef setup_e types;

  // choice methods
  pwr_pref_ind_cfg_r11_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "PowerPrefIndicationConfig-r11");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "PowerPrefIndicationConfig-r11");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// QuantityConfigNR-r15 ::= SEQUENCE
struct quant_cfg_nr_r15_s {
  // member variables
  bool                  meas_quant_rs_idx_nr_r15_present = false;
  quant_cfg_rs_nr_r15_s meas_quant_cell_nr_r15;
  quant_cfg_rs_nr_r15_s meas_quant_rs_idx_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v10l0-IEs ::= SEQUENCE
struct rrc_conn_recfg_v10l0_ies_s {
  // member variables
  bool                          mob_ctrl_info_v10l0_present          = false;
  bool                          s_cell_to_add_mod_list_v10l0_present = false;
  bool                          late_non_crit_ext_present            = false;
  bool                          non_crit_ext_present                 = false;
  mob_ctrl_info_v10l0_s         mob_ctrl_info_v10l0;
  scell_to_add_mod_list_v10l0_l s_cell_to_add_mod_list_v10l0;
  dyn_octstring                 late_non_crit_ext;
  rrc_conn_recfg_v12f0_ies_s    non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v1130-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1130_ies_s {
  // member variables
  bool                       sib_type1_ded_r11_present = false;
  bool                       non_crit_ext_present      = false;
  dyn_octstring              sib_type1_ded_r11;
  rrc_conn_recfg_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease-v1320-IEs ::= SEQUENCE
struct rrc_conn_release_v1320_ies_s {
  // member variables
  bool                         resume_id_r13_present = false;
  bool                         non_crit_ext_present  = false;
  fixed_bitstring<40>          resume_id_r13;
  rrc_conn_release_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct eutra_event_s {
  struct event_id_c_ {
    struct event_a1_s_ {
      // member variables
      thres_eutra_c a1_thres;
    };
    struct event_a2_s_ {
      // member variables
      thres_eutra_c a2_thres;
    };
    struct event_a3_s_ {
      // member variables
      int8_t a3_offset       = -30;
      bool   report_on_leave = false;
    };
    struct event_a4_s_ {
      // member variables
      thres_eutra_c a4_thres;
    };
    struct event_a5_s_ {
      // member variables
      thres_eutra_c a5_thres1;
      thres_eutra_c a5_thres2;
    };
    struct event_a6_r10_s_ {
      // member variables
      int8_t a6_offset_r10          = -30;
      bool   a6_report_on_leave_r10 = false;
    };
    struct event_c1_r12_s_ {
      // member variables
      uint8_t c1_thres_r12           = 0;
      bool    c1_report_on_leave_r12 = false;
    };
    struct event_c2_r12_s_ {
      // member variables
      uint8_t c2_ref_csi_rs_r12      = 1;
      int8_t  c2_offset_r12          = -30;
      bool    c2_report_on_leave_r12 = false;
    };
    struct event_v1_r14_s_ {
      // member variables
      uint8_t v1_thres_r14 = 0;
    };
    struct event_v2_r14_s_ {
      // member variables
      uint8_t v2_thres_r14 = 0;
    };
    struct event_h1_r15_s_ {
      // member variables
      uint16_t h1_thres_offset_r15   = 0;
      uint8_t  h1_hysteresis_minus15 = 1;
    };
    struct event_h2_r15_s_ {
      // member variables
      uint16_t h2_thres_offset_r15   = 0;
      uint8_t  h2_hysteresis_minus15 = 1;
    };
    struct types_opts {
      enum options {
        event_a1,
        event_a2,
        event_a3,
        event_a4,
        event_a5,
        // ...
        event_a6_r10,
        event_c1_r12,
        event_c2_r12,
        event_v1_r14,
        event_v2_r14,
        event_h1_r15,
        event_h2_r15,
        nulltype
      } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts, true, 7> types;

    // choice methods
    event_id_c_() = default;
    event_id_c_(const event_id_c_& other);
    event_id_c_& operator=(const event_id_c_& other);
    ~event_id_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    event_a1_s_& event_a1()
    {
      assert_choice_type("eventA1", type_.to_string(), "eventId");
      return c.get<event_a1_s_>();
    }
    event_a2_s_& event_a2()
    {
      assert_choice_type("eventA2", type_.to_string(), "eventId");
      return c.get<event_a2_s_>();
    }
    event_a3_s_& event_a3()
    {
      assert_choice_type("eventA3", type_.to_string(), "eventId");
      return c.get<event_a3_s_>();
    }
    event_a4_s_& event_a4()
    {
      assert_choice_type("eventA4", type_.to_string(), "eventId");
      return c.get<event_a4_s_>();
    }
    event_a5_s_& event_a5()
    {
      assert_choice_type("eventA5", type_.to_string(), "eventId");
      return c.get<event_a5_s_>();
    }
    event_a6_r10_s_& event_a6_r10()
    {
      assert_choice_type("eventA6-r10", type_.to_string(), "eventId");
      return c.get<event_a6_r10_s_>();
    }
    event_c1_r12_s_& event_c1_r12()
    {
      assert_choice_type("eventC1-r12", type_.to_string(), "eventId");
      return c.get<event_c1_r12_s_>();
    }
    event_c2_r12_s_& event_c2_r12()
    {
      assert_choice_type("eventC2-r12", type_.to_string(), "eventId");
      return c.get<event_c2_r12_s_>();
    }
    event_v1_r14_s_& event_v1_r14()
    {
      assert_choice_type("eventV1-r14", type_.to_string(), "eventId");
      return c.get<event_v1_r14_s_>();
    }
    event_v2_r14_s_& event_v2_r14()
    {
      assert_choice_type("eventV2-r14", type_.to_string(), "eventId");
      return c.get<event_v2_r14_s_>();
    }
    event_h1_r15_s_& event_h1_r15()
    {
      assert_choice_type("eventH1-r15", type_.to_string(), "eventId");
      return c.get<event_h1_r15_s_>();
    }
    event_h2_r15_s_& event_h2_r15()
    {
      assert_choice_type("eventH2-r15", type_.to_string(), "eventId");
      return c.get<event_h2_r15_s_>();
    }
    const event_a1_s_& event_a1() const
    {
      assert_choice_type("eventA1", type_.to_string(), "eventId");
      return c.get<event_a1_s_>();
    }
    const event_a2_s_& event_a2() const
    {
      assert_choice_type("eventA2", type_.to_string(), "eventId");
      return c.get<event_a2_s_>();
    }
    const event_a3_s_& event_a3() const
    {
      assert_choice_type("eventA3", type_.to_string(), "eventId");
      return c.get<event_a3_s_>();
    }
    const event_a4_s_& event_a4() const
    {
      assert_choice_type("eventA4", type_.to_string(), "eventId");
      return c.get<event_a4_s_>();
    }
    const event_a5_s_& event_a5() const
    {
      assert_choice_type("eventA5", type_.to_string(), "eventId");
      return c.get<event_a5_s_>();
    }
    const event_a6_r10_s_& event_a6_r10() const
    {
      assert_choice_type("eventA6-r10", type_.to_string(), "eventId");
      return c.get<event_a6_r10_s_>();
    }
    const event_c1_r12_s_& event_c1_r12() const
    {
      assert_choice_type("eventC1-r12", type_.to_string(), "eventId");
      return c.get<event_c1_r12_s_>();
    }
    const event_c2_r12_s_& event_c2_r12() const
    {
      assert_choice_type("eventC2-r12", type_.to_string(), "eventId");
      return c.get<event_c2_r12_s_>();
    }
    const event_v1_r14_s_& event_v1_r14() const
    {
      assert_choice_type("eventV1-r14", type_.to_string(), "eventId");
      return c.get<event_v1_r14_s_>();
    }
    const event_v2_r14_s_& event_v2_r14() const
    {
      assert_choice_type("eventV2-r14", type_.to_string(), "eventId");
      return c.get<event_v2_r14_s_>();
    }
    const event_h1_r15_s_& event_h1_r15() const
    {
      assert_choice_type("eventH1-r15", type_.to_string(), "eventId");
      return c.get<event_h1_r15_s_>();
    }
    const event_h2_r15_s_& event_h2_r15() const
    {
      assert_choice_type("eventH2-r15", type_.to_string(), "eventId");
      return c.get<event_h2_r15_s_>();
    }
    event_a1_s_& set_event_a1()
    {
      set(types::event_a1);
      return c.get<event_a1_s_>();
    }
    event_a2_s_& set_event_a2()
    {
      set(types::event_a2);
      return c.get<event_a2_s_>();
    }
    event_a3_s_& set_event_a3()
    {
      set(types::event_a3);
      return c.get<event_a3_s_>();
    }
    event_a4_s_& set_event_a4()
    {
      set(types::event_a4);
      return c.get<event_a4_s_>();
    }
    event_a5_s_& set_event_a5()
    {
      set(types::event_a5);
      return c.get<event_a5_s_>();
    }
    event_a6_r10_s_& set_event_a6_r10()
    {
      set(types::event_a6_r10);
      return c.get<event_a6_r10_s_>();
    }
    event_c1_r12_s_& set_event_c1_r12()
    {
      set(types::event_c1_r12);
      return c.get<event_c1_r12_s_>();
    }
    event_c2_r12_s_& set_event_c2_r12()
    {
      set(types::event_c2_r12);
      return c.get<event_c2_r12_s_>();
    }
    event_v1_r14_s_& set_event_v1_r14()
    {
      set(types::event_v1_r14);
      return c.get<event_v1_r14_s_>();
    }
    event_v2_r14_s_& set_event_v2_r14()
    {
      set(types::event_v2_r14);
      return c.get<event_v2_r14_s_>();
    }
    event_h1_r15_s_& set_event_h1_r15()
    {
      set(types::event_h1_r15);
      return c.get<event_h1_r15_s_>();
    }
    event_h2_r15_s_& set_event_h2_r15()
    {
      set(types::event_h2_r15);
      return c.get<event_h2_r15_s_>();
    }

  private:
    types type_;
    choice_buffer_t<MAX16(sizeof(event_a1_s_),
                          sizeof(event_a2_s_),
                          sizeof(event_a3_s_),
                          sizeof(event_a4_s_),
                          sizeof(event_a5_s_),
                          sizeof(event_a6_r10_s_),
                          sizeof(event_c1_r12_s_),
                          sizeof(event_c2_r12_s_),
                          sizeof(event_h1_r15_s_),
                          sizeof(event_h2_r15_s_),
                          sizeof(event_v1_r14_s_),
                          sizeof(event_v2_r14_s_),
                          0,
                          0,
                          0,
                          0)>
        c;

    void destroy_();
  };

  // member variables
  event_id_c_       event_id;
  uint8_t           hysteresis = 0;
  time_to_trigger_e time_to_trigger;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReportConfigEUTRA ::= SEQUENCE
struct report_cfg_eutra_s {
  struct trigger_type_c_ {
    typedef eutra_event_s event_s_;
    struct periodical_s_ {
      struct purpose_opts {
        enum options { report_strongest_cells, report_cgi, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<purpose_opts> purpose_e_;

      // member variables
      purpose_e_ purpose;
    };
    struct types_opts {
      enum options { event, periodical, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    trigger_type_c_() = default;
    trigger_type_c_(const trigger_type_c_& other);
    trigger_type_c_& operator=(const trigger_type_c_& other);
    ~trigger_type_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    event_s_& event()
    {
      assert_choice_type("event", type_.to_string(), "triggerType");
      return c.get<event_s_>();
    }
    periodical_s_& periodical()
    {
      assert_choice_type("periodical", type_.to_string(), "triggerType");
      return c.get<periodical_s_>();
    }
    const event_s_& event() const
    {
      assert_choice_type("event", type_.to_string(), "triggerType");
      return c.get<event_s_>();
    }
    const periodical_s_& periodical() const
    {
      assert_choice_type("periodical", type_.to_string(), "triggerType");
      return c.get<periodical_s_>();
    }
    event_s_& set_event()
    {
      set(types::event);
      return c.get<event_s_>();
    }
    periodical_s_& set_periodical()
    {
      set(types::periodical);
      return c.get<periodical_s_>();
    }

  private:
    types                                                          type_;
    choice_buffer_t<MAX2(sizeof(event_s_), sizeof(periodical_s_))> c;

    void destroy_();
  };
  struct trigger_quant_opts {
    enum options { rsrp, rsrq, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<trigger_quant_opts> trigger_quant_e_;
  struct report_quant_opts {
    enum options { same_as_trigger_quant, both, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<report_quant_opts> report_quant_e_;
  struct report_amount_opts {
    enum options { r1, r2, r4, r8, r16, r32, r64, infinity, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<report_amount_opts> report_amount_e_;
  struct alternative_time_to_trigger_r12_c_ {
    typedef setup_e types;

    // choice methods
    alternative_time_to_trigger_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    time_to_trigger_e& setup()
    {
      assert_choice_type("setup", type_.to_string(), "alternativeTimeToTrigger-r12");
      return c;
    }
    const time_to_trigger_e& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "alternativeTimeToTrigger-r12");
      return c;
    }
    time_to_trigger_e& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types             type_;
    time_to_trigger_e c;
  };
  struct rs_sinr_cfg_r13_c_ {
    struct setup_s_ {
      struct report_quant_v1310_opts {
        enum options { rsrp_andsinr, rsrq_andsinr, all, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<report_quant_v1310_opts> report_quant_v1310_e_;

      // member variables
      bool                  trigger_quant_v1310_present = false;
      bool                  a_n_thres1_r13_present      = false;
      bool                  a5_thres2_r13_present       = false;
      uint8_t               a_n_thres1_r13              = 0;
      uint8_t               a5_thres2_r13               = 0;
      report_quant_v1310_e_ report_quant_v1310;
    };
    typedef setup_e types;

    // choice methods
    rs_sinr_cfg_r13_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "rs-sinr-Config-r13");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "rs-sinr-Config-r13");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct purpose_v1430_opts {
    enum options { report_location, sidelink, spare2, spare1, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<purpose_v1430_opts> purpose_v1430_e_;

  // member variables
  bool             ext = false;
  trigger_type_c_  trigger_type;
  trigger_quant_e_ trigger_quant;
  report_quant_e_  report_quant;
  uint8_t          max_report_cells = 1;
  report_interv_e  report_interv;
  report_amount_e_ report_amount;
  // ...
  // group 0
  bool si_request_for_ho_r9_present             = false;
  bool ue_rx_tx_time_diff_periodical_r9_present = false;
  // group 1
  bool include_location_info_r10_present = false;
  bool report_add_neigh_meas_r10_present = false;
  // group 2
  bool                                         alternative_time_to_trigger_r12_present = false;
  bool                                         use_t312_r12_present                    = false;
  bool                                         use_ps_cell_r12_present                 = false;
  bool                                         a_n_thres1_v1250_present                = false;
  bool                                         a5_thres2_v1250_present                 = false;
  bool                                         report_strongest_csi_rss_r12_present    = false;
  bool                                         report_crs_meas_r12_present             = false;
  bool                                         trigger_quant_csi_rs_r12_present        = false;
  copy_ptr<alternative_time_to_trigger_r12_c_> alternative_time_to_trigger_r12;
  bool                                         use_t312_r12    = false;
  bool                                         use_ps_cell_r12 = false;
  copy_ptr<rsrq_range_cfg_r12_c>               a_n_thres1_v1250;
  copy_ptr<rsrq_range_cfg_r12_c>               a5_thres2_v1250;
  bool                                         report_strongest_csi_rss_r12 = false;
  bool                                         report_crs_meas_r12          = false;
  bool                                         trigger_quant_csi_rs_r12     = false;
  // group 3
  bool                                 report_sstd_meas_r13_present        = false;
  bool                                 rs_sinr_cfg_r13_present             = false;
  bool                                 use_white_cell_list_r13_present     = false;
  bool                                 meas_rssi_report_cfg_r13_present    = false;
  bool                                 include_multi_band_info_r13_present = false;
  bool                                 ul_delay_cfg_r13_present            = false;
  bool                                 report_sstd_meas_r13                = false;
  copy_ptr<rs_sinr_cfg_r13_c_>         rs_sinr_cfg_r13;
  bool                                 use_white_cell_list_r13 = false;
  copy_ptr<meas_rssi_report_cfg_r13_s> meas_rssi_report_cfg_r13;
  copy_ptr<ul_delay_cfg_r13_c>         ul_delay_cfg_r13;
  // group 4
  bool ue_rx_tx_time_diff_periodical_tdd_r13_present = false;
  bool ue_rx_tx_time_diff_periodical_tdd_r13         = false;
  // group 5
  bool             purpose_v1430_present = false;
  purpose_v1430_e_ purpose_v1430;
  // group 6
  bool    max_report_rs_idx_r15_present = false;
  uint8_t max_report_rs_idx_r15         = 0;
  // group 7
  bool                               include_bt_meas_r15_present       = false;
  bool                               include_wlan_meas_r15_present     = false;
  bool                               purpose_r15_present               = false;
  bool                               nof_triggering_cells_r15_present  = false;
  bool                               a4_a5_report_on_leave_r15_present = false;
  copy_ptr<bt_name_list_cfg_r15_c>   include_bt_meas_r15;
  copy_ptr<wlan_name_list_cfg_r15_c> include_wlan_meas_r15;
  uint8_t                            nof_triggering_cells_r15  = 2;
  bool                               a4_a5_report_on_leave_r15 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReportConfigInterRAT ::= SEQUENCE
struct report_cfg_inter_rat_s {
  struct trigger_type_c_ {
    struct event_s_ {
      struct event_id_c_ {
        struct event_b1_s_ {
          struct b1_thres_c_ {
            struct types_opts {
              enum options { b1_thres_utra, b1_thres_geran, b1_thres_cdma2000, nulltype } value;

              std::string to_string() const;
            };
            typedef enumerated<types_opts> types;

            // choice methods
            b1_thres_c_() = default;
            b1_thres_c_(const b1_thres_c_& other);
            b1_thres_c_& operator=(const b1_thres_c_& other);
            ~b1_thres_c_() { destroy_(); }
            void        set(types::options e = types::nulltype);
            types       type() const { return type_; }
            SRSASN_CODE pack(bit_ref& bref) const;
            SRSASN_CODE unpack(bit_ref& bref);
            void        to_json(json_writer& j) const;
            // getters
            thres_utra_c& b1_thres_utra()
            {
              assert_choice_type("b1-ThresholdUTRA", type_.to_string(), "b1-Threshold");
              return c.get<thres_utra_c>();
            }
            uint8_t& b1_thres_geran()
            {
              assert_choice_type("b1-ThresholdGERAN", type_.to_string(), "b1-Threshold");
              return c.get<uint8_t>();
            }
            uint8_t& b1_thres_cdma2000()
            {
              assert_choice_type("b1-ThresholdCDMA2000", type_.to_string(), "b1-Threshold");
              return c.get<uint8_t>();
            }
            const thres_utra_c& b1_thres_utra() const
            {
              assert_choice_type("b1-ThresholdUTRA", type_.to_string(), "b1-Threshold");
              return c.get<thres_utra_c>();
            }
            const uint8_t& b1_thres_geran() const
            {
              assert_choice_type("b1-ThresholdGERAN", type_.to_string(), "b1-Threshold");
              return c.get<uint8_t>();
            }
            const uint8_t& b1_thres_cdma2000() const
            {
              assert_choice_type("b1-ThresholdCDMA2000", type_.to_string(), "b1-Threshold");
              return c.get<uint8_t>();
            }
            thres_utra_c& set_b1_thres_utra()
            {
              set(types::b1_thres_utra);
              return c.get<thres_utra_c>();
            }
            uint8_t& set_b1_thres_geran()
            {
              set(types::b1_thres_geran);
              return c.get<uint8_t>();
            }
            uint8_t& set_b1_thres_cdma2000()
            {
              set(types::b1_thres_cdma2000);
              return c.get<uint8_t>();
            }

          private:
            types                                 type_;
            choice_buffer_t<sizeof(thres_utra_c)> c;

            void destroy_();
          };

          // member variables
          b1_thres_c_ b1_thres;
        };
        struct event_b2_s_ {
          struct b2_thres2_c_ {
            struct types_opts {
              enum options { b2_thres2_utra, b2_thres2_geran, b2_thres2_cdma2000, nulltype } value;

              std::string to_string() const;
            };
            typedef enumerated<types_opts> types;

            // choice methods
            b2_thres2_c_() = default;
            b2_thres2_c_(const b2_thres2_c_& other);
            b2_thres2_c_& operator=(const b2_thres2_c_& other);
            ~b2_thres2_c_() { destroy_(); }
            void        set(types::options e = types::nulltype);
            types       type() const { return type_; }
            SRSASN_CODE pack(bit_ref& bref) const;
            SRSASN_CODE unpack(bit_ref& bref);
            void        to_json(json_writer& j) const;
            // getters
            thres_utra_c& b2_thres2_utra()
            {
              assert_choice_type("b2-Threshold2UTRA", type_.to_string(), "b2-Threshold2");
              return c.get<thres_utra_c>();
            }
            uint8_t& b2_thres2_geran()
            {
              assert_choice_type("b2-Threshold2GERAN", type_.to_string(), "b2-Threshold2");
              return c.get<uint8_t>();
            }
            uint8_t& b2_thres2_cdma2000()
            {
              assert_choice_type("b2-Threshold2CDMA2000", type_.to_string(), "b2-Threshold2");
              return c.get<uint8_t>();
            }
            const thres_utra_c& b2_thres2_utra() const
            {
              assert_choice_type("b2-Threshold2UTRA", type_.to_string(), "b2-Threshold2");
              return c.get<thres_utra_c>();
            }
            const uint8_t& b2_thres2_geran() const
            {
              assert_choice_type("b2-Threshold2GERAN", type_.to_string(), "b2-Threshold2");
              return c.get<uint8_t>();
            }
            const uint8_t& b2_thres2_cdma2000() const
            {
              assert_choice_type("b2-Threshold2CDMA2000", type_.to_string(), "b2-Threshold2");
              return c.get<uint8_t>();
            }
            thres_utra_c& set_b2_thres2_utra()
            {
              set(types::b2_thres2_utra);
              return c.get<thres_utra_c>();
            }
            uint8_t& set_b2_thres2_geran()
            {
              set(types::b2_thres2_geran);
              return c.get<uint8_t>();
            }
            uint8_t& set_b2_thres2_cdma2000()
            {
              set(types::b2_thres2_cdma2000);
              return c.get<uint8_t>();
            }

          private:
            types                                 type_;
            choice_buffer_t<sizeof(thres_utra_c)> c;

            void destroy_();
          };

          // member variables
          thres_eutra_c b2_thres1;
          b2_thres2_c_  b2_thres2;
        };
        struct event_w1_r13_s_ {
          // member variables
          uint8_t w1_thres_r13 = 0;
        };
        struct event_w2_r13_s_ {
          // member variables
          uint8_t w2_thres1_r13 = 0;
          uint8_t w2_thres2_r13 = 0;
        };
        struct event_w3_r13_s_ {
          // member variables
          uint8_t w3_thres_r13 = 0;
        };
        struct event_b1_nr_r15_s_ {
          // member variables
          thres_nr_r15_c b1_thres_nr_r15;
          bool           report_on_leave_r15 = false;
        };
        struct event_b2_nr_r15_s_ {
          // member variables
          thres_eutra_c  b2_thres1_r15;
          thres_nr_r15_c b2_thres2_nr_r15;
          bool           report_on_leave_r15 = false;
        };
        struct types_opts {
          enum options {
            event_b1,
            event_b2,
            // ...
            event_w1_r13,
            event_w2_r13,
            event_w3_r13,
            event_b1_nr_r15,
            event_b2_nr_r15,
            nulltype
          } value;

          std::string to_string() const;
        };
        typedef enumerated<types_opts, true, 5> types;

        // choice methods
        event_id_c_() = default;
        event_id_c_(const event_id_c_& other);
        event_id_c_& operator=(const event_id_c_& other);
        ~event_id_c_() { destroy_(); }
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        event_b1_s_& event_b1()
        {
          assert_choice_type("eventB1", type_.to_string(), "eventId");
          return c.get<event_b1_s_>();
        }
        event_b2_s_& event_b2()
        {
          assert_choice_type("eventB2", type_.to_string(), "eventId");
          return c.get<event_b2_s_>();
        }
        event_w1_r13_s_& event_w1_r13()
        {
          assert_choice_type("eventW1-r13", type_.to_string(), "eventId");
          return c.get<event_w1_r13_s_>();
        }
        event_w2_r13_s_& event_w2_r13()
        {
          assert_choice_type("eventW2-r13", type_.to_string(), "eventId");
          return c.get<event_w2_r13_s_>();
        }
        event_w3_r13_s_& event_w3_r13()
        {
          assert_choice_type("eventW3-r13", type_.to_string(), "eventId");
          return c.get<event_w3_r13_s_>();
        }
        event_b1_nr_r15_s_& event_b1_nr_r15()
        {
          assert_choice_type("eventB1-NR-r15", type_.to_string(), "eventId");
          return c.get<event_b1_nr_r15_s_>();
        }
        event_b2_nr_r15_s_& event_b2_nr_r15()
        {
          assert_choice_type("eventB2-NR-r15", type_.to_string(), "eventId");
          return c.get<event_b2_nr_r15_s_>();
        }
        const event_b1_s_& event_b1() const
        {
          assert_choice_type("eventB1", type_.to_string(), "eventId");
          return c.get<event_b1_s_>();
        }
        const event_b2_s_& event_b2() const
        {
          assert_choice_type("eventB2", type_.to_string(), "eventId");
          return c.get<event_b2_s_>();
        }
        const event_w1_r13_s_& event_w1_r13() const
        {
          assert_choice_type("eventW1-r13", type_.to_string(), "eventId");
          return c.get<event_w1_r13_s_>();
        }
        const event_w2_r13_s_& event_w2_r13() const
        {
          assert_choice_type("eventW2-r13", type_.to_string(), "eventId");
          return c.get<event_w2_r13_s_>();
        }
        const event_w3_r13_s_& event_w3_r13() const
        {
          assert_choice_type("eventW3-r13", type_.to_string(), "eventId");
          return c.get<event_w3_r13_s_>();
        }
        const event_b1_nr_r15_s_& event_b1_nr_r15() const
        {
          assert_choice_type("eventB1-NR-r15", type_.to_string(), "eventId");
          return c.get<event_b1_nr_r15_s_>();
        }
        const event_b2_nr_r15_s_& event_b2_nr_r15() const
        {
          assert_choice_type("eventB2-NR-r15", type_.to_string(), "eventId");
          return c.get<event_b2_nr_r15_s_>();
        }
        event_b1_s_& set_event_b1()
        {
          set(types::event_b1);
          return c.get<event_b1_s_>();
        }
        event_b2_s_& set_event_b2()
        {
          set(types::event_b2);
          return c.get<event_b2_s_>();
        }
        event_w1_r13_s_& set_event_w1_r13()
        {
          set(types::event_w1_r13);
          return c.get<event_w1_r13_s_>();
        }
        event_w2_r13_s_& set_event_w2_r13()
        {
          set(types::event_w2_r13);
          return c.get<event_w2_r13_s_>();
        }
        event_w3_r13_s_& set_event_w3_r13()
        {
          set(types::event_w3_r13);
          return c.get<event_w3_r13_s_>();
        }
        event_b1_nr_r15_s_& set_event_b1_nr_r15()
        {
          set(types::event_b1_nr_r15);
          return c.get<event_b1_nr_r15_s_>();
        }
        event_b2_nr_r15_s_& set_event_b2_nr_r15()
        {
          set(types::event_b2_nr_r15);
          return c.get<event_b2_nr_r15_s_>();
        }

      private:
        types type_;
        choice_buffer_t<MAX8(sizeof(event_b1_nr_r15_s_),
                             sizeof(event_b1_s_),
                             sizeof(event_b2_nr_r15_s_),
                             sizeof(event_b2_s_),
                             sizeof(event_w1_r13_s_),
                             sizeof(event_w2_r13_s_),
                             sizeof(event_w3_r13_s_),
                             0)>
            c;

        void destroy_();
      };

      // member variables
      event_id_c_       event_id;
      uint8_t           hysteresis = 0;
      time_to_trigger_e time_to_trigger;
    };
    struct periodical_s_ {
      struct purpose_opts {
        enum options { report_strongest_cells, report_strongest_cells_for_son, report_cgi, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<purpose_opts> purpose_e_;

      // member variables
      purpose_e_ purpose;
    };
    struct types_opts {
      enum options { event, periodical, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    trigger_type_c_() = default;
    trigger_type_c_(const trigger_type_c_& other);
    trigger_type_c_& operator=(const trigger_type_c_& other);
    ~trigger_type_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    event_s_& event()
    {
      assert_choice_type("event", type_.to_string(), "triggerType");
      return c.get<event_s_>();
    }
    periodical_s_& periodical()
    {
      assert_choice_type("periodical", type_.to_string(), "triggerType");
      return c.get<periodical_s_>();
    }
    const event_s_& event() const
    {
      assert_choice_type("event", type_.to_string(), "triggerType");
      return c.get<event_s_>();
    }
    const periodical_s_& periodical() const
    {
      assert_choice_type("periodical", type_.to_string(), "triggerType");
      return c.get<periodical_s_>();
    }
    event_s_& set_event()
    {
      set(types::event);
      return c.get<event_s_>();
    }
    periodical_s_& set_periodical()
    {
      set(types::periodical);
      return c.get<periodical_s_>();
    }

  private:
    types                                                          type_;
    choice_buffer_t<MAX2(sizeof(event_s_), sizeof(periodical_s_))> c;

    void destroy_();
  };
  struct report_amount_opts {
    enum options { r1, r2, r4, r8, r16, r32, r64, infinity, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<report_amount_opts> report_amount_e_;
  struct b2_thres1_v1250_c_ {
    typedef setup_e types;

    // choice methods
    b2_thres1_v1250_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    int8_t& setup()
    {
      assert_choice_type("setup", type_.to_string(), "b2-Threshold1-v1250");
      return c;
    }
    const int8_t& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "b2-Threshold1-v1250");
      return c;
    }
    int8_t& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types  type_;
    int8_t c;
  };
  struct report_sftd_meas_r15_opts {
    enum options { p_scell, neighbor_cells, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<report_sftd_meas_r15_opts> report_sftd_meas_r15_e_;

  // member variables
  bool             ext = false;
  trigger_type_c_  trigger_type;
  uint8_t          max_report_cells = 1;
  report_interv_e  report_interv;
  report_amount_e_ report_amount;
  // ...
  // group 0
  bool si_request_for_ho_r9_present = false;
  // group 1
  bool report_quant_utra_fdd_r10_present = false;
  // group 2
  bool include_location_info_r11_present = false;
  bool include_location_info_r11         = false;
  // group 3
  bool                         b2_thres1_v1250_present = false;
  copy_ptr<b2_thres1_v1250_c_> b2_thres1_v1250;
  // group 4
  bool                              report_quant_wlan_r13_present = false;
  copy_ptr<report_quant_wlan_r13_s> report_quant_wlan_r13;
  // group 5
  bool report_any_wlan_r14_present = false;
  bool report_any_wlan_r14         = false;
  // group 6
  bool                            report_quant_cell_nr_r15_present   = false;
  bool                            max_report_rs_idx_r15_present      = false;
  bool                            report_quant_rs_idx_nr_r15_present = false;
  bool                            report_rs_idx_results_nr_present   = false;
  bool                            report_sftd_meas_r15_present       = false;
  copy_ptr<report_quant_nr_r15_s> report_quant_cell_nr_r15;
  uint8_t                         max_report_rs_idx_r15 = 0;
  copy_ptr<report_quant_nr_r15_s> report_quant_rs_idx_nr_r15;
  bool                            report_rs_idx_results_nr = false;
  report_sftd_meas_r15_e_         report_sftd_meas_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReportProximityConfig-r9 ::= SEQUENCE
struct report_proximity_cfg_r9_s {
  // member variables
  bool proximity_ind_eutra_r9_present = false;
  bool proximity_ind_utra_r9_present  = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TargetMBSFN-AreaList-r12 ::= SEQUENCE (SIZE (0..maxMBSFN-Area)) OF TargetMBSFN-Area-r12
typedef dyn_array<target_mbsfn_area_r12_s> target_mbsfn_area_list_r12_l;

// TrackingAreaCodeList-v1130 ::= SEQUENCE
struct tac_list_v1130_s {
  typedef dyn_array<plmn_id_s> plmn_id_per_tac_list_r11_l_;

  // member variables
  plmn_id_per_tac_list_r11_l_ plmn_id_per_tac_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityEnquiry-v1430-IEs ::= SEQUENCE
struct ue_cap_enquiry_v1430_ies_s {
  // member variables
  bool                        request_diff_fallback_comb_list_r14_present = false;
  bool                        non_crit_ext_present                        = false;
  band_combination_list_r14_l request_diff_fallback_comb_list_r14;
  ue_cap_enquiry_v1510_ies_s  non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationRequest-v1250-IEs ::= SEQUENCE
struct ue_info_request_v1250_ies_s {
  // member variables
  bool                        mob_history_report_req_r12_present = false;
  bool                        non_crit_ext_present               = false;
  ue_info_request_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AreaConfiguration-v1130 ::= SEQUENCE
struct area_cfg_v1130_s {
  // member variables
  tac_list_v1130_s tac_list_v1130;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellGlobalIdEUTRA ::= SEQUENCE
struct cell_global_id_eutra_s {
  // member variables
  plmn_id_s           plmn_id;
  fixed_bitstring<28> cell_id;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellInfoListGERAN-r9 ::= SEQUENCE (SIZE (1..maxCellInfoGERAN-r9)) OF CellInfoGERAN-r9
typedef dyn_array<cell_info_geran_r9_s> cell_info_list_geran_r9_l;

// CellInfoListUTRA-FDD-r9 ::= SEQUENCE (SIZE (1..maxCellInfoUTRA-r9)) OF CellInfoUTRA-FDD-r9
typedef dyn_array<cell_info_utra_fdd_r9_s> cell_info_list_utra_fdd_r9_l;

// CellInfoListUTRA-TDD-r10 ::= SEQUENCE (SIZE (1..maxCellInfoUTRA-r9)) OF CellInfoUTRA-TDD-r10
typedef dyn_array<cell_info_utra_tdd_r10_s> cell_info_list_utra_tdd_r10_l;

// CellInfoListUTRA-TDD-r9 ::= SEQUENCE (SIZE (1..maxCellInfoUTRA-r9)) OF CellInfoUTRA-TDD-r9
typedef dyn_array<cell_info_utra_tdd_r9_s> cell_info_list_utra_tdd_r9_l;

// DRB-CountMSB-InfoListExt-r15 ::= SEQUENCE (SIZE (1..maxDRBExt-r15)) OF DRB-CountMSB-Info
typedef dyn_array<drb_count_msb_info_s> drb_count_msb_info_list_ext_r15_l;

// HandoverFromEUTRAPreparationRequest-v1020-IEs ::= SEQUENCE
struct ho_from_eutra_prep_request_v1020_ies_s {
  // member variables
  bool                    dual_rx_tx_redirect_ind_r10_present               = false;
  bool                    redirect_carrier_cdma2000_minus1_xrtt_r10_present = false;
  bool                    non_crit_ext_present                              = false;
  carrier_freq_cdma2000_s redirect_carrier_cdma2000_minus1_xrtt_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoggedMeasurementConfiguration-v1250-IEs ::= SEQUENCE
struct logged_meas_cfg_v1250_ies_s {
  // member variables
  bool                         target_mbsfn_area_list_r12_present = false;
  bool                         non_crit_ext_present               = false;
  target_mbsfn_area_list_r12_l target_mbsfn_area_list_r12;
  logged_meas_cfg_v1530_ies_s  non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasGapConfigToAddModList-r14 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF MeasGapConfigPerCC-r14
typedef dyn_array<meas_gap_cfg_per_cc_r14_s> meas_gap_cfg_to_add_mod_list_r14_l;

// MeasGapConfigToRemoveList-r14 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF INTEGER
typedef bounded_array<uint8_t, 32> meas_gap_cfg_to_rem_list_r14_l;

// MeasIdToAddMod ::= SEQUENCE
struct meas_id_to_add_mod_s {
  // member variables
  uint8_t meas_id       = 1;
  uint8_t meas_obj_id   = 1;
  uint8_t report_cfg_id = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasIdToAddMod-v1310 ::= SEQUENCE
struct meas_id_to_add_mod_v1310_s {
  // member variables
  bool    meas_obj_id_v1310_present = false;
  uint8_t meas_obj_id_v1310         = 33;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasIdToAddModExt-r12 ::= SEQUENCE
struct meas_id_to_add_mod_ext_r12_s {
  // member variables
  uint8_t meas_id_v1250     = 33;
  uint8_t meas_obj_id_r12   = 1;
  uint8_t report_cfg_id_r12 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectToAddMod ::= SEQUENCE
struct meas_obj_to_add_mod_s {
  struct meas_obj_c_ {
    struct types_opts {
      enum options {
        meas_obj_eutra,
        meas_obj_utra,
        meas_obj_geran,
        meas_obj_cdma2000,
        // ...
        meas_obj_wlan_r13,
        meas_obj_nr_r15,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts, true, 2> types;

    // choice methods
    meas_obj_c_() = default;
    meas_obj_c_(const meas_obj_c_& other);
    meas_obj_c_& operator=(const meas_obj_c_& other);
    ~meas_obj_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    meas_obj_eutra_s& meas_obj_eutra()
    {
      assert_choice_type("measObjectEUTRA", type_.to_string(), "measObject");
      return c.get<meas_obj_eutra_s>();
    }
    meas_obj_utra_s& meas_obj_utra()
    {
      assert_choice_type("measObjectUTRA", type_.to_string(), "measObject");
      return c.get<meas_obj_utra_s>();
    }
    meas_obj_geran_s& meas_obj_geran()
    {
      assert_choice_type("measObjectGERAN", type_.to_string(), "measObject");
      return c.get<meas_obj_geran_s>();
    }
    meas_obj_cdma2000_s& meas_obj_cdma2000()
    {
      assert_choice_type("measObjectCDMA2000", type_.to_string(), "measObject");
      return c.get<meas_obj_cdma2000_s>();
    }
    meas_obj_wlan_r13_s& meas_obj_wlan_r13()
    {
      assert_choice_type("measObjectWLAN-r13", type_.to_string(), "measObject");
      return c.get<meas_obj_wlan_r13_s>();
    }
    meas_obj_nr_r15_s& meas_obj_nr_r15()
    {
      assert_choice_type("measObjectNR-r15", type_.to_string(), "measObject");
      return c.get<meas_obj_nr_r15_s>();
    }
    const meas_obj_eutra_s& meas_obj_eutra() const
    {
      assert_choice_type("measObjectEUTRA", type_.to_string(), "measObject");
      return c.get<meas_obj_eutra_s>();
    }
    const meas_obj_utra_s& meas_obj_utra() const
    {
      assert_choice_type("measObjectUTRA", type_.to_string(), "measObject");
      return c.get<meas_obj_utra_s>();
    }
    const meas_obj_geran_s& meas_obj_geran() const
    {
      assert_choice_type("measObjectGERAN", type_.to_string(), "measObject");
      return c.get<meas_obj_geran_s>();
    }
    const meas_obj_cdma2000_s& meas_obj_cdma2000() const
    {
      assert_choice_type("measObjectCDMA2000", type_.to_string(), "measObject");
      return c.get<meas_obj_cdma2000_s>();
    }
    const meas_obj_wlan_r13_s& meas_obj_wlan_r13() const
    {
      assert_choice_type("measObjectWLAN-r13", type_.to_string(), "measObject");
      return c.get<meas_obj_wlan_r13_s>();
    }
    const meas_obj_nr_r15_s& meas_obj_nr_r15() const
    {
      assert_choice_type("measObjectNR-r15", type_.to_string(), "measObject");
      return c.get<meas_obj_nr_r15_s>();
    }
    meas_obj_eutra_s& set_meas_obj_eutra()
    {
      set(types::meas_obj_eutra);
      return c.get<meas_obj_eutra_s>();
    }
    meas_obj_utra_s& set_meas_obj_utra()
    {
      set(types::meas_obj_utra);
      return c.get<meas_obj_utra_s>();
    }
    meas_obj_geran_s& set_meas_obj_geran()
    {
      set(types::meas_obj_geran);
      return c.get<meas_obj_geran_s>();
    }
    meas_obj_cdma2000_s& set_meas_obj_cdma2000()
    {
      set(types::meas_obj_cdma2000);
      return c.get<meas_obj_cdma2000_s>();
    }
    meas_obj_wlan_r13_s& set_meas_obj_wlan_r13()
    {
      set(types::meas_obj_wlan_r13);
      return c.get<meas_obj_wlan_r13_s>();
    }
    meas_obj_nr_r15_s& set_meas_obj_nr_r15()
    {
      set(types::meas_obj_nr_r15);
      return c.get<meas_obj_nr_r15_s>();
    }

  private:
    types type_;
    choice_buffer_t<MAX8(sizeof(meas_obj_cdma2000_s),
                         sizeof(meas_obj_eutra_s),
                         sizeof(meas_obj_geran_s),
                         sizeof(meas_obj_nr_r15_s),
                         sizeof(meas_obj_utra_s),
                         sizeof(meas_obj_wlan_r13_s),
                         0,
                         0)>
        c;

    void destroy_();
  };

  // member variables
  uint8_t     meas_obj_id = 1;
  meas_obj_c_ meas_obj;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectToAddMod-v9e0 ::= SEQUENCE
struct meas_obj_to_add_mod_v9e0_s {
  // member variables
  bool                  meas_obj_eutra_v9e0_present = false;
  meas_obj_eutra_v9e0_s meas_obj_eutra_v9e0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasObjectToAddModExt-r13 ::= SEQUENCE
struct meas_obj_to_add_mod_ext_r13_s {
  struct meas_obj_r13_c_ {
    struct types_opts {
      enum options {
        meas_obj_eutra_r13,
        meas_obj_utra_r13,
        meas_obj_geran_r13,
        meas_obj_cdma2000_r13,
        // ...
        meas_obj_wlan_v1320,
        meas_obj_nr_r15,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts, true, 2> types;

    // choice methods
    meas_obj_r13_c_() = default;
    meas_obj_r13_c_(const meas_obj_r13_c_& other);
    meas_obj_r13_c_& operator=(const meas_obj_r13_c_& other);
    ~meas_obj_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    meas_obj_eutra_s& meas_obj_eutra_r13()
    {
      assert_choice_type("measObjectEUTRA-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_eutra_s>();
    }
    meas_obj_utra_s& meas_obj_utra_r13()
    {
      assert_choice_type("measObjectUTRA-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_utra_s>();
    }
    meas_obj_geran_s& meas_obj_geran_r13()
    {
      assert_choice_type("measObjectGERAN-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_geran_s>();
    }
    meas_obj_cdma2000_s& meas_obj_cdma2000_r13()
    {
      assert_choice_type("measObjectCDMA2000-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_cdma2000_s>();
    }
    meas_obj_wlan_r13_s& meas_obj_wlan_v1320()
    {
      assert_choice_type("measObjectWLAN-v1320", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_wlan_r13_s>();
    }
    meas_obj_nr_r15_s& meas_obj_nr_r15()
    {
      assert_choice_type("measObjectNR-r15", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_nr_r15_s>();
    }
    const meas_obj_eutra_s& meas_obj_eutra_r13() const
    {
      assert_choice_type("measObjectEUTRA-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_eutra_s>();
    }
    const meas_obj_utra_s& meas_obj_utra_r13() const
    {
      assert_choice_type("measObjectUTRA-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_utra_s>();
    }
    const meas_obj_geran_s& meas_obj_geran_r13() const
    {
      assert_choice_type("measObjectGERAN-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_geran_s>();
    }
    const meas_obj_cdma2000_s& meas_obj_cdma2000_r13() const
    {
      assert_choice_type("measObjectCDMA2000-r13", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_cdma2000_s>();
    }
    const meas_obj_wlan_r13_s& meas_obj_wlan_v1320() const
    {
      assert_choice_type("measObjectWLAN-v1320", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_wlan_r13_s>();
    }
    const meas_obj_nr_r15_s& meas_obj_nr_r15() const
    {
      assert_choice_type("measObjectNR-r15", type_.to_string(), "measObject-r13");
      return c.get<meas_obj_nr_r15_s>();
    }
    meas_obj_eutra_s& set_meas_obj_eutra_r13()
    {
      set(types::meas_obj_eutra_r13);
      return c.get<meas_obj_eutra_s>();
    }
    meas_obj_utra_s& set_meas_obj_utra_r13()
    {
      set(types::meas_obj_utra_r13);
      return c.get<meas_obj_utra_s>();
    }
    meas_obj_geran_s& set_meas_obj_geran_r13()
    {
      set(types::meas_obj_geran_r13);
      return c.get<meas_obj_geran_s>();
    }
    meas_obj_cdma2000_s& set_meas_obj_cdma2000_r13()
    {
      set(types::meas_obj_cdma2000_r13);
      return c.get<meas_obj_cdma2000_s>();
    }
    meas_obj_wlan_r13_s& set_meas_obj_wlan_v1320()
    {
      set(types::meas_obj_wlan_v1320);
      return c.get<meas_obj_wlan_r13_s>();
    }
    meas_obj_nr_r15_s& set_meas_obj_nr_r15()
    {
      set(types::meas_obj_nr_r15);
      return c.get<meas_obj_nr_r15_s>();
    }

  private:
    types type_;
    choice_buffer_t<MAX8(sizeof(meas_obj_cdma2000_s),
                         sizeof(meas_obj_eutra_s),
                         sizeof(meas_obj_geran_s),
                         sizeof(meas_obj_nr_r15_s),
                         sizeof(meas_obj_utra_s),
                         sizeof(meas_obj_wlan_r13_s),
                         0,
                         0)>
        c;

    void destroy_();
  };

  // member variables
  uint8_t         meas_obj_id_r13 = 33;
  meas_obj_r13_c_ meas_obj_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand-v1530-IEs ::= SEQUENCE
struct mob_from_eutra_cmd_v1530_ies_s {
  // member variables
  bool             smtc_r15_present     = false;
  bool             non_crit_ext_present = false;
  mtc_ssb_nr_r15_s smtc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// OtherConfig-r9 ::= SEQUENCE
struct other_cfg_r9_s {
  struct bw_pref_ind_timer_r14_opts {
    enum options {
      s0,
      s0dot5,
      s1,
      s2,
      s5,
      s10,
      s20,
      s30,
      s60,
      s90,
      s120,
      s300,
      s600,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<bw_pref_ind_timer_r14_opts> bw_pref_ind_timer_r14_e_;
  struct delay_budget_report_cfg_r14_c_ {
    struct setup_s_ {
      struct delay_budget_report_prohibit_timer_r14_opts {
        enum options { s0, s0dot4, s0dot8, s1dot6, s3, s6, s12, s30, nulltype } value;
        typedef float number_type;

        std::string to_string() const;
        float       to_number() const;
        std::string to_number_string() const;
      };
      typedef enumerated<delay_budget_report_prohibit_timer_r14_opts> delay_budget_report_prohibit_timer_r14_e_;

      // member variables
      delay_budget_report_prohibit_timer_r14_e_ delay_budget_report_prohibit_timer_r14;
    };
    typedef setup_e types;

    // choice methods
    delay_budget_report_cfg_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "delayBudgetReportingConfig-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "delayBudgetReportingConfig-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct rlm_report_cfg_r14_c_ {
    struct setup_s_ {
      struct rlm_report_timer_r14_opts {
        enum options {
          s0,
          s0dot5,
          s1,
          s2,
          s5,
          s10,
          s20,
          s30,
          s60,
          s90,
          s120,
          s300,
          s600,
          spare3,
          spare2,
          spare1,
          nulltype
        } value;
        typedef float number_type;

        std::string to_string() const;
        float       to_number() const;
        std::string to_number_string() const;
      };
      typedef enumerated<rlm_report_timer_r14_opts> rlm_report_timer_r14_e_;

      // member variables
      bool                    rlm_report_rep_mpdcch_r14_present = false;
      rlm_report_timer_r14_e_ rlm_report_timer_r14;
    };
    typedef setup_e types;

    // choice methods
    rlm_report_cfg_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "rlm-ReportConfig-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "rlm-ReportConfig-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct overheat_assist_cfg_r14_c_ {
    struct setup_s_ {
      struct overheat_ind_prohibit_timer_r14_opts {
        enum options {
          s0,
          s0dot5,
          s1,
          s2,
          s5,
          s10,
          s20,
          s30,
          s60,
          s90,
          s120,
          s300,
          s600,
          spare3,
          spare2,
          spare1,
          nulltype
        } value;
        typedef float number_type;

        std::string to_string() const;
        float       to_number() const;
        std::string to_number_string() const;
      };
      typedef enumerated<overheat_ind_prohibit_timer_r14_opts> overheat_ind_prohibit_timer_r14_e_;

      // member variables
      overheat_ind_prohibit_timer_r14_e_ overheat_ind_prohibit_timer_r14;
    };
    typedef setup_e types;

    // choice methods
    overheat_assist_cfg_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "overheatingAssistanceConfig-r14");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "overheatingAssistanceConfig-r14");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct meas_cfg_app_layer_r15_c_ {
    struct setup_s_ {
      struct service_type_opts {
        enum options { qoe, qoemtsi, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<service_type_opts> service_type_e_;

      // member variables
      dyn_octstring   meas_cfg_app_layer_container_r15;
      service_type_e_ service_type;
    };
    typedef setup_e types;

    // choice methods
    meas_cfg_app_layer_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "measConfigAppLayer-r15");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "measConfigAppLayer-r15");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                      ext                             = false;
  bool                      report_proximity_cfg_r9_present = false;
  report_proximity_cfg_r9_s report_proximity_cfg_r9;
  // ...
  // group 0
  bool                                idc_cfg_r11_present             = false;
  bool                                pwr_pref_ind_cfg_r11_present    = false;
  bool                                obtain_location_cfg_r11_present = false;
  copy_ptr<idc_cfg_r11_s>             idc_cfg_r11;
  copy_ptr<pwr_pref_ind_cfg_r11_c>    pwr_pref_ind_cfg_r11;
  copy_ptr<obtain_location_cfg_r11_s> obtain_location_cfg_r11;
  // group 1
  bool                                     bw_pref_ind_timer_r14_present       = false;
  bool                                     sps_assist_info_report_r14_present  = false;
  bool                                     delay_budget_report_cfg_r14_present = false;
  bool                                     rlm_report_cfg_r14_present          = false;
  bw_pref_ind_timer_r14_e_                 bw_pref_ind_timer_r14;
  bool                                     sps_assist_info_report_r14 = false;
  copy_ptr<delay_budget_report_cfg_r14_c_> delay_budget_report_cfg_r14;
  copy_ptr<rlm_report_cfg_r14_c_>          rlm_report_cfg_r14;
  // group 2
  bool                                 overheat_assist_cfg_r14_present = false;
  copy_ptr<overheat_assist_cfg_r14_c_> overheat_assist_cfg_r14;
  // group 3
  bool                                meas_cfg_app_layer_r15_present = false;
  bool                                ailc_bit_cfg_r15_present       = false;
  bool                                bt_name_list_cfg_r15_present   = false;
  bool                                wlan_name_list_cfg_r15_present = false;
  copy_ptr<meas_cfg_app_layer_r15_c_> meas_cfg_app_layer_r15;
  bool                                ailc_bit_cfg_r15 = false;
  copy_ptr<bt_name_list_cfg_r15_c>    bt_name_list_cfg_r15;
  copy_ptr<wlan_name_list_cfg_r15_c>  wlan_name_list_cfg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityList3-r11 ::= SEQUENCE (SIZE (1..16)) OF PLMN-Identity
typedef dyn_array<plmn_id_s> plmn_id_list3_r11_l;

// PRACH-Config-v1310 ::= SEQUENCE
struct prach_cfg_v1310_s {
  struct mpdcch_start_sf_css_ra_r13_c_ {
    struct fdd_r13_opts {
      enum options { v1, v1dot5, v2, v2dot5, v4, v5, v8, v10, nulltype } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<fdd_r13_opts> fdd_r13_e_;
    struct tdd_r13_opts {
      enum options { v1, v2, v4, v5, v8, v10, v20, spare, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tdd_r13_opts> tdd_r13_e_;
    struct types_opts {
      enum options { fdd_r13, tdd_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    mpdcch_start_sf_css_ra_r13_c_() = default;
    mpdcch_start_sf_css_ra_r13_c_(const mpdcch_start_sf_css_ra_r13_c_& other);
    mpdcch_start_sf_css_ra_r13_c_& operator=(const mpdcch_start_sf_css_ra_r13_c_& other);
    ~mpdcch_start_sf_css_ra_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fdd_r13_e_& fdd_r13()
    {
      assert_choice_type("fdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<fdd_r13_e_>();
    }
    tdd_r13_e_& tdd_r13()
    {
      assert_choice_type("tdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<tdd_r13_e_>();
    }
    const fdd_r13_e_& fdd_r13() const
    {
      assert_choice_type("fdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<fdd_r13_e_>();
    }
    const tdd_r13_e_& tdd_r13() const
    {
      assert_choice_type("tdd-r13", type_.to_string(), "mpdcch-startSF-CSS-RA-r13");
      return c.get<tdd_r13_e_>();
    }
    fdd_r13_e_& set_fdd_r13()
    {
      set(types::fdd_r13);
      return c.get<fdd_r13_e_>();
    }
    tdd_r13_e_& set_tdd_r13()
    {
      set(types::tdd_r13);
      return c.get<tdd_r13_e_>();
    }

  private:
    types                                                         type_;
    choice_buffer_t<MAX2(sizeof(fdd_r13_e_), sizeof(tdd_r13_e_))> c;

    void destroy_();
  };

  // member variables
  bool                              rsrp_thress_prach_info_list_r13_present = false;
  bool                              mpdcch_start_sf_css_ra_r13_present      = false;
  bool                              prach_hop_offset_r13_present            = false;
  bool                              prach_params_list_ce_r13_present        = false;
  bool                              init_ce_level_r13_present               = false;
  rsrp_thress_prach_info_list_r13_l rsrp_thress_prach_info_list_r13;
  mpdcch_start_sf_css_ra_r13_c_     mpdcch_start_sf_css_ra_r13;
  uint8_t                           prach_hop_offset_r13 = 0;
  prach_params_list_ce_r13_l        prach_params_list_ce_r13;
  uint8_t                           init_ce_level_r13 = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigCDMA2000 ::= SEQUENCE
struct quant_cfg_cdma2000_s {
  struct meas_quant_cdma2000_opts {
    enum options { pilot_strength, pilot_pn_phase_and_pilot_strength, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<meas_quant_cdma2000_opts> meas_quant_cdma2000_e_;

  // member variables
  meas_quant_cdma2000_e_ meas_quant_cdma2000;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigEUTRA ::= SEQUENCE
struct quant_cfg_eutra_s {
  // member variables
  bool        filt_coef_rsrp_present = false;
  bool        filt_coef_rsrq_present = false;
  filt_coef_e filt_coef_rsrp;
  filt_coef_e filt_coef_rsrq;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigEUTRA-v1250 ::= SEQUENCE
struct quant_cfg_eutra_v1250_s {
  // member variables
  bool        filt_coef_csi_rsrp_r12_present = false;
  filt_coef_e filt_coef_csi_rsrp_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigEUTRA-v1310 ::= SEQUENCE
struct quant_cfg_eutra_v1310_s {
  // member variables
  bool        filt_coef_rs_sinr_r13_present = false;
  filt_coef_e filt_coef_rs_sinr_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigGERAN ::= SEQUENCE
struct quant_cfg_geran_s {
  // member variables
  bool        filt_coef_present = false;
  filt_coef_e filt_coef;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigNRList-r15 ::= SEQUENCE (SIZE (1..maxQuantSetsNR-r15)) OF QuantityConfigNR-r15
typedef dyn_array<quant_cfg_nr_r15_s> quant_cfg_nr_list_r15_l;

// QuantityConfigUTRA ::= SEQUENCE
struct quant_cfg_utra_s {
  struct meas_quant_utra_fdd_opts {
    enum options { cpich_rscp, cpich_ec_n0, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<meas_quant_utra_fdd_opts> meas_quant_utra_fdd_e_;

  // member variables
  bool                   filt_coef_present = false;
  meas_quant_utra_fdd_e_ meas_quant_utra_fdd;
  filt_coef_e            filt_coef;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigUTRA-v1020 ::= SEQUENCE
struct quant_cfg_utra_v1020_s {
  // member variables
  bool        filt_coef2_fdd_r10_present = false;
  filt_coef_e filt_coef2_fdd_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfigWLAN-r13 ::= SEQUENCE
struct quant_cfg_wlan_r13_s {
  // member variables
  bool        filt_coef_r13_present = false;
  filt_coef_e filt_coef_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v1020-IEs ::= SEQUENCE
struct rrc_conn_recfg_v1020_ies_s {
  // member variables
  bool                        s_cell_to_release_list_r10_present = false;
  bool                        s_cell_to_add_mod_list_r10_present = false;
  bool                        non_crit_ext_present               = false;
  scell_to_release_list_r10_l s_cell_to_release_list_r10;
  scell_to_add_mod_list_r10_l s_cell_to_add_mod_list_r10;
  rrc_conn_recfg_v1130_ies_s  non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v10i0-IEs ::= SEQUENCE
struct rrc_conn_recfg_v10i0_ies_s {
  // member variables
  bool                       ant_info_ded_pcell_v10i0_present = false;
  bool                       non_crit_ext_present             = false;
  ant_info_ded_v10i0_s       ant_info_ded_pcell_v10i0;
  rrc_conn_recfg_v10l0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease-v1020-IEs ::= SEQUENCE
struct rrc_conn_release_v1020_ies_s {
  // member variables
  bool                         extended_wait_time_r10_present = false;
  bool                         non_crit_ext_present           = false;
  uint16_t                     extended_wait_time_r10         = 1;
  rrc_conn_release_v1320_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResume-v1530-IEs ::= SEQUENCE
struct rrc_conn_resume_v1530_ies_s {
  // member variables
  bool full_cfg_r15_present = false;
  bool non_crit_ext_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RedirectedCarrierInfo-v9e0 ::= SEQUENCE
struct redirected_carrier_info_v9e0_s {
  // member variables
  uint32_t eutra_v9e0 = 65536;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReportConfigToAddMod ::= SEQUENCE
struct report_cfg_to_add_mod_s {
  struct report_cfg_c_ {
    struct types_opts {
      enum options { report_cfg_eutra, report_cfg_inter_rat, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    report_cfg_c_() = default;
    report_cfg_c_(const report_cfg_c_& other);
    report_cfg_c_& operator=(const report_cfg_c_& other);
    ~report_cfg_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    report_cfg_eutra_s& report_cfg_eutra()
    {
      assert_choice_type("reportConfigEUTRA", type_.to_string(), "reportConfig");
      return c.get<report_cfg_eutra_s>();
    }
    report_cfg_inter_rat_s& report_cfg_inter_rat()
    {
      assert_choice_type("reportConfigInterRAT", type_.to_string(), "reportConfig");
      return c.get<report_cfg_inter_rat_s>();
    }
    const report_cfg_eutra_s& report_cfg_eutra() const
    {
      assert_choice_type("reportConfigEUTRA", type_.to_string(), "reportConfig");
      return c.get<report_cfg_eutra_s>();
    }
    const report_cfg_inter_rat_s& report_cfg_inter_rat() const
    {
      assert_choice_type("reportConfigInterRAT", type_.to_string(), "reportConfig");
      return c.get<report_cfg_inter_rat_s>();
    }
    report_cfg_eutra_s& set_report_cfg_eutra()
    {
      set(types::report_cfg_eutra);
      return c.get<report_cfg_eutra_s>();
    }
    report_cfg_inter_rat_s& set_report_cfg_inter_rat()
    {
      set(types::report_cfg_inter_rat);
      return c.get<report_cfg_inter_rat_s>();
    }

  private:
    types                                                                             type_;
    choice_buffer_t<MAX2(sizeof(report_cfg_eutra_s), sizeof(report_cfg_inter_rat_s))> c;

    void destroy_();
  };

  // member variables
  uint8_t       report_cfg_id = 1;
  report_cfg_c_ report_cfg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityEnquiry-v1310-IEs ::= SEQUENCE
struct ue_cap_enquiry_v1310_ies_s {
  // member variables
  bool                       request_reduced_format_r13_present            = false;
  bool                       request_skip_fallback_comb_r13_present        = false;
  bool                       requested_max_ccs_dl_r13_present              = false;
  bool                       requested_max_ccs_ul_r13_present              = false;
  bool                       request_reduced_int_non_cont_comb_r13_present = false;
  bool                       non_crit_ext_present                          = false;
  uint8_t                    requested_max_ccs_dl_r13                      = 2;
  uint8_t                    requested_max_ccs_ul_r13                      = 2;
  ue_cap_enquiry_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationRequest-v1130-IEs ::= SEQUENCE
struct ue_info_request_v1130_ies_s {
  // member variables
  bool                        conn_est_fail_report_req_r11_present = false;
  bool                        non_crit_ext_present                 = false;
  ue_info_request_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierBandwidthEUTRA ::= SEQUENCE
struct carrier_bw_eutra_s {
  struct dl_bw_opts {
    enum options {
      n6,
      n15,
      n25,
      n50,
      n75,
      n100,
      spare10,
      spare9,
      spare8,
      spare7,
      spare6,
      spare5,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<dl_bw_opts> dl_bw_e_;
  struct ul_bw_opts {
    enum options {
      n6,
      n15,
      n25,
      n50,
      n75,
      n100,
      spare10,
      spare9,
      spare8,
      spare7,
      spare6,
      spare5,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ul_bw_opts> ul_bw_e_;

  // member variables
  bool     ul_bw_present = false;
  dl_bw_e_ dl_bw;
  ul_bw_e_ ul_bw;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqEUTRA ::= SEQUENCE
struct carrier_freq_eutra_s {
  // member variables
  bool     ul_carrier_freq_present = false;
  uint16_t dl_carrier_freq         = 0;
  uint16_t ul_carrier_freq         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqEUTRA-v9e0 ::= SEQUENCE
struct carrier_freq_eutra_v9e0_s {
  // member variables
  bool     ul_carrier_freq_v9e0_present = false;
  uint32_t dl_carrier_freq_v9e0         = 0;
  uint32_t ul_carrier_freq_v9e0         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierInfoNR-r15 ::= SEQUENCE
struct carrier_info_nr_r15_s {
  struct subcarrier_spacing_ssb_r15_opts {
    enum options { k_hz15, k_hz30, k_hz120, k_hz240, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<subcarrier_spacing_ssb_r15_opts> subcarrier_spacing_ssb_r15_e_;

  // member variables
  bool                          smtc_r15_present = false;
  uint32_t                      carrier_freq_r15 = 0;
  subcarrier_spacing_ssb_r15_e_ subcarrier_spacing_ssb_r15;
  mtc_ssb_nr_r15_s              smtc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellGlobalIdList-r10 ::= SEQUENCE (SIZE (1..32)) OF CellGlobalIdEUTRA
typedef dyn_array<cell_global_id_eutra_s> cell_global_id_list_r10_l;

// CounterCheck-v1530-IEs ::= SEQUENCE
struct counter_check_v1530_ies_s {
  // member variables
  bool                              drb_count_msb_info_list_ext_r15_present = false;
  bool                              non_crit_ext_present                    = false;
  drb_count_msb_info_list_ext_r15_l drb_count_msb_info_list_ext_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverFromEUTRAPreparationRequest-v920-IEs ::= SEQUENCE
struct ho_from_eutra_prep_request_v920_ies_s {
  // member variables
  bool                                   concurr_prep_cdma2000_hrpd_r9_present = false;
  bool                                   non_crit_ext_present                  = false;
  bool                                   concurr_prep_cdma2000_hrpd_r9         = false;
  ho_from_eutra_prep_request_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoggedMeasurementConfiguration-v1130-IEs ::= SEQUENCE
struct logged_meas_cfg_v1130_ies_s {
  // member variables
  bool                        plmn_id_list_r11_present = false;
  bool                        area_cfg_v1130_present   = false;
  bool                        non_crit_ext_present     = false;
  plmn_id_list3_r11_l         plmn_id_list_r11;
  area_cfg_v1130_s            area_cfg_v1130;
  logged_meas_cfg_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasGapConfigDensePRS-r15 ::= CHOICE
struct meas_gap_cfg_dense_prs_r15_c {
  struct setup_s_ {
    struct gap_offset_dense_prs_r15_c_ {
      struct types_opts {
        enum options {
          rstd0_r15,
          rstd1_r15,
          rstd2_r15,
          rstd3_r15,
          rstd4_r15,
          rstd5_r15,
          rstd6_r15,
          rstd7_r15,
          rstd8_r15,
          rstd9_r15,
          rstd10_r15,
          rstd11_r15,
          rstd12_r15,
          rstd13_r15,
          rstd14_r15,
          rstd15_r15,
          rstd16_r15,
          rstd17_r15,
          rstd18_r15,
          rstd19_r15,
          rstd20_r15,
          // ...
          nulltype
        } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<types_opts, true> types;

      // choice methods
      gap_offset_dense_prs_r15_c_() = default;
      gap_offset_dense_prs_r15_c_(const gap_offset_dense_prs_r15_c_& other);
      gap_offset_dense_prs_r15_c_& operator=(const gap_offset_dense_prs_r15_c_& other);
      ~gap_offset_dense_prs_r15_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint8_t& rstd0_r15()
      {
        assert_choice_type("rstd0-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint8_t>();
      }
      uint8_t& rstd1_r15()
      {
        assert_choice_type("rstd1-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint8_t>();
      }
      uint16_t& rstd2_r15()
      {
        assert_choice_type("rstd2-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd3_r15()
      {
        assert_choice_type("rstd3-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd4_r15()
      {
        assert_choice_type("rstd4-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint8_t& rstd5_r15()
      {
        assert_choice_type("rstd5-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint8_t>();
      }
      uint16_t& rstd6_r15()
      {
        assert_choice_type("rstd6-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd7_r15()
      {
        assert_choice_type("rstd7-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd8_r15()
      {
        assert_choice_type("rstd8-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd9_r15()
      {
        assert_choice_type("rstd9-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd10_r15()
      {
        assert_choice_type("rstd10-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd11_r15()
      {
        assert_choice_type("rstd11-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd12_r15()
      {
        assert_choice_type("rstd12-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd13_r15()
      {
        assert_choice_type("rstd13-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd14_r15()
      {
        assert_choice_type("rstd14-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd15_r15()
      {
        assert_choice_type("rstd15-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd16_r15()
      {
        assert_choice_type("rstd16-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd17_r15()
      {
        assert_choice_type("rstd17-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd18_r15()
      {
        assert_choice_type("rstd18-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd19_r15()
      {
        assert_choice_type("rstd19-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint16_t& rstd20_r15()
      {
        assert_choice_type("rstd20-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint8_t& rstd0_r15() const
      {
        assert_choice_type("rstd0-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint8_t>();
      }
      const uint8_t& rstd1_r15() const
      {
        assert_choice_type("rstd1-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint8_t>();
      }
      const uint16_t& rstd2_r15() const
      {
        assert_choice_type("rstd2-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd3_r15() const
      {
        assert_choice_type("rstd3-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd4_r15() const
      {
        assert_choice_type("rstd4-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint8_t& rstd5_r15() const
      {
        assert_choice_type("rstd5-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint8_t>();
      }
      const uint16_t& rstd6_r15() const
      {
        assert_choice_type("rstd6-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd7_r15() const
      {
        assert_choice_type("rstd7-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd8_r15() const
      {
        assert_choice_type("rstd8-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd9_r15() const
      {
        assert_choice_type("rstd9-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd10_r15() const
      {
        assert_choice_type("rstd10-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd11_r15() const
      {
        assert_choice_type("rstd11-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd12_r15() const
      {
        assert_choice_type("rstd12-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd13_r15() const
      {
        assert_choice_type("rstd13-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd14_r15() const
      {
        assert_choice_type("rstd14-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd15_r15() const
      {
        assert_choice_type("rstd15-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd16_r15() const
      {
        assert_choice_type("rstd16-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd17_r15() const
      {
        assert_choice_type("rstd17-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd18_r15() const
      {
        assert_choice_type("rstd18-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd19_r15() const
      {
        assert_choice_type("rstd19-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      const uint16_t& rstd20_r15() const
      {
        assert_choice_type("rstd20-r15", type_.to_string(), "gapOffsetDensePRS-r15");
        return c.get<uint16_t>();
      }
      uint8_t& set_rstd0_r15()
      {
        set(types::rstd0_r15);
        return c.get<uint8_t>();
      }
      uint8_t& set_rstd1_r15()
      {
        set(types::rstd1_r15);
        return c.get<uint8_t>();
      }
      uint16_t& set_rstd2_r15()
      {
        set(types::rstd2_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd3_r15()
      {
        set(types::rstd3_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd4_r15()
      {
        set(types::rstd4_r15);
        return c.get<uint16_t>();
      }
      uint8_t& set_rstd5_r15()
      {
        set(types::rstd5_r15);
        return c.get<uint8_t>();
      }
      uint16_t& set_rstd6_r15()
      {
        set(types::rstd6_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd7_r15()
      {
        set(types::rstd7_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd8_r15()
      {
        set(types::rstd8_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd9_r15()
      {
        set(types::rstd9_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd10_r15()
      {
        set(types::rstd10_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd11_r15()
      {
        set(types::rstd11_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd12_r15()
      {
        set(types::rstd12_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd13_r15()
      {
        set(types::rstd13_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd14_r15()
      {
        set(types::rstd14_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd15_r15()
      {
        set(types::rstd15_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd16_r15()
      {
        set(types::rstd16_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd17_r15()
      {
        set(types::rstd17_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd18_r15()
      {
        set(types::rstd18_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd19_r15()
      {
        set(types::rstd19_r15);
        return c.get<uint16_t>();
      }
      uint16_t& set_rstd20_r15()
      {
        set(types::rstd20_r15);
        return c.get<uint16_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };

    // member variables
    gap_offset_dense_prs_r15_c_ gap_offset_dense_prs_r15;
  };
  typedef setup_e types;

  // choice methods
  meas_gap_cfg_dense_prs_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapConfigDensePRS-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapConfigDensePRS-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// MeasGapConfigPerCC-List-r14 ::= CHOICE
struct meas_gap_cfg_per_cc_list_r14_c {
  struct setup_s_ {
    // member variables
    bool                               meas_gap_cfg_to_rem_list_r14_present     = false;
    bool                               meas_gap_cfg_to_add_mod_list_r14_present = false;
    meas_gap_cfg_to_rem_list_r14_l     meas_gap_cfg_to_rem_list_r14;
    meas_gap_cfg_to_add_mod_list_r14_l meas_gap_cfg_to_add_mod_list_r14;
  };
  typedef setup_e types;

  // choice methods
  meas_gap_cfg_per_cc_list_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapConfigPerCC-List-r14");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapConfigPerCC-List-r14");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// MeasGapSharingConfig-r14 ::= CHOICE
struct meas_gap_sharing_cfg_r14_c {
  struct setup_s_ {
    struct meas_gap_sharing_scheme_r14_opts {
      enum options { scheme00, scheme01, scheme10, scheme11, nulltype } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<meas_gap_sharing_scheme_r14_opts> meas_gap_sharing_scheme_r14_e_;

    // member variables
    meas_gap_sharing_scheme_r14_e_ meas_gap_sharing_scheme_r14;
  };
  typedef setup_e types;

  // choice methods
  meas_gap_sharing_cfg_r14_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapSharingConfig-r14");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "MeasGapSharingConfig-r14");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// MeasIdToAddModList ::= SEQUENCE (SIZE (1..maxMeasId)) OF MeasIdToAddMod
typedef dyn_array<meas_id_to_add_mod_s> meas_id_to_add_mod_list_l;

// MeasIdToAddModList-v1310 ::= SEQUENCE (SIZE (1..maxMeasId)) OF MeasIdToAddMod-v1310
typedef dyn_array<meas_id_to_add_mod_v1310_s> meas_id_to_add_mod_list_v1310_l;

// MeasIdToAddModListExt-r12 ::= SEQUENCE (SIZE (1..maxMeasId)) OF MeasIdToAddModExt-r12
typedef dyn_array<meas_id_to_add_mod_ext_r12_s> meas_id_to_add_mod_list_ext_r12_l;

// MeasIdToAddModListExt-v1310 ::= SEQUENCE (SIZE (1..maxMeasId)) OF MeasIdToAddMod-v1310
typedef dyn_array<meas_id_to_add_mod_v1310_s> meas_id_to_add_mod_list_ext_v1310_l;

// MeasIdToRemoveList ::= SEQUENCE (SIZE (1..maxMeasId)) OF INTEGER
typedef bounded_array<uint8_t, 32> meas_id_to_rem_list_l;

// MeasIdToRemoveListExt-r12 ::= SEQUENCE (SIZE (1..maxMeasId)) OF INTEGER
typedef bounded_array<uint8_t, 32> meas_id_to_rem_list_ext_r12_l;

// MeasObjectToAddModList ::= SEQUENCE (SIZE (1..maxObjectId)) OF MeasObjectToAddMod
typedef dyn_array<meas_obj_to_add_mod_s> meas_obj_to_add_mod_list_l;

// MeasObjectToAddModList-v9e0 ::= SEQUENCE (SIZE (1..maxObjectId)) OF MeasObjectToAddMod-v9e0
typedef dyn_array<meas_obj_to_add_mod_v9e0_s> meas_obj_to_add_mod_list_v9e0_l;

// MeasObjectToAddModListExt-r13 ::= SEQUENCE (SIZE (1..maxObjectId)) OF MeasObjectToAddModExt-r13
typedef dyn_array<meas_obj_to_add_mod_ext_r13_s> meas_obj_to_add_mod_list_ext_r13_l;

// MeasObjectToRemoveList ::= SEQUENCE (SIZE (1..maxObjectId)) OF INTEGER
typedef bounded_array<uint8_t, 32> meas_obj_to_rem_list_l;

// MeasObjectToRemoveListExt-r13 ::= SEQUENCE (SIZE (1..maxObjectId)) OF INTEGER
typedef bounded_array<uint8_t, 32> meas_obj_to_rem_list_ext_r13_l;

// MeasScaleFactor-r12 ::= ENUMERATED
struct meas_scale_factor_r12_opts {
  enum options { sf_eutra_cf1, sf_eutra_cf2, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<meas_scale_factor_r12_opts> meas_scale_factor_r12_e;

// MobilityControlInfoV2X-r14 ::= SEQUENCE
struct mob_ctrl_info_v2x_r14_s {
  // member variables
  bool                            v2x_comm_tx_pool_exceptional_r14_present = false;
  bool                            v2x_comm_rx_pool_r14_present             = false;
  bool                            v2x_comm_sync_cfg_r14_present            = false;
  bool                            cbr_mob_tx_cfg_list_r14_present          = false;
  sl_comm_res_pool_v2x_r14_s      v2x_comm_tx_pool_exceptional_r14;
  sl_comm_rx_pool_list_v2x_r14_l  v2x_comm_rx_pool_r14;
  sl_sync_cfg_list_v2x_r14_l      v2x_comm_sync_cfg_r14;
  sl_cbr_common_tx_cfg_list_r14_s cbr_mob_tx_cfg_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand-v8d0-IEs ::= SEQUENCE
struct mob_from_eutra_cmd_v8d0_ies_s {
  // member variables
  bool             band_ind_present     = false;
  bool             non_crit_ext_present = false;
  band_ind_geran_e band_ind;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand-v960-IEs ::= SEQUENCE
struct mob_from_eutra_cmd_v960_ies_s {
  // member variables
  bool                           band_ind_present     = false;
  bool                           non_crit_ext_present = false;
  band_ind_geran_e               band_ind;
  mob_from_eutra_cmd_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QuantityConfig ::= SEQUENCE
struct quant_cfg_s {
  // member variables
  bool                 ext                        = false;
  bool                 quant_cfg_eutra_present    = false;
  bool                 quant_cfg_utra_present     = false;
  bool                 quant_cfg_geran_present    = false;
  bool                 quant_cfg_cdma2000_present = false;
  quant_cfg_eutra_s    quant_cfg_eutra;
  quant_cfg_utra_s     quant_cfg_utra;
  quant_cfg_geran_s    quant_cfg_geran;
  quant_cfg_cdma2000_s quant_cfg_cdma2000;
  // ...
  // group 0
  bool                             quant_cfg_utra_v1020_present = false;
  copy_ptr<quant_cfg_utra_v1020_s> quant_cfg_utra_v1020;
  // group 1
  bool                              quant_cfg_eutra_v1250_present = false;
  copy_ptr<quant_cfg_eutra_v1250_s> quant_cfg_eutra_v1250;
  // group 2
  bool                              quant_cfg_eutra_v1310_present = false;
  bool                              quant_cfg_wlan_r13_present    = false;
  copy_ptr<quant_cfg_eutra_v1310_s> quant_cfg_eutra_v1310;
  copy_ptr<quant_cfg_wlan_r13_s>    quant_cfg_wlan_r13;
  // group 3
  bool                              quant_cfg_nr_list_r15_present = false;
  copy_ptr<quant_cfg_nr_list_r15_l> quant_cfg_nr_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RAT-Type ::= ENUMERATED
struct rat_type_opts {
  enum options { eutra, utra, geran_cs, geran_ps, cdma2000_minus1_xrtt, nr, eutra_nr, spare1, /*...*/ nulltype } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<rat_type_opts, true> rat_type_e;

// RRCConnectionReconfiguration-v8m0-IEs ::= SEQUENCE
struct rrc_conn_recfg_v8m0_ies_s {
  // member variables
  bool                       late_non_crit_ext_present = false;
  bool                       non_crit_ext_present      = false;
  dyn_octstring              late_non_crit_ext;
  rrc_conn_recfg_v10i0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v920-IEs ::= SEQUENCE
struct rrc_conn_recfg_v920_ies_s {
  // member variables
  bool                       other_cfg_r9_present = false;
  bool                       full_cfg_r9_present  = false;
  bool                       non_crit_ext_present = false;
  other_cfg_r9_s             other_cfg_r9;
  rrc_conn_recfg_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease-v920-IEs ::= SEQUENCE
struct rrc_conn_release_v920_ies_s {
  struct cell_info_list_r9_c_ {
    struct types_opts {
      enum options { geran_r9, utra_fdd_r9, utra_tdd_r9, /*...*/ utra_tdd_r10, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts, true, 1> types;

    // choice methods
    cell_info_list_r9_c_() = default;
    cell_info_list_r9_c_(const cell_info_list_r9_c_& other);
    cell_info_list_r9_c_& operator=(const cell_info_list_r9_c_& other);
    ~cell_info_list_r9_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cell_info_list_geran_r9_l& geran_r9()
    {
      assert_choice_type("geran-r9", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_geran_r9_l>();
    }
    cell_info_list_utra_fdd_r9_l& utra_fdd_r9()
    {
      assert_choice_type("utra-FDD-r9", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_utra_fdd_r9_l>();
    }
    cell_info_list_utra_tdd_r9_l& utra_tdd_r9()
    {
      assert_choice_type("utra-TDD-r9", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_utra_tdd_r9_l>();
    }
    cell_info_list_utra_tdd_r10_l& utra_tdd_r10()
    {
      assert_choice_type("utra-TDD-r10", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_utra_tdd_r10_l>();
    }
    const cell_info_list_geran_r9_l& geran_r9() const
    {
      assert_choice_type("geran-r9", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_geran_r9_l>();
    }
    const cell_info_list_utra_fdd_r9_l& utra_fdd_r9() const
    {
      assert_choice_type("utra-FDD-r9", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_utra_fdd_r9_l>();
    }
    const cell_info_list_utra_tdd_r9_l& utra_tdd_r9() const
    {
      assert_choice_type("utra-TDD-r9", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_utra_tdd_r9_l>();
    }
    const cell_info_list_utra_tdd_r10_l& utra_tdd_r10() const
    {
      assert_choice_type("utra-TDD-r10", type_.to_string(), "cellInfoList-r9");
      return c.get<cell_info_list_utra_tdd_r10_l>();
    }
    cell_info_list_geran_r9_l& set_geran_r9()
    {
      set(types::geran_r9);
      return c.get<cell_info_list_geran_r9_l>();
    }
    cell_info_list_utra_fdd_r9_l& set_utra_fdd_r9()
    {
      set(types::utra_fdd_r9);
      return c.get<cell_info_list_utra_fdd_r9_l>();
    }
    cell_info_list_utra_tdd_r9_l& set_utra_tdd_r9()
    {
      set(types::utra_tdd_r9);
      return c.get<cell_info_list_utra_tdd_r9_l>();
    }
    cell_info_list_utra_tdd_r10_l& set_utra_tdd_r10()
    {
      set(types::utra_tdd_r10);
      return c.get<cell_info_list_utra_tdd_r10_l>();
    }

  private:
    types type_;
    choice_buffer_t<MAX4(sizeof(cell_info_list_geran_r9_l),
                         sizeof(cell_info_list_utra_fdd_r9_l),
                         sizeof(cell_info_list_utra_tdd_r10_l),
                         sizeof(cell_info_list_utra_tdd_r9_l))>
        c;

    void destroy_();
  };

  // member variables
  bool                         cell_info_list_r9_present = false;
  bool                         non_crit_ext_present      = false;
  cell_info_list_r9_c_         cell_info_list_r9;
  rrc_conn_release_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease-v9e0-IEs ::= SEQUENCE
struct rrc_conn_release_v9e0_ies_s {
  // member variables
  bool                           redirected_carrier_info_v9e0_present = false;
  bool                           idle_mode_mob_ctrl_info_v9e0_present = false;
  bool                           non_crit_ext_present                 = false;
  redirected_carrier_info_v9e0_s redirected_carrier_info_v9e0;
  idle_mode_mob_ctrl_info_v9e0_s idle_mode_mob_ctrl_info_v9e0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResume-v1510-IEs ::= SEQUENCE
struct rrc_conn_resume_v1510_ies_s {
  // member variables
  bool                        sk_counter_r15_present           = false;
  bool                        nr_radio_bearer_cfg1_r15_present = false;
  bool                        nr_radio_bearer_cfg2_r15_present = false;
  bool                        non_crit_ext_present             = false;
  uint16_t                    sk_counter_r15                   = 0;
  dyn_octstring               nr_radio_bearer_cfg1_r15;
  dyn_octstring               nr_radio_bearer_cfg2_r15;
  rrc_conn_resume_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceConfigCommon ::= SEQUENCE
struct rr_cfg_common_s {
  // member variables
  bool                 ext                        = false;
  bool                 rach_cfg_common_present    = false;
  bool                 pdsch_cfg_common_present   = false;
  bool                 phich_cfg_present          = false;
  bool                 pucch_cfg_common_present   = false;
  bool                 srs_ul_cfg_common_present  = false;
  bool                 ul_pwr_ctrl_common_present = false;
  bool                 ant_info_common_present    = false;
  bool                 p_max_present              = false;
  bool                 tdd_cfg_present            = false;
  rach_cfg_common_s    rach_cfg_common;
  prach_cfg_s          prach_cfg;
  pdsch_cfg_common_s   pdsch_cfg_common;
  pusch_cfg_common_s   pusch_cfg_common;
  phich_cfg_s          phich_cfg;
  pucch_cfg_common_s   pucch_cfg_common;
  srs_ul_cfg_common_c  srs_ul_cfg_common;
  ul_pwr_ctrl_common_s ul_pwr_ctrl_common;
  ant_info_common_s    ant_info_common;
  int8_t               p_max = -30;
  tdd_cfg_s            tdd_cfg;
  ul_cp_len_e          ul_cp_len;
  // ...
  // group 0
  bool                                 ul_pwr_ctrl_common_v1020_present = false;
  copy_ptr<ul_pwr_ctrl_common_v1020_s> ul_pwr_ctrl_common_v1020;
  // group 1
  bool                      tdd_cfg_v1130_present = false;
  copy_ptr<tdd_cfg_v1130_s> tdd_cfg_v1130;
  // group 2
  bool                               pusch_cfg_common_v1270_present = false;
  copy_ptr<pusch_cfg_common_v1270_s> pusch_cfg_common_v1270;
  // group 3
  bool                                 prach_cfg_v1310_present          = false;
  bool                                 freq_hop_params_r13_present      = false;
  bool                                 pdsch_cfg_common_v1310_present   = false;
  bool                                 pucch_cfg_common_v1310_present   = false;
  bool                                 pusch_cfg_common_v1310_present   = false;
  bool                                 ul_pwr_ctrl_common_v1310_present = false;
  copy_ptr<prach_cfg_v1310_s>          prach_cfg_v1310;
  copy_ptr<freq_hop_params_r13_s>      freq_hop_params_r13;
  copy_ptr<pdsch_cfg_common_v1310_s>   pdsch_cfg_common_v1310;
  copy_ptr<pucch_cfg_common_v1310_s>   pucch_cfg_common_v1310;
  copy_ptr<pusch_cfg_common_v1310_s>   pusch_cfg_common_v1310;
  copy_ptr<ul_pwr_ctrl_common_v1310_s> ul_pwr_ctrl_common_v1310;
  // group 4
  bool                               high_speed_cfg_r14_present     = false;
  bool                               prach_cfg_v1430_present        = false;
  bool                               pucch_cfg_common_v1430_present = false;
  bool                               tdd_cfg_v1430_present          = false;
  copy_ptr<high_speed_cfg_r14_s>     high_speed_cfg_r14;
  copy_ptr<prach_cfg_v1430_s>        prach_cfg_v1430;
  copy_ptr<pucch_cfg_common_v1430_s> pucch_cfg_common_v1430;
  copy_ptr<tdd_cfg_v1430_s>          tdd_cfg_v1430;
  // group 5
  bool                      tdd_cfg_v1450_present = false;
  copy_ptr<tdd_cfg_v1450_s> tdd_cfg_v1450;
  // group 6
  bool                                 ul_pwr_ctrl_common_v1530_present = false;
  bool                                 high_speed_cfg_v1530_present     = false;
  copy_ptr<ul_pwr_ctrl_common_v1530_s> ul_pwr_ctrl_common_v1530;
  copy_ptr<high_speed_cfg_v1530_s>     high_speed_cfg_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReportConfigToAddModList ::= SEQUENCE (SIZE (1..maxReportConfigId)) OF ReportConfigToAddMod
typedef dyn_array<report_cfg_to_add_mod_s> report_cfg_to_add_mod_list_l;

// ReportConfigToRemoveList ::= SEQUENCE (SIZE (1..maxReportConfigId)) OF INTEGER
typedef bounded_array<uint8_t, 32> report_cfg_to_rem_list_l;

// SI-OrPSI-GERAN ::= CHOICE
struct si_or_psi_geran_c {
  struct types_opts {
    enum options { si, psi, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  si_or_psi_geran_c() = default;
  si_or_psi_geran_c(const si_or_psi_geran_c& other);
  si_or_psi_geran_c& operator=(const si_or_psi_geran_c& other);
  ~si_or_psi_geran_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  sys_info_list_geran_l& si()
  {
    assert_choice_type("si", type_.to_string(), "SI-OrPSI-GERAN");
    return c.get<sys_info_list_geran_l>();
  }
  sys_info_list_geran_l& psi()
  {
    assert_choice_type("psi", type_.to_string(), "SI-OrPSI-GERAN");
    return c.get<sys_info_list_geran_l>();
  }
  const sys_info_list_geran_l& si() const
  {
    assert_choice_type("si", type_.to_string(), "SI-OrPSI-GERAN");
    return c.get<sys_info_list_geran_l>();
  }
  const sys_info_list_geran_l& psi() const
  {
    assert_choice_type("psi", type_.to_string(), "SI-OrPSI-GERAN");
    return c.get<sys_info_list_geran_l>();
  }
  sys_info_list_geran_l& set_si()
  {
    set(types::si);
    return c.get<sys_info_list_geran_l>();
  }
  sys_info_list_geran_l& set_psi()
  {
    set(types::psi);
    return c.get<sys_info_list_geran_l>();
  }

private:
  types                                          type_;
  choice_buffer_t<sizeof(sys_info_list_geran_l)> c;

  void destroy_();
};

// TrackingAreaCodeList-r10 ::= SEQUENCE (SIZE (1..8)) OF BIT STRING
typedef bounded_array<fixed_bitstring<16>, 8> tac_list_r10_l;

// UECapabilityEnquiry-v1180-IEs ::= SEQUENCE
struct ue_cap_enquiry_v1180_ies_s {
  typedef bounded_array<uint16_t, 16> requested_freq_bands_r11_l_;

  // member variables
  bool                        requested_freq_bands_r11_present = false;
  bool                        non_crit_ext_present             = false;
  requested_freq_bands_r11_l_ requested_freq_bands_r11;
  ue_cap_enquiry_v1310_ies_s  non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationRequest-v1020-IEs ::= SEQUENCE
struct ue_info_request_v1020_ies_s {
  // member variables
  bool                        log_meas_report_req_r10_present = false;
  bool                        non_crit_ext_present            = false;
  ue_info_request_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AreaConfiguration-r10 ::= CHOICE
struct area_cfg_r10_c {
  struct types_opts {
    enum options { cell_global_id_list_r10, tac_list_r10, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  area_cfg_r10_c() = default;
  area_cfg_r10_c(const area_cfg_r10_c& other);
  area_cfg_r10_c& operator=(const area_cfg_r10_c& other);
  ~area_cfg_r10_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  cell_global_id_list_r10_l& cell_global_id_list_r10()
  {
    assert_choice_type("cellGlobalIdList-r10", type_.to_string(), "AreaConfiguration-r10");
    return c.get<cell_global_id_list_r10_l>();
  }
  tac_list_r10_l& tac_list_r10()
  {
    assert_choice_type("trackingAreaCodeList-r10", type_.to_string(), "AreaConfiguration-r10");
    return c.get<tac_list_r10_l>();
  }
  const cell_global_id_list_r10_l& cell_global_id_list_r10() const
  {
    assert_choice_type("cellGlobalIdList-r10", type_.to_string(), "AreaConfiguration-r10");
    return c.get<cell_global_id_list_r10_l>();
  }
  const tac_list_r10_l& tac_list_r10() const
  {
    assert_choice_type("trackingAreaCodeList-r10", type_.to_string(), "AreaConfiguration-r10");
    return c.get<tac_list_r10_l>();
  }
  cell_global_id_list_r10_l& set_cell_global_id_list_r10()
  {
    set(types::cell_global_id_list_r10);
    return c.get<cell_global_id_list_r10_l>();
  }
  tac_list_r10_l& set_tac_list_r10()
  {
    set(types::tac_list_r10);
    return c.get<tac_list_r10_l>();
  }

private:
  types                                                                            type_;
  choice_buffer_t<MAX2(sizeof(cell_global_id_list_r10_l), sizeof(tac_list_r10_l))> c;

  void destroy_();
};

// CSFBParametersResponseCDMA2000-v8a0-IEs ::= SEQUENCE
struct csfb_params_resp_cdma2000_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellChangeOrder ::= SEQUENCE
struct cell_change_order_s {
  struct t304_opts {
    enum options { ms100, ms200, ms500, ms1000, ms2000, ms4000, ms8000, ms10000_v1310, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t304_opts> t304_e_;
  struct target_rat_type_c_ {
    struct geran_s_ {
      // member variables
      bool                 network_ctrl_order_present = false;
      bool                 sys_info_present           = false;
      pci_geran_s          pci;
      carrier_freq_geran_s carrier_freq;
      fixed_bitstring<2>   network_ctrl_order;
      si_or_psi_geran_c    sys_info;
    };
    struct types_opts {
      enum options { geran, /*...*/ nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts, true> types;

    // choice methods
    types       type() const { return types::geran; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    geran_s_&       geran() { return c; }
    const geran_s_& geran() const { return c; }

  private:
    geran_s_ c;
  };

  // member variables
  t304_e_            t304;
  target_rat_type_c_ target_rat_type;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CounterCheck-v8a0-IEs ::= SEQUENCE
struct counter_check_v8a0_ies_s {
  // member variables
  bool                      late_non_crit_ext_present = false;
  bool                      non_crit_ext_present      = false;
  dyn_octstring             late_non_crit_ext;
  counter_check_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DLInformationTransfer-v8a0-IEs ::= SEQUENCE
struct dl_info_transfer_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-CountMSB-InfoList ::= SEQUENCE (SIZE (1..maxDRB)) OF DRB-CountMSB-Info
typedef dyn_array<drb_count_msb_info_s> drb_count_msb_info_list_l;

// E-CSFB-r9 ::= SEQUENCE
struct e_csfb_r9_s {
  struct mob_cdma2000_hrpd_r9_opts {
    enum options { ho, redirection, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<mob_cdma2000_hrpd_r9_opts> mob_cdma2000_hrpd_r9_e_;

  // member variables
  bool                    msg_cont_cdma2000_minus1_xrtt_r9_present  = false;
  bool                    mob_cdma2000_hrpd_r9_present              = false;
  bool                    msg_cont_cdma2000_hrpd_r9_present         = false;
  bool                    redirect_carrier_cdma2000_hrpd_r9_present = false;
  dyn_octstring           msg_cont_cdma2000_minus1_xrtt_r9;
  mob_cdma2000_hrpd_r9_e_ mob_cdma2000_hrpd_r9;
  dyn_octstring           msg_cont_cdma2000_hrpd_r9;
  carrier_freq_cdma2000_s redirect_carrier_cdma2000_hrpd_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Handover ::= SEQUENCE
struct ho_s {
  struct target_rat_type_opts {
    enum options {
      utra,
      geran,
      cdma2000_minus1_xrtt,
      cdma2000_hrpd,
      nr,
      eutra,
      spare2,
      spare1,
      /*...*/ nulltype
    } value;

    std::string to_string() const;
  };
  typedef enumerated<target_rat_type_opts, true> target_rat_type_e_;

  // member variables
  bool               nas_security_param_from_eutra_present = false;
  bool               sys_info_present                      = false;
  target_rat_type_e_ target_rat_type;
  dyn_octstring      target_rat_msg_container;
  fixed_octstring<1> nas_security_param_from_eutra;
  si_or_psi_geran_c  sys_info;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverFromEUTRAPreparationRequest-v890-IEs ::= SEQUENCE
struct ho_from_eutra_prep_request_v890_ies_s {
  // member variables
  bool                                  late_non_crit_ext_present = false;
  bool                                  non_crit_ext_present      = false;
  dyn_octstring                         late_non_crit_ext;
  ho_from_eutra_prep_request_v920_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoggedMeasurementConfiguration-v1080-IEs ::= SEQUENCE
struct logged_meas_cfg_v1080_ies_s {
  // member variables
  bool                        late_non_crit_ext_r10_present = false;
  bool                        non_crit_ext_present          = false;
  dyn_octstring               late_non_crit_ext_r10;
  logged_meas_cfg_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoggingDuration-r10 ::= ENUMERATED
struct logging_dur_r10_opts {
  enum options { min10, min20, min40, min60, min90, min120, spare2, spare1, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<logging_dur_r10_opts> logging_dur_r10_e;

// LoggingInterval-r10 ::= ENUMERATED
struct logging_interv_r10_opts {
  enum options { ms1280, ms2560, ms5120, ms10240, ms20480, ms30720, ms40960, ms61440, nulltype } value;
  typedef uint16_t number_type;

  std::string to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<logging_interv_r10_opts> logging_interv_r10_e;

// MeasConfig ::= SEQUENCE
struct meas_cfg_s {
  struct speed_state_pars_c_ {
    struct setup_s_ {
      // member variables
      mob_state_params_s          mob_state_params;
      speed_state_scale_factors_s time_to_trigger_sf;
    };
    typedef setup_e types;

    // choice methods
    speed_state_pars_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "speedStatePars");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "speedStatePars");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };
  struct meas_scale_factor_r12_c_ {
    typedef setup_e types;

    // choice methods
    meas_scale_factor_r12_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    meas_scale_factor_r12_e& setup()
    {
      assert_choice_type("setup", type_.to_string(), "measScaleFactor-r12");
      return c;
    }
    const meas_scale_factor_r12_e& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "measScaleFactor-r12");
      return c;
    }
    meas_scale_factor_r12_e& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types                   type_;
    meas_scale_factor_r12_e c;
  };
  struct height_thresh_ref_r15_c_ {
    typedef setup_e types;

    // choice methods
    height_thresh_ref_r15_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& setup()
    {
      assert_choice_type("setup", type_.to_string(), "heightThreshRef-r15");
      return c;
    }
    const uint8_t& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "heightThreshRef-r15");
      return c;
    }
    uint8_t& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types   type_;
    uint8_t c;
  };

  // member variables
  bool                         ext                                = false;
  bool                         meas_obj_to_rem_list_present       = false;
  bool                         meas_obj_to_add_mod_list_present   = false;
  bool                         report_cfg_to_rem_list_present     = false;
  bool                         report_cfg_to_add_mod_list_present = false;
  bool                         meas_id_to_rem_list_present        = false;
  bool                         meas_id_to_add_mod_list_present    = false;
  bool                         quant_cfg_present                  = false;
  bool                         meas_gap_cfg_present               = false;
  bool                         s_measure_present                  = false;
  bool                         pre_regist_info_hrpd_present       = false;
  bool                         speed_state_pars_present           = false;
  meas_obj_to_rem_list_l       meas_obj_to_rem_list;
  meas_obj_to_add_mod_list_l   meas_obj_to_add_mod_list;
  report_cfg_to_rem_list_l     report_cfg_to_rem_list;
  report_cfg_to_add_mod_list_l report_cfg_to_add_mod_list;
  meas_id_to_rem_list_l        meas_id_to_rem_list;
  meas_id_to_add_mod_list_l    meas_id_to_add_mod_list;
  quant_cfg_s                  quant_cfg;
  meas_gap_cfg_c               meas_gap_cfg;
  uint8_t                      s_measure = 0;
  pre_regist_info_hrpd_s       pre_regist_info_hrpd;
  speed_state_pars_c_          speed_state_pars;
  // ...
  // group 0
  bool                                      meas_obj_to_add_mod_list_v9e0_present = false;
  copy_ptr<meas_obj_to_add_mod_list_v9e0_l> meas_obj_to_add_mod_list_v9e0;
  // group 1
  bool allow_interruptions_r11_present = false;
  bool allow_interruptions_r11         = false;
  // group 2
  bool                                        meas_scale_factor_r12_present           = false;
  bool                                        meas_id_to_rem_list_ext_r12_present     = false;
  bool                                        meas_id_to_add_mod_list_ext_r12_present = false;
  bool                                        meas_rsrq_on_all_symbols_r12_present    = false;
  copy_ptr<meas_scale_factor_r12_c_>          meas_scale_factor_r12;
  copy_ptr<meas_id_to_rem_list_ext_r12_l>     meas_id_to_rem_list_ext_r12;
  copy_ptr<meas_id_to_add_mod_list_ext_r12_l> meas_id_to_add_mod_list_ext_r12;
  bool                                        meas_rsrq_on_all_symbols_r12 = false;
  // group 3
  bool                                          meas_obj_to_rem_list_ext_r13_present      = false;
  bool                                          meas_obj_to_add_mod_list_ext_r13_present  = false;
  bool                                          meas_id_to_add_mod_list_v1310_present     = false;
  bool                                          meas_id_to_add_mod_list_ext_v1310_present = false;
  copy_ptr<meas_obj_to_rem_list_ext_r13_l>      meas_obj_to_rem_list_ext_r13;
  copy_ptr<meas_obj_to_add_mod_list_ext_r13_l>  meas_obj_to_add_mod_list_ext_r13;
  copy_ptr<meas_id_to_add_mod_list_v1310_l>     meas_id_to_add_mod_list_v1310;
  copy_ptr<meas_id_to_add_mod_list_ext_v1310_l> meas_id_to_add_mod_list_ext_v1310;
  // group 4
  bool                                     meas_gap_cfg_per_cc_list_r14_present = false;
  bool                                     meas_gap_sharing_cfg_r14_present     = false;
  copy_ptr<meas_gap_cfg_per_cc_list_r14_c> meas_gap_cfg_per_cc_list_r14;
  copy_ptr<meas_gap_sharing_cfg_r14_c>     meas_gap_sharing_cfg_r14;
  // group 5
  bool fr1_gap_r15_present = false;
  bool mgta_r15_present    = false;
  bool fr1_gap_r15         = false;
  bool mgta_r15            = false;
  // group 6
  bool                                   meas_gap_cfg_dense_prs_r15_present = false;
  bool                                   height_thresh_ref_r15_present      = false;
  copy_ptr<meas_gap_cfg_dense_prs_r15_c> meas_gap_cfg_dense_prs_r15;
  copy_ptr<height_thresh_ref_r15_c_>     height_thresh_ref_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityControlInfo ::= SEQUENCE
struct mob_ctrl_info_s {
  struct t304_opts {
    enum options { ms50, ms100, ms150, ms200, ms500, ms1000, ms2000, ms10000_v1310, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t304_opts> t304_e_;
  struct ho_without_wt_change_r14_opts {
    enum options { keep_lwa_cfg, send_end_marker, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<ho_without_wt_change_r14_opts> ho_without_wt_change_r14_e_;

  // member variables
  bool                 ext                       = false;
  bool                 carrier_freq_present      = false;
  bool                 carrier_bw_present        = false;
  bool                 add_spec_emission_present = false;
  bool                 rach_cfg_ded_present      = false;
  uint16_t             target_pci                = 0;
  carrier_freq_eutra_s carrier_freq;
  carrier_bw_eutra_s   carrier_bw;
  uint8_t              add_spec_emission = 1;
  t304_e_              t304;
  fixed_bitstring<16>  new_ue_id;
  rr_cfg_common_s      rr_cfg_common;
  rach_cfg_ded_s       rach_cfg_ded;
  // ...
  // group 0
  bool                                carrier_freq_v9e0_present = false;
  copy_ptr<carrier_freq_eutra_v9e0_s> carrier_freq_v9e0;
  // group 1
  bool drb_continue_rohc_r11_present = false;
  // group 2
  bool                              mob_ctrl_info_v2x_r14_present    = false;
  bool                              ho_without_wt_change_r14_present = false;
  bool                              make_before_break_r14_present    = false;
  bool                              rach_skip_r14_present            = false;
  bool                              same_sfn_ind_r14_present         = false;
  copy_ptr<mob_ctrl_info_v2x_r14_s> mob_ctrl_info_v2x_r14;
  ho_without_wt_change_r14_e_       ho_without_wt_change_r14;
  copy_ptr<rach_skip_r14_s>         rach_skip_r14;
  // group 3
  bool    mib_repeat_status_r14_present  = false;
  bool    sched_info_sib1_br_r14_present = false;
  bool    mib_repeat_status_r14          = false;
  uint8_t sched_info_sib1_br_r14         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand-v8a0-IEs ::= SEQUENCE
struct mob_from_eutra_cmd_v8a0_ies_s {
  // member variables
  bool                          late_non_crit_ext_present = false;
  bool                          non_crit_ext_present      = false;
  dyn_octstring                 late_non_crit_ext;
  mob_from_eutra_cmd_v8d0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand-v930-IEs ::= SEQUENCE
struct mob_from_eutra_cmd_v930_ies_s {
  // member variables
  bool                          late_non_crit_ext_present = false;
  bool                          non_crit_ext_present      = false;
  dyn_octstring                 late_non_crit_ext;
  mob_from_eutra_cmd_v960_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RN-SubframeConfig-r10 ::= SEQUENCE
struct rn_sf_cfg_r10_s {
  struct sf_cfg_pattern_r10_c_ {
    struct types_opts {
      enum options { sf_cfg_pattern_fdd_r10, sf_cfg_pattern_tdd_r10, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sf_cfg_pattern_r10_c_() = default;
    sf_cfg_pattern_r10_c_(const sf_cfg_pattern_r10_c_& other);
    sf_cfg_pattern_r10_c_& operator=(const sf_cfg_pattern_r10_c_& other);
    ~sf_cfg_pattern_r10_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<8>& sf_cfg_pattern_fdd_r10()
    {
      assert_choice_type("subframeConfigPatternFDD-r10", type_.to_string(), "subframeConfigPattern-r10");
      return c.get<fixed_bitstring<8> >();
    }
    uint8_t& sf_cfg_pattern_tdd_r10()
    {
      assert_choice_type("subframeConfigPatternTDD-r10", type_.to_string(), "subframeConfigPattern-r10");
      return c.get<uint8_t>();
    }
    const fixed_bitstring<8>& sf_cfg_pattern_fdd_r10() const
    {
      assert_choice_type("subframeConfigPatternFDD-r10", type_.to_string(), "subframeConfigPattern-r10");
      return c.get<fixed_bitstring<8> >();
    }
    const uint8_t& sf_cfg_pattern_tdd_r10() const
    {
      assert_choice_type("subframeConfigPatternTDD-r10", type_.to_string(), "subframeConfigPattern-r10");
      return c.get<uint8_t>();
    }
    fixed_bitstring<8>& set_sf_cfg_pattern_fdd_r10()
    {
      set(types::sf_cfg_pattern_fdd_r10);
      return c.get<fixed_bitstring<8> >();
    }
    uint8_t& set_sf_cfg_pattern_tdd_r10()
    {
      set(types::sf_cfg_pattern_tdd_r10);
      return c.get<uint8_t>();
    }

  private:
    types                                       type_;
    choice_buffer_t<sizeof(fixed_bitstring<8>)> c;

    void destroy_();
  };
  struct rpdcch_cfg_r10_s_ {
    struct res_alloc_type_r10_opts {
      enum options { type0, type1, type2_localized, type2_distributed, spare4, spare3, spare2, spare1, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<res_alloc_type_r10_opts> res_alloc_type_r10_e_;
    struct res_block_assign_r10_c_ {
      struct type01_r10_c_ {
        struct types_opts {
          enum options { nrb6_r10, nrb15_r10, nrb25_r10, nrb50_r10, nrb75_r10, nrb100_r10, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<types_opts> types;

        // choice methods
        type01_r10_c_() = default;
        type01_r10_c_(const type01_r10_c_& other);
        type01_r10_c_& operator=(const type01_r10_c_& other);
        ~type01_r10_c_() { destroy_(); }
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        fixed_bitstring<6>& nrb6_r10()
        {
          assert_choice_type("nrb6-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<6> >();
        }
        fixed_bitstring<8>& nrb15_r10()
        {
          assert_choice_type("nrb15-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<8> >();
        }
        fixed_bitstring<13>& nrb25_r10()
        {
          assert_choice_type("nrb25-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<13> >();
        }
        fixed_bitstring<17>& nrb50_r10()
        {
          assert_choice_type("nrb50-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<17> >();
        }
        fixed_bitstring<19>& nrb75_r10()
        {
          assert_choice_type("nrb75-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<19> >();
        }
        fixed_bitstring<25>& nrb100_r10()
        {
          assert_choice_type("nrb100-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<25> >();
        }
        const fixed_bitstring<6>& nrb6_r10() const
        {
          assert_choice_type("nrb6-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<6> >();
        }
        const fixed_bitstring<8>& nrb15_r10() const
        {
          assert_choice_type("nrb15-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<8> >();
        }
        const fixed_bitstring<13>& nrb25_r10() const
        {
          assert_choice_type("nrb25-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<13> >();
        }
        const fixed_bitstring<17>& nrb50_r10() const
        {
          assert_choice_type("nrb50-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<17> >();
        }
        const fixed_bitstring<19>& nrb75_r10() const
        {
          assert_choice_type("nrb75-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<19> >();
        }
        const fixed_bitstring<25>& nrb100_r10() const
        {
          assert_choice_type("nrb100-r10", type_.to_string(), "type01-r10");
          return c.get<fixed_bitstring<25> >();
        }
        fixed_bitstring<6>& set_nrb6_r10()
        {
          set(types::nrb6_r10);
          return c.get<fixed_bitstring<6> >();
        }
        fixed_bitstring<8>& set_nrb15_r10()
        {
          set(types::nrb15_r10);
          return c.get<fixed_bitstring<8> >();
        }
        fixed_bitstring<13>& set_nrb25_r10()
        {
          set(types::nrb25_r10);
          return c.get<fixed_bitstring<13> >();
        }
        fixed_bitstring<17>& set_nrb50_r10()
        {
          set(types::nrb50_r10);
          return c.get<fixed_bitstring<17> >();
        }
        fixed_bitstring<19>& set_nrb75_r10()
        {
          set(types::nrb75_r10);
          return c.get<fixed_bitstring<19> >();
        }
        fixed_bitstring<25>& set_nrb100_r10()
        {
          set(types::nrb100_r10);
          return c.get<fixed_bitstring<25> >();
        }

      private:
        types                                        type_;
        choice_buffer_t<sizeof(fixed_bitstring<25>)> c;

        void destroy_();
      };
      struct type2_r10_c_ {
        struct types_opts {
          enum options { nrb6_r10, nrb15_r10, nrb25_r10, nrb50_r10, nrb75_r10, nrb100_r10, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<types_opts> types;

        // choice methods
        type2_r10_c_() = default;
        type2_r10_c_(const type2_r10_c_& other);
        type2_r10_c_& operator=(const type2_r10_c_& other);
        ~type2_r10_c_() { destroy_(); }
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        fixed_bitstring<5>& nrb6_r10()
        {
          assert_choice_type("nrb6-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<5> >();
        }
        fixed_bitstring<7>& nrb15_r10()
        {
          assert_choice_type("nrb15-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<7> >();
        }
        fixed_bitstring<9>& nrb25_r10()
        {
          assert_choice_type("nrb25-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<9> >();
        }
        fixed_bitstring<11>& nrb50_r10()
        {
          assert_choice_type("nrb50-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<11> >();
        }
        fixed_bitstring<12>& nrb75_r10()
        {
          assert_choice_type("nrb75-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<12> >();
        }
        fixed_bitstring<13>& nrb100_r10()
        {
          assert_choice_type("nrb100-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<13> >();
        }
        const fixed_bitstring<5>& nrb6_r10() const
        {
          assert_choice_type("nrb6-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<5> >();
        }
        const fixed_bitstring<7>& nrb15_r10() const
        {
          assert_choice_type("nrb15-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<7> >();
        }
        const fixed_bitstring<9>& nrb25_r10() const
        {
          assert_choice_type("nrb25-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<9> >();
        }
        const fixed_bitstring<11>& nrb50_r10() const
        {
          assert_choice_type("nrb50-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<11> >();
        }
        const fixed_bitstring<12>& nrb75_r10() const
        {
          assert_choice_type("nrb75-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<12> >();
        }
        const fixed_bitstring<13>& nrb100_r10() const
        {
          assert_choice_type("nrb100-r10", type_.to_string(), "type2-r10");
          return c.get<fixed_bitstring<13> >();
        }
        fixed_bitstring<5>& set_nrb6_r10()
        {
          set(types::nrb6_r10);
          return c.get<fixed_bitstring<5> >();
        }
        fixed_bitstring<7>& set_nrb15_r10()
        {
          set(types::nrb15_r10);
          return c.get<fixed_bitstring<7> >();
        }
        fixed_bitstring<9>& set_nrb25_r10()
        {
          set(types::nrb25_r10);
          return c.get<fixed_bitstring<9> >();
        }
        fixed_bitstring<11>& set_nrb50_r10()
        {
          set(types::nrb50_r10);
          return c.get<fixed_bitstring<11> >();
        }
        fixed_bitstring<12>& set_nrb75_r10()
        {
          set(types::nrb75_r10);
          return c.get<fixed_bitstring<12> >();
        }
        fixed_bitstring<13>& set_nrb100_r10()
        {
          set(types::nrb100_r10);
          return c.get<fixed_bitstring<13> >();
        }

      private:
        types                                        type_;
        choice_buffer_t<sizeof(fixed_bitstring<13>)> c;

        void destroy_();
      };
      struct types_opts {
        enum options { type01_r10, type2_r10, /*...*/ nulltype } value;
        typedef float number_type;

        std::string to_string() const;
        float       to_number() const;
        std::string to_number_string() const;
      };
      typedef enumerated<types_opts, true> types;

      // choice methods
      res_block_assign_r10_c_() = default;
      res_block_assign_r10_c_(const res_block_assign_r10_c_& other);
      res_block_assign_r10_c_& operator=(const res_block_assign_r10_c_& other);
      ~res_block_assign_r10_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      type01_r10_c_& type01_r10()
      {
        assert_choice_type("type01-r10", type_.to_string(), "resourceBlockAssignment-r10");
        return c.get<type01_r10_c_>();
      }
      type2_r10_c_& type2_r10()
      {
        assert_choice_type("type2-r10", type_.to_string(), "resourceBlockAssignment-r10");
        return c.get<type2_r10_c_>();
      }
      const type01_r10_c_& type01_r10() const
      {
        assert_choice_type("type01-r10", type_.to_string(), "resourceBlockAssignment-r10");
        return c.get<type01_r10_c_>();
      }
      const type2_r10_c_& type2_r10() const
      {
        assert_choice_type("type2-r10", type_.to_string(), "resourceBlockAssignment-r10");
        return c.get<type2_r10_c_>();
      }
      type01_r10_c_& set_type01_r10()
      {
        set(types::type01_r10);
        return c.get<type01_r10_c_>();
      }
      type2_r10_c_& set_type2_r10()
      {
        set(types::type2_r10);
        return c.get<type2_r10_c_>();
      }

    private:
      types                                                              type_;
      choice_buffer_t<MAX2(sizeof(type01_r10_c_), sizeof(type2_r10_c_))> c;

      void destroy_();
    };
    struct demod_rs_r10_c_ {
      struct no_interleaving_r10_opts {
        enum options { crs, dmrs, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<no_interleaving_r10_opts> no_interleaving_r10_e_;
      struct types_opts {
        enum options { interleaving_r10, no_interleaving_r10, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      demod_rs_r10_c_() = default;
      demod_rs_r10_c_(const demod_rs_r10_c_& other);
      demod_rs_r10_c_& operator=(const demod_rs_r10_c_& other);
      ~demod_rs_r10_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      no_interleaving_r10_e_& no_interleaving_r10()
      {
        assert_choice_type("noInterleaving-r10", type_.to_string(), "demodulationRS-r10");
        return c.get<no_interleaving_r10_e_>();
      }
      const no_interleaving_r10_e_& no_interleaving_r10() const
      {
        assert_choice_type("noInterleaving-r10", type_.to_string(), "demodulationRS-r10");
        return c.get<no_interleaving_r10_e_>();
      }
      no_interleaving_r10_e_& set_no_interleaving_r10()
      {
        set(types::no_interleaving_r10);
        return c.get<no_interleaving_r10_e_>();
      }

    private:
      types                                           type_;
      choice_buffer_t<sizeof(no_interleaving_r10_e_)> c;

      void destroy_();
    };
    struct pucch_cfg_r10_c_ {
      struct tdd_c_ {
        struct ch_sel_mux_bundling_s_ {
          typedef bounded_array<uint16_t, 4> n1_pucch_an_list_r10_l_;

          // member variables
          n1_pucch_an_list_r10_l_ n1_pucch_an_list_r10;
        };
        struct fallback_for_format3_s_ {
          // member variables
          bool     n1_pucch_an_p1_r10_present = false;
          uint16_t n1_pucch_an_p0_r10         = 0;
          uint16_t n1_pucch_an_p1_r10         = 0;
        };
        struct types_opts {
          enum options { ch_sel_mux_bundling, fallback_for_format3, nulltype } value;
          typedef uint8_t number_type;

          std::string to_string() const;
          uint8_t     to_number() const;
        };
        typedef enumerated<types_opts> types;

        // choice methods
        tdd_c_() = default;
        tdd_c_(const tdd_c_& other);
        tdd_c_& operator=(const tdd_c_& other);
        ~tdd_c_() { destroy_(); }
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        ch_sel_mux_bundling_s_& ch_sel_mux_bundling()
        {
          assert_choice_type("channelSelectionMultiplexingBundling", type_.to_string(), "tdd");
          return c.get<ch_sel_mux_bundling_s_>();
        }
        fallback_for_format3_s_& fallback_for_format3()
        {
          assert_choice_type("fallbackForFormat3", type_.to_string(), "tdd");
          return c.get<fallback_for_format3_s_>();
        }
        const ch_sel_mux_bundling_s_& ch_sel_mux_bundling() const
        {
          assert_choice_type("channelSelectionMultiplexingBundling", type_.to_string(), "tdd");
          return c.get<ch_sel_mux_bundling_s_>();
        }
        const fallback_for_format3_s_& fallback_for_format3() const
        {
          assert_choice_type("fallbackForFormat3", type_.to_string(), "tdd");
          return c.get<fallback_for_format3_s_>();
        }
        ch_sel_mux_bundling_s_& set_ch_sel_mux_bundling()
        {
          set(types::ch_sel_mux_bundling);
          return c.get<ch_sel_mux_bundling_s_>();
        }
        fallback_for_format3_s_& set_fallback_for_format3()
        {
          set(types::fallback_for_format3);
          return c.get<fallback_for_format3_s_>();
        }

      private:
        types                                                                                  type_;
        choice_buffer_t<MAX2(sizeof(ch_sel_mux_bundling_s_), sizeof(fallback_for_format3_s_))> c;

        void destroy_();
      };
      struct fdd_s_ {
        // member variables
        bool     n1_pucch_an_p1_r10_present = false;
        uint16_t n1_pucch_an_p0_r10         = 0;
        uint16_t n1_pucch_an_p1_r10         = 0;
      };
      struct types_opts {
        enum options { tdd, fdd, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      pucch_cfg_r10_c_() = default;
      pucch_cfg_r10_c_(const pucch_cfg_r10_c_& other);
      pucch_cfg_r10_c_& operator=(const pucch_cfg_r10_c_& other);
      ~pucch_cfg_r10_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      tdd_c_& tdd()
      {
        assert_choice_type("tdd", type_.to_string(), "pucch-Config-r10");
        return c.get<tdd_c_>();
      }
      fdd_s_& fdd()
      {
        assert_choice_type("fdd", type_.to_string(), "pucch-Config-r10");
        return c.get<fdd_s_>();
      }
      const tdd_c_& tdd() const
      {
        assert_choice_type("tdd", type_.to_string(), "pucch-Config-r10");
        return c.get<tdd_c_>();
      }
      const fdd_s_& fdd() const
      {
        assert_choice_type("fdd", type_.to_string(), "pucch-Config-r10");
        return c.get<fdd_s_>();
      }
      tdd_c_& set_tdd()
      {
        set(types::tdd);
        return c.get<tdd_c_>();
      }
      fdd_s_& set_fdd()
      {
        set(types::fdd);
        return c.get<fdd_s_>();
      }

    private:
      types                                                 type_;
      choice_buffer_t<MAX2(sizeof(fdd_s_), sizeof(tdd_c_))> c;

      void destroy_();
    };

    // member variables
    bool                    ext = false;
    res_alloc_type_r10_e_   res_alloc_type_r10;
    res_block_assign_r10_c_ res_block_assign_r10;
    demod_rs_r10_c_         demod_rs_r10;
    uint8_t                 pdsch_start_r10 = 1;
    pucch_cfg_r10_c_        pucch_cfg_r10;
    // ...
  };

  // member variables
  bool                  ext                        = false;
  bool                  sf_cfg_pattern_r10_present = false;
  bool                  rpdcch_cfg_r10_present     = false;
  sf_cfg_pattern_r10_c_ sf_cfg_pattern_r10;
  rpdcch_cfg_r10_s_     rpdcch_cfg_r10;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RN-SystemInfo-r10 ::= SEQUENCE
struct rn_sys_info_r10_s {
  // member variables
  bool          ext                   = false;
  bool          sib_type1_r10_present = false;
  bool          sib_type2_r10_present = false;
  dyn_octstring sib_type1_r10;
  sib_type2_s   sib_type2_r10;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-v890-IEs ::= SEQUENCE
struct rrc_conn_recfg_v890_ies_s {
  // member variables
  bool                      late_non_crit_ext_present = false;
  bool                      non_crit_ext_present      = false;
  dyn_octstring             late_non_crit_ext;
  rrc_conn_recfg_v920_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease-v890-IEs ::= SEQUENCE
struct rrc_conn_release_v890_ies_s {
  // member variables
  bool                        late_non_crit_ext_present = false;
  bool                        non_crit_ext_present      = false;
  dyn_octstring               late_non_crit_ext;
  rrc_conn_release_v920_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResume-v1430-IEs ::= SEQUENCE
struct rrc_conn_resume_v1430_ies_s {
  // member variables
  bool                        other_cfg_r14_present             = false;
  bool                        rrc_conn_resume_v1510_ies_present = false;
  other_cfg_r9_s              other_cfg_r14;
  rrc_conn_resume_v1510_ies_s rrc_conn_resume_v1510_ies;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RedirectedCarrierInfo ::= CHOICE
struct redirected_carrier_info_c {
  struct types_opts {
    enum options {
      eutra,
      geran,
      utra_fdd,
      utra_tdd,
      cdma2000_hrpd,
      cdma2000_minus1x_rtt,
      // ...
      utra_tdd_r10,
      nr_r15,
      nulltype
    } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts, true, 2> types;

  // choice methods
  redirected_carrier_info_c() = default;
  redirected_carrier_info_c(const redirected_carrier_info_c& other);
  redirected_carrier_info_c& operator=(const redirected_carrier_info_c& other);
  ~redirected_carrier_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& eutra()
  {
    assert_choice_type("eutra", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<uint16_t>();
  }
  carrier_freqs_geran_s& geran()
  {
    assert_choice_type("geran", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freqs_geran_s>();
  }
  uint16_t& utra_fdd()
  {
    assert_choice_type("utra-FDD", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<uint16_t>();
  }
  uint16_t& utra_tdd()
  {
    assert_choice_type("utra-TDD", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<uint16_t>();
  }
  carrier_freq_cdma2000_s& cdma2000_hrpd()
  {
    assert_choice_type("cdma2000-HRPD", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_cdma2000_s& cdma2000_minus1x_rtt()
  {
    assert_choice_type("cdma2000-1xRTT", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_list_utra_tdd_r10_l& utra_tdd_r10()
  {
    assert_choice_type("utra-TDD-r10", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freq_list_utra_tdd_r10_l>();
  }
  carrier_info_nr_r15_s& nr_r15()
  {
    assert_choice_type("nr-r15", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_info_nr_r15_s>();
  }
  const uint16_t& eutra() const
  {
    assert_choice_type("eutra", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<uint16_t>();
  }
  const carrier_freqs_geran_s& geran() const
  {
    assert_choice_type("geran", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freqs_geran_s>();
  }
  const uint16_t& utra_fdd() const
  {
    assert_choice_type("utra-FDD", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<uint16_t>();
  }
  const uint16_t& utra_tdd() const
  {
    assert_choice_type("utra-TDD", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<uint16_t>();
  }
  const carrier_freq_cdma2000_s& cdma2000_hrpd() const
  {
    assert_choice_type("cdma2000-HRPD", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freq_cdma2000_s>();
  }
  const carrier_freq_cdma2000_s& cdma2000_minus1x_rtt() const
  {
    assert_choice_type("cdma2000-1xRTT", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freq_cdma2000_s>();
  }
  const carrier_freq_list_utra_tdd_r10_l& utra_tdd_r10() const
  {
    assert_choice_type("utra-TDD-r10", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_freq_list_utra_tdd_r10_l>();
  }
  const carrier_info_nr_r15_s& nr_r15() const
  {
    assert_choice_type("nr-r15", type_.to_string(), "RedirectedCarrierInfo");
    return c.get<carrier_info_nr_r15_s>();
  }
  uint16_t& set_eutra()
  {
    set(types::eutra);
    return c.get<uint16_t>();
  }
  carrier_freqs_geran_s& set_geran()
  {
    set(types::geran);
    return c.get<carrier_freqs_geran_s>();
  }
  uint16_t& set_utra_fdd()
  {
    set(types::utra_fdd);
    return c.get<uint16_t>();
  }
  uint16_t& set_utra_tdd()
  {
    set(types::utra_tdd);
    return c.get<uint16_t>();
  }
  carrier_freq_cdma2000_s& set_cdma2000_hrpd()
  {
    set(types::cdma2000_hrpd);
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_cdma2000_s& set_cdma2000_minus1x_rtt()
  {
    set(types::cdma2000_minus1x_rtt);
    return c.get<carrier_freq_cdma2000_s>();
  }
  carrier_freq_list_utra_tdd_r10_l& set_utra_tdd_r10()
  {
    set(types::utra_tdd_r10);
    return c.get<carrier_freq_list_utra_tdd_r10_l>();
  }
  carrier_info_nr_r15_s& set_nr_r15()
  {
    set(types::nr_r15);
    return c.get<carrier_info_nr_r15_s>();
  }

private:
  types type_;
  choice_buffer_t<MAX4(sizeof(carrier_freq_cdma2000_s),
                       sizeof(carrier_freq_list_utra_tdd_r10_l),
                       sizeof(carrier_freqs_geran_s),
                       sizeof(carrier_info_nr_r15_s))>
      c;

  void destroy_();
};

// ReleaseCause ::= ENUMERATED
struct release_cause_opts {
  enum options { load_balancing_ta_urequired, other, cs_fallback_high_prio_v1020, rrc_suspend_v1320, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<release_cause_opts> release_cause_e;

// SecurityConfigHO ::= SEQUENCE
struct security_cfg_ho_s {
  struct ho_type_c_ {
    struct intra_lte_s_ {
      // member variables
      bool                     security_algorithm_cfg_present = false;
      security_algorithm_cfg_s security_algorithm_cfg;
      bool                     key_change_ind          = false;
      uint8_t                  next_hop_chaining_count = 0;
    };
    struct inter_rat_s_ {
      // member variables
      security_algorithm_cfg_s security_algorithm_cfg;
      fixed_octstring<6>       nas_security_param_to_eutra;
    };
    struct types_opts {
      enum options { intra_lte, inter_rat, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ho_type_c_() = default;
    ho_type_c_(const ho_type_c_& other);
    ho_type_c_& operator=(const ho_type_c_& other);
    ~ho_type_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    intra_lte_s_& intra_lte()
    {
      assert_choice_type("intraLTE", type_.to_string(), "handoverType");
      return c.get<intra_lte_s_>();
    }
    inter_rat_s_& inter_rat()
    {
      assert_choice_type("interRAT", type_.to_string(), "handoverType");
      return c.get<inter_rat_s_>();
    }
    const intra_lte_s_& intra_lte() const
    {
      assert_choice_type("intraLTE", type_.to_string(), "handoverType");
      return c.get<intra_lte_s_>();
    }
    const inter_rat_s_& inter_rat() const
    {
      assert_choice_type("interRAT", type_.to_string(), "handoverType");
      return c.get<inter_rat_s_>();
    }
    intra_lte_s_& set_intra_lte()
    {
      set(types::intra_lte);
      return c.get<intra_lte_s_>();
    }
    inter_rat_s_& set_inter_rat()
    {
      set(types::inter_rat);
      return c.get<inter_rat_s_>();
    }

  private:
    types                                                             type_;
    choice_buffer_t<MAX2(sizeof(inter_rat_s_), sizeof(intra_lte_s_))> c;

    void destroy_();
  };

  // member variables
  bool       ext = false;
  ho_type_c_ ho_type;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityConfigSMC ::= SEQUENCE
struct security_cfg_smc_s {
  // member variables
  bool                     ext = false;
  security_algorithm_cfg_s security_algorithm_cfg;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeCommand-v8a0-IEs ::= SEQUENCE
struct security_mode_cmd_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TraceReference-r10 ::= SEQUENCE
struct trace_ref_r10_s {
  // member variables
  plmn_id_s          plmn_id_r10;
  fixed_octstring<3> trace_id_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-CapabilityRequest ::= SEQUENCE (SIZE (1..maxRAT-Capabilities)) OF RAT-Type
typedef bounded_array<rat_type_e, 8> ue_cap_request_l;

// UECapabilityEnquiry-v8a0-IEs ::= SEQUENCE
struct ue_cap_enquiry_v8a0_ies_s {
  // member variables
  bool                       late_non_crit_ext_present = false;
  bool                       non_crit_ext_present      = false;
  dyn_octstring              late_non_crit_ext;
  ue_cap_enquiry_v1180_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationRequest-v930-IEs ::= SEQUENCE
struct ue_info_request_v930_ies_s {
  // member variables
  bool                        late_non_crit_ext_present = false;
  bool                        non_crit_ext_present      = false;
  dyn_octstring               late_non_crit_ext;
  ue_info_request_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSFBParametersResponseCDMA2000-r8-IEs ::= SEQUENCE
struct csfb_params_resp_cdma2000_r8_ies_s {
  // member variables
  bool                                 non_crit_ext_present = false;
  fixed_bitstring<32>                  rand;
  dyn_octstring                        mob_params;
  csfb_params_resp_cdma2000_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CounterCheck-r8-IEs ::= SEQUENCE
struct counter_check_r8_ies_s {
  // member variables
  bool                      non_crit_ext_present = false;
  drb_count_msb_info_list_l drb_count_msb_info_list;
  counter_check_v8a0_ies_s  non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DLInformationTransfer-r15-IEs ::= SEQUENCE
struct dl_info_transfer_r15_ies_s {
  struct ded_info_type_r15_c_ {
    struct types_opts {
      enum options { ded_info_nas_r15, ded_info_cdma2000_minus1_xrtt_r15, ded_info_cdma2000_hrpd_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ded_info_type_r15_c_() = default;
    ded_info_type_r15_c_(const ded_info_type_r15_c_& other);
    ded_info_type_r15_c_& operator=(const ded_info_type_r15_c_& other);
    ~ded_info_type_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dyn_octstring& ded_info_nas_r15()
    {
      assert_choice_type("dedicatedInfoNAS-r15", type_.to_string(), "dedicatedInfoType-r15");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ded_info_cdma2000_minus1_xrtt_r15()
    {
      assert_choice_type("dedicatedInfoCDMA2000-1XRTT-r15", type_.to_string(), "dedicatedInfoType-r15");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ded_info_cdma2000_hrpd_r15()
    {
      assert_choice_type("dedicatedInfoCDMA2000-HRPD-r15", type_.to_string(), "dedicatedInfoType-r15");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_nas_r15() const
    {
      assert_choice_type("dedicatedInfoNAS-r15", type_.to_string(), "dedicatedInfoType-r15");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_cdma2000_minus1_xrtt_r15() const
    {
      assert_choice_type("dedicatedInfoCDMA2000-1XRTT-r15", type_.to_string(), "dedicatedInfoType-r15");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_cdma2000_hrpd_r15() const
    {
      assert_choice_type("dedicatedInfoCDMA2000-HRPD-r15", type_.to_string(), "dedicatedInfoType-r15");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_nas_r15()
    {
      set(types::ded_info_nas_r15);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_cdma2000_minus1_xrtt_r15()
    {
      set(types::ded_info_cdma2000_minus1_xrtt_r15);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_cdma2000_hrpd_r15()
    {
      set(types::ded_info_cdma2000_hrpd_r15);
      return c.get<dyn_octstring>();
    }

  private:
    types                                  type_;
    choice_buffer_t<sizeof(dyn_octstring)> c;

    void destroy_();
  };

  // member variables
  bool                        ded_info_type_r15_present = false;
  bool                        time_ref_info_r15_present = false;
  bool                        non_crit_ext_present      = false;
  ded_info_type_r15_c_        ded_info_type_r15;
  time_ref_info_r15_s         time_ref_info_r15;
  dl_info_transfer_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DLInformationTransfer-r8-IEs ::= SEQUENCE
struct dl_info_transfer_r8_ies_s {
  struct ded_info_type_c_ {
    struct types_opts {
      enum options { ded_info_nas, ded_info_cdma2000_minus1_xrtt, ded_info_cdma2000_hrpd, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ded_info_type_c_() = default;
    ded_info_type_c_(const ded_info_type_c_& other);
    ded_info_type_c_& operator=(const ded_info_type_c_& other);
    ~ded_info_type_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dyn_octstring& ded_info_nas()
    {
      assert_choice_type("dedicatedInfoNAS", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ded_info_cdma2000_minus1_xrtt()
    {
      assert_choice_type("dedicatedInfoCDMA2000-1XRTT", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ded_info_cdma2000_hrpd()
    {
      assert_choice_type("dedicatedInfoCDMA2000-HRPD", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_nas() const
    {
      assert_choice_type("dedicatedInfoNAS", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_cdma2000_minus1_xrtt() const
    {
      assert_choice_type("dedicatedInfoCDMA2000-1XRTT", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_cdma2000_hrpd() const
    {
      assert_choice_type("dedicatedInfoCDMA2000-HRPD", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_nas()
    {
      set(types::ded_info_nas);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_cdma2000_minus1_xrtt()
    {
      set(types::ded_info_cdma2000_minus1_xrtt);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_cdma2000_hrpd()
    {
      set(types::ded_info_cdma2000_hrpd);
      return c.get<dyn_octstring>();
    }

  private:
    types                                  type_;
    choice_buffer_t<sizeof(dyn_octstring)> c;

    void destroy_();
  };

  // member variables
  bool                        non_crit_ext_present = false;
  ded_info_type_c_            ded_info_type;
  dl_info_transfer_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverFromEUTRAPreparationRequest-r8-IEs ::= SEQUENCE
struct ho_from_eutra_prep_request_r8_ies_s {
  // member variables
  bool                                  rand_present         = false;
  bool                                  mob_params_present   = false;
  bool                                  non_crit_ext_present = false;
  cdma2000_type_e                       cdma2000_type;
  fixed_bitstring<32>                   rand;
  dyn_octstring                         mob_params;
  ho_from_eutra_prep_request_v890_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoggedMeasurementConfiguration-r10-IEs ::= SEQUENCE
struct logged_meas_cfg_r10_ies_s {
  // member variables
  bool                        area_cfg_r10_present = false;
  bool                        non_crit_ext_present = false;
  trace_ref_r10_s             trace_ref_r10;
  fixed_octstring<2>          trace_recording_session_ref_r10;
  fixed_octstring<1>          tce_id_r10;
  fixed_bitstring<48>         absolute_time_info_r10;
  area_cfg_r10_c              area_cfg_r10;
  logging_dur_r10_e           logging_dur_r10;
  logging_interv_r10_e        logging_interv_r10;
  logged_meas_cfg_v1080_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand-r8-IEs ::= SEQUENCE
struct mob_from_eutra_cmd_r8_ies_s {
  struct purpose_c_ {
    struct types_opts {
      enum options { ho, cell_change_order, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    purpose_c_() = default;
    purpose_c_(const purpose_c_& other);
    purpose_c_& operator=(const purpose_c_& other);
    ~purpose_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ho_s& ho()
    {
      assert_choice_type("handover", type_.to_string(), "purpose");
      return c.get<ho_s>();
    }
    cell_change_order_s& cell_change_order()
    {
      assert_choice_type("cellChangeOrder", type_.to_string(), "purpose");
      return c.get<cell_change_order_s>();
    }
    const ho_s& ho() const
    {
      assert_choice_type("handover", type_.to_string(), "purpose");
      return c.get<ho_s>();
    }
    const cell_change_order_s& cell_change_order() const
    {
      assert_choice_type("cellChangeOrder", type_.to_string(), "purpose");
      return c.get<cell_change_order_s>();
    }
    ho_s& set_ho()
    {
      set(types::ho);
      return c.get<ho_s>();
    }
    cell_change_order_s& set_cell_change_order()
    {
      set(types::cell_change_order);
      return c.get<cell_change_order_s>();
    }

  private:
    types                                                            type_;
    choice_buffer_t<MAX2(sizeof(cell_change_order_s), sizeof(ho_s))> c;

    void destroy_();
  };

  // member variables
  bool                          non_crit_ext_present = false;
  bool                          cs_fallback_ind      = false;
  purpose_c_                    purpose;
  mob_from_eutra_cmd_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand-r9-IEs ::= SEQUENCE
struct mob_from_eutra_cmd_r9_ies_s {
  struct purpose_c_ {
    struct types_opts {
      enum options { ho, cell_change_order, e_csfb_r9, /*...*/ nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts, true> types;

    // choice methods
    purpose_c_() = default;
    purpose_c_(const purpose_c_& other);
    purpose_c_& operator=(const purpose_c_& other);
    ~purpose_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ho_s& ho()
    {
      assert_choice_type("handover", type_.to_string(), "purpose");
      return c.get<ho_s>();
    }
    cell_change_order_s& cell_change_order()
    {
      assert_choice_type("cellChangeOrder", type_.to_string(), "purpose");
      return c.get<cell_change_order_s>();
    }
    e_csfb_r9_s& e_csfb_r9()
    {
      assert_choice_type("e-CSFB-r9", type_.to_string(), "purpose");
      return c.get<e_csfb_r9_s>();
    }
    const ho_s& ho() const
    {
      assert_choice_type("handover", type_.to_string(), "purpose");
      return c.get<ho_s>();
    }
    const cell_change_order_s& cell_change_order() const
    {
      assert_choice_type("cellChangeOrder", type_.to_string(), "purpose");
      return c.get<cell_change_order_s>();
    }
    const e_csfb_r9_s& e_csfb_r9() const
    {
      assert_choice_type("e-CSFB-r9", type_.to_string(), "purpose");
      return c.get<e_csfb_r9_s>();
    }
    ho_s& set_ho()
    {
      set(types::ho);
      return c.get<ho_s>();
    }
    cell_change_order_s& set_cell_change_order()
    {
      set(types::cell_change_order);
      return c.get<cell_change_order_s>();
    }
    e_csfb_r9_s& set_e_csfb_r9()
    {
      set(types::e_csfb_r9);
      return c.get<e_csfb_r9_s>();
    }

  private:
    types                                                                                    type_;
    choice_buffer_t<MAX4(sizeof(cell_change_order_s), sizeof(e_csfb_r9_s), sizeof(ho_s), 0)> c;

    void destroy_();
  };

  // member variables
  bool                          non_crit_ext_present = false;
  bool                          cs_fallback_ind      = false;
  purpose_c_                    purpose;
  mob_from_eutra_cmd_v930_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RNReconfiguration-r10-IEs ::= SEQUENCE
struct rn_recfg_r10_ies_s {
  // member variables
  bool              rn_sys_info_r10_present   = false;
  bool              rn_sf_cfg_r10_present     = false;
  bool              late_non_crit_ext_present = false;
  bool              non_crit_ext_present      = false;
  rn_sys_info_r10_s rn_sys_info_r10;
  rn_sf_cfg_r10_s   rn_sf_cfg_r10;
  dyn_octstring     late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration-r8-IEs ::= SEQUENCE
struct rrc_conn_recfg_r8_ies_s {
  typedef bounded_array<dyn_octstring, 11> ded_info_nas_list_l_;

  // member variables
  bool                      meas_cfg_present          = false;
  bool                      mob_ctrl_info_present     = false;
  bool                      ded_info_nas_list_present = false;
  bool                      rr_cfg_ded_present        = false;
  bool                      security_cfg_ho_present   = false;
  bool                      non_crit_ext_present      = false;
  meas_cfg_s                meas_cfg;
  mob_ctrl_info_s           mob_ctrl_info;
  ded_info_nas_list_l_      ded_info_nas_list;
  rr_cfg_ded_s              rr_cfg_ded;
  security_cfg_ho_s         security_cfg_ho;
  rrc_conn_recfg_v890_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease-r8-IEs ::= SEQUENCE
struct rrc_conn_release_r8_ies_s {
  // member variables
  bool                        redirected_carrier_info_present = false;
  bool                        idle_mode_mob_ctrl_info_present = false;
  bool                        non_crit_ext_present            = false;
  release_cause_e             release_cause;
  redirected_carrier_info_c   redirected_carrier_info;
  idle_mode_mob_ctrl_info_s   idle_mode_mob_ctrl_info;
  rrc_conn_release_v890_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResume-r13-IEs ::= SEQUENCE
struct rrc_conn_resume_r13_ies_s {
  // member variables
  bool                        rr_cfg_ded_r13_present            = false;
  bool                        meas_cfg_r13_present              = false;
  bool                        ant_info_ded_pcell_r13_present    = false;
  bool                        drb_continue_rohc_r13_present     = false;
  bool                        late_non_crit_ext_present         = false;
  bool                        rrc_conn_resume_v1430_ies_present = false;
  rr_cfg_ded_s                rr_cfg_ded_r13;
  uint8_t                     next_hop_chaining_count_r13 = 0;
  meas_cfg_s                  meas_cfg_r13;
  ant_info_ded_v10i0_s        ant_info_ded_pcell_r13;
  dyn_octstring               late_non_crit_ext;
  rrc_conn_resume_v1430_ies_s rrc_conn_resume_v1430_ies;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeCommand-r8-IEs ::= SEQUENCE
struct security_mode_cmd_r8_ies_s {
  // member variables
  bool                         non_crit_ext_present = false;
  security_cfg_smc_s           security_cfg_smc;
  security_mode_cmd_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityEnquiry-r8-IEs ::= SEQUENCE
struct ue_cap_enquiry_r8_ies_s {
  // member variables
  bool                      non_crit_ext_present = false;
  ue_cap_request_l          ue_cap_request;
  ue_cap_enquiry_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationRequest-r9-IEs ::= SEQUENCE
struct ue_info_request_r9_ies_s {
  // member variables
  bool                       non_crit_ext_present = false;
  bool                       rach_report_req_r9   = false;
  bool                       rlf_report_req_r9    = false;
  ue_info_request_v930_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSFBParametersResponseCDMA2000 ::= SEQUENCE
struct csfb_params_resp_cdma2000_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { csfb_params_resp_cdma2000_r8, crit_exts_future, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csfb_params_resp_cdma2000_r8_ies_s& csfb_params_resp_cdma2000_r8()
    {
      assert_choice_type("csfbParametersResponseCDMA2000-r8", type_.to_string(), "criticalExtensions");
      return c.get<csfb_params_resp_cdma2000_r8_ies_s>();
    }
    const csfb_params_resp_cdma2000_r8_ies_s& csfb_params_resp_cdma2000_r8() const
    {
      assert_choice_type("csfbParametersResponseCDMA2000-r8", type_.to_string(), "criticalExtensions");
      return c.get<csfb_params_resp_cdma2000_r8_ies_s>();
    }
    csfb_params_resp_cdma2000_r8_ies_s& set_csfb_params_resp_cdma2000_r8()
    {
      set(types::csfb_params_resp_cdma2000_r8);
      return c.get<csfb_params_resp_cdma2000_r8_ies_s>();
    }

  private:
    types                                                       type_;
    choice_buffer_t<sizeof(csfb_params_resp_cdma2000_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CounterCheck ::= SEQUENCE
struct counter_check_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { counter_check_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      counter_check_r8_ies_s& counter_check_r8()
      {
        assert_choice_type("counterCheck-r8", type_.to_string(), "c1");
        return c;
      }
      const counter_check_r8_ies_s& counter_check_r8() const
      {
        assert_choice_type("counterCheck-r8", type_.to_string(), "c1");
        return c;
      }
      counter_check_r8_ies_s& set_counter_check_r8()
      {
        set(types::counter_check_r8);
        return c;
      }

    private:
      types                  type_;
      counter_check_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DLInformationTransfer ::= SEQUENCE
struct dl_info_transfer_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { dl_info_transfer_r8, dl_info_transfer_r15, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      c1_c_(const c1_c_& other);
      c1_c_& operator=(const c1_c_& other);
      ~c1_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      dl_info_transfer_r8_ies_s& dl_info_transfer_r8()
      {
        assert_choice_type("dlInformationTransfer-r8", type_.to_string(), "c1");
        return c.get<dl_info_transfer_r8_ies_s>();
      }
      dl_info_transfer_r15_ies_s& dl_info_transfer_r15()
      {
        assert_choice_type("dlInformationTransfer-r15", type_.to_string(), "c1");
        return c.get<dl_info_transfer_r15_ies_s>();
      }
      const dl_info_transfer_r8_ies_s& dl_info_transfer_r8() const
      {
        assert_choice_type("dlInformationTransfer-r8", type_.to_string(), "c1");
        return c.get<dl_info_transfer_r8_ies_s>();
      }
      const dl_info_transfer_r15_ies_s& dl_info_transfer_r15() const
      {
        assert_choice_type("dlInformationTransfer-r15", type_.to_string(), "c1");
        return c.get<dl_info_transfer_r15_ies_s>();
      }
      dl_info_transfer_r8_ies_s& set_dl_info_transfer_r8()
      {
        set(types::dl_info_transfer_r8);
        return c.get<dl_info_transfer_r8_ies_s>();
      }
      dl_info_transfer_r15_ies_s& set_dl_info_transfer_r15()
      {
        set(types::dl_info_transfer_r15);
        return c.get<dl_info_transfer_r15_ies_s>();
      }

    private:
      types                                                                                        type_;
      choice_buffer_t<MAX2(sizeof(dl_info_transfer_r15_ies_s), sizeof(dl_info_transfer_r8_ies_s))> c;

      void destroy_();
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverFromEUTRAPreparationRequest ::= SEQUENCE
struct ho_from_eutra_prep_request_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ho_from_eutra_prep_request_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ho_from_eutra_prep_request_r8_ies_s& ho_from_eutra_prep_request_r8()
      {
        assert_choice_type("handoverFromEUTRAPreparationRequest-r8", type_.to_string(), "c1");
        return c;
      }
      const ho_from_eutra_prep_request_r8_ies_s& ho_from_eutra_prep_request_r8() const
      {
        assert_choice_type("handoverFromEUTRAPreparationRequest-r8", type_.to_string(), "c1");
        return c;
      }
      ho_from_eutra_prep_request_r8_ies_s& set_ho_from_eutra_prep_request_r8()
      {
        set(types::ho_from_eutra_prep_request_r8);
        return c;
      }

    private:
      types                               type_;
      ho_from_eutra_prep_request_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoggedMeasurementConfiguration-r10 ::= SEQUENCE
struct logged_meas_cfg_r10_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { logged_meas_cfg_r10, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      logged_meas_cfg_r10_ies_s& logged_meas_cfg_r10()
      {
        assert_choice_type("loggedMeasurementConfiguration-r10", type_.to_string(), "c1");
        return c;
      }
      const logged_meas_cfg_r10_ies_s& logged_meas_cfg_r10() const
      {
        assert_choice_type("loggedMeasurementConfiguration-r10", type_.to_string(), "c1");
        return c;
      }
      logged_meas_cfg_r10_ies_s& set_logged_meas_cfg_r10()
      {
        set(types::logged_meas_cfg_r10);
        return c;
      }

    private:
      types                     type_;
      logged_meas_cfg_r10_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityFromEUTRACommand ::= SEQUENCE
struct mob_from_eutra_cmd_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { mob_from_eutra_cmd_r8, mob_from_eutra_cmd_r9, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      c1_c_(const c1_c_& other);
      c1_c_& operator=(const c1_c_& other);
      ~c1_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      mob_from_eutra_cmd_r8_ies_s& mob_from_eutra_cmd_r8()
      {
        assert_choice_type("mobilityFromEUTRACommand-r8", type_.to_string(), "c1");
        return c.get<mob_from_eutra_cmd_r8_ies_s>();
      }
      mob_from_eutra_cmd_r9_ies_s& mob_from_eutra_cmd_r9()
      {
        assert_choice_type("mobilityFromEUTRACommand-r9", type_.to_string(), "c1");
        return c.get<mob_from_eutra_cmd_r9_ies_s>();
      }
      const mob_from_eutra_cmd_r8_ies_s& mob_from_eutra_cmd_r8() const
      {
        assert_choice_type("mobilityFromEUTRACommand-r8", type_.to_string(), "c1");
        return c.get<mob_from_eutra_cmd_r8_ies_s>();
      }
      const mob_from_eutra_cmd_r9_ies_s& mob_from_eutra_cmd_r9() const
      {
        assert_choice_type("mobilityFromEUTRACommand-r9", type_.to_string(), "c1");
        return c.get<mob_from_eutra_cmd_r9_ies_s>();
      }
      mob_from_eutra_cmd_r8_ies_s& set_mob_from_eutra_cmd_r8()
      {
        set(types::mob_from_eutra_cmd_r8);
        return c.get<mob_from_eutra_cmd_r8_ies_s>();
      }
      mob_from_eutra_cmd_r9_ies_s& set_mob_from_eutra_cmd_r9()
      {
        set(types::mob_from_eutra_cmd_r9);
        return c.get<mob_from_eutra_cmd_r9_ies_s>();
      }

    private:
      types                                                                                           type_;
      choice_buffer_t<MAX2(sizeof(mob_from_eutra_cmd_r8_ies_s), sizeof(mob_from_eutra_cmd_r9_ies_s))> c;

      void destroy_();
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RNReconfiguration-r10 ::= SEQUENCE
struct rn_recfg_r10_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rn_recfg_r10, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rn_recfg_r10_ies_s& rn_recfg_r10()
      {
        assert_choice_type("rnReconfiguration-r10", type_.to_string(), "c1");
        return c;
      }
      const rn_recfg_r10_ies_s& rn_recfg_r10() const
      {
        assert_choice_type("rnReconfiguration-r10", type_.to_string(), "c1");
        return c;
      }
      rn_recfg_r10_ies_s& set_rn_recfg_r10()
      {
        set(types::rn_recfg_r10);
        return c;
      }

    private:
      types              type_;
      rn_recfg_r10_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfiguration ::= SEQUENCE
struct rrc_conn_recfg_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rrc_conn_recfg_r8, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_recfg_r8_ies_s& rrc_conn_recfg_r8()
      {
        assert_choice_type("rrcConnectionReconfiguration-r8", type_.to_string(), "c1");
        return c;
      }
      const rrc_conn_recfg_r8_ies_s& rrc_conn_recfg_r8() const
      {
        assert_choice_type("rrcConnectionReconfiguration-r8", type_.to_string(), "c1");
        return c;
      }
      rrc_conn_recfg_r8_ies_s& set_rrc_conn_recfg_r8()
      {
        set(types::rrc_conn_recfg_r8);
        return c;
      }

    private:
      types                   type_;
      rrc_conn_recfg_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRelease ::= SEQUENCE
struct rrc_conn_release_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rrc_conn_release_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_release_r8_ies_s& rrc_conn_release_r8()
      {
        assert_choice_type("rrcConnectionRelease-r8", type_.to_string(), "c1");
        return c;
      }
      const rrc_conn_release_r8_ies_s& rrc_conn_release_r8() const
      {
        assert_choice_type("rrcConnectionRelease-r8", type_.to_string(), "c1");
        return c;
      }
      rrc_conn_release_r8_ies_s& set_rrc_conn_release_r8()
      {
        set(types::rrc_conn_release_r8);
        return c;
      }

    private:
      types                     type_;
      rrc_conn_release_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResume-r13 ::= SEQUENCE
struct rrc_conn_resume_r13_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rrc_conn_resume_r13, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_resume_r13_ies_s& rrc_conn_resume_r13()
      {
        assert_choice_type("rrcConnectionResume-r13", type_.to_string(), "c1");
        return c;
      }
      const rrc_conn_resume_r13_ies_s& rrc_conn_resume_r13() const
      {
        assert_choice_type("rrcConnectionResume-r13", type_.to_string(), "c1");
        return c;
      }
      rrc_conn_resume_r13_ies_s& set_rrc_conn_resume_r13()
      {
        set(types::rrc_conn_resume_r13);
        return c;
      }

    private:
      types                     type_;
      rrc_conn_resume_r13_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeCommand ::= SEQUENCE
struct security_mode_cmd_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { security_mode_cmd_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      security_mode_cmd_r8_ies_s& security_mode_cmd_r8()
      {
        assert_choice_type("securityModeCommand-r8", type_.to_string(), "c1");
        return c;
      }
      const security_mode_cmd_r8_ies_s& security_mode_cmd_r8() const
      {
        assert_choice_type("securityModeCommand-r8", type_.to_string(), "c1");
        return c;
      }
      security_mode_cmd_r8_ies_s& set_security_mode_cmd_r8()
      {
        set(types::security_mode_cmd_r8);
        return c;
      }

    private:
      types                      type_;
      security_mode_cmd_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityEnquiry ::= SEQUENCE
struct ue_cap_enquiry_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ue_cap_enquiry_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ue_cap_enquiry_r8_ies_s& ue_cap_enquiry_r8()
      {
        assert_choice_type("ueCapabilityEnquiry-r8", type_.to_string(), "c1");
        return c;
      }
      const ue_cap_enquiry_r8_ies_s& ue_cap_enquiry_r8() const
      {
        assert_choice_type("ueCapabilityEnquiry-r8", type_.to_string(), "c1");
        return c;
      }
      ue_cap_enquiry_r8_ies_s& set_ue_cap_enquiry_r8()
      {
        set(types::ue_cap_enquiry_r8);
        return c;
      }

    private:
      types                   type_;
      ue_cap_enquiry_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationRequest-r9 ::= SEQUENCE
struct ue_info_request_r9_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ue_info_request_r9, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ue_info_request_r9_ies_s& ue_info_request_r9()
      {
        assert_choice_type("ueInformationRequest-r9", type_.to_string(), "c1");
        return c;
      }
      const ue_info_request_r9_ies_s& ue_info_request_r9() const
      {
        assert_choice_type("ueInformationRequest-r9", type_.to_string(), "c1");
        return c;
      }
      ue_info_request_r9_ies_s& set_ue_info_request_r9()
      {
        set(types::ue_info_request_r9);
        return c;
      }

    private:
      types                    type_;
      ue_info_request_r9_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-DCCH-MessageType ::= CHOICE
struct dl_dcch_msg_type_c {
  struct c1_c_ {
    struct types_opts {
      enum options {
        csfb_params_resp_cdma2000,
        dl_info_transfer,
        ho_from_eutra_prep_request,
        mob_from_eutra_cmd,
        rrc_conn_recfg,
        rrc_conn_release,
        security_mode_cmd,
        ue_cap_enquiry,
        counter_check,
        ue_info_request_r9,
        logged_meas_cfg_r10,
        rn_recfg_r10,
        rrc_conn_resume_r13,
        spare3,
        spare2,
        spare1,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    c1_c_() = default;
    c1_c_(const c1_c_& other);
    c1_c_& operator=(const c1_c_& other);
    ~c1_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csfb_params_resp_cdma2000_s& csfb_params_resp_cdma2000()
    {
      assert_choice_type("csfbParametersResponseCDMA2000", type_.to_string(), "c1");
      return c.get<csfb_params_resp_cdma2000_s>();
    }
    dl_info_transfer_s& dl_info_transfer()
    {
      assert_choice_type("dlInformationTransfer", type_.to_string(), "c1");
      return c.get<dl_info_transfer_s>();
    }
    ho_from_eutra_prep_request_s& ho_from_eutra_prep_request()
    {
      assert_choice_type("handoverFromEUTRAPreparationRequest", type_.to_string(), "c1");
      return c.get<ho_from_eutra_prep_request_s>();
    }
    mob_from_eutra_cmd_s& mob_from_eutra_cmd()
    {
      assert_choice_type("mobilityFromEUTRACommand", type_.to_string(), "c1");
      return c.get<mob_from_eutra_cmd_s>();
    }
    rrc_conn_recfg_s& rrc_conn_recfg()
    {
      assert_choice_type("rrcConnectionReconfiguration", type_.to_string(), "c1");
      return c.get<rrc_conn_recfg_s>();
    }
    rrc_conn_release_s& rrc_conn_release()
    {
      assert_choice_type("rrcConnectionRelease", type_.to_string(), "c1");
      return c.get<rrc_conn_release_s>();
    }
    security_mode_cmd_s& security_mode_cmd()
    {
      assert_choice_type("securityModeCommand", type_.to_string(), "c1");
      return c.get<security_mode_cmd_s>();
    }
    ue_cap_enquiry_s& ue_cap_enquiry()
    {
      assert_choice_type("ueCapabilityEnquiry", type_.to_string(), "c1");
      return c.get<ue_cap_enquiry_s>();
    }
    counter_check_s& counter_check()
    {
      assert_choice_type("counterCheck", type_.to_string(), "c1");
      return c.get<counter_check_s>();
    }
    ue_info_request_r9_s& ue_info_request_r9()
    {
      assert_choice_type("ueInformationRequest-r9", type_.to_string(), "c1");
      return c.get<ue_info_request_r9_s>();
    }
    logged_meas_cfg_r10_s& logged_meas_cfg_r10()
    {
      assert_choice_type("loggedMeasurementConfiguration-r10", type_.to_string(), "c1");
      return c.get<logged_meas_cfg_r10_s>();
    }
    rn_recfg_r10_s& rn_recfg_r10()
    {
      assert_choice_type("rnReconfiguration-r10", type_.to_string(), "c1");
      return c.get<rn_recfg_r10_s>();
    }
    rrc_conn_resume_r13_s& rrc_conn_resume_r13()
    {
      assert_choice_type("rrcConnectionResume-r13", type_.to_string(), "c1");
      return c.get<rrc_conn_resume_r13_s>();
    }
    const csfb_params_resp_cdma2000_s& csfb_params_resp_cdma2000() const
    {
      assert_choice_type("csfbParametersResponseCDMA2000", type_.to_string(), "c1");
      return c.get<csfb_params_resp_cdma2000_s>();
    }
    const dl_info_transfer_s& dl_info_transfer() const
    {
      assert_choice_type("dlInformationTransfer", type_.to_string(), "c1");
      return c.get<dl_info_transfer_s>();
    }
    const ho_from_eutra_prep_request_s& ho_from_eutra_prep_request() const
    {
      assert_choice_type("handoverFromEUTRAPreparationRequest", type_.to_string(), "c1");
      return c.get<ho_from_eutra_prep_request_s>();
    }
    const mob_from_eutra_cmd_s& mob_from_eutra_cmd() const
    {
      assert_choice_type("mobilityFromEUTRACommand", type_.to_string(), "c1");
      return c.get<mob_from_eutra_cmd_s>();
    }
    const rrc_conn_recfg_s& rrc_conn_recfg() const
    {
      assert_choice_type("rrcConnectionReconfiguration", type_.to_string(), "c1");
      return c.get<rrc_conn_recfg_s>();
    }
    const rrc_conn_release_s& rrc_conn_release() const
    {
      assert_choice_type("rrcConnectionRelease", type_.to_string(), "c1");
      return c.get<rrc_conn_release_s>();
    }
    const security_mode_cmd_s& security_mode_cmd() const
    {
      assert_choice_type("securityModeCommand", type_.to_string(), "c1");
      return c.get<security_mode_cmd_s>();
    }
    const ue_cap_enquiry_s& ue_cap_enquiry() const
    {
      assert_choice_type("ueCapabilityEnquiry", type_.to_string(), "c1");
      return c.get<ue_cap_enquiry_s>();
    }
    const counter_check_s& counter_check() const
    {
      assert_choice_type("counterCheck", type_.to_string(), "c1");
      return c.get<counter_check_s>();
    }
    const ue_info_request_r9_s& ue_info_request_r9() const
    {
      assert_choice_type("ueInformationRequest-r9", type_.to_string(), "c1");
      return c.get<ue_info_request_r9_s>();
    }
    const logged_meas_cfg_r10_s& logged_meas_cfg_r10() const
    {
      assert_choice_type("loggedMeasurementConfiguration-r10", type_.to_string(), "c1");
      return c.get<logged_meas_cfg_r10_s>();
    }
    const rn_recfg_r10_s& rn_recfg_r10() const
    {
      assert_choice_type("rnReconfiguration-r10", type_.to_string(), "c1");
      return c.get<rn_recfg_r10_s>();
    }
    const rrc_conn_resume_r13_s& rrc_conn_resume_r13() const
    {
      assert_choice_type("rrcConnectionResume-r13", type_.to_string(), "c1");
      return c.get<rrc_conn_resume_r13_s>();
    }
    csfb_params_resp_cdma2000_s& set_csfb_params_resp_cdma2000()
    {
      set(types::csfb_params_resp_cdma2000);
      return c.get<csfb_params_resp_cdma2000_s>();
    }
    dl_info_transfer_s& set_dl_info_transfer()
    {
      set(types::dl_info_transfer);
      return c.get<dl_info_transfer_s>();
    }
    ho_from_eutra_prep_request_s& set_ho_from_eutra_prep_request()
    {
      set(types::ho_from_eutra_prep_request);
      return c.get<ho_from_eutra_prep_request_s>();
    }
    mob_from_eutra_cmd_s& set_mob_from_eutra_cmd()
    {
      set(types::mob_from_eutra_cmd);
      return c.get<mob_from_eutra_cmd_s>();
    }
    rrc_conn_recfg_s& set_rrc_conn_recfg()
    {
      set(types::rrc_conn_recfg);
      return c.get<rrc_conn_recfg_s>();
    }
    rrc_conn_release_s& set_rrc_conn_release()
    {
      set(types::rrc_conn_release);
      return c.get<rrc_conn_release_s>();
    }
    security_mode_cmd_s& set_security_mode_cmd()
    {
      set(types::security_mode_cmd);
      return c.get<security_mode_cmd_s>();
    }
    ue_cap_enquiry_s& set_ue_cap_enquiry()
    {
      set(types::ue_cap_enquiry);
      return c.get<ue_cap_enquiry_s>();
    }
    counter_check_s& set_counter_check()
    {
      set(types::counter_check);
      return c.get<counter_check_s>();
    }
    ue_info_request_r9_s& set_ue_info_request_r9()
    {
      set(types::ue_info_request_r9);
      return c.get<ue_info_request_r9_s>();
    }
    logged_meas_cfg_r10_s& set_logged_meas_cfg_r10()
    {
      set(types::logged_meas_cfg_r10);
      return c.get<logged_meas_cfg_r10_s>();
    }
    rn_recfg_r10_s& set_rn_recfg_r10()
    {
      set(types::rn_recfg_r10);
      return c.get<rn_recfg_r10_s>();
    }
    rrc_conn_resume_r13_s& set_rrc_conn_resume_r13()
    {
      set(types::rrc_conn_resume_r13);
      return c.get<rrc_conn_resume_r13_s>();
    }

  private:
    types type_;
    choice_buffer_t<MAX16(sizeof(counter_check_s),
                          sizeof(csfb_params_resp_cdma2000_s),
                          sizeof(dl_info_transfer_s),
                          sizeof(ho_from_eutra_prep_request_s),
                          sizeof(logged_meas_cfg_r10_s),
                          sizeof(mob_from_eutra_cmd_s),
                          sizeof(rn_recfg_r10_s),
                          sizeof(rrc_conn_recfg_s),
                          sizeof(rrc_conn_release_s),
                          sizeof(rrc_conn_resume_r13_s),
                          sizeof(security_mode_cmd_s),
                          sizeof(ue_cap_enquiry_s),
                          sizeof(ue_info_request_r9_s),
                          0,
                          0,
                          0)>
        c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  dl_dcch_msg_type_c() = default;
  dl_dcch_msg_type_c(const dl_dcch_msg_type_c& other);
  dl_dcch_msg_type_c& operator=(const dl_dcch_msg_type_c& other);
  ~dl_dcch_msg_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "DL-DCCH-MessageType");
    return c.get<c1_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "DL-DCCH-MessageType");
    return c.get<c1_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }

private:
  types                          type_;
  choice_buffer_t<sizeof(c1_c_)> c;

  void destroy_();
};

// DL-DCCH-Message ::= SEQUENCE
struct dl_dcch_msg_s {
  // member variables
  dl_dcch_msg_type_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TMGI-r9 ::= SEQUENCE
struct tmgi_r9_s {
  struct plmn_id_r9_c_ {
    struct types_opts {
      enum options { plmn_idx_r9, explicit_value_r9, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    plmn_id_r9_c_() = default;
    plmn_id_r9_c_(const plmn_id_r9_c_& other);
    plmn_id_r9_c_& operator=(const plmn_id_r9_c_& other);
    ~plmn_id_r9_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& plmn_idx_r9()
    {
      assert_choice_type("plmn-Index-r9", type_.to_string(), "plmn-Id-r9");
      return c.get<uint8_t>();
    }
    plmn_id_s& explicit_value_r9()
    {
      assert_choice_type("explicitValue-r9", type_.to_string(), "plmn-Id-r9");
      return c.get<plmn_id_s>();
    }
    const uint8_t& plmn_idx_r9() const
    {
      assert_choice_type("plmn-Index-r9", type_.to_string(), "plmn-Id-r9");
      return c.get<uint8_t>();
    }
    const plmn_id_s& explicit_value_r9() const
    {
      assert_choice_type("explicitValue-r9", type_.to_string(), "plmn-Id-r9");
      return c.get<plmn_id_s>();
    }
    uint8_t& set_plmn_idx_r9()
    {
      set(types::plmn_idx_r9);
      return c.get<uint8_t>();
    }
    plmn_id_s& set_explicit_value_r9()
    {
      set(types::explicit_value_r9);
      return c.get<plmn_id_s>();
    }

  private:
    types                              type_;
    choice_buffer_t<sizeof(plmn_id_s)> c;

    void destroy_();
  };

  // member variables
  plmn_id_r9_c_      plmn_id_r9;
  fixed_octstring<3> service_id_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-SessionInfo-r9 ::= SEQUENCE
struct mbms_session_info_r9_s {
  // member variables
  bool               ext                   = false;
  bool               session_id_r9_present = false;
  tmgi_r9_s          tmgi_r9;
  fixed_octstring<1> session_id_r9;
  uint8_t            lc_ch_id_r9 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-SessionInfoList-r9 ::= SEQUENCE (SIZE (0..maxSessionPerPMCH)) OF MBMS-SessionInfo-r9
typedef dyn_array<mbms_session_info_r9_s> mbms_session_info_list_r9_l;

// PMCH-Config-r12 ::= SEQUENCE
struct pmch_cfg_r12_s {
  struct data_mcs_r12_c_ {
    struct types_opts {
      enum options { normal_r12, higer_order_r12, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    data_mcs_r12_c_() = default;
    data_mcs_r12_c_(const data_mcs_r12_c_& other);
    data_mcs_r12_c_& operator=(const data_mcs_r12_c_& other);
    ~data_mcs_r12_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& normal_r12()
    {
      assert_choice_type("normal-r12", type_.to_string(), "dataMCS-r12");
      return c.get<uint8_t>();
    }
    uint8_t& higer_order_r12()
    {
      assert_choice_type("higerOrder-r12", type_.to_string(), "dataMCS-r12");
      return c.get<uint8_t>();
    }
    const uint8_t& normal_r12() const
    {
      assert_choice_type("normal-r12", type_.to_string(), "dataMCS-r12");
      return c.get<uint8_t>();
    }
    const uint8_t& higer_order_r12() const
    {
      assert_choice_type("higerOrder-r12", type_.to_string(), "dataMCS-r12");
      return c.get<uint8_t>();
    }
    uint8_t& set_normal_r12()
    {
      set(types::normal_r12);
      return c.get<uint8_t>();
    }
    uint8_t& set_higer_order_r12()
    {
      set(types::higer_order_r12);
      return c.get<uint8_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };
  struct mch_sched_period_r12_opts {
    enum options { rf4, rf8, rf16, rf32, rf64, rf128, rf256, rf512, rf1024, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<mch_sched_period_r12_opts> mch_sched_period_r12_e_;
  struct mch_sched_period_v1430_opts {
    enum options { rf1, rf2, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<mch_sched_period_v1430_opts> mch_sched_period_v1430_e_;

  // member variables
  bool                    ext              = false;
  uint16_t                sf_alloc_end_r12 = 0;
  data_mcs_r12_c_         data_mcs_r12;
  mch_sched_period_r12_e_ mch_sched_period_r12;
  // ...
  // group 0
  bool                      mch_sched_period_v1430_present = false;
  mch_sched_period_v1430_e_ mch_sched_period_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CommonSF-AllocPatternList-r14 ::= SEQUENCE (SIZE (1..maxMBSFN-Allocations)) OF MBSFN-SubframeConfig-v1430
typedef dyn_array<mbsfn_sf_cfg_v1430_s> common_sf_alloc_pattern_list_r14_l;

// PMCH-InfoExt-r12 ::= SEQUENCE
struct pmch_info_ext_r12_s {
  // member variables
  bool                        ext = false;
  pmch_cfg_r12_s              pmch_cfg_r12;
  mbms_session_info_list_r9_l mbms_session_info_list_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSFNAreaConfiguration-v1430-IEs ::= SEQUENCE
struct mbsfn_area_cfg_v1430_ies_s {
  // member variables
  bool                               non_crit_ext_present = false;
  common_sf_alloc_pattern_list_r14_l common_sf_alloc_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PMCH-Config-r9 ::= SEQUENCE
struct pmch_cfg_r9_s {
  struct mch_sched_period_r9_opts {
    enum options { rf8, rf16, rf32, rf64, rf128, rf256, rf512, rf1024, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<mch_sched_period_r9_opts> mch_sched_period_r9_e_;

  // member variables
  bool                   ext             = false;
  uint16_t               sf_alloc_end_r9 = 0;
  uint8_t                data_mcs_r9     = 0;
  mch_sched_period_r9_e_ mch_sched_period_r9;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PMCH-InfoListExt-r12 ::= SEQUENCE (SIZE (0..maxPMCH-PerMBSFN)) OF PMCH-InfoExt-r12
typedef dyn_array<pmch_info_ext_r12_s> pmch_info_list_ext_r12_l;

// CountingRequestInfo-r10 ::= SEQUENCE
struct count_request_info_r10_s {
  // member variables
  bool      ext = false;
  tmgi_r9_s tmgi_r10;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSFNAreaConfiguration-v1250-IEs ::= SEQUENCE
struct mbsfn_area_cfg_v1250_ies_s {
  // member variables
  bool                       pmch_info_list_ext_r12_present = false;
  bool                       non_crit_ext_present           = false;
  pmch_info_list_ext_r12_l   pmch_info_list_ext_r12;
  mbsfn_area_cfg_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PMCH-Info-r9 ::= SEQUENCE
struct pmch_info_r9_s {
  // member variables
  bool                        ext = false;
  pmch_cfg_r9_s               pmch_cfg_r9;
  mbms_session_info_list_r9_l mbms_session_info_list_r9;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CommonSF-AllocPatternList-r9 ::= SEQUENCE (SIZE (1..maxMBSFN-Allocations)) OF MBSFN-SubframeConfig
typedef dyn_array<mbsfn_sf_cfg_s> common_sf_alloc_pattern_list_r9_l;

// CountingRequestList-r10 ::= SEQUENCE (SIZE (1..maxServiceCount)) OF CountingRequestInfo-r10
typedef dyn_array<count_request_info_r10_s> count_request_list_r10_l;

// MBSFNAreaConfiguration-v930-IEs ::= SEQUENCE
struct mbsfn_area_cfg_v930_ies_s {
  // member variables
  bool                       late_non_crit_ext_present = false;
  bool                       non_crit_ext_present      = false;
  dyn_octstring              late_non_crit_ext;
  mbsfn_area_cfg_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PMCH-InfoList-r9 ::= SEQUENCE (SIZE (0..maxPMCH-PerMBSFN)) OF PMCH-Info-r9
typedef dyn_array<pmch_info_r9_s> pmch_info_list_r9_l;

// MBMSCountingRequest-r10 ::= SEQUENCE
struct mbms_count_request_r10_s {
  // member variables
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  count_request_list_r10_l count_request_list_r10;
  dyn_octstring            late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSFNAreaConfiguration-r9 ::= SEQUENCE
struct mbsfn_area_cfg_r9_s {
  struct common_sf_alloc_period_r9_opts {
    enum options { rf4, rf8, rf16, rf32, rf64, rf128, rf256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<common_sf_alloc_period_r9_opts> common_sf_alloc_period_r9_e_;

  // member variables
  bool                              non_crit_ext_present = false;
  common_sf_alloc_pattern_list_r9_l common_sf_alloc_r9;
  common_sf_alloc_period_r9_e_      common_sf_alloc_period_r9;
  pmch_info_list_r9_l               pmch_info_list_r9;
  mbsfn_area_cfg_v930_ies_s         non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MCCH-MessageType ::= CHOICE
struct mcch_msg_type_c {
  struct c1_c_ {
    struct types_opts {
      enum options { mbsfn_area_cfg_r9, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::mbsfn_area_cfg_r9; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    mbsfn_area_cfg_r9_s&       mbsfn_area_cfg_r9() { return c; }
    const mbsfn_area_cfg_r9_s& mbsfn_area_cfg_r9() const { return c; }

  private:
    mbsfn_area_cfg_r9_s c;
  };
  struct later_c_ {
    struct c2_c_ {
      struct types_opts {
        enum options { mbms_count_request_r10, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      types       type() const { return types::mbms_count_request_r10; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      mbms_count_request_r10_s&       mbms_count_request_r10() { return c; }
      const mbms_count_request_r10_s& mbms_count_request_r10() const { return c; }

    private:
      mbms_count_request_r10_s c;
    };
    struct types_opts {
      enum options { c2, msg_class_ext, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    later_c_() = default;
    later_c_(const later_c_& other);
    later_c_& operator=(const later_c_& other);
    ~later_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c2_c_& c2()
    {
      assert_choice_type("c2", type_.to_string(), "later");
      return c.get<c2_c_>();
    }
    const c2_c_& c2() const
    {
      assert_choice_type("c2", type_.to_string(), "later");
      return c.get<c2_c_>();
    }
    c2_c_& set_c2()
    {
      set(types::c2);
      return c.get<c2_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c2_c_)> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, later, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  mcch_msg_type_c() = default;
  mcch_msg_type_c(const mcch_msg_type_c& other);
  mcch_msg_type_c& operator=(const mcch_msg_type_c& other);
  ~mcch_msg_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "MCCH-MessageType");
    return c.get<c1_c_>();
  }
  later_c_& later()
  {
    assert_choice_type("later", type_.to_string(), "MCCH-MessageType");
    return c.get<later_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "MCCH-MessageType");
    return c.get<c1_c_>();
  }
  const later_c_& later() const
  {
    assert_choice_type("later", type_.to_string(), "MCCH-MessageType");
    return c.get<later_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }
  later_c_& set_later()
  {
    set(types::later);
    return c.get<later_c_>();
  }

private:
  types                                                  type_;
  choice_buffer_t<MAX2(sizeof(c1_c_), sizeof(later_c_))> c;

  void destroy_();
};

// MCCH-Message ::= SEQUENCE
struct mcch_msg_s {
  // member variables
  mcch_msg_type_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Paging-v1530-IEs ::= SEQUENCE
struct paging_v1530_ies_s {
  // member variables
  bool access_type_present  = false;
  bool non_crit_ext_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IMSI ::= SEQUENCE (SIZE (6..21)) OF INTEGER
typedef bounded_array<uint8_t, 21> imsi_l;

// Paging-v1310-IEs ::= SEQUENCE
struct paging_v1310_ies_s {
  // member variables
  bool               redist_ind_r13_present         = false;
  bool               sys_info_mod_e_drx_r13_present = false;
  bool               non_crit_ext_present           = false;
  paging_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// S-TMSI ::= SEQUENCE
struct s_tmsi_s {
  // member variables
  fixed_bitstring<8>  mmec;
  fixed_bitstring<32> m_tmsi;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Paging-v1130-IEs ::= SEQUENCE
struct paging_v1130_ies_s {
  // member variables
  bool               eab_param_mod_r11_present = false;
  bool               non_crit_ext_present      = false;
  paging_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PagingUE-Identity ::= CHOICE
struct paging_ue_id_c {
  struct types_opts {
    enum options { s_tmsi, imsi, /*...*/ ng_minus5_g_s_tmsi_r15, i_rnti_r15, nulltype } value;
    typedef int8_t number_type;

    std::string to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<types_opts, true, 2> types;

  // choice methods
  paging_ue_id_c() = default;
  paging_ue_id_c(const paging_ue_id_c& other);
  paging_ue_id_c& operator=(const paging_ue_id_c& other);
  ~paging_ue_id_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  s_tmsi_s& s_tmsi()
  {
    assert_choice_type("s-TMSI", type_.to_string(), "PagingUE-Identity");
    return c.get<s_tmsi_s>();
  }
  imsi_l& imsi()
  {
    assert_choice_type("imsi", type_.to_string(), "PagingUE-Identity");
    return c.get<imsi_l>();
  }
  fixed_bitstring<48>& ng_minus5_g_s_tmsi_r15()
  {
    assert_choice_type("ng-5G-S-TMSI-r15", type_.to_string(), "PagingUE-Identity");
    return c.get<fixed_bitstring<48> >();
  }
  fixed_bitstring<40>& i_rnti_r15()
  {
    assert_choice_type("i-RNTI-r15", type_.to_string(), "PagingUE-Identity");
    return c.get<fixed_bitstring<40> >();
  }
  const s_tmsi_s& s_tmsi() const
  {
    assert_choice_type("s-TMSI", type_.to_string(), "PagingUE-Identity");
    return c.get<s_tmsi_s>();
  }
  const imsi_l& imsi() const
  {
    assert_choice_type("imsi", type_.to_string(), "PagingUE-Identity");
    return c.get<imsi_l>();
  }
  const fixed_bitstring<48>& ng_minus5_g_s_tmsi_r15() const
  {
    assert_choice_type("ng-5G-S-TMSI-r15", type_.to_string(), "PagingUE-Identity");
    return c.get<fixed_bitstring<48> >();
  }
  const fixed_bitstring<40>& i_rnti_r15() const
  {
    assert_choice_type("i-RNTI-r15", type_.to_string(), "PagingUE-Identity");
    return c.get<fixed_bitstring<40> >();
  }
  s_tmsi_s& set_s_tmsi()
  {
    set(types::s_tmsi);
    return c.get<s_tmsi_s>();
  }
  imsi_l& set_imsi()
  {
    set(types::imsi);
    return c.get<imsi_l>();
  }
  fixed_bitstring<48>& set_ng_minus5_g_s_tmsi_r15()
  {
    set(types::ng_minus5_g_s_tmsi_r15);
    return c.get<fixed_bitstring<48> >();
  }
  fixed_bitstring<40>& set_i_rnti_r15()
  {
    set(types::i_rnti_r15);
    return c.get<fixed_bitstring<40> >();
  }

private:
  types                                                                                   type_;
  choice_buffer_t<MAX4(sizeof(fixed_bitstring<48>), sizeof(imsi_l), sizeof(s_tmsi_s), 0)> c;

  void destroy_();
};

// Paging-v920-IEs ::= SEQUENCE
struct paging_v920_ies_s {
  // member variables
  bool               cmas_ind_r9_present  = false;
  bool               non_crit_ext_present = false;
  paging_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PagingRecord ::= SEQUENCE
struct paging_record_s {
  struct cn_domain_opts {
    enum options { ps, cs, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<cn_domain_opts> cn_domain_e_;

  // member variables
  bool           ext = false;
  paging_ue_id_c ue_id;
  cn_domain_e_   cn_domain;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Paging-v890-IEs ::= SEQUENCE
struct paging_v890_ies_s {
  // member variables
  bool              late_non_crit_ext_present = false;
  bool              non_crit_ext_present      = false;
  dyn_octstring     late_non_crit_ext;
  paging_v920_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PagingRecordList ::= SEQUENCE (SIZE (1..maxPageRec)) OF PagingRecord
typedef dyn_array<paging_record_s> paging_record_list_l;

// Paging ::= SEQUENCE
struct paging_s {
  // member variables
  bool                 paging_record_list_present = false;
  bool                 sys_info_mod_present       = false;
  bool                 etws_ind_present           = false;
  bool                 non_crit_ext_present       = false;
  paging_record_list_l paging_record_list;
  paging_v890_ies_s    non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PCCH-MessageType ::= CHOICE
struct pcch_msg_type_c {
  struct c1_c_ {
    struct types_opts {
      enum options { paging, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::paging; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    paging_s&       paging() { return c; }
    const paging_s& paging() const { return c; }

  private:
    paging_s c;
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  pcch_msg_type_c() = default;
  pcch_msg_type_c(const pcch_msg_type_c& other);
  pcch_msg_type_c& operator=(const pcch_msg_type_c& other);
  ~pcch_msg_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "PCCH-MessageType");
    return c.get<c1_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "PCCH-MessageType");
    return c.get<c1_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }

private:
  types                          type_;
  choice_buffer_t<sizeof(c1_c_)> c;

  void destroy_();
};

// PCCH-Message ::= SEQUENCE
struct pcch_msg_s {
  // member variables
  pcch_msg_type_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMSSessionInfo-r13 ::= SEQUENCE
struct mbms_session_info_r13_s {
  // member variables
  bool               session_id_r13_present = false;
  tmgi_r9_s          tmgi_r13;
  fixed_octstring<1> session_id_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SC-MTCH-SchedulingInfo-BR-r14 ::= SEQUENCE
struct sc_mtch_sched_info_br_r14_s {
  struct on_dur_timer_scptm_r14_opts {
    enum options { psf300, psf400, psf500, psf600, psf800, psf1000, psf1200, psf1600, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<on_dur_timer_scptm_r14_opts> on_dur_timer_scptm_r14_e_;
  struct drx_inactivity_timer_scptm_r14_opts {
    enum options {
      psf0,
      psf1,
      psf2,
      psf4,
      psf8,
      psf16,
      psf32,
      psf64,
      psf128,
      psf256,
      ps512,
      psf1024,
      psf2048,
      psf4096,
      psf8192,
      psf16384,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<drx_inactivity_timer_scptm_r14_opts> drx_inactivity_timer_scptm_r14_e_;
  struct sched_period_start_offset_scptm_r14_c_ {
    struct types_opts {
      enum options {
        sf10,
        sf20,
        sf32,
        sf40,
        sf64,
        sf80,
        sf128,
        sf160,
        sf256,
        sf320,
        sf512,
        sf640,
        sf1024,
        sf2048,
        sf4096,
        sf8192,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sched_period_start_offset_scptm_r14_c_() = default;
    sched_period_start_offset_scptm_r14_c_(const sched_period_start_offset_scptm_r14_c_& other);
    sched_period_start_offset_scptm_r14_c_& operator=(const sched_period_start_offset_scptm_r14_c_& other);
    ~sched_period_start_offset_scptm_r14_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& sf10()
    {
      assert_choice_type("sf10", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf20()
    {
      assert_choice_type("sf20", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf32()
    {
      assert_choice_type("sf32", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf40()
    {
      assert_choice_type("sf40", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf64()
    {
      assert_choice_type("sf64", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf80()
    {
      assert_choice_type("sf80", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf128()
    {
      assert_choice_type("sf128", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf160()
    {
      assert_choice_type("sf160", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint8_t& sf256()
    {
      assert_choice_type("sf256", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    uint16_t& sf320()
    {
      assert_choice_type("sf320", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf512()
    {
      assert_choice_type("sf512", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf640()
    {
      assert_choice_type("sf640", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf1024()
    {
      assert_choice_type("sf1024", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf2048()
    {
      assert_choice_type("sf2048", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf4096()
    {
      assert_choice_type("sf4096", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint16_t& sf8192()
    {
      assert_choice_type("sf8192", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint8_t& sf10() const
    {
      assert_choice_type("sf10", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf20() const
    {
      assert_choice_type("sf20", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf32() const
    {
      assert_choice_type("sf32", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf40() const
    {
      assert_choice_type("sf40", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf64() const
    {
      assert_choice_type("sf64", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf80() const
    {
      assert_choice_type("sf80", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf128() const
    {
      assert_choice_type("sf128", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf160() const
    {
      assert_choice_type("sf160", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint8_t& sf256() const
    {
      assert_choice_type("sf256", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint8_t>();
    }
    const uint16_t& sf320() const
    {
      assert_choice_type("sf320", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf512() const
    {
      assert_choice_type("sf512", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf640() const
    {
      assert_choice_type("sf640", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf1024() const
    {
      assert_choice_type("sf1024", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf2048() const
    {
      assert_choice_type("sf2048", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf4096() const
    {
      assert_choice_type("sf4096", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    const uint16_t& sf8192() const
    {
      assert_choice_type("sf8192", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r14");
      return c.get<uint16_t>();
    }
    uint8_t& set_sf10()
    {
      set(types::sf10);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf20()
    {
      set(types::sf20);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf32()
    {
      set(types::sf32);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf40()
    {
      set(types::sf40);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf64()
    {
      set(types::sf64);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf80()
    {
      set(types::sf80);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf128()
    {
      set(types::sf128);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf160()
    {
      set(types::sf160);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf256()
    {
      set(types::sf256);
      return c.get<uint8_t>();
    }
    uint16_t& set_sf320()
    {
      set(types::sf320);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf512()
    {
      set(types::sf512);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf640()
    {
      set(types::sf640);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf1024()
    {
      set(types::sf1024);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf2048()
    {
      set(types::sf2048);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf4096()
    {
      set(types::sf4096);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf8192()
    {
      set(types::sf8192);
      return c.get<uint16_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool                                   ext = false;
  on_dur_timer_scptm_r14_e_              on_dur_timer_scptm_r14;
  drx_inactivity_timer_scptm_r14_e_      drx_inactivity_timer_scptm_r14;
  sched_period_start_offset_scptm_r14_c_ sched_period_start_offset_scptm_r14;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SC-MTCH-SchedulingInfo-r13 ::= SEQUENCE
struct sc_mtch_sched_info_r13_s {
  struct on_dur_timer_scptm_r13_opts {
    enum options {
      psf1,
      psf2,
      psf3,
      psf4,
      psf5,
      psf6,
      psf8,
      psf10,
      psf20,
      psf30,
      psf40,
      psf50,
      psf60,
      psf80,
      psf100,
      psf200,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<on_dur_timer_scptm_r13_opts> on_dur_timer_scptm_r13_e_;
  struct drx_inactivity_timer_scptm_r13_opts {
    enum options {
      psf0,
      psf1,
      psf2,
      psf4,
      psf8,
      psf10,
      psf20,
      psf40,
      psf80,
      psf160,
      ps320,
      psf640,
      psf960,
      psf1280,
      psf1920,
      psf2560,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<drx_inactivity_timer_scptm_r13_opts> drx_inactivity_timer_scptm_r13_e_;
  struct sched_period_start_offset_scptm_r13_c_ {
    struct types_opts {
      enum options {
        sf10,
        sf20,
        sf32,
        sf40,
        sf64,
        sf80,
        sf128,
        sf160,
        sf256,
        sf320,
        sf512,
        sf640,
        sf1024,
        sf2048,
        sf4096,
        sf8192,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sched_period_start_offset_scptm_r13_c_() = default;
    sched_period_start_offset_scptm_r13_c_(const sched_period_start_offset_scptm_r13_c_& other);
    sched_period_start_offset_scptm_r13_c_& operator=(const sched_period_start_offset_scptm_r13_c_& other);
    ~sched_period_start_offset_scptm_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& sf10()
    {
      assert_choice_type("sf10", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf20()
    {
      assert_choice_type("sf20", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf32()
    {
      assert_choice_type("sf32", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf40()
    {
      assert_choice_type("sf40", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf64()
    {
      assert_choice_type("sf64", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf80()
    {
      assert_choice_type("sf80", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf128()
    {
      assert_choice_type("sf128", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf160()
    {
      assert_choice_type("sf160", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint8_t& sf256()
    {
      assert_choice_type("sf256", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    uint16_t& sf320()
    {
      assert_choice_type("sf320", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    uint16_t& sf512()
    {
      assert_choice_type("sf512", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    uint16_t& sf640()
    {
      assert_choice_type("sf640", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    uint16_t& sf1024()
    {
      assert_choice_type("sf1024", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    uint16_t& sf2048()
    {
      assert_choice_type("sf2048", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    uint16_t& sf4096()
    {
      assert_choice_type("sf4096", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    uint16_t& sf8192()
    {
      assert_choice_type("sf8192", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    const uint8_t& sf10() const
    {
      assert_choice_type("sf10", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf20() const
    {
      assert_choice_type("sf20", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf32() const
    {
      assert_choice_type("sf32", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf40() const
    {
      assert_choice_type("sf40", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf64() const
    {
      assert_choice_type("sf64", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf80() const
    {
      assert_choice_type("sf80", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf128() const
    {
      assert_choice_type("sf128", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf160() const
    {
      assert_choice_type("sf160", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint8_t& sf256() const
    {
      assert_choice_type("sf256", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint8_t>();
    }
    const uint16_t& sf320() const
    {
      assert_choice_type("sf320", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    const uint16_t& sf512() const
    {
      assert_choice_type("sf512", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    const uint16_t& sf640() const
    {
      assert_choice_type("sf640", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    const uint16_t& sf1024() const
    {
      assert_choice_type("sf1024", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    const uint16_t& sf2048() const
    {
      assert_choice_type("sf2048", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    const uint16_t& sf4096() const
    {
      assert_choice_type("sf4096", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    const uint16_t& sf8192() const
    {
      assert_choice_type("sf8192", type_.to_string(), "schedulingPeriodStartOffsetSCPTM-r13");
      return c.get<uint16_t>();
    }
    uint8_t& set_sf10()
    {
      set(types::sf10);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf20()
    {
      set(types::sf20);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf32()
    {
      set(types::sf32);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf40()
    {
      set(types::sf40);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf64()
    {
      set(types::sf64);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf80()
    {
      set(types::sf80);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf128()
    {
      set(types::sf128);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf160()
    {
      set(types::sf160);
      return c.get<uint8_t>();
    }
    uint8_t& set_sf256()
    {
      set(types::sf256);
      return c.get<uint8_t>();
    }
    uint16_t& set_sf320()
    {
      set(types::sf320);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf512()
    {
      set(types::sf512);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf640()
    {
      set(types::sf640);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf1024()
    {
      set(types::sf1024);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf2048()
    {
      set(types::sf2048);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf4096()
    {
      set(types::sf4096);
      return c.get<uint16_t>();
    }
    uint16_t& set_sf8192()
    {
      set(types::sf8192);
      return c.get<uint16_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool                                   ext = false;
  on_dur_timer_scptm_r13_e_              on_dur_timer_scptm_r13;
  drx_inactivity_timer_scptm_r13_e_      drx_inactivity_timer_scptm_r13;
  sched_period_start_offset_scptm_r13_c_ sched_period_start_offset_scptm_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PCI-ARFCN-r13 ::= SEQUENCE
struct pci_arfcn_r13_s {
  // member variables
  bool     carrier_freq_r13_present = false;
  uint16_t pci_r13                  = 0;
  uint32_t carrier_freq_r13         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SC-MTCH-Info-BR-r14 ::= SEQUENCE
struct sc_mtch_info_br_r14_s {
  struct mpdcch_num_repeat_sc_mtch_r14_opts {
    enum options { r1, r2, r4, r8, r16, r32, r64, r128, r256, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<mpdcch_num_repeat_sc_mtch_r14_opts> mpdcch_num_repeat_sc_mtch_r14_e_;
  struct mpdcch_start_sf_sc_mtch_r14_c_ {
    struct fdd_r14_opts {
      enum options { v1, v1dot5, v2, v2dot5, v4, v5, v8, v10, nulltype } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<fdd_r14_opts> fdd_r14_e_;
    struct tdd_r14_opts {
      enum options { v1, v2, v4, v5, v8, v10, v20, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tdd_r14_opts> tdd_r14_e_;
    struct types_opts {
      enum options { fdd_r14, tdd_r14, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    mpdcch_start_sf_sc_mtch_r14_c_() = default;
    mpdcch_start_sf_sc_mtch_r14_c_(const mpdcch_start_sf_sc_mtch_r14_c_& other);
    mpdcch_start_sf_sc_mtch_r14_c_& operator=(const mpdcch_start_sf_sc_mtch_r14_c_& other);
    ~mpdcch_start_sf_sc_mtch_r14_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fdd_r14_e_& fdd_r14()
    {
      assert_choice_type("fdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MTCH-r14");
      return c.get<fdd_r14_e_>();
    }
    tdd_r14_e_& tdd_r14()
    {
      assert_choice_type("tdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MTCH-r14");
      return c.get<tdd_r14_e_>();
    }
    const fdd_r14_e_& fdd_r14() const
    {
      assert_choice_type("fdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MTCH-r14");
      return c.get<fdd_r14_e_>();
    }
    const tdd_r14_e_& tdd_r14() const
    {
      assert_choice_type("tdd-r14", type_.to_string(), "mpdcch-StartSF-SC-MTCH-r14");
      return c.get<tdd_r14_e_>();
    }
    fdd_r14_e_& set_fdd_r14()
    {
      set(types::fdd_r14);
      return c.get<fdd_r14_e_>();
    }
    tdd_r14_e_& set_tdd_r14()
    {
      set(types::tdd_r14);
      return c.get<tdd_r14_e_>();
    }

  private:
    types                                                         type_;
    choice_buffer_t<MAX2(sizeof(fdd_r14_e_), sizeof(tdd_r14_e_))> c;

    void destroy_();
  };
  struct mpdcch_pdsch_hop_cfg_sc_mtch_r14_opts {
    enum options { on, off, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<mpdcch_pdsch_hop_cfg_sc_mtch_r14_opts> mpdcch_pdsch_hop_cfg_sc_mtch_r14_e_;
  struct mpdcch_pdsch_cemode_cfg_sc_mtch_r14_opts {
    enum options { ce_mode_a, ce_mode_b, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<mpdcch_pdsch_cemode_cfg_sc_mtch_r14_opts> mpdcch_pdsch_cemode_cfg_sc_mtch_r14_e_;
  struct mpdcch_pdsch_max_bw_sc_mtch_r14_opts {
    enum options { bw1dot4, bw5, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<mpdcch_pdsch_max_bw_sc_mtch_r14_opts> mpdcch_pdsch_max_bw_sc_mtch_r14_e_;
  struct mpdcch_offset_sc_mtch_r14_opts {
    enum options {
      zero,
      one_eighth,
      one_quarter,
      three_eighth,
      one_half,
      five_eighth,
      three_quarter,
      seven_eighth,
      nulltype
    } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<mpdcch_offset_sc_mtch_r14_opts> mpdcch_offset_sc_mtch_r14_e_;
  struct p_a_r14_opts {
    enum options { db_minus6, db_minus4dot77, db_minus3, db_minus1dot77, db0, db1, db2, db3, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<p_a_r14_opts> p_a_r14_e_;

  // member variables
  bool                                   ext                                = false;
  bool                                   sc_mtch_sched_info_r14_present     = false;
  bool                                   sc_mtch_neighbour_cell_r14_present = false;
  bool                                   p_a_r14_present                    = false;
  uint32_t                               sc_mtch_carrier_freq_r14           = 0;
  mbms_session_info_r13_s                mbms_session_info_r14;
  fixed_bitstring<16>                    g_rnti_r14;
  sc_mtch_sched_info_br_r14_s            sc_mtch_sched_info_r14;
  fixed_bitstring<8>                     sc_mtch_neighbour_cell_r14;
  uint8_t                                mpdcch_nb_sc_mtch_r14 = 1;
  mpdcch_num_repeat_sc_mtch_r14_e_       mpdcch_num_repeat_sc_mtch_r14;
  mpdcch_start_sf_sc_mtch_r14_c_         mpdcch_start_sf_sc_mtch_r14;
  mpdcch_pdsch_hop_cfg_sc_mtch_r14_e_    mpdcch_pdsch_hop_cfg_sc_mtch_r14;
  mpdcch_pdsch_cemode_cfg_sc_mtch_r14_e_ mpdcch_pdsch_cemode_cfg_sc_mtch_r14;
  mpdcch_pdsch_max_bw_sc_mtch_r14_e_     mpdcch_pdsch_max_bw_sc_mtch_r14;
  mpdcch_offset_sc_mtch_r14_e_           mpdcch_offset_sc_mtch_r14;
  p_a_r14_e_                             p_a_r14;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SC-MTCH-Info-r13 ::= SEQUENCE
struct sc_mtch_info_r13_s {
  struct p_a_r13_opts {
    enum options { db_minus6, db_minus4dot77, db_minus3, db_minus1dot77, db0, db1, db2, db3, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<p_a_r13_opts> p_a_r13_e_;

  // member variables
  bool                     ext                                = false;
  bool                     sc_mtch_sched_info_r13_present     = false;
  bool                     sc_mtch_neighbour_cell_r13_present = false;
  mbms_session_info_r13_s  mbms_session_info_r13;
  fixed_bitstring<16>      g_rnti_r13;
  sc_mtch_sched_info_r13_s sc_mtch_sched_info_r13;
  fixed_bitstring<8>       sc_mtch_neighbour_cell_r13;
  // ...
  // group 0
  bool       p_a_r13_present = false;
  p_a_r13_e_ p_a_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SC-MTCH-InfoList-BR-r14 ::= SEQUENCE (SIZE (0..maxSC-MTCH-BR-r14)) OF SC-MTCH-Info-BR-r14
typedef dyn_array<sc_mtch_info_br_r14_s> sc_mtch_info_list_br_r14_l;

// SC-MTCH-InfoList-r13 ::= SEQUENCE (SIZE (0..maxSC-MTCH-r13)) OF SC-MTCH-Info-r13
typedef dyn_array<sc_mtch_info_r13_s> sc_mtch_info_list_r13_l;

// SCPTM-NeighbourCellList-r13 ::= SEQUENCE (SIZE (1..maxNeighCell-SCPTM-r13)) OF PCI-ARFCN-r13
typedef dyn_array<pci_arfcn_r13_s> scptm_neighbour_cell_list_r13_l;

// SCPTMConfiguration-v1340 ::= SEQUENCE
struct scptm_cfg_v1340_s {
  // member variables
  bool    p_b_r13_present      = false;
  bool    non_crit_ext_present = false;
  uint8_t p_b_r13              = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCPTMConfiguration-BR-r14 ::= SEQUENCE
struct scptm_cfg_br_r14_s {
  // member variables
  bool                            scptm_neighbour_cell_list_r14_present = false;
  bool                            p_b_r14_present                       = false;
  bool                            late_non_crit_ext_present             = false;
  bool                            non_crit_ext_present                  = false;
  sc_mtch_info_list_br_r14_l      sc_mtch_info_list_r14;
  scptm_neighbour_cell_list_r13_l scptm_neighbour_cell_list_r14;
  uint8_t                         p_b_r14 = 0;
  dyn_octstring                   late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCPTMConfiguration-r13 ::= SEQUENCE
struct scptm_cfg_r13_s {
  // member variables
  bool                            scptm_neighbour_cell_list_r13_present = false;
  bool                            late_non_crit_ext_present             = false;
  bool                            non_crit_ext_present                  = false;
  sc_mtch_info_list_r13_l         sc_mtch_info_list_r13;
  scptm_neighbour_cell_list_r13_l scptm_neighbour_cell_list_r13;
  dyn_octstring                   late_non_crit_ext;
  scptm_cfg_v1340_s               non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SC-MCCH-MessageType-r13 ::= CHOICE
struct sc_mcch_msg_type_r13_c {
  struct c1_c_ {
    struct types_opts {
      enum options { scptm_cfg_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::scptm_cfg_r13; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    scptm_cfg_r13_s&       scptm_cfg_r13() { return c; }
    const scptm_cfg_r13_s& scptm_cfg_r13() const { return c; }

  private:
    scptm_cfg_r13_s c;
  };
  struct msg_class_ext_c_ {
    struct c2_c_ {
      struct types_opts {
        enum options { scptm_cfg_br_r14, spare, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c2_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      scptm_cfg_br_r14_s& scptm_cfg_br_r14()
      {
        assert_choice_type("scptmConfiguration-BR-r14", type_.to_string(), "c2");
        return c;
      }
      const scptm_cfg_br_r14_s& scptm_cfg_br_r14() const
      {
        assert_choice_type("scptmConfiguration-BR-r14", type_.to_string(), "c2");
        return c;
      }
      scptm_cfg_br_r14_s& set_scptm_cfg_br_r14()
      {
        set(types::scptm_cfg_br_r14);
        return c;
      }

    private:
      types              type_;
      scptm_cfg_br_r14_s c;
    };
    struct types_opts {
      enum options { c2, msg_class_ext_future_r14, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    msg_class_ext_c_() = default;
    msg_class_ext_c_(const msg_class_ext_c_& other);
    msg_class_ext_c_& operator=(const msg_class_ext_c_& other);
    ~msg_class_ext_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c2_c_& c2()
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    const c2_c_& c2() const
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    c2_c_& set_c2()
    {
      set(types::c2);
      return c.get<c2_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c2_c_)> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sc_mcch_msg_type_r13_c() = default;
  sc_mcch_msg_type_r13_c(const sc_mcch_msg_type_r13_c& other);
  sc_mcch_msg_type_r13_c& operator=(const sc_mcch_msg_type_r13_c& other);
  ~sc_mcch_msg_type_r13_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "SC-MCCH-MessageType-r13");
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& msg_class_ext()
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "SC-MCCH-MessageType-r13");
    return c.get<msg_class_ext_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "SC-MCCH-MessageType-r13");
    return c.get<c1_c_>();
  }
  const msg_class_ext_c_& msg_class_ext() const
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "SC-MCCH-MessageType-r13");
    return c.get<msg_class_ext_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& set_msg_class_ext()
  {
    set(types::msg_class_ext);
    return c.get<msg_class_ext_c_>();
  }

private:
  types                                                          type_;
  choice_buffer_t<MAX2(sizeof(c1_c_), sizeof(msg_class_ext_c_))> c;

  void destroy_();
};

// SC-MCCH-Message-r13 ::= SEQUENCE
struct sc_mcch_msg_r13_s {
  // member variables
  sc_mcch_msg_type_r13_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EstablishmentCause ::= ENUMERATED
struct establishment_cause_opts {
  enum options {
    emergency,
    high_prio_access,
    mt_access,
    mo_sig,
    mo_data,
    delay_tolerant_access_v1020,
    mo_voice_call_v1280,
    spare1,
    nulltype
  } value;

  std::string to_string() const;
};
typedef enumerated<establishment_cause_opts> establishment_cause_e;

// InitialUE-Identity ::= CHOICE
struct init_ue_id_c {
  struct types_opts {
    enum options { s_tmsi, random_value, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  init_ue_id_c() = default;
  init_ue_id_c(const init_ue_id_c& other);
  init_ue_id_c& operator=(const init_ue_id_c& other);
  ~init_ue_id_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  s_tmsi_s& s_tmsi()
  {
    assert_choice_type("s-TMSI", type_.to_string(), "InitialUE-Identity");
    return c.get<s_tmsi_s>();
  }
  fixed_bitstring<40>& random_value()
  {
    assert_choice_type("randomValue", type_.to_string(), "InitialUE-Identity");
    return c.get<fixed_bitstring<40> >();
  }
  const s_tmsi_s& s_tmsi() const
  {
    assert_choice_type("s-TMSI", type_.to_string(), "InitialUE-Identity");
    return c.get<s_tmsi_s>();
  }
  const fixed_bitstring<40>& random_value() const
  {
    assert_choice_type("randomValue", type_.to_string(), "InitialUE-Identity");
    return c.get<fixed_bitstring<40> >();
  }
  s_tmsi_s& set_s_tmsi()
  {
    set(types::s_tmsi);
    return c.get<s_tmsi_s>();
  }
  fixed_bitstring<40>& set_random_value()
  {
    set(types::random_value);
    return c.get<fixed_bitstring<40> >();
  }

private:
  types                                                                type_;
  choice_buffer_t<MAX2(sizeof(fixed_bitstring<40>), sizeof(s_tmsi_s))> c;

  void destroy_();
};

// ReestabUE-Identity ::= SEQUENCE
struct reestab_ue_id_s {
  // member variables
  fixed_bitstring<16> c_rnti;
  uint16_t            pci = 0;
  fixed_bitstring<16> short_mac_i;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReestablishmentCause ::= ENUMERATED
struct reest_cause_opts {
  enum options { recfg_fail, ho_fail, other_fail, spare1, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<reest_cause_opts> reest_cause_e;

// ResumeCause ::= ENUMERATED
struct resume_cause_opts {
  enum options {
    emergency,
    high_prio_access,
    mt_access,
    mo_sig,
    mo_data,
    delay_tolerant_access_v1020,
    mo_voice_call_v1280,
    spare1,
    nulltype
  } value;

  std::string to_string() const;
};
typedef enumerated<resume_cause_opts> resume_cause_e;

// ResumeCause-r15 ::= ENUMERATED
struct resume_cause_r15_opts {
  enum options {
    emergency,
    high_prio_access,
    mt_access,
    mo_sig,
    mo_data,
    rna_update,
    mo_voice_call,
    spare1,
    nulltype
  } value;

  std::string to_string() const;
};
typedef enumerated<resume_cause_r15_opts> resume_cause_r15_e;

// RRCConnectionReestablishmentRequest-r8-IEs ::= SEQUENCE
struct rrc_conn_reest_request_r8_ies_s {
  // member variables
  reestab_ue_id_s    ue_id;
  reest_cause_e      reest_cause;
  fixed_bitstring<2> spare;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRequest-r8-IEs ::= SEQUENCE
struct rrc_conn_request_r8_ies_s {
  // member variables
  init_ue_id_c          ue_id;
  establishment_cause_e establishment_cause;
  fixed_bitstring<1>    spare;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResumeRequest-5GC-r15-IEs ::= SEQUENCE
struct rrc_conn_resume_request_minus5_gc_r15_ies_s {
  struct resume_id_r15_c_ {
    struct types_opts {
      enum options { full_i_rnti_r15, short_i_rnti_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    resume_id_r15_c_() = default;
    resume_id_r15_c_(const resume_id_r15_c_& other);
    resume_id_r15_c_& operator=(const resume_id_r15_c_& other);
    ~resume_id_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<40>& full_i_rnti_r15()
    {
      assert_choice_type("fullI-RNTI-r15", type_.to_string(), "resumeIdentity-r15");
      return c.get<fixed_bitstring<40> >();
    }
    fixed_bitstring<24>& short_i_rnti_r15()
    {
      assert_choice_type("shortI-RNTI-r15", type_.to_string(), "resumeIdentity-r15");
      return c.get<fixed_bitstring<24> >();
    }
    const fixed_bitstring<40>& full_i_rnti_r15() const
    {
      assert_choice_type("fullI-RNTI-r15", type_.to_string(), "resumeIdentity-r15");
      return c.get<fixed_bitstring<40> >();
    }
    const fixed_bitstring<24>& short_i_rnti_r15() const
    {
      assert_choice_type("shortI-RNTI-r15", type_.to_string(), "resumeIdentity-r15");
      return c.get<fixed_bitstring<24> >();
    }
    fixed_bitstring<40>& set_full_i_rnti_r15()
    {
      set(types::full_i_rnti_r15);
      return c.get<fixed_bitstring<40> >();
    }
    fixed_bitstring<24>& set_short_i_rnti_r15()
    {
      set(types::short_i_rnti_r15);
      return c.get<fixed_bitstring<24> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<40>)> c;

    void destroy_();
  };

  // member variables
  resume_id_r15_c_    resume_id_r15;
  fixed_bitstring<16> short_resume_mac_i_r15;
  resume_cause_r15_e  resume_cause_r15;
  fixed_bitstring<1>  spare;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResumeRequest-r13-IEs ::= SEQUENCE
struct rrc_conn_resume_request_r13_ies_s {
  struct resume_id_r13_c_ {
    struct types_opts {
      enum options { resume_id_r13, truncated_resume_id_r13, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    resume_id_r13_c_() = default;
    resume_id_r13_c_(const resume_id_r13_c_& other);
    resume_id_r13_c_& operator=(const resume_id_r13_c_& other);
    ~resume_id_r13_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<40>& resume_id_r13()
    {
      assert_choice_type("resumeID-r13", type_.to_string(), "resumeIdentity-r13");
      return c.get<fixed_bitstring<40> >();
    }
    fixed_bitstring<24>& truncated_resume_id_r13()
    {
      assert_choice_type("truncatedResumeID-r13", type_.to_string(), "resumeIdentity-r13");
      return c.get<fixed_bitstring<24> >();
    }
    const fixed_bitstring<40>& resume_id_r13() const
    {
      assert_choice_type("resumeID-r13", type_.to_string(), "resumeIdentity-r13");
      return c.get<fixed_bitstring<40> >();
    }
    const fixed_bitstring<24>& truncated_resume_id_r13() const
    {
      assert_choice_type("truncatedResumeID-r13", type_.to_string(), "resumeIdentity-r13");
      return c.get<fixed_bitstring<24> >();
    }
    fixed_bitstring<40>& set_resume_id_r13()
    {
      set(types::resume_id_r13);
      return c.get<fixed_bitstring<40> >();
    }
    fixed_bitstring<24>& set_truncated_resume_id_r13()
    {
      set(types::truncated_resume_id_r13);
      return c.get<fixed_bitstring<24> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<40>)> c;

    void destroy_();
  };

  // member variables
  resume_id_r13_c_    resume_id_r13;
  fixed_bitstring<16> short_resume_mac_i_r13;
  resume_cause_e      resume_cause_r13;
  fixed_bitstring<1>  spare;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCEarlyDataRequest-r15-IEs ::= SEQUENCE
struct rrc_early_data_request_r15_ies_s {
  struct establishment_cause_r15_opts {
    enum options { mo_data_r15, delay_tolerant_access_r15, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<establishment_cause_r15_opts> establishment_cause_r15_e_;

  // member variables
  bool                       non_crit_ext_present = false;
  s_tmsi_s                   s_tmsi_r15;
  establishment_cause_r15_e_ establishment_cause_r15;
  dyn_octstring              ded_info_nas_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentRequest ::= SEQUENCE
struct rrc_conn_reest_request_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_conn_reest_request_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_reest_request_r8_ies_s& rrc_conn_reest_request_r8()
    {
      assert_choice_type("rrcConnectionReestablishmentRequest-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_reest_request_r8_ies_s>();
    }
    const rrc_conn_reest_request_r8_ies_s& rrc_conn_reest_request_r8() const
    {
      assert_choice_type("rrcConnectionReestablishmentRequest-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_reest_request_r8_ies_s>();
    }
    rrc_conn_reest_request_r8_ies_s& set_rrc_conn_reest_request_r8()
    {
      set(types::rrc_conn_reest_request_r8);
      return c.get<rrc_conn_reest_request_r8_ies_s>();
    }

  private:
    types                                                    type_;
    choice_buffer_t<sizeof(rrc_conn_reest_request_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionRequest ::= SEQUENCE
struct rrc_conn_request_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_conn_request_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_request_r8_ies_s& rrc_conn_request_r8()
    {
      assert_choice_type("rrcConnectionRequest-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_request_r8_ies_s>();
    }
    const rrc_conn_request_r8_ies_s& rrc_conn_request_r8() const
    {
      assert_choice_type("rrcConnectionRequest-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_request_r8_ies_s>();
    }
    rrc_conn_request_r8_ies_s& set_rrc_conn_request_r8()
    {
      set(types::rrc_conn_request_r8);
      return c.get<rrc_conn_request_r8_ies_s>();
    }

  private:
    types                                              type_;
    choice_buffer_t<sizeof(rrc_conn_request_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResumeRequest-r13 ::= SEQUENCE
struct rrc_conn_resume_request_r13_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_conn_resume_request_r13, rrc_conn_resume_request_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_resume_request_r13_ies_s& rrc_conn_resume_request_r13()
    {
      assert_choice_type("rrcConnectionResumeRequest-r13", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_resume_request_r13_ies_s>();
    }
    rrc_conn_resume_request_minus5_gc_r15_ies_s& rrc_conn_resume_request_r15()
    {
      assert_choice_type("rrcConnectionResumeRequest-r15", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_resume_request_minus5_gc_r15_ies_s>();
    }
    const rrc_conn_resume_request_r13_ies_s& rrc_conn_resume_request_r13() const
    {
      assert_choice_type("rrcConnectionResumeRequest-r13", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_resume_request_r13_ies_s>();
    }
    const rrc_conn_resume_request_minus5_gc_r15_ies_s& rrc_conn_resume_request_r15() const
    {
      assert_choice_type("rrcConnectionResumeRequest-r15", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_resume_request_minus5_gc_r15_ies_s>();
    }
    rrc_conn_resume_request_r13_ies_s& set_rrc_conn_resume_request_r13()
    {
      set(types::rrc_conn_resume_request_r13);
      return c.get<rrc_conn_resume_request_r13_ies_s>();
    }
    rrc_conn_resume_request_minus5_gc_r15_ies_s& set_rrc_conn_resume_request_r15()
    {
      set(types::rrc_conn_resume_request_r15);
      return c.get<rrc_conn_resume_request_minus5_gc_r15_ies_s>();
    }

  private:
    types type_;
    choice_buffer_t<MAX2(sizeof(rrc_conn_resume_request_minus5_gc_r15_ies_s),
                         sizeof(rrc_conn_resume_request_r13_ies_s))>
        c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCEarlyDataRequest-r15 ::= SEQUENCE
struct rrc_early_data_request_r15_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_early_data_request_r15, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_early_data_request_r15_ies_s& rrc_early_data_request_r15()
    {
      assert_choice_type("rrcEarlyDataRequest-r15", type_.to_string(), "criticalExtensions");
      return c.get<rrc_early_data_request_r15_ies_s>();
    }
    const rrc_early_data_request_r15_ies_s& rrc_early_data_request_r15() const
    {
      assert_choice_type("rrcEarlyDataRequest-r15", type_.to_string(), "criticalExtensions");
      return c.get<rrc_early_data_request_r15_ies_s>();
    }
    rrc_early_data_request_r15_ies_s& set_rrc_early_data_request_r15()
    {
      set(types::rrc_early_data_request_r15);
      return c.get<rrc_early_data_request_r15_ies_s>();
    }

  private:
    types                                                     type_;
    choice_buffer_t<sizeof(rrc_early_data_request_r15_ies_s)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-CCCH-MessageType ::= CHOICE
struct ul_ccch_msg_type_c {
  struct c1_c_ {
    struct types_opts {
      enum options { rrc_conn_reest_request, rrc_conn_request, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    c1_c_() = default;
    c1_c_(const c1_c_& other);
    c1_c_& operator=(const c1_c_& other);
    ~c1_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_reest_request_s& rrc_conn_reest_request()
    {
      assert_choice_type("rrcConnectionReestablishmentRequest", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_request_s>();
    }
    rrc_conn_request_s& rrc_conn_request()
    {
      assert_choice_type("rrcConnectionRequest", type_.to_string(), "c1");
      return c.get<rrc_conn_request_s>();
    }
    const rrc_conn_reest_request_s& rrc_conn_reest_request() const
    {
      assert_choice_type("rrcConnectionReestablishmentRequest", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_request_s>();
    }
    const rrc_conn_request_s& rrc_conn_request() const
    {
      assert_choice_type("rrcConnectionRequest", type_.to_string(), "c1");
      return c.get<rrc_conn_request_s>();
    }
    rrc_conn_reest_request_s& set_rrc_conn_reest_request()
    {
      set(types::rrc_conn_reest_request);
      return c.get<rrc_conn_reest_request_s>();
    }
    rrc_conn_request_s& set_rrc_conn_request()
    {
      set(types::rrc_conn_request);
      return c.get<rrc_conn_request_s>();
    }

  private:
    types                                                                               type_;
    choice_buffer_t<MAX2(sizeof(rrc_conn_reest_request_s), sizeof(rrc_conn_request_s))> c;

    void destroy_();
  };
  struct msg_class_ext_c_ {
    struct c2_c_ {
      struct types_opts {
        enum options { rrc_conn_resume_request_r13, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      types       type() const { return types::rrc_conn_resume_request_r13; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_resume_request_r13_s&       rrc_conn_resume_request_r13() { return c; }
      const rrc_conn_resume_request_r13_s& rrc_conn_resume_request_r13() const { return c; }

    private:
      rrc_conn_resume_request_r13_s c;
    };
    struct msg_class_ext_future_r13_c_ {
      struct c3_c_ {
        struct types_opts {
          enum options { rrc_early_data_request_r15, spare3, spare2, spare1, nulltype } value;

          std::string to_string() const;
        };
        typedef enumerated<types_opts> types;

        // choice methods
        c3_c_() = default;
        void        set(types::options e = types::nulltype);
        types       type() const { return type_; }
        SRSASN_CODE pack(bit_ref& bref) const;
        SRSASN_CODE unpack(bit_ref& bref);
        void        to_json(json_writer& j) const;
        // getters
        rrc_early_data_request_r15_s& rrc_early_data_request_r15()
        {
          assert_choice_type("rrcEarlyDataRequest-r15", type_.to_string(), "c3");
          return c;
        }
        const rrc_early_data_request_r15_s& rrc_early_data_request_r15() const
        {
          assert_choice_type("rrcEarlyDataRequest-r15", type_.to_string(), "c3");
          return c;
        }
        rrc_early_data_request_r15_s& set_rrc_early_data_request_r15()
        {
          set(types::rrc_early_data_request_r15);
          return c;
        }

      private:
        types                        type_;
        rrc_early_data_request_r15_s c;
      };
      struct types_opts {
        enum options { c3, msg_class_ext_future_r15, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      msg_class_ext_future_r13_c_() = default;
      msg_class_ext_future_r13_c_(const msg_class_ext_future_r13_c_& other);
      msg_class_ext_future_r13_c_& operator=(const msg_class_ext_future_r13_c_& other);
      ~msg_class_ext_future_r13_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      c3_c_& c3()
      {
        assert_choice_type("c3", type_.to_string(), "messageClassExtensionFuture-r13");
        return c.get<c3_c_>();
      }
      const c3_c_& c3() const
      {
        assert_choice_type("c3", type_.to_string(), "messageClassExtensionFuture-r13");
        return c.get<c3_c_>();
      }
      c3_c_& set_c3()
      {
        set(types::c3);
        return c.get<c3_c_>();
      }

    private:
      types                          type_;
      choice_buffer_t<sizeof(c3_c_)> c;

      void destroy_();
    };
    struct types_opts {
      enum options { c2, msg_class_ext_future_r13, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    msg_class_ext_c_() = default;
    msg_class_ext_c_(const msg_class_ext_c_& other);
    msg_class_ext_c_& operator=(const msg_class_ext_c_& other);
    ~msg_class_ext_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c2_c_& c2()
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    msg_class_ext_future_r13_c_& msg_class_ext_future_r13()
    {
      assert_choice_type("messageClassExtensionFuture-r13", type_.to_string(), "messageClassExtension");
      return c.get<msg_class_ext_future_r13_c_>();
    }
    const c2_c_& c2() const
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    const msg_class_ext_future_r13_c_& msg_class_ext_future_r13() const
    {
      assert_choice_type("messageClassExtensionFuture-r13", type_.to_string(), "messageClassExtension");
      return c.get<msg_class_ext_future_r13_c_>();
    }
    c2_c_& set_c2()
    {
      set(types::c2);
      return c.get<c2_c_>();
    }
    msg_class_ext_future_r13_c_& set_msg_class_ext_future_r13()
    {
      set(types::msg_class_ext_future_r13);
      return c.get<msg_class_ext_future_r13_c_>();
    }

  private:
    types                                                                     type_;
    choice_buffer_t<MAX2(sizeof(c2_c_), sizeof(msg_class_ext_future_r13_c_))> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ul_ccch_msg_type_c() = default;
  ul_ccch_msg_type_c(const ul_ccch_msg_type_c& other);
  ul_ccch_msg_type_c& operator=(const ul_ccch_msg_type_c& other);
  ~ul_ccch_msg_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "UL-CCCH-MessageType");
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& msg_class_ext()
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "UL-CCCH-MessageType");
    return c.get<msg_class_ext_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "UL-CCCH-MessageType");
    return c.get<c1_c_>();
  }
  const msg_class_ext_c_& msg_class_ext() const
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "UL-CCCH-MessageType");
    return c.get<msg_class_ext_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& set_msg_class_ext()
  {
    set(types::msg_class_ext);
    return c.get<msg_class_ext_c_>();
  }

private:
  types                                                          type_;
  choice_buffer_t<MAX2(sizeof(c1_c_), sizeof(msg_class_ext_c_))> c;

  void destroy_();
};

// UL-CCCH-Message ::= SEQUENCE
struct ul_ccch_msg_s {
  // member variables
  ul_ccch_msg_type_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellGlobalIdCDMA2000 ::= CHOICE
struct cell_global_id_cdma2000_c {
  struct types_opts {
    enum options { cell_global_id1_xrtt, cell_global_id_hrpd, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  cell_global_id_cdma2000_c() = default;
  cell_global_id_cdma2000_c(const cell_global_id_cdma2000_c& other);
  cell_global_id_cdma2000_c& operator=(const cell_global_id_cdma2000_c& other);
  ~cell_global_id_cdma2000_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<47>& cell_global_id1_xrtt()
  {
    assert_choice_type("cellGlobalId1XRTT", type_.to_string(), "CellGlobalIdCDMA2000");
    return c.get<fixed_bitstring<47> >();
  }
  fixed_bitstring<128>& cell_global_id_hrpd()
  {
    assert_choice_type("cellGlobalIdHRPD", type_.to_string(), "CellGlobalIdCDMA2000");
    return c.get<fixed_bitstring<128> >();
  }
  const fixed_bitstring<47>& cell_global_id1_xrtt() const
  {
    assert_choice_type("cellGlobalId1XRTT", type_.to_string(), "CellGlobalIdCDMA2000");
    return c.get<fixed_bitstring<47> >();
  }
  const fixed_bitstring<128>& cell_global_id_hrpd() const
  {
    assert_choice_type("cellGlobalIdHRPD", type_.to_string(), "CellGlobalIdCDMA2000");
    return c.get<fixed_bitstring<128> >();
  }
  fixed_bitstring<47>& set_cell_global_id1_xrtt()
  {
    set(types::cell_global_id1_xrtt);
    return c.get<fixed_bitstring<47> >();
  }
  fixed_bitstring<128>& set_cell_global_id_hrpd()
  {
    set(types::cell_global_id_hrpd);
    return c.get<fixed_bitstring<128> >();
  }

private:
  types                                         type_;
  choice_buffer_t<sizeof(fixed_bitstring<128>)> c;

  void destroy_();
};

// AdditionalSI-Info-r9 ::= SEQUENCE
struct add_si_info_r9_s {
  // member variables
  bool                csg_member_status_r9_present = false;
  bool                csg_id_r9_present            = false;
  fixed_bitstring<27> csg_id_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BLER-Result-r12 ::= SEQUENCE
struct bler_result_r12_s {
  struct blocks_rx_r12_s_ {
    // member variables
    fixed_bitstring<3> n_r12;
    fixed_bitstring<8> m_r12;
  };

  // member variables
  uint8_t          bler_r12 = 0;
  blocks_rx_r12_s_ blocks_rx_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellGlobalIdUTRA ::= SEQUENCE
struct cell_global_id_utra_s {
  // member variables
  plmn_id_s           plmn_id;
  fixed_bitstring<28> cell_id;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultCDMA2000 ::= SEQUENCE
struct meas_result_cdma2000_s {
  struct meas_result_s_ {
    // member variables
    bool     ext                    = false;
    bool     pilot_pn_phase_present = false;
    uint16_t pilot_pn_phase         = 0;
    uint8_t  pilot_strength         = 0;
    // ...
  };

  // member variables
  bool                      cgi_info_present = false;
  uint16_t                  pci              = 0;
  cell_global_id_cdma2000_c cgi_info;
  meas_result_s_            meas_result;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityList2 ::= SEQUENCE (SIZE (1..5)) OF PLMN-Identity
typedef dyn_array<plmn_id_s> plmn_id_list2_l;

// CellGlobalIdGERAN ::= SEQUENCE
struct cell_global_id_geran_s {
  // member variables
  plmn_id_s           plmn_id;
  fixed_bitstring<16> location_area_code;
  fixed_bitstring<16> cell_id;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DataBLER-MCH-Result-r12 ::= SEQUENCE
struct data_bler_mch_result_r12_s {
  // member variables
  uint8_t           mch_idx_r12 = 1;
  bler_result_r12_s data_bler_result_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultEUTRA ::= SEQUENCE
struct meas_result_eutra_s {
  struct cgi_info_s_ {
    // member variables
    bool                   plmn_id_list_present = false;
    cell_global_id_eutra_s cell_global_id;
    fixed_bitstring<16>    tac;
    plmn_id_list2_l        plmn_id_list;
  };
  struct meas_result_s_ {
    struct cgi_info_v1310_s_ {
      // member variables
      bool                       freq_band_ind_r13_present        = false;
      bool                       multi_band_info_list_r13_present = false;
      bool                       freq_band_ind_prio_r13_present   = false;
      uint16_t                   freq_band_ind_r13                = 1;
      multi_band_info_list_r11_l multi_band_info_list_r13;
    };
    typedef dyn_array<cell_access_related_info_minus5_gc_r15_s> cgi_info_minus5_gc_r15_l_;

    // member variables
    bool    ext                 = false;
    bool    rsrp_result_present = false;
    bool    rsrq_result_present = false;
    uint8_t rsrp_result         = 0;
    uint8_t rsrq_result         = 0;
    // ...
    // group 0
    bool                       add_si_info_r9_present = false;
    copy_ptr<add_si_info_r9_s> add_si_info_r9;
    // group 1
    bool   primary_plmn_suitable_r12_present = false;
    bool   meas_result_v1250_present         = false;
    int8_t meas_result_v1250                 = -30;
    // group 2
    bool                        rs_sinr_result_r13_present = false;
    bool                        cgi_info_v1310_present     = false;
    uint8_t                     rs_sinr_result_r13         = 0;
    copy_ptr<cgi_info_v1310_s_> cgi_info_v1310;
    // group 3
    bool   meas_result_v1360_present = false;
    int8_t meas_result_v1360         = -17;
    // group 4
    bool                                cgi_info_minus5_gc_r15_present = false;
    copy_ptr<cgi_info_minus5_gc_r15_l_> cgi_info_minus5_gc_r15;

    // sequence methods
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
  };

  // member variables
  bool           cgi_info_present = false;
  uint16_t       pci              = 0;
  cgi_info_s_    cgi_info;
  meas_result_s_ meas_result;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultIdleEUTRA-r15 ::= SEQUENCE
struct meas_result_idle_eutra_r15_s {
  struct meas_result_r15_s_ {
    // member variables
    uint8_t rsrp_result_r15 = 0;
    int8_t  rsrq_result_r15 = -30;
  };

  // member variables
  bool               ext              = false;
  uint32_t           carrier_freq_r15 = 0;
  uint16_t           pci_r15          = 0;
  meas_result_r15_s_ meas_result_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultListCDMA2000 ::= SEQUENCE (SIZE (1..maxCellReport)) OF MeasResultCDMA2000
typedef dyn_array<meas_result_cdma2000_s> meas_result_list_cdma2000_l;

// MeasResultUTRA ::= SEQUENCE
struct meas_result_utra_s {
  struct pci_c_ {
    struct types_opts {
      enum options { fdd, tdd, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    pci_c_() = default;
    pci_c_(const pci_c_& other);
    pci_c_& operator=(const pci_c_& other);
    ~pci_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t& fdd()
    {
      assert_choice_type("fdd", type_.to_string(), "physCellId");
      return c.get<uint16_t>();
    }
    uint8_t& tdd()
    {
      assert_choice_type("tdd", type_.to_string(), "physCellId");
      return c.get<uint8_t>();
    }
    const uint16_t& fdd() const
    {
      assert_choice_type("fdd", type_.to_string(), "physCellId");
      return c.get<uint16_t>();
    }
    const uint8_t& tdd() const
    {
      assert_choice_type("tdd", type_.to_string(), "physCellId");
      return c.get<uint8_t>();
    }
    uint16_t& set_fdd()
    {
      set(types::fdd);
      return c.get<uint16_t>();
    }
    uint8_t& set_tdd()
    {
      set(types::tdd);
      return c.get<uint8_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };
  struct cgi_info_s_ {
    // member variables
    bool                  location_area_code_present = false;
    bool                  routing_area_code_present  = false;
    bool                  plmn_id_list_present       = false;
    cell_global_id_utra_s cell_global_id;
    fixed_bitstring<16>   location_area_code;
    fixed_bitstring<8>    routing_area_code;
    plmn_id_list2_l       plmn_id_list;
  };
  struct meas_result_s_ {
    // member variables
    bool    ext                = false;
    bool    utra_rscp_present  = false;
    bool    utra_ec_n0_present = false;
    int8_t  utra_rscp          = -5;
    uint8_t utra_ec_n0         = 0;
    // ...
    // group 0
    bool                       add_si_info_r9_present = false;
    copy_ptr<add_si_info_r9_s> add_si_info_r9;
    // group 1
    bool primary_plmn_suitable_r12_present = false;

    // sequence methods
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
  };

  // member variables
  bool           cgi_info_present = false;
  pci_c_         pci;
  cgi_info_s_    cgi_info;
  meas_result_s_ meas_result;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityListNR-r15 ::= SEQUENCE (SIZE (1.. maxPLMN-NR-r15)) OF PLMN-Identity
typedef dyn_array<plmn_id_s> plmn_id_list_nr_r15_l;

// RegisteredAMF-r15 ::= SEQUENCE
struct registered_amf_r15_s {
  // member variables
  bool                plmn_id_r15_present = false;
  plmn_id_s           plmn_id_r15;
  fixed_bitstring<24> amf_id_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// S-NSSAI-r15 ::= CHOICE
struct s_nssai_r15_c {
  struct types_opts {
    enum options { sst, sst_sd, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  s_nssai_r15_c() = default;
  s_nssai_r15_c(const s_nssai_r15_c& other);
  s_nssai_r15_c& operator=(const s_nssai_r15_c& other);
  ~s_nssai_r15_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<8>& sst()
  {
    assert_choice_type("sst", type_.to_string(), "S-NSSAI-r15");
    return c.get<fixed_bitstring<8> >();
  }
  fixed_bitstring<32>& sst_sd()
  {
    assert_choice_type("sst-SD", type_.to_string(), "S-NSSAI-r15");
    return c.get<fixed_bitstring<32> >();
  }
  const fixed_bitstring<8>& sst() const
  {
    assert_choice_type("sst", type_.to_string(), "S-NSSAI-r15");
    return c.get<fixed_bitstring<8> >();
  }
  const fixed_bitstring<32>& sst_sd() const
  {
    assert_choice_type("sst-SD", type_.to_string(), "S-NSSAI-r15");
    return c.get<fixed_bitstring<32> >();
  }
  fixed_bitstring<8>& set_sst()
  {
    set(types::sst);
    return c.get<fixed_bitstring<8> >();
  }
  fixed_bitstring<32>& set_sst_sd()
  {
    set(types::sst_sd);
    return c.get<fixed_bitstring<32> >();
  }

private:
  types                                        type_;
  choice_buffer_t<sizeof(fixed_bitstring<32>)> c;

  void destroy_();
};

// DataBLER-MCH-ResultList-r12 ::= SEQUENCE (SIZE (1.. maxPMCH-PerMBSFN)) OF DataBLER-MCH-Result-r12
typedef dyn_array<data_bler_mch_result_r12_s> data_bler_mch_result_list_r12_l;

// LocationInfo-r10 ::= SEQUENCE
struct location_info_r10_s {
  struct location_coordinates_r10_c_ {
    struct types_opts {
      enum options {
        ellipsoid_point_r10,
        ellipsoid_point_with_altitude_r10,
        // ...
        ellipsoid_point_with_uncertainty_circle_r11,
        ellipsoid_point_with_uncertainty_ellipse_r11,
        ellipsoid_point_with_altitude_and_uncertainty_ellipsoid_r11,
        ellipsoid_arc_r11,
        polygon_r11,
        nulltype
      } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts, true, 5> types;

    // choice methods
    location_coordinates_r10_c_() = default;
    location_coordinates_r10_c_(const location_coordinates_r10_c_& other);
    location_coordinates_r10_c_& operator=(const location_coordinates_r10_c_& other);
    ~location_coordinates_r10_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dyn_octstring& ellipsoid_point_r10()
    {
      assert_choice_type("ellipsoid-Point-r10", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ellipsoid_point_with_altitude_r10()
    {
      assert_choice_type("ellipsoidPointWithAltitude-r10", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ellipsoid_point_with_uncertainty_circle_r11()
    {
      assert_choice_type("ellipsoidPointWithUncertaintyCircle-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ellipsoid_point_with_uncertainty_ellipse_r11()
    {
      assert_choice_type("ellipsoidPointWithUncertaintyEllipse-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ellipsoid_point_with_altitude_and_uncertainty_ellipsoid_r11()
    {
      assert_choice_type(
          "ellipsoidPointWithAltitudeAndUncertaintyEllipsoid-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ellipsoid_arc_r11()
    {
      assert_choice_type("ellipsoidArc-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& polygon_r11()
    {
      assert_choice_type("polygon-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ellipsoid_point_r10() const
    {
      assert_choice_type("ellipsoid-Point-r10", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ellipsoid_point_with_altitude_r10() const
    {
      assert_choice_type("ellipsoidPointWithAltitude-r10", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ellipsoid_point_with_uncertainty_circle_r11() const
    {
      assert_choice_type("ellipsoidPointWithUncertaintyCircle-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ellipsoid_point_with_uncertainty_ellipse_r11() const
    {
      assert_choice_type("ellipsoidPointWithUncertaintyEllipse-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ellipsoid_point_with_altitude_and_uncertainty_ellipsoid_r11() const
    {
      assert_choice_type(
          "ellipsoidPointWithAltitudeAndUncertaintyEllipsoid-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ellipsoid_arc_r11() const
    {
      assert_choice_type("ellipsoidArc-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& polygon_r11() const
    {
      assert_choice_type("polygon-r11", type_.to_string(), "locationCoordinates-r10");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ellipsoid_point_r10()
    {
      set(types::ellipsoid_point_r10);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ellipsoid_point_with_altitude_r10()
    {
      set(types::ellipsoid_point_with_altitude_r10);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ellipsoid_point_with_uncertainty_circle_r11()
    {
      set(types::ellipsoid_point_with_uncertainty_circle_r11);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ellipsoid_point_with_uncertainty_ellipse_r11()
    {
      set(types::ellipsoid_point_with_uncertainty_ellipse_r11);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ellipsoid_point_with_altitude_and_uncertainty_ellipsoid_r11()
    {
      set(types::ellipsoid_point_with_altitude_and_uncertainty_ellipsoid_r11);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ellipsoid_arc_r11()
    {
      set(types::ellipsoid_arc_r11);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_polygon_r11()
    {
      set(types::polygon_r11);
      return c.get<dyn_octstring>();
    }

  private:
    types                                  type_;
    choice_buffer_t<sizeof(dyn_octstring)> c;

    void destroy_();
  };
  struct vertical_velocity_info_r15_c_ {
    struct types_opts {
      enum options { vertical_velocity_r15, vertical_velocity_and_uncertainty_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    vertical_velocity_info_r15_c_() = default;
    vertical_velocity_info_r15_c_(const vertical_velocity_info_r15_c_& other);
    vertical_velocity_info_r15_c_& operator=(const vertical_velocity_info_r15_c_& other);
    ~vertical_velocity_info_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dyn_octstring& vertical_velocity_r15()
    {
      assert_choice_type("verticalVelocity-r15", type_.to_string(), "verticalVelocityInfo-r15");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& vertical_velocity_and_uncertainty_r15()
    {
      assert_choice_type("verticalVelocityAndUncertainty-r15", type_.to_string(), "verticalVelocityInfo-r15");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& vertical_velocity_r15() const
    {
      assert_choice_type("verticalVelocity-r15", type_.to_string(), "verticalVelocityInfo-r15");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& vertical_velocity_and_uncertainty_r15() const
    {
      assert_choice_type("verticalVelocityAndUncertainty-r15", type_.to_string(), "verticalVelocityInfo-r15");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_vertical_velocity_r15()
    {
      set(types::vertical_velocity_r15);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_vertical_velocity_and_uncertainty_r15()
    {
      set(types::vertical_velocity_and_uncertainty_r15);
      return c.get<dyn_octstring>();
    }

  private:
    types                                  type_;
    choice_buffer_t<sizeof(dyn_octstring)> c;

    void destroy_();
  };

  // member variables
  bool                        ext                             = false;
  bool                        horizontal_velocity_r10_present = false;
  bool                        gnss_tod_msec_r10_present       = false;
  location_coordinates_r10_c_ location_coordinates_r10;
  dyn_octstring               horizontal_velocity_r10;
  dyn_octstring               gnss_tod_msec_r10;
  // ...
  // group 0
  bool                                    vertical_velocity_info_r15_present = false;
  copy_ptr<vertical_velocity_info_r15_c_> vertical_velocity_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultGERAN ::= SEQUENCE
struct meas_result_geran_s {
  struct cgi_info_s_ {
    // member variables
    bool                   routing_area_code_present = false;
    cell_global_id_geran_s cell_global_id;
    fixed_bitstring<8>     routing_area_code;
  };
  struct meas_result_s_ {
    // member variables
    bool    ext  = false;
    uint8_t rssi = 0;
    // ...
  };

  // member variables
  bool                 cgi_info_present = false;
  carrier_freq_geran_s carrier_freq;
  pci_geran_s          pci;
  cgi_info_s_          cgi_info;
  meas_result_s_       meas_result;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultIdleListEUTRA-r15 ::= SEQUENCE (SIZE (1..maxCellMeasIdle-r15)) OF MeasResultIdleEUTRA-r15
typedef dyn_array<meas_result_idle_eutra_r15_s> meas_result_idle_list_eutra_r15_l;

// MeasResultListEUTRA ::= SEQUENCE (SIZE (1..maxCellReport)) OF MeasResultEUTRA
typedef dyn_array<meas_result_eutra_s> meas_result_list_eutra_l;

// MeasResultListUTRA ::= SEQUENCE (SIZE (1..maxCellReport)) OF MeasResultUTRA
typedef dyn_array<meas_result_utra_s> meas_result_list_utra_l;

// MeasResultNR-r15 ::= SEQUENCE
struct meas_result_nr_r15_s {
  // member variables
  bool    ext                        = false;
  bool    rsrp_result_r15_present    = false;
  bool    rsrq_result_r15_present    = false;
  bool    rs_sinr_result_r15_present = false;
  uint8_t rsrp_result_r15            = 0;
  uint8_t rsrq_result_r15            = 0;
  uint8_t rs_sinr_result_r15         = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultsCDMA2000 ::= SEQUENCE
struct meas_results_cdma2000_s {
  // member variables
  bool                        pre_regist_status_hrpd = false;
  meas_result_list_cdma2000_l meas_result_list_cdma2000;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityInfoNR-r15 ::= SEQUENCE
struct plmn_id_info_nr_r15_s {
  // member variables
  bool                  tac_r15_present           = false;
  bool                  ran_area_code_r15_present = false;
  plmn_id_list_nr_r15_l plmn_id_list_r15;
  fixed_bitstring<24>   tac_r15;
  uint8_t               ran_area_code_r15 = 0;
  fixed_bitstring<36>   cell_id_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v1530-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v1530_ies_s {
  typedef dyn_array<s_nssai_r15_c> s_nssai_list_r15_l_;
  struct ng_minus5_g_s_tmsi_bits_r15_c_ {
    struct types_opts {
      enum options { ng_minus5_g_s_tmsi_r15, ng_minus5_g_s_tmsi_part2_r15, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ng_minus5_g_s_tmsi_bits_r15_c_() = default;
    ng_minus5_g_s_tmsi_bits_r15_c_(const ng_minus5_g_s_tmsi_bits_r15_c_& other);
    ng_minus5_g_s_tmsi_bits_r15_c_& operator=(const ng_minus5_g_s_tmsi_bits_r15_c_& other);
    ~ng_minus5_g_s_tmsi_bits_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<48>& ng_minus5_g_s_tmsi_r15()
    {
      assert_choice_type("ng-5G-S-TMSI-r15", type_.to_string(), "ng-5G-S-TMSI-Bits-r15");
      return c.get<fixed_bitstring<48> >();
    }
    fixed_bitstring<8>& ng_minus5_g_s_tmsi_part2_r15()
    {
      assert_choice_type("ng-5G-S-TMSI-Part2-r15", type_.to_string(), "ng-5G-S-TMSI-Bits-r15");
      return c.get<fixed_bitstring<8> >();
    }
    const fixed_bitstring<48>& ng_minus5_g_s_tmsi_r15() const
    {
      assert_choice_type("ng-5G-S-TMSI-r15", type_.to_string(), "ng-5G-S-TMSI-Bits-r15");
      return c.get<fixed_bitstring<48> >();
    }
    const fixed_bitstring<8>& ng_minus5_g_s_tmsi_part2_r15() const
    {
      assert_choice_type("ng-5G-S-TMSI-Part2-r15", type_.to_string(), "ng-5G-S-TMSI-Bits-r15");
      return c.get<fixed_bitstring<8> >();
    }
    fixed_bitstring<48>& set_ng_minus5_g_s_tmsi_r15()
    {
      set(types::ng_minus5_g_s_tmsi_r15);
      return c.get<fixed_bitstring<48> >();
    }
    fixed_bitstring<8>& set_ng_minus5_g_s_tmsi_part2_r15()
    {
      set(types::ng_minus5_g_s_tmsi_part2_r15);
      return c.get<fixed_bitstring<8> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<48>)> c;

    void destroy_();
  };

  // member variables
  bool                           log_meas_available_bt_r15_present      = false;
  bool                           log_meas_available_wlan_r15_present    = false;
  bool                           idle_meas_available_r15_present        = false;
  bool                           flight_path_info_available_r15_present = false;
  bool                           connect_to5_gc_r15_present             = false;
  bool                           registered_amf_r15_present             = false;
  bool                           s_nssai_list_r15_present               = false;
  bool                           ng_minus5_g_s_tmsi_bits_r15_present    = false;
  bool                           non_crit_ext_present                   = false;
  registered_amf_r15_s           registered_amf_r15;
  s_nssai_list_r15_l_            s_nssai_list_r15;
  ng_minus5_g_s_tmsi_bits_r15_c_ ng_minus5_g_s_tmsi_bits_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RSRQ-Type-r12 ::= SEQUENCE
struct rsrq_type_r12_s {
  // member variables
  bool all_symbols_r12 = false;
  bool wide_band_r12   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-RTT-r15 ::= SEQUENCE
struct wlan_rtt_r15_s {
  struct rtt_units_r15_opts {
    enum options {
      microseconds,
      hundredsofnanoseconds,
      tensofnanoseconds,
      nanoseconds,
      tenthsofnanoseconds,
      /*...*/ nulltype
    } value;

    std::string to_string() const;
  };
  typedef enumerated<rtt_units_r15_opts, true> rtt_units_r15_e_;

  // member variables
  bool             ext                      = false;
  bool             rtt_accuracy_r15_present = false;
  uint32_t         rtt_value_r15            = 0;
  rtt_units_r15_e_ rtt_units_r15;
  uint8_t          rtt_accuracy_r15 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCarrierFreqComb-r15 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF INTEGER
typedef bounded_array<uint8_t, 32> affected_carrier_freq_comb_r15_l;

// AffectedCarrierFreqCombNR-r15 ::= SEQUENCE (SIZE (1..maxServCellNR-r15)) OF INTEGER
typedef bounded_array<uint32_t, 16> affected_carrier_freq_comb_nr_r15_l;

// LogMeasResultBT-r15 ::= SEQUENCE
struct log_meas_result_bt_r15_s {
  // member variables
  bool                ext                 = false;
  bool                rssi_bt_r15_present = false;
  fixed_bitstring<48> bt_addr_r15;
  int8_t              rssi_bt_r15 = -128;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LogMeasResultWLAN-r15 ::= SEQUENCE
struct log_meas_result_wlan_r15_s {
  // member variables
  bool           ext                   = false;
  bool           rssi_wlan_r15_present = false;
  bool           rtt_wlan_r15_present  = false;
  wlan_ids_r12_s wlan_ids_r15;
  uint8_t        rssi_wlan_r15 = 0;
  wlan_rtt_r15_s rtt_wlan_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResult2CDMA2000-r9 ::= SEQUENCE
struct meas_result2_cdma2000_r9_s {
  // member variables
  carrier_freq_cdma2000_s carrier_freq_r9;
  meas_results_cdma2000_s meas_result_list_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResult2EUTRA-r9 ::= SEQUENCE
struct meas_result2_eutra_r9_s {
  // member variables
  uint16_t                 carrier_freq_r9 = 0;
  meas_result_list_eutra_l meas_result_list_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResult2EUTRA-v1250 ::= SEQUENCE
struct meas_result2_eutra_v1250_s {
  // member variables
  bool            rsrq_type_r12_present = false;
  rsrq_type_r12_s rsrq_type_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResult2EUTRA-v9e0 ::= SEQUENCE
struct meas_result2_eutra_v9e0_s {
  // member variables
  bool     carrier_freq_v9e0_present = false;
  uint32_t carrier_freq_v9e0         = 65536;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResult2UTRA-r9 ::= SEQUENCE
struct meas_result2_utra_r9_s {
  // member variables
  uint16_t                carrier_freq_r9 = 0;
  meas_result_list_utra_l meas_result_list_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultIdle-r15 ::= SEQUENCE
struct meas_result_idle_r15_s {
  struct meas_result_serving_cell_r15_s_ {
    // member variables
    uint8_t rsrp_result_r15 = 0;
    int8_t  rsrq_result_r15 = -30;
  };
  struct meas_result_neigh_cells_r15_c_ {
    struct types_opts {
      enum options { meas_result_idle_list_eutra_r15, /*...*/ nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts, true> types;

    // choice methods
    types       type() const { return types::meas_result_idle_list_eutra_r15; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    meas_result_idle_list_eutra_r15_l&       meas_result_idle_list_eutra_r15() { return c; }
    const meas_result_idle_list_eutra_r15_l& meas_result_idle_list_eutra_r15() const { return c; }

  private:
    meas_result_idle_list_eutra_r15_l c;
  };

  // member variables
  bool                            ext                                 = false;
  bool                            meas_result_neigh_cells_r15_present = false;
  meas_result_serving_cell_r15_s_ meas_result_serving_cell_r15;
  meas_result_neigh_cells_r15_c_  meas_result_neigh_cells_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultListGERAN ::= SEQUENCE (SIZE (1..maxCellReport)) OF MeasResultGERAN
typedef dyn_array<meas_result_geran_s> meas_result_list_geran_l;

// MeasResultMBSFN-r12 ::= SEQUENCE
struct meas_result_mbsfn_r12_s {
  struct mbsfn_area_r12_s_ {
    // member variables
    uint8_t  mbsfn_area_id_r12 = 0;
    uint32_t carrier_freq_r12  = 0;
  };

  // member variables
  bool                            ext                                   = false;
  bool                            sig_bler_result_r12_present           = false;
  bool                            data_bler_mch_result_list_r12_present = false;
  mbsfn_area_r12_s_               mbsfn_area_r12;
  uint8_t                         rsrp_result_mbsfn_r12 = 0;
  uint8_t                         rsrq_result_mbsfn_r12 = 0;
  bler_result_r12_s               sig_bler_result_r12;
  data_bler_mch_result_list_r12_l data_bler_mch_result_list_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultSSB-Index-r15 ::= SEQUENCE
struct meas_result_ssb_idx_r15_s {
  // member variables
  bool                 ext                             = false;
  bool                 meas_result_ssb_idx_r15_present = false;
  uint8_t              ssb_idx_r15                     = 0;
  meas_result_nr_r15_s meas_result_ssb_idx_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PLMN-IdentityInfoListNR-r15 ::= SEQUENCE (SIZE (1..maxPLMN-NR-r15)) OF PLMN-IdentityInfoNR-r15
typedef dyn_array<plmn_id_info_nr_r15_s> plmn_id_info_list_nr_r15_l;

// PerCC-GapIndication-r14 ::= SEQUENCE
struct per_cc_gap_ind_r14_s {
  struct gap_ind_r14_opts {
    enum options { gap, ncsg, nogap_no_ncsg, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<gap_ind_r14_opts> gap_ind_r14_e_;

  // member variables
  uint8_t        serv_cell_id_r14 = 0;
  gap_ind_r14_e_ gap_ind_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfigurationComplete-v1530-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_v1530_ies_s {
  // member variables
  bool log_meas_available_bt_r15_present      = false;
  bool log_meas_available_wlan_r15_present    = false;
  bool flight_path_info_available_r15_present = false;
  bool non_crit_ext_present                   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v1430-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v1430_ies_s {
  // member variables
  bool                                dcn_id_r14_present   = false;
  bool                                non_crit_ext_present = false;
  uint16_t                            dcn_id_r14           = 0;
  rrc_conn_setup_complete_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VictimSystemType-r11 ::= SEQUENCE
struct victim_sys_type_r11_s {
  // member variables
  bool gps_r11_present       = false;
  bool glonass_r11_present   = false;
  bool bds_r11_present       = false;
  bool galileo_r11_present   = false;
  bool wlan_r11_present      = false;
  bool bluetooth_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VisitedCellInfo-r12 ::= SEQUENCE
struct visited_cell_info_r12_s {
  struct visited_cell_id_r12_c_ {
    struct pci_arfcn_r12_s_ {
      // member variables
      uint16_t pci_r12          = 0;
      uint32_t carrier_freq_r12 = 0;
    };
    struct types_opts {
      enum options { cell_global_id_r12, pci_arfcn_r12, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    visited_cell_id_r12_c_() = default;
    visited_cell_id_r12_c_(const visited_cell_id_r12_c_& other);
    visited_cell_id_r12_c_& operator=(const visited_cell_id_r12_c_& other);
    ~visited_cell_id_r12_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cell_global_id_eutra_s& cell_global_id_r12()
    {
      assert_choice_type("cellGlobalId-r12", type_.to_string(), "visitedCellId-r12");
      return c.get<cell_global_id_eutra_s>();
    }
    pci_arfcn_r12_s_& pci_arfcn_r12()
    {
      assert_choice_type("pci-arfcn-r12", type_.to_string(), "visitedCellId-r12");
      return c.get<pci_arfcn_r12_s_>();
    }
    const cell_global_id_eutra_s& cell_global_id_r12() const
    {
      assert_choice_type("cellGlobalId-r12", type_.to_string(), "visitedCellId-r12");
      return c.get<cell_global_id_eutra_s>();
    }
    const pci_arfcn_r12_s_& pci_arfcn_r12() const
    {
      assert_choice_type("pci-arfcn-r12", type_.to_string(), "visitedCellId-r12");
      return c.get<pci_arfcn_r12_s_>();
    }
    cell_global_id_eutra_s& set_cell_global_id_r12()
    {
      set(types::cell_global_id_r12);
      return c.get<cell_global_id_eutra_s>();
    }
    pci_arfcn_r12_s_& set_pci_arfcn_r12()
    {
      set(types::pci_arfcn_r12);
      return c.get<pci_arfcn_r12_s_>();
    }

  private:
    types                                                                           type_;
    choice_buffer_t<MAX2(sizeof(cell_global_id_eutra_s), sizeof(pci_arfcn_r12_s_))> c;

    void destroy_();
  };

  // member variables
  bool                   ext                         = false;
  bool                   visited_cell_id_r12_present = false;
  visited_cell_id_r12_c_ visited_cell_id_r12;
  uint16_t               time_spent_r12 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WayPointLocation-r15 ::= SEQUENCE
struct way_point_location_r15_s {
  // member variables
  bool                time_stamp_r15_present = false;
  location_info_r10_s way_point_location_r15;
  fixed_bitstring<48> time_stamp_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCarrierFreqCombInfoMRDC-r15 ::= SEQUENCE
struct affected_carrier_freq_comb_info_mrdc_r15_s {
  struct interference_direction_mrdc_r15_opts {
    enum options { eutra_nr, nr, other, eutra_nr_other, nr_other, spare3, spare2, spare1, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<interference_direction_mrdc_r15_opts> interference_direction_mrdc_r15_e_;
  struct affected_carrier_freq_comb_mrdc_r15_s_ {
    // member variables
    bool                                affected_carrier_freq_comb_eutra_r15_present = false;
    affected_carrier_freq_comb_r15_l    affected_carrier_freq_comb_eutra_r15;
    affected_carrier_freq_comb_nr_r15_l affected_carrier_freq_comb_nr_r15;
  };

  // member variables
  bool                                   affected_carrier_freq_comb_mrdc_r15_present = false;
  victim_sys_type_r11_s                  victim_sys_type_r15;
  interference_direction_mrdc_r15_e_     interference_direction_mrdc_r15;
  affected_carrier_freq_comb_mrdc_r15_s_ affected_carrier_freq_comb_mrdc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CGI-InfoNR-r15 ::= SEQUENCE
struct cgi_info_nr_r15_s {
  struct no_sib1_r15_s_ {
    // member variables
    uint8_t ssb_subcarrier_offset_r15 = 0;
    uint8_t pdcch_cfg_sib1_r15        = 0;
  };

  // member variables
  bool                          ext                            = false;
  bool                          plmn_id_info_list_r15_present  = false;
  bool                          freq_band_list_minus15_present = false;
  bool                          no_sib1_r15_present            = false;
  plmn_id_info_list_nr_r15_l    plmn_id_info_list_r15;
  multi_freq_band_list_nr_r15_l freq_band_list_minus15;
  no_sib1_r15_s_                no_sib1_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FlightPathInfoReport-r15 ::= SEQUENCE
struct flight_path_info_report_r15_s {
  typedef dyn_array<way_point_location_r15_s> flight_path_r15_l_;

  // member variables
  bool               flight_path_r15_present = false;
  bool               non_crit_ext_present    = false;
  flight_path_r15_l_ flight_path_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LogMeasResultListBT-r15 ::= SEQUENCE (SIZE (1..maxBT-IdReport-r15)) OF LogMeasResultBT-r15
typedef dyn_array<log_meas_result_bt_r15_s> log_meas_result_list_bt_r15_l;

// LogMeasResultListWLAN-r15 ::= SEQUENCE (SIZE (1..maxWLAN-Id-Report-r14)) OF LogMeasResultWLAN-r15
typedef dyn_array<log_meas_result_wlan_r15_s> log_meas_result_list_wlan_r15_l;

// MeasResultList2CDMA2000-r9 ::= SEQUENCE (SIZE (1..maxFreq)) OF MeasResult2CDMA2000-r9
typedef dyn_array<meas_result2_cdma2000_r9_s> meas_result_list2_cdma2000_r9_l;

// MeasResultList2EUTRA-r9 ::= SEQUENCE (SIZE (1..maxFreq)) OF MeasResult2EUTRA-r9
typedef dyn_array<meas_result2_eutra_r9_s> meas_result_list2_eutra_r9_l;

// MeasResultList2EUTRA-v1250 ::= SEQUENCE (SIZE (1..maxFreq)) OF MeasResult2EUTRA-v1250
typedef dyn_array<meas_result2_eutra_v1250_s> meas_result_list2_eutra_v1250_l;

// MeasResultList2EUTRA-v9e0 ::= SEQUENCE (SIZE (1..maxFreq)) OF MeasResult2EUTRA-v9e0
typedef dyn_array<meas_result2_eutra_v9e0_s> meas_result_list2_eutra_v9e0_l;

// MeasResultList2GERAN-r10 ::= SEQUENCE (SIZE (1..maxCellListGERAN)) OF MeasResultListGERAN
typedef dyn_array<meas_result_list_geran_l> meas_result_list2_geran_r10_l;

// MeasResultList2UTRA-r9 ::= SEQUENCE (SIZE (1..maxFreq)) OF MeasResult2UTRA-r9
typedef dyn_array<meas_result2_utra_r9_s> meas_result_list2_utra_r9_l;

// MeasResultListIdle-r15 ::= SEQUENCE (SIZE (1..maxIdleMeasCarriers-r15)) OF MeasResultIdle-r15
typedef dyn_array<meas_result_idle_r15_s> meas_result_list_idle_r15_l;

// MeasResultListMBSFN-r12 ::= SEQUENCE (SIZE (1..maxMBSFN-Area)) OF MeasResultMBSFN-r12
typedef dyn_array<meas_result_mbsfn_r12_s> meas_result_list_mbsfn_r12_l;

// MeasResultSSB-IndexList-r15 ::= SEQUENCE (SIZE (1..maxRS-IndexReport-r15)) OF MeasResultSSB-Index-r15
typedef dyn_array<meas_result_ssb_idx_r15_s> meas_result_ssb_idx_list_r15_l;

// PerCC-GapIndicationList-r14 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF PerCC-GapIndication-r14
typedef dyn_array<per_cc_gap_ind_r14_s> per_cc_gap_ind_list_r14_l;

// RRCConnectionReconfigurationComplete-v1510-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_v1510_ies_s {
  // member variables
  bool                                scg_cfg_resp_nr_r15_present = false;
  bool                                non_crit_ext_present        = false;
  dyn_octstring                       scg_cfg_resp_nr_r15;
  rrc_conn_recfg_complete_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete-v1530-IEs ::= SEQUENCE
struct rrc_conn_reest_complete_v1530_ies_s {
  // member variables
  bool log_meas_available_bt_r15_present      = false;
  bool log_meas_available_wlan_r15_present    = false;
  bool flight_path_info_available_r15_present = false;
  bool non_crit_ext_present                   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v1330-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v1330_ies_s {
  // member variables
  bool                                ue_ce_need_ul_gaps_r13_present = false;
  bool                                non_crit_ext_present           = false;
  rrc_conn_setup_complete_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VisitedCellInfoList-r12 ::= SEQUENCE (SIZE (1..maxCellHistory-r12)) OF VisitedCellInfo-r12
typedef dyn_array<visited_cell_info_r12_s> visited_cell_info_list_r12_l;

// LogMeasInfo-r10 ::= SEQUENCE
struct log_meas_info_r10_s {
  struct meas_result_serv_cell_r10_s_ {
    // member variables
    uint8_t rsrp_result_r10 = 0;
    uint8_t rsrq_result_r10 = 0;
  };
  struct meas_result_neigh_cells_r10_s_ {
    // member variables
    bool                            meas_result_list_eutra_r10_present    = false;
    bool                            meas_result_list_utra_r10_present     = false;
    bool                            meas_result_list_geran_r10_present    = false;
    bool                            meas_result_list_cdma2000_r10_present = false;
    meas_result_list2_eutra_r9_l    meas_result_list_eutra_r10;
    meas_result_list2_utra_r9_l     meas_result_list_utra_r10;
    meas_result_list2_geran_r10_l   meas_result_list_geran_r10;
    meas_result_list2_cdma2000_r9_l meas_result_list_cdma2000_r10;
  };

  // member variables
  bool                           ext                                 = false;
  bool                           location_info_r10_present           = false;
  bool                           meas_result_neigh_cells_r10_present = false;
  location_info_r10_s            location_info_r10;
  uint16_t                       relative_time_stamp_r10 = 0;
  cell_global_id_eutra_s         serv_cell_id_r10;
  meas_result_serv_cell_r10_s_   meas_result_serv_cell_r10;
  meas_result_neigh_cells_r10_s_ meas_result_neigh_cells_r10;
  // ...
  // group 0
  bool                                     meas_result_list_eutra_v1090_present = false;
  copy_ptr<meas_result_list2_eutra_v9e0_l> meas_result_list_eutra_v1090;
  // group 1
  bool                                      meas_result_list_mbsfn_r12_present   = false;
  bool                                      meas_result_serv_cell_v1250_present  = false;
  bool                                      serv_cell_rsrq_type_r12_present      = false;
  bool                                      meas_result_list_eutra_v1250_present = false;
  copy_ptr<meas_result_list_mbsfn_r12_l>    meas_result_list_mbsfn_r12;
  int8_t                                    meas_result_serv_cell_v1250 = -30;
  copy_ptr<rsrq_type_r12_s>                 serv_cell_rsrq_type_r12;
  copy_ptr<meas_result_list2_eutra_v1250_l> meas_result_list_eutra_v1250;
  // group 2
  bool in_dev_coex_detected_r13_present = false;
  // group 3
  bool   meas_result_serv_cell_v1360_present = false;
  int8_t meas_result_serv_cell_v1360         = -17;
  // group 4
  bool                                      log_meas_result_list_bt_r15_present   = false;
  bool                                      log_meas_result_list_wlan_r15_present = false;
  copy_ptr<log_meas_result_list_bt_r15_l>   log_meas_result_list_bt_r15;
  copy_ptr<log_meas_result_list_wlan_r15_l> log_meas_result_list_wlan_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MRDC-AssistanceInfo-r15 ::= SEQUENCE
struct mrdc_assist_info_r15_s {
  typedef dyn_array<affected_carrier_freq_comb_info_mrdc_r15_s> affected_carrier_freq_comb_info_list_mrdc_r15_l_;

  // member variables
  bool                                             ext = false;
  affected_carrier_freq_comb_info_list_mrdc_r15_l_ affected_carrier_freq_comb_info_list_mrdc_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultCellNR-r15 ::= SEQUENCE
struct meas_result_cell_nr_r15_s {
  // member variables
  bool                           ext                                 = false;
  bool                           meas_result_rs_idx_list_r15_present = false;
  uint16_t                       pci_r15                             = 0;
  meas_result_nr_r15_s           meas_result_cell_r15;
  meas_result_ssb_idx_list_r15_l meas_result_rs_idx_list_r15;
  // ...
  // group 0
  bool                        cgi_info_r15_present = false;
  copy_ptr<cgi_info_nr_r15_s> cgi_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityHistoryReport-r12 ::= VisitedCellInfoList-r12
typedef visited_cell_info_list_r12_l mob_history_report_r12_l;

// RRCConnectionReconfigurationComplete-v1430-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_v1430_ies_s {
  // member variables
  bool                                per_cc_gap_ind_list_r14_present        = false;
  bool                                num_freq_effective_r14_present         = false;
  bool                                num_freq_effective_reduced_r14_present = false;
  bool                                non_crit_ext_present                   = false;
  per_cc_gap_ind_list_r14_l           per_cc_gap_ind_list_r14;
  uint8_t                             num_freq_effective_r14         = 1;
  uint8_t                             num_freq_effective_reduced_r14 = 1;
  rrc_conn_recfg_complete_v1510_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete-v1250-IEs ::= SEQUENCE
struct rrc_conn_reest_complete_v1250_ies_s {
  // member variables
  bool                                log_meas_available_mbsfn_r12_present = false;
  bool                                non_crit_ext_present                 = false;
  rrc_conn_reest_complete_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v1320-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v1320_ies_s {
  // member variables
  bool                                ce_mode_b_r13_present                  = false;
  bool                                s_tmsi_r13_present                     = false;
  bool                                attach_without_pdn_connect_r13_present = false;
  bool                                up_cio_t_eps_optim_r13_present         = false;
  bool                                cp_cio_t_eps_optim_r13_present         = false;
  bool                                non_crit_ext_present                   = false;
  s_tmsi_s                            s_tmsi_r13;
  rrc_conn_setup_complete_v1330_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TrafficPatternInfo-v1530 ::= SEQUENCE
struct traffic_pattern_info_v1530_s {
  // member variables
  bool                traffic_dest_r15_present        = false;
  bool                reliability_info_sl_r15_present = false;
  fixed_bitstring<24> traffic_dest_r15;
  uint8_t             reliability_info_sl_r15 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationResponse-v1530-IEs ::= SEQUENCE
struct ue_info_resp_v1530_ies_s {
  // member variables
  bool                          meas_result_list_idle_r15_present   = false;
  bool                          flight_path_info_report_r15_present = false;
  bool                          non_crit_ext_present                = false;
  meas_result_list_idle_r15_l   meas_result_list_idle_r15;
  flight_path_info_report_r15_s flight_path_info_report_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCarrierFreq-v1310 ::= SEQUENCE
struct affected_carrier_freq_v1310_s {
  // member variables
  bool    carrier_freq_v1310_present = false;
  uint8_t carrier_freq_v1310         = 33;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCarrierFreqComb-r13 ::= SEQUENCE (SIZE (2..maxServCell-r13)) OF INTEGER
typedef bounded_array<uint8_t, 32> affected_carrier_freq_comb_r13_l;

// ConnEstFailReport-r11 ::= SEQUENCE
struct conn_est_fail_report_r11_s {
  struct meas_result_failed_cell_r11_s_ {
    // member variables
    bool    rsrq_result_r11_present = false;
    uint8_t rsrp_result_r11         = 0;
    uint8_t rsrq_result_r11         = 0;
  };
  struct meas_result_neigh_cells_r11_s_ {
    // member variables
    bool                            meas_result_list_eutra_r11_present = false;
    bool                            meas_result_list_utra_r11_present  = false;
    bool                            meas_result_list_geran_r11_present = false;
    bool                            meas_results_cdma2000_r11_present  = false;
    meas_result_list2_eutra_r9_l    meas_result_list_eutra_r11;
    meas_result_list2_utra_r9_l     meas_result_list_utra_r11;
    meas_result_list_geran_l        meas_result_list_geran_r11;
    meas_result_list2_cdma2000_r9_l meas_results_cdma2000_r11;
  };

  // member variables
  bool                           ext                                  = false;
  bool                           location_info_r11_present            = false;
  bool                           meas_result_neigh_cells_r11_present  = false;
  bool                           meas_result_list_eutra_v1130_present = false;
  cell_global_id_eutra_s         failed_cell_id_r11;
  location_info_r10_s            location_info_r11;
  meas_result_failed_cell_r11_s_ meas_result_failed_cell_r11;
  meas_result_neigh_cells_r11_s_ meas_result_neigh_cells_r11;
  uint8_t                        nof_preambs_sent_r11    = 1;
  bool                           contention_detected_r11 = false;
  bool                           max_tx_pwr_reached_r11  = false;
  uint32_t                       time_since_fail_r11     = 0;
  meas_result_list2_eutra_v9e0_l meas_result_list_eutra_v1130;
  // ...
  // group 0
  bool                                      meas_result_failed_cell_v1250_present = false;
  bool                                      failed_cell_rsrq_type_r12_present     = false;
  bool                                      meas_result_list_eutra_v1250_present  = false;
  int8_t                                    meas_result_failed_cell_v1250         = -30;
  copy_ptr<rsrq_type_r12_s>                 failed_cell_rsrq_type_r12;
  copy_ptr<meas_result_list2_eutra_v1250_l> meas_result_list_eutra_v1250;
  // group 1
  bool   meas_result_failed_cell_v1360_present = false;
  int8_t meas_result_failed_cell_v1360         = -17;
  // group 2
  bool                                      log_meas_result_list_bt_r15_present   = false;
  bool                                      log_meas_result_list_wlan_r15_present = false;
  copy_ptr<log_meas_result_list_bt_r15_l>   log_meas_result_list_bt_r15;
  copy_ptr<log_meas_result_list_wlan_r15_l> log_meas_result_list_wlan_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-CountInfo ::= SEQUENCE
struct drb_count_info_s {
  // member variables
  uint8_t  drb_id   = 1;
  uint32_t count_ul = 0;
  uint32_t count_dl = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InDeviceCoexIndication-v1530-IEs ::= SEQUENCE
struct in_dev_coex_ind_v1530_ies_s {
  // member variables
  bool                   mrdc_assist_info_r15_present = false;
  bool                   non_crit_ext_present         = false;
  mrdc_assist_info_r15_s mrdc_assist_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LogMeasInfoList-r10 ::= SEQUENCE (SIZE (1..maxLogMeasReport-r10)) OF LogMeasInfo-r10
typedef dyn_array<log_meas_info_r10_s> log_meas_info_list_r10_l;

// MeasResultCellListNR-r15 ::= SEQUENCE (SIZE (1..maxCellReport)) OF MeasResultCellNR-r15
typedef dyn_array<meas_result_cell_nr_r15_s> meas_result_cell_list_nr_r15_l;

// RRCConnectionReconfigurationComplete-v1250-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_v1250_ies_s {
  // member variables
  bool                                log_meas_available_mbsfn_r12_present = false;
  bool                                non_crit_ext_present                 = false;
  rrc_conn_recfg_complete_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete-v1130-IEs ::= SEQUENCE
struct rrc_conn_reest_complete_v1130_ies_s {
  // member variables
  bool                                conn_est_fail_info_available_r11_present = false;
  bool                                non_crit_ext_present                     = false;
  rrc_conn_reest_complete_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v1250-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v1250_ies_s {
  struct mob_state_r12_opts {
    enum options { normal, medium, high, spare, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<mob_state_r12_opts> mob_state_r12_e_;

  // member variables
  bool                                mob_state_r12_present                = false;
  bool                                mob_history_avail_r12_present        = false;
  bool                                log_meas_available_mbsfn_r12_present = false;
  bool                                non_crit_ext_present                 = false;
  mob_state_r12_e_                    mob_state_r12;
  rrc_conn_setup_complete_v1320_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-CommTxResourceReq-r14 ::= SEQUENCE
struct sl_v2x_comm_tx_res_req_r14_s {
  // member variables
  bool                    carrier_freq_comm_tx_r14_present = false;
  bool                    v2x_type_tx_sync_r14_present     = false;
  bool                    v2x_dest_info_list_r14_present   = false;
  uint8_t                 carrier_freq_comm_tx_r14         = 0;
  sl_type_tx_sync_r14_e   v2x_type_tx_sync_r14;
  sl_dest_info_list_r12_l v2x_dest_info_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TrafficPatternInfoList-v1530 ::= SEQUENCE (SIZE (1..maxTrafficPattern-r14)) OF TrafficPatternInfo-v1530
typedef dyn_array<traffic_pattern_info_v1530_s> traffic_pattern_info_list_v1530_l;

// UEInformationResponse-v1250-IEs ::= SEQUENCE
struct ue_info_resp_v1250_ies_s {
  // member variables
  bool                     mob_history_report_r12_present = false;
  bool                     non_crit_ext_present           = false;
  mob_history_report_r12_l mob_history_report_r12;
  ue_info_resp_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCarrierFreqComb-r11 ::= SEQUENCE (SIZE (2..maxServCell-r10)) OF INTEGER
typedef bounded_array<uint8_t, 5> affected_carrier_freq_comb_r11_l;

// AffectedCarrierFreqCombList-r13 ::= SEQUENCE (SIZE (1..maxCombIDC-r11)) OF AffectedCarrierFreqComb-r13
typedef dyn_array<affected_carrier_freq_comb_r13_l> affected_carrier_freq_comb_list_r13_l;

// AffectedCarrierFreqList-v1310 ::= SEQUENCE (SIZE (1..maxFreqIDC-r11)) OF AffectedCarrierFreq-v1310
typedef dyn_array<affected_carrier_freq_v1310_s> affected_carrier_freq_list_v1310_l;

// DRB-CountInfoListExt-r15 ::= SEQUENCE (SIZE (1..maxDRBExt-r15)) OF DRB-CountInfo
typedef dyn_array<drb_count_info_s> drb_count_info_list_ext_r15_l;

// FailureReportSCG-v12d0 ::= SEQUENCE
struct fail_report_scg_v12d0_s {
  // member variables
  bool                           meas_result_neigh_cells_v12d0_present = false;
  meas_result_list2_eutra_v9e0_l meas_result_neigh_cells_v12d0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IDC-SubframePattern-r11 ::= CHOICE
struct idc_sf_pattern_r11_c {
  struct sf_pattern_tdd_r11_c_ {
    struct types_opts {
      enum options { sf_cfg0_r11, sf_cfg1_minus5_r11, sf_cfg6_r11, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    sf_pattern_tdd_r11_c_() = default;
    sf_pattern_tdd_r11_c_(const sf_pattern_tdd_r11_c_& other);
    sf_pattern_tdd_r11_c_& operator=(const sf_pattern_tdd_r11_c_& other);
    ~sf_pattern_tdd_r11_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<70>& sf_cfg0_r11()
    {
      assert_choice_type("subframeConfig0-r11", type_.to_string(), "subframePatternTDD-r11");
      return c.get<fixed_bitstring<70> >();
    }
    fixed_bitstring<10>& sf_cfg1_minus5_r11()
    {
      assert_choice_type("subframeConfig1-5-r11", type_.to_string(), "subframePatternTDD-r11");
      return c.get<fixed_bitstring<10> >();
    }
    fixed_bitstring<60>& sf_cfg6_r11()
    {
      assert_choice_type("subframeConfig6-r11", type_.to_string(), "subframePatternTDD-r11");
      return c.get<fixed_bitstring<60> >();
    }
    const fixed_bitstring<70>& sf_cfg0_r11() const
    {
      assert_choice_type("subframeConfig0-r11", type_.to_string(), "subframePatternTDD-r11");
      return c.get<fixed_bitstring<70> >();
    }
    const fixed_bitstring<10>& sf_cfg1_minus5_r11() const
    {
      assert_choice_type("subframeConfig1-5-r11", type_.to_string(), "subframePatternTDD-r11");
      return c.get<fixed_bitstring<10> >();
    }
    const fixed_bitstring<60>& sf_cfg6_r11() const
    {
      assert_choice_type("subframeConfig6-r11", type_.to_string(), "subframePatternTDD-r11");
      return c.get<fixed_bitstring<60> >();
    }
    fixed_bitstring<70>& set_sf_cfg0_r11()
    {
      set(types::sf_cfg0_r11);
      return c.get<fixed_bitstring<70> >();
    }
    fixed_bitstring<10>& set_sf_cfg1_minus5_r11()
    {
      set(types::sf_cfg1_minus5_r11);
      return c.get<fixed_bitstring<10> >();
    }
    fixed_bitstring<60>& set_sf_cfg6_r11()
    {
      set(types::sf_cfg6_r11);
      return c.get<fixed_bitstring<60> >();
    }

  private:
    types                                        type_;
    choice_buffer_t<sizeof(fixed_bitstring<70>)> c;

    void destroy_();
  };
  struct types_opts {
    enum options { sf_pattern_fdd_r11, sf_pattern_tdd_r11, /*...*/ nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts, true> types;

  // choice methods
  idc_sf_pattern_r11_c() = default;
  idc_sf_pattern_r11_c(const idc_sf_pattern_r11_c& other);
  idc_sf_pattern_r11_c& operator=(const idc_sf_pattern_r11_c& other);
  ~idc_sf_pattern_r11_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<4>& sf_pattern_fdd_r11()
  {
    assert_choice_type("subframePatternFDD-r11", type_.to_string(), "IDC-SubframePattern-r11");
    return c.get<fixed_bitstring<4> >();
  }
  sf_pattern_tdd_r11_c_& sf_pattern_tdd_r11()
  {
    assert_choice_type("subframePatternTDD-r11", type_.to_string(), "IDC-SubframePattern-r11");
    return c.get<sf_pattern_tdd_r11_c_>();
  }
  const fixed_bitstring<4>& sf_pattern_fdd_r11() const
  {
    assert_choice_type("subframePatternFDD-r11", type_.to_string(), "IDC-SubframePattern-r11");
    return c.get<fixed_bitstring<4> >();
  }
  const sf_pattern_tdd_r11_c_& sf_pattern_tdd_r11() const
  {
    assert_choice_type("subframePatternTDD-r11", type_.to_string(), "IDC-SubframePattern-r11");
    return c.get<sf_pattern_tdd_r11_c_>();
  }
  fixed_bitstring<4>& set_sf_pattern_fdd_r11()
  {
    set(types::sf_pattern_fdd_r11);
    return c.get<fixed_bitstring<4> >();
  }
  sf_pattern_tdd_r11_c_& set_sf_pattern_tdd_r11()
  {
    set(types::sf_pattern_tdd_r11);
    return c.get<sf_pattern_tdd_r11_c_>();
  }

private:
  types                                                                            type_;
  choice_buffer_t<MAX2(sizeof(fixed_bitstring<4>), sizeof(sf_pattern_tdd_r11_c_))> c;

  void destroy_();
};

// InDeviceCoexIndication-v1360-IEs ::= SEQUENCE
struct in_dev_coex_ind_v1360_ies_s {
  // member variables
  bool                        hardware_sharing_problem_r13_present = false;
  bool                        non_crit_ext_present                 = false;
  in_dev_coex_ind_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LogMeasReport-r10 ::= SEQUENCE
struct log_meas_report_r10_s {
  // member variables
  bool                     ext                            = false;
  bool                     log_meas_available_r10_present = false;
  fixed_bitstring<48>      absolute_time_stamp_r10;
  trace_ref_r10_s          trace_ref_r10;
  fixed_octstring<2>       trace_recording_session_ref_r10;
  fixed_octstring<1>       tce_id_r10;
  log_meas_info_list_r10_l log_meas_info_list_r10;
  // ...
  // group 0
  bool log_meas_available_bt_r15_present   = false;
  bool log_meas_available_wlan_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-ServiceInfo-r13 ::= SEQUENCE
struct mbms_service_info_r13_s {
  // member variables
  tmgi_r9_s tmgi_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultCBR-r14 ::= SEQUENCE
struct meas_result_cbr_r14_s {
  // member variables
  bool    cbr_pscch_r14_present = false;
  uint8_t pool_id_r14           = 1;
  uint8_t cbr_pssch_r14         = 0;
  uint8_t cbr_pscch_r14         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultCSI-RS-r12 ::= SEQUENCE
struct meas_result_csi_rs_r12_s {
  // member variables
  bool    ext                 = false;
  uint8_t meas_csi_rs_id_r12  = 1;
  uint8_t csi_rsrp_result_r12 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultCellSFTD-r15 ::= SEQUENCE
struct meas_result_cell_sftd_r15_s {
  // member variables
  bool     rsrp_result_r15_present          = false;
  uint16_t pci_r15                          = 0;
  uint16_t sfn_offset_result_r15            = 0;
  int16_t  frame_boundary_offset_result_r15 = -30720;
  uint8_t  rsrp_result_r15                  = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultFreqFailNR-r15 ::= SEQUENCE
struct meas_result_freq_fail_nr_r15_s {
  // member variables
  bool                           ext                               = false;
  bool                           meas_result_cell_list_r15_present = false;
  uint32_t                       carrier_freq_r15                  = 0;
  meas_result_cell_list_nr_r15_l meas_result_cell_list_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultServFreq-r10 ::= SEQUENCE
struct meas_result_serv_freq_r10_s {
  struct meas_result_scell_r10_s_ {
    // member variables
    uint8_t rsrp_result_scell_r10 = 0;
    uint8_t rsrq_result_scell_r10 = 0;
  };
  struct meas_result_best_neigh_cell_r10_s_ {
    // member variables
    uint16_t pci_r10               = 0;
    uint8_t  rsrp_result_ncell_r10 = 0;
    uint8_t  rsrq_result_ncell_r10 = 0;
  };
  struct meas_result_scell_v1310_s_ {
    // member variables
    uint8_t rs_sinr_result_r13 = 0;
  };
  struct meas_result_best_neigh_cell_v1310_s_ {
    // member variables
    uint8_t rs_sinr_result_r13 = 0;
  };

  // member variables
  bool                               ext                                     = false;
  bool                               meas_result_scell_r10_present           = false;
  bool                               meas_result_best_neigh_cell_r10_present = false;
  uint8_t                            serv_freq_id_r10                        = 0;
  meas_result_scell_r10_s_           meas_result_scell_r10;
  meas_result_best_neigh_cell_r10_s_ meas_result_best_neigh_cell_r10;
  // ...
  // group 0
  bool   meas_result_scell_v1250_present           = false;
  bool   meas_result_best_neigh_cell_v1250_present = false;
  int8_t meas_result_scell_v1250                   = -30;
  int8_t meas_result_best_neigh_cell_v1250         = -30;
  // group 1
  bool                                           meas_result_scell_v1310_present           = false;
  bool                                           meas_result_best_neigh_cell_v1310_present = false;
  copy_ptr<meas_result_scell_v1310_s_>           meas_result_scell_v1310;
  copy_ptr<meas_result_best_neigh_cell_v1310_s_> meas_result_best_neigh_cell_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultServFreq-r13 ::= SEQUENCE
struct meas_result_serv_freq_r13_s {
  struct meas_result_scell_r13_s_ {
    // member variables
    bool    rs_sinr_result_r13_present = false;
    uint8_t rsrp_result_scell_r13      = 0;
    int8_t  rsrq_result_scell_r13      = -30;
    uint8_t rs_sinr_result_r13         = 0;
  };
  struct meas_result_best_neigh_cell_r13_s_ {
    // member variables
    bool     rs_sinr_result_r13_present = false;
    uint16_t pci_r13                    = 0;
    uint8_t  rsrp_result_ncell_r13      = 0;
    int8_t   rsrq_result_ncell_r13      = -30;
    uint8_t  rs_sinr_result_r13         = 0;
  };
  struct meas_result_best_neigh_cell_v1360_s_ {
    // member variables
    int8_t rsrp_result_ncell_v1360 = -17;
  };

  // member variables
  bool                               ext                                     = false;
  bool                               meas_result_scell_r13_present           = false;
  bool                               meas_result_best_neigh_cell_r13_present = false;
  uint8_t                            serv_freq_id_r13                        = 0;
  meas_result_scell_r13_s_           meas_result_scell_r13;
  meas_result_best_neigh_cell_r13_s_ meas_result_best_neigh_cell_r13;
  // ...
  // group 0
  bool                                           meas_result_best_neigh_cell_v1360_present = false;
  copy_ptr<meas_result_best_neigh_cell_v1360_s_> meas_result_best_neigh_cell_v1360;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultServFreqNR-r15 ::= SEQUENCE
struct meas_result_serv_freq_nr_r15_s {
  // member variables
  bool                      ext                                     = false;
  bool                      meas_result_scell_r15_present           = false;
  bool                      meas_result_best_neigh_cell_r15_present = false;
  uint32_t                  carrier_freq_r15                        = 0;
  meas_result_cell_nr_r15_s meas_result_scell_r15;
  meas_result_cell_nr_r15_s meas_result_best_neigh_cell_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultWLAN-r13 ::= SEQUENCE
struct meas_result_wlan_r13_s {
  // member variables
  bool                     ext                                           = false;
  bool                     carrier_info_wlan_r13_present                 = false;
  bool                     band_wlan_r13_present                         = false;
  bool                     available_admission_capacity_wlan_r13_present = false;
  bool                     backhaul_dl_bw_wlan_r13_present               = false;
  bool                     backhaul_ul_bw_wlan_r13_present               = false;
  bool                     ch_utilization_wlan_r13_present               = false;
  bool                     station_count_wlan_r13_present                = false;
  bool                     connected_wlan_r13_present                    = false;
  wlan_ids_r12_s           wlan_ids_r13;
  wlan_carrier_info_r13_s  carrier_info_wlan_r13;
  wlan_band_ind_r13_e      band_wlan_r13;
  uint8_t                  rssi_wlan_r13                         = 0;
  uint16_t                 available_admission_capacity_wlan_r13 = 0;
  wlan_backhaul_rate_r12_e backhaul_dl_bw_wlan_r13;
  wlan_backhaul_rate_r12_e backhaul_ul_bw_wlan_r13;
  uint8_t                  ch_utilization_wlan_r13 = 0;
  uint16_t                 station_count_wlan_r13  = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// OverheatingAssistance-r14 ::= SEQUENCE
struct overheat_assist_r14_s {
  struct reduced_ue_category_s_ {
    // member variables
    uint8_t reduced_ue_category_dl = 0;
    uint8_t reduced_ue_category_ul = 0;
  };
  struct reduced_max_ccs_s_ {
    // member variables
    uint8_t reduced_ccs_dl = 0;
    uint8_t reduced_ccs_ul = 0;
  };

  // member variables
  bool                   reduced_ue_category_present = false;
  bool                   reduced_max_ccs_present     = false;
  reduced_ue_category_s_ reduced_ue_category;
  reduced_max_ccs_s_     reduced_max_ccs;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLF-Report-v9e0 ::= SEQUENCE
struct rlf_report_v9e0_s {
  // member variables
  meas_result_list2_eutra_v9e0_l meas_result_list_eutra_v9e0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfigurationComplete-v1130-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_v1130_ies_s {
  // member variables
  bool                                conn_est_fail_info_available_r11_present = false;
  bool                                non_crit_ext_present                     = false;
  rrc_conn_recfg_complete_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete-v1020-IEs ::= SEQUENCE
struct rrc_conn_reest_complete_v1020_ies_s {
  // member variables
  bool                                log_meas_available_r10_present = false;
  bool                                non_crit_ext_present           = false;
  rrc_conn_reest_complete_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v1130-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v1130_ies_s {
  // member variables
  bool                                conn_est_fail_info_available_r11_present = false;
  bool                                non_crit_ext_present                     = false;
  rrc_conn_setup_complete_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscSysInfoReport-r13 ::= SEQUENCE
struct sl_disc_sys_info_report_r13_s {
  struct disc_cell_sel_info_r13_s_ {
    // member variables
    bool    q_rx_lev_min_offset_r13_present = false;
    int8_t  q_rx_lev_min_r13                = -70;
    uint8_t q_rx_lev_min_offset_r13         = 1;
  };
  struct cell_resel_info_r13_s_ {
    struct q_hyst_r13_opts {
      enum options {
        db0,
        db1,
        db2,
        db3,
        db4,
        db5,
        db6,
        db8,
        db10,
        db12,
        db14,
        db16,
        db18,
        db20,
        db22,
        db24,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<q_hyst_r13_opts> q_hyst_r13_e_;

    // member variables
    q_hyst_r13_e_ q_hyst_r13;
    int8_t        q_rx_lev_min_r13  = -70;
    uint8_t       t_resel_eutra_r13 = 0;
  };
  struct freq_info_r13_s_ {
    struct ul_bw_r13_opts {
      enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<ul_bw_r13_opts> ul_bw_r13_e_;

    // member variables
    bool         ul_carrier_freq_r13_present   = false;
    bool         ul_bw_r13_present             = false;
    bool         add_spec_emission_r13_present = false;
    uint16_t     ul_carrier_freq_r13           = 0;
    ul_bw_r13_e_ ul_bw_r13;
    uint8_t      add_spec_emission_r13 = 1;
  };
  struct freq_info_v1370_s_ {
    // member variables
    uint16_t add_spec_emission_v1370 = 33;
  };

  // member variables
  bool                           ext                               = false;
  bool                           plmn_id_list_r13_present          = false;
  bool                           cell_id_minus13_present           = false;
  bool                           carrier_freq_info_minus13_present = false;
  bool                           disc_rx_res_r13_present           = false;
  bool                           disc_tx_pool_common_r13_present   = false;
  bool                           disc_tx_pwr_info_r13_present      = false;
  bool                           disc_sync_cfg_r13_present         = false;
  bool                           disc_cell_sel_info_r13_present    = false;
  bool                           cell_resel_info_r13_present       = false;
  bool                           tdd_cfg_r13_present               = false;
  bool                           freq_info_r13_present             = false;
  bool                           p_max_r13_present                 = false;
  bool                           ref_sig_pwr_r13_present           = false;
  plmn_id_list_l                 plmn_id_list_r13;
  fixed_bitstring<28>            cell_id_minus13;
  uint32_t                       carrier_freq_info_minus13 = 0;
  sl_disc_rx_pool_list_r12_l     disc_rx_res_r13;
  sl_disc_tx_pool_list_r12_l     disc_tx_pool_common_r13;
  sl_disc_tx_pwr_info_list_r12_l disc_tx_pwr_info_r13;
  sl_sync_cfg_nfreq_r13_s        disc_sync_cfg_r13;
  disc_cell_sel_info_r13_s_      disc_cell_sel_info_r13;
  cell_resel_info_r13_s_         cell_resel_info_r13;
  tdd_cfg_s                      tdd_cfg_r13;
  freq_info_r13_s_               freq_info_r13;
  int8_t                         p_max_r13       = -30;
  int8_t                         ref_sig_pwr_r13 = -60;
  // ...
  // group 0
  bool                         freq_info_v1370_present = false;
  copy_ptr<freq_info_v1370_s_> freq_info_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscTxResourceReq-r13 ::= SEQUENCE
struct sl_disc_tx_res_req_r13_s {
  // member variables
  bool    carrier_freq_disc_tx_r13_present = false;
  uint8_t carrier_freq_disc_tx_r13         = 1;
  uint8_t disc_tx_res_req_r13              = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-GapFreqInfo-r13 ::= SEQUENCE
struct sl_gap_freq_info_r13_s {
  // member variables
  bool                      carrier_freq_r13_present = false;
  uint32_t                  carrier_freq_r13         = 0;
  sl_gap_pattern_list_r13_l gap_pattern_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-CommFreqList-r14 ::= SEQUENCE (SIZE (1..maxFreqV2X-r14)) OF INTEGER
typedef bounded_array<uint8_t, 8> sl_v2x_comm_freq_list_r14_l;

// SL-V2X-CommTxFreqList-r14 ::= SEQUENCE (SIZE (1..maxFreqV2X-r14)) OF SL-V2X-CommTxResourceReq-r14
typedef dyn_array<sl_v2x_comm_tx_res_req_r14_s> sl_v2x_comm_tx_freq_list_r14_l;

// SensingResult-r15 ::= SEQUENCE
struct sensing_result_r15_s {
  // member variables
  uint16_t res_idx_r15 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SidelinkUEInformation-v1530-IEs ::= SEQUENCE
struct sidelink_ue_info_v1530_ies_s {
  // member variables
  bool                      reliability_info_list_sl_r15_present = false;
  bool                      non_crit_ext_present                 = false;
  sl_reliability_list_r15_l reliability_info_list_sl_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TrafficPatternInfo-r14 ::= SEQUENCE
struct traffic_pattern_info_r14_s {
  struct traffic_periodicity_r14_opts {
    enum options { sf20, sf50, sf100, sf200, sf300, sf400, sf500, sf600, sf700, sf800, sf900, sf1000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<traffic_periodicity_r14_opts> traffic_periodicity_r14_e_;

  // member variables
  bool                       prio_info_sl_r14_present = false;
  bool                       lc_ch_id_ul_r14_present  = false;
  traffic_periodicity_r14_e_ traffic_periodicity_r14;
  uint16_t                   timing_offset_r14 = 0;
  uint8_t                    prio_info_sl_r14  = 1;
  uint8_t                    lc_ch_id_ul_r14   = 3;
  fixed_bitstring<6>         msg_size_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-RadioPagingInfo-r12 ::= SEQUENCE
struct ue_radio_paging_info_r12_s {
  struct wake_up_signal_min_gap_e_drx_r15_opts {
    enum options { ms40, ms240, ms1000, ms2000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<wake_up_signal_min_gap_e_drx_r15_opts> wake_up_signal_min_gap_e_drx_r15_e_;
  struct wake_up_signal_min_gap_e_drx_tdd_r15_opts {
    enum options { ms40, ms240, ms1000, ms2000, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<wake_up_signal_min_gap_e_drx_tdd_r15_opts> wake_up_signal_min_gap_e_drx_tdd_r15_e_;

  // member variables
  bool    ext                       = false;
  bool    ue_category_v1250_present = false;
  uint8_t ue_category_v1250         = 0;
  // ...
  // group 0
  bool ue_category_dl_v1310_present = false;
  bool ce_mode_a_r13_present        = false;
  bool ce_mode_b_r13_present        = false;
  // group 1
  bool                                    wake_up_signal_r15_present                   = false;
  bool                                    wake_up_signal_tdd_r15_present               = false;
  bool                                    wake_up_signal_min_gap_e_drx_r15_present     = false;
  bool                                    wake_up_signal_min_gap_e_drx_tdd_r15_present = false;
  wake_up_signal_min_gap_e_drx_r15_e_     wake_up_signal_min_gap_e_drx_r15;
  wake_up_signal_min_gap_e_drx_tdd_r15_e_ wake_up_signal_min_gap_e_drx_tdd_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEAssistanceInformation-v1530-IEs ::= SEQUENCE
struct ueassist_info_v1530_ies_s {
  struct sps_assist_info_v1530_s_ {
    // member variables
    traffic_pattern_info_list_v1530_l traffic_pattern_info_list_sl_v1530;
  };

  // member variables
  bool                     sps_assist_info_v1530_present = false;
  bool                     non_crit_ext_present          = false;
  sps_assist_info_v1530_s_ sps_assist_info_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationResponse-v1130-IEs ::= SEQUENCE
struct ue_info_resp_v1130_ies_s {
  // member variables
  bool                       conn_est_fail_report_r11_present = false;
  bool                       non_crit_ext_present             = false;
  conn_est_fail_report_r11_s conn_est_fail_report_r11;
  ue_info_resp_v1250_ies_s   non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-PDCP-DelayResult-r13 ::= SEQUENCE
struct ul_pdcp_delay_result_r13_s {
  struct qci_id_r13_opts {
    enum options { qci1, qci2, qci3, qci4, spare4, spare3, spare2, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<qci_id_r13_opts> qci_id_r13_e_;

  // member variables
  bool          ext = false;
  qci_id_r13_e_ qci_id_r13;
  uint8_t       excess_delay_r13 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCarrierFreq-r11 ::= SEQUENCE
struct affected_carrier_freq_r11_s {
  struct interference_direction_r11_opts {
    enum options { eutra, other, both, spare, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<interference_direction_r11_opts> interference_direction_r11_e_;

  // member variables
  uint8_t                       carrier_freq_r11 = 1;
  interference_direction_r11_e_ interference_direction_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCarrierFreqCombList-r11 ::= SEQUENCE (SIZE (1..maxCombIDC-r11)) OF AffectedCarrierFreqComb-r11
typedef dyn_array<affected_carrier_freq_comb_r11_l> affected_carrier_freq_comb_list_r11_l;

// BW-Preference-r14 ::= SEQUENCE
struct bw_pref_r14_s {
  struct dl_pref_r14_opts {
    enum options { mhz1dot4, mhz5, mhz20, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<dl_pref_r14_opts> dl_pref_r14_e_;
  struct ul_pref_r14_opts {
    enum options { mhz1dot4, mhz5, nulltype } value;
    typedef float number_type;

    std::string to_string() const;
    float       to_number() const;
    std::string to_number_string() const;
  };
  typedef enumerated<ul_pref_r14_opts> ul_pref_r14_e_;

  // member variables
  bool           dl_pref_r14_present = false;
  bool           ul_pref_r14_present = false;
  dl_pref_r14_e_ dl_pref_r14;
  ul_pref_r14_e_ ul_pref_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CounterCheckResponse-v1530-IEs ::= SEQUENCE
struct counter_check_resp_v1530_ies_s {
  // member variables
  bool                          drb_count_info_list_ext_r15_present = false;
  bool                          non_crit_ext_present                = false;
  drb_count_info_list_ext_r15_l drb_count_info_list_ext_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CountingResponseInfo-r10 ::= SEQUENCE
struct count_resp_info_r10_s {
  // member variables
  bool    ext                    = false;
  uint8_t count_resp_service_r10 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DelayBudgetReport-r14 ::= CHOICE
struct delay_budget_report_r14_c {
  struct type1_opts {
    enum options {
      ms_minus1280,
      ms_minus640,
      ms_minus320,
      ms_minus160,
      ms_minus80,
      ms_minus60,
      ms_minus40,
      ms_minus20,
      ms0,
      ms20,
      ms40,
      ms60,
      ms80,
      ms160,
      ms320,
      ms640,
      ms1280,
      nulltype
    } value;
    typedef int16_t number_type;

    std::string to_string() const;
    int16_t     to_number() const;
  };
  typedef enumerated<type1_opts> type1_e_;
  struct type2_opts {
    enum options {
      ms_minus192,
      ms_minus168,
      ms_minus144,
      ms_minus120,
      ms_minus96,
      ms_minus72,
      ms_minus48,
      ms_minus24,
      ms0,
      ms24,
      ms48,
      ms72,
      ms96,
      ms120,
      ms144,
      ms168,
      ms192,
      nulltype
    } value;
    typedef int16_t number_type;

    std::string to_string() const;
    int16_t     to_number() const;
  };
  typedef enumerated<type2_opts> type2_e_;
  struct types_opts {
    enum options { type1, type2, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  delay_budget_report_r14_c() = default;
  delay_budget_report_r14_c(const delay_budget_report_r14_c& other);
  delay_budget_report_r14_c& operator=(const delay_budget_report_r14_c& other);
  ~delay_budget_report_r14_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  type1_e_& type1()
  {
    assert_choice_type("type1", type_.to_string(), "DelayBudgetReport-r14");
    return c.get<type1_e_>();
  }
  type2_e_& type2()
  {
    assert_choice_type("type2", type_.to_string(), "DelayBudgetReport-r14");
    return c.get<type2_e_>();
  }
  const type1_e_& type1() const
  {
    assert_choice_type("type1", type_.to_string(), "DelayBudgetReport-r14");
    return c.get<type1_e_>();
  }
  const type2_e_& type2() const
  {
    assert_choice_type("type2", type_.to_string(), "DelayBudgetReport-r14");
    return c.get<type2_e_>();
  }
  type1_e_& set_type1()
  {
    set(types::type1);
    return c.get<type1_e_>();
  }
  type2_e_& set_type2()
  {
    set(types::type2);
    return c.get<type2_e_>();
  }

private:
  types                                                     type_;
  choice_buffer_t<MAX2(sizeof(type1_e_), sizeof(type2_e_))> c;

  void destroy_();
};

// IDC-SubframePatternList-r11 ::= SEQUENCE (SIZE (1..maxSubframePatternIDC-r11)) OF IDC-SubframePattern-r11
typedef dyn_array<idc_sf_pattern_r11_c> idc_sf_pattern_list_r11_l;

// InDeviceCoexIndication-v1310-IEs ::= SEQUENCE
struct in_dev_coex_ind_v1310_ies_s {
  // member variables
  bool                                  affected_carrier_freq_list_v1310_present    = false;
  bool                                  affected_carrier_freq_comb_list_r13_present = false;
  bool                                  non_crit_ext_present                        = false;
  affected_carrier_freq_list_v1310_l    affected_carrier_freq_list_v1310;
  affected_carrier_freq_comb_list_r13_l affected_carrier_freq_comb_list_r13;
  in_dev_coex_ind_v1360_ies_s           non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-ServiceList-r13 ::= SEQUENCE (SIZE (0..maxMBMS-ServiceListPerUE-r13)) OF MBMS-ServiceInfo-r13
typedef dyn_array<mbms_service_info_r13_s> mbms_service_list_r13_l;

// MeasResultCSI-RS-List-r12 ::= SEQUENCE (SIZE (1..maxCellReport)) OF MeasResultCSI-RS-r12
typedef dyn_array<meas_result_csi_rs_r12_s> meas_result_csi_rs_list_r12_l;

// MeasResultCellListSFTD-r15 ::= SEQUENCE (SIZE (1..maxCellSFTD)) OF MeasResultCellSFTD-r15
typedef dyn_array<meas_result_cell_sftd_r15_s> meas_result_cell_list_sftd_r15_l;

// MeasResultForECID-r9 ::= SEQUENCE
struct meas_result_for_ecid_r9_s {
  // member variables
  uint16_t            ue_rx_tx_time_diff_result_r9 = 0;
  fixed_bitstring<10> current_sfn_r9;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultForRSSI-r13 ::= SEQUENCE
struct meas_result_for_rssi_r13_s {
  // member variables
  bool    ext              = false;
  uint8_t rssi_result_r13  = 0;
  uint8_t ch_occupancy_r13 = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultFreqListFailNR-r15 ::= SEQUENCE (SIZE (1..maxFreqNR-r15)) OF MeasResultFreqFailNR-r15
typedef dyn_array<meas_result_freq_fail_nr_r15_s> meas_result_freq_list_fail_nr_r15_l;

// MeasResultListCBR-r14 ::= SEQUENCE (SIZE (1..maxCBR-Report-r14)) OF MeasResultCBR-r14
typedef dyn_array<meas_result_cbr_r14_s> meas_result_list_cbr_r14_l;

// MeasResultListWLAN-r13 ::= SEQUENCE (SIZE (1..maxCellReport)) OF MeasResultWLAN-r13
typedef dyn_array<meas_result_wlan_r13_s> meas_result_list_wlan_r13_l;

// MeasResultListWLAN-r14 ::= SEQUENCE (SIZE (1..maxWLAN-Id-Report-r14)) OF MeasResultWLAN-r13
typedef dyn_array<meas_result_wlan_r13_s> meas_result_list_wlan_r14_l;

// MeasResultSSTD-r13 ::= SEQUENCE
struct meas_result_sstd_r13_s {
  // member variables
  uint16_t sfn_offset_result_r13            = 0;
  int8_t   frame_boundary_offset_result_r13 = -5;
  uint8_t  sf_boundary_offset_result_r13    = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultSensing-r15 ::= SEQUENCE
struct meas_result_sensing_r15_s {
  typedef dyn_array<sensing_result_r15_s> sensing_result_r15_l_;

  // member variables
  uint16_t              sl_sf_ref_r15 = 0;
  sensing_result_r15_l_ sensing_result_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultServFreqList-r10 ::= SEQUENCE (SIZE (1..maxServCell-r10)) OF MeasResultServFreq-r10
typedef dyn_array<meas_result_serv_freq_r10_s> meas_result_serv_freq_list_r10_l;

// MeasResultServFreqListExt-r13 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF MeasResultServFreq-r13
typedef dyn_array<meas_result_serv_freq_r13_s> meas_result_serv_freq_list_ext_r13_l;

// MeasResultServFreqListNR-r15 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF MeasResultServFreqNR-r15
typedef dyn_array<meas_result_serv_freq_nr_r15_s> meas_result_serv_freq_list_nr_r15_l;

// RRCConnectionReconfigurationComplete-v1020-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_v1020_ies_s {
  // member variables
  bool                                rlf_info_available_r10_present = false;
  bool                                log_meas_available_r10_present = false;
  bool                                non_crit_ext_present           = false;
  rrc_conn_recfg_complete_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete-v8a0-IEs ::= SEQUENCE
struct rrc_conn_reest_complete_v8a0_ies_s {
  // member variables
  bool                                late_non_crit_ext_present = false;
  bool                                non_crit_ext_present      = false;
  dyn_octstring                       late_non_crit_ext;
  rrc_conn_reest_complete_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v1020-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v1020_ies_s {
  struct gummei_type_r10_opts {
    enum options { native, mapped, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<gummei_type_r10_opts> gummei_type_r10_e_;
  struct rn_sf_cfg_req_r10_opts {
    enum options { required, not_required, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<rn_sf_cfg_req_r10_opts> rn_sf_cfg_req_r10_e_;

  // member variables
  bool                                gummei_type_r10_present        = false;
  bool                                rlf_info_available_r10_present = false;
  bool                                log_meas_available_r10_present = false;
  bool                                rn_sf_cfg_req_r10_present      = false;
  bool                                non_crit_ext_present           = false;
  gummei_type_r10_e_                  gummei_type_r10;
  rn_sf_cfg_req_r10_e_                rn_sf_cfg_req_r10;
  rrc_conn_setup_complete_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RSTD-InterFreqInfo-r10 ::= SEQUENCE
struct rstd_inter_freq_info_r10_s {
  struct meas_prs_offset_r15_c_ {
    struct types_opts {
      enum options {
        rstd0_r15,
        rstd1_r15,
        rstd2_r15,
        rstd3_r15,
        rstd4_r15,
        rstd5_r15,
        rstd6_r15,
        rstd7_r15,
        rstd8_r15,
        rstd9_r15,
        rstd10_r15,
        rstd11_r15,
        rstd12_r15,
        rstd13_r15,
        rstd14_r15,
        rstd15_r15,
        rstd16_r15,
        rstd17_r15,
        rstd18_r15,
        rstd19_r15,
        rstd20_r15,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    meas_prs_offset_r15_c_() = default;
    meas_prs_offset_r15_c_(const meas_prs_offset_r15_c_& other);
    meas_prs_offset_r15_c_& operator=(const meas_prs_offset_r15_c_& other);
    ~meas_prs_offset_r15_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& rstd0_r15()
    {
      assert_choice_type("rstd0-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint8_t>();
    }
    uint8_t& rstd1_r15()
    {
      assert_choice_type("rstd1-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint8_t>();
    }
    uint16_t& rstd2_r15()
    {
      assert_choice_type("rstd2-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd3_r15()
    {
      assert_choice_type("rstd3-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd4_r15()
    {
      assert_choice_type("rstd4-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint8_t& rstd5_r15()
    {
      assert_choice_type("rstd5-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint8_t>();
    }
    uint16_t& rstd6_r15()
    {
      assert_choice_type("rstd6-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd7_r15()
    {
      assert_choice_type("rstd7-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd8_r15()
    {
      assert_choice_type("rstd8-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd9_r15()
    {
      assert_choice_type("rstd9-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd10_r15()
    {
      assert_choice_type("rstd10-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd11_r15()
    {
      assert_choice_type("rstd11-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd12_r15()
    {
      assert_choice_type("rstd12-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd13_r15()
    {
      assert_choice_type("rstd13-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd14_r15()
    {
      assert_choice_type("rstd14-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd15_r15()
    {
      assert_choice_type("rstd15-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd16_r15()
    {
      assert_choice_type("rstd16-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd17_r15()
    {
      assert_choice_type("rstd17-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd18_r15()
    {
      assert_choice_type("rstd18-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd19_r15()
    {
      assert_choice_type("rstd19-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint16_t& rstd20_r15()
    {
      assert_choice_type("rstd20-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint8_t& rstd0_r15() const
    {
      assert_choice_type("rstd0-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint8_t>();
    }
    const uint8_t& rstd1_r15() const
    {
      assert_choice_type("rstd1-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint8_t>();
    }
    const uint16_t& rstd2_r15() const
    {
      assert_choice_type("rstd2-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd3_r15() const
    {
      assert_choice_type("rstd3-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd4_r15() const
    {
      assert_choice_type("rstd4-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint8_t& rstd5_r15() const
    {
      assert_choice_type("rstd5-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint8_t>();
    }
    const uint16_t& rstd6_r15() const
    {
      assert_choice_type("rstd6-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd7_r15() const
    {
      assert_choice_type("rstd7-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd8_r15() const
    {
      assert_choice_type("rstd8-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd9_r15() const
    {
      assert_choice_type("rstd9-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd10_r15() const
    {
      assert_choice_type("rstd10-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd11_r15() const
    {
      assert_choice_type("rstd11-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd12_r15() const
    {
      assert_choice_type("rstd12-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd13_r15() const
    {
      assert_choice_type("rstd13-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd14_r15() const
    {
      assert_choice_type("rstd14-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd15_r15() const
    {
      assert_choice_type("rstd15-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd16_r15() const
    {
      assert_choice_type("rstd16-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd17_r15() const
    {
      assert_choice_type("rstd17-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd18_r15() const
    {
      assert_choice_type("rstd18-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd19_r15() const
    {
      assert_choice_type("rstd19-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    const uint16_t& rstd20_r15() const
    {
      assert_choice_type("rstd20-r15", type_.to_string(), "measPRS-Offset-r15");
      return c.get<uint16_t>();
    }
    uint8_t& set_rstd0_r15()
    {
      set(types::rstd0_r15);
      return c.get<uint8_t>();
    }
    uint8_t& set_rstd1_r15()
    {
      set(types::rstd1_r15);
      return c.get<uint8_t>();
    }
    uint16_t& set_rstd2_r15()
    {
      set(types::rstd2_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd3_r15()
    {
      set(types::rstd3_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd4_r15()
    {
      set(types::rstd4_r15);
      return c.get<uint16_t>();
    }
    uint8_t& set_rstd5_r15()
    {
      set(types::rstd5_r15);
      return c.get<uint8_t>();
    }
    uint16_t& set_rstd6_r15()
    {
      set(types::rstd6_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd7_r15()
    {
      set(types::rstd7_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd8_r15()
    {
      set(types::rstd8_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd9_r15()
    {
      set(types::rstd9_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd10_r15()
    {
      set(types::rstd10_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd11_r15()
    {
      set(types::rstd11_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd12_r15()
    {
      set(types::rstd12_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd13_r15()
    {
      set(types::rstd13_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd14_r15()
    {
      set(types::rstd14_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd15_r15()
    {
      set(types::rstd15_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd16_r15()
    {
      set(types::rstd16_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd17_r15()
    {
      set(types::rstd17_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd18_r15()
    {
      set(types::rstd18_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd19_r15()
    {
      set(types::rstd19_r15);
      return c.get<uint16_t>();
    }
    uint16_t& set_rstd20_r15()
    {
      set(types::rstd20_r15);
      return c.get<uint16_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool     ext                 = false;
  uint16_t carrier_freq_r10    = 0;
  uint8_t  meas_prs_offset_r10 = 0;
  // ...
  // group 0
  bool     carrier_freq_v1090_present = false;
  uint32_t carrier_freq_v1090         = 65536;
  // group 1
  bool                             meas_prs_offset_r15_present = false;
  copy_ptr<meas_prs_offset_r15_c_> meas_prs_offset_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCGFailureInformation-v12d0-IEs ::= SEQUENCE
struct scg_fail_info_v12d0_ies_s {
  // member variables
  bool                    fail_report_scg_v12d0_present = false;
  bool                    non_crit_ext_present          = false;
  fail_report_scg_v12d0_s fail_report_scg_v12d0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CommTxResourceReq-r12 ::= SEQUENCE
struct sl_comm_tx_res_req_r12_s {
  // member variables
  bool                    carrier_freq_r12_present = false;
  uint32_t                carrier_freq_r12         = 0;
  sl_dest_info_list_r12_l dest_info_list_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-DiscSysInfoReportFreqList-r13 ::= SEQUENCE (SIZE (1.. maxSL-DiscSysInfoReportFreq-r13)) OF
// SL-DiscSysInfoReport-r13
typedef dyn_array<sl_disc_sys_info_report_r13_s> sl_disc_sys_info_report_freq_list_r13_l;

// SL-DiscTxResourceReqPerFreqList-r13 ::= SEQUENCE (SIZE (1..maxFreq)) OF SL-DiscTxResourceReq-r13
typedef dyn_array<sl_disc_tx_res_req_r13_s> sl_disc_tx_res_req_per_freq_list_r13_l;

// SL-GapRequest-r13 ::= SEQUENCE (SIZE (1..maxFreq)) OF SL-GapFreqInfo-r13
typedef dyn_array<sl_gap_freq_info_r13_s> sl_gap_request_r13_l;

// SidelinkUEInformation-v1430-IEs ::= SEQUENCE
struct sidelink_ue_info_v1430_ies_s {
  // member variables
  bool                           v2x_comm_rx_interested_freq_list_r14_present = false;
  bool                           p2x_comm_tx_type_r14_present                 = false;
  bool                           v2x_comm_tx_res_req_r14_present              = false;
  bool                           non_crit_ext_present                         = false;
  sl_v2x_comm_freq_list_r14_l    v2x_comm_rx_interested_freq_list_r14;
  sl_v2x_comm_tx_freq_list_r14_l v2x_comm_tx_res_req_r14;
  sidelink_ue_info_v1530_ies_s   non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TrafficPatternInfoList-r14 ::= SEQUENCE (SIZE (1..maxTrafficPattern-r14)) OF TrafficPatternInfo-r14
typedef dyn_array<traffic_pattern_info_r14_s> traffic_pattern_info_list_r14_l;

// UE-CapabilityRAT-Container ::= SEQUENCE
struct ue_cap_rat_container_s {
  // member variables
  rat_type_e    rat_type;
  dyn_octstring ue_cap_rat_container;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEAssistanceInformation-v1450-IEs ::= SEQUENCE
struct ueassist_info_v1450_ies_s {
  // member variables
  bool                      overheat_assist_r14_present = false;
  bool                      non_crit_ext_present        = false;
  overheat_assist_r14_s     overheat_assist_r14;
  ueassist_info_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityInformation-v1250-IEs ::= SEQUENCE
struct ue_cap_info_v1250_ies_s {
  // member variables
  bool                       ue_radio_paging_info_r12_present = false;
  bool                       non_crit_ext_present             = false;
  ue_radio_paging_info_r12_s ue_radio_paging_info_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationResponse-v1020-IEs ::= SEQUENCE
struct ue_info_resp_v1020_ies_s {
  // member variables
  bool                     log_meas_report_r10_present = false;
  bool                     non_crit_ext_present        = false;
  log_meas_report_r10_s    log_meas_report_r10;
  ue_info_resp_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationResponse-v9e0-IEs ::= SEQUENCE
struct ue_info_resp_v9e0_ies_s {
  // member variables
  bool              rlf_report_v9e0_present = false;
  bool              non_crit_ext_present    = false;
  rlf_report_v9e0_s rlf_report_v9e0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-PDCP-DelayResultList-r13 ::= SEQUENCE (SIZE (1..maxQCI-r13)) OF UL-PDCP-DelayResult-r13
typedef dyn_array<ul_pdcp_delay_result_r13_s> ul_pdcp_delay_result_list_r13_l;

// WLAN-Status-v1430 ::= ENUMERATED
struct wlan_status_v1430_opts {
  enum options { suspended, resumed, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<wlan_status_v1430_opts> wlan_status_v1430_e;

// AffectedCarrierFreqList-r11 ::= SEQUENCE (SIZE (1..maxFreqIDC-r11)) OF AffectedCarrierFreq-r11
typedef dyn_array<affected_carrier_freq_r11_s> affected_carrier_freq_list_r11_l;

// CSFBParametersRequestCDMA2000-v8a0-IEs ::= SEQUENCE
struct csfb_params_request_cdma2000_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CarrierFreqListMBMS-r11 ::= SEQUENCE (SIZE (1..maxFreqMBMS-r11)) OF INTEGER
typedef bounded_array<uint32_t, 5> carrier_freq_list_mbms_r11_l;

// CounterCheckResponse-v8a0-IEs ::= SEQUENCE
struct counter_check_resp_v8a0_ies_s {
  // member variables
  bool                           late_non_crit_ext_present = false;
  bool                           non_crit_ext_present      = false;
  dyn_octstring                  late_non_crit_ext;
  counter_check_resp_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CountingResponseList-r10 ::= SEQUENCE (SIZE (1..maxServiceCount)) OF CountingResponseInfo-r10
typedef dyn_array<count_resp_info_r10_s> count_resp_list_r10_l;

// DRB-CountInfoList ::= SEQUENCE (SIZE (0..maxDRB)) OF DRB-CountInfo
typedef dyn_array<drb_count_info_s> drb_count_info_list_l;

// FailureReportSCG-NR-r15 ::= SEQUENCE
struct fail_report_scg_nr_r15_s {
  struct fail_type_r15_opts {
    enum options {
      t310_expiry,
      random_access_problem,
      rlc_max_num_retx,
      scg_change_fail,
      scg_recfg_fail,
      srb3_integrity_fail,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<fail_type_r15_opts> fail_type_r15_e_;

  // member variables
  bool                                ext                                  = false;
  bool                                meas_result_freq_list_nr_r15_present = false;
  bool                                meas_result_scg_r15_present          = false;
  fail_type_r15_e_                    fail_type_r15;
  meas_result_freq_list_fail_nr_r15_l meas_result_freq_list_nr_r15;
  dyn_octstring                       meas_result_scg_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FailureReportSCG-r12 ::= SEQUENCE
struct fail_report_scg_r12_s {
  struct fail_type_r12_opts {
    enum options { t313_expiry, random_access_problem, rlc_max_num_retx, scg_change_fail, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<fail_type_r12_opts> fail_type_r12_e_;

  // member variables
  bool                             ext                                    = false;
  bool                             meas_result_serv_freq_list_r12_present = false;
  bool                             meas_result_neigh_cells_r12_present    = false;
  fail_type_r12_e_                 fail_type_r12;
  meas_result_serv_freq_list_r10_l meas_result_serv_freq_list_r12;
  meas_result_list2_eutra_r9_l     meas_result_neigh_cells_r12;
  // ...
  // group 0
  bool fail_type_v1290_present = false;
  // group 1
  bool                                           meas_result_serv_freq_list_ext_r13_present = false;
  copy_ptr<meas_result_serv_freq_list_ext_r13_l> meas_result_serv_freq_list_ext_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InDeviceCoexIndication-v11d0-IEs ::= SEQUENCE
struct in_dev_coex_ind_v11d0_ies_s {
  struct ul_ca_assist_info_r11_s_ {
    // member variables
    bool                                  affected_carrier_freq_comb_list_r11_present = false;
    affected_carrier_freq_comb_list_r11_l affected_carrier_freq_comb_list_r11;
    victim_sys_type_r11_s                 victim_sys_type_r11;
  };

  // member variables
  bool                        ul_ca_assist_info_r11_present = false;
  bool                        non_crit_ext_present          = false;
  ul_ca_assist_info_r11_s_    ul_ca_assist_info_r11;
  in_dev_coex_ind_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMSInterestIndication-v1310-IEs ::= SEQUENCE
struct mbms_interest_ind_v1310_ies_s {
  // member variables
  bool                    mbms_services_r13_present = false;
  bool                    non_crit_ext_present      = false;
  mbms_service_list_r13_l mbms_services_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResults ::= SEQUENCE
struct meas_results_s {
  struct meas_result_pcell_s_ {
    // member variables
    uint8_t rsrp_result = 0;
    uint8_t rsrq_result = 0;
  };
  struct meas_result_neigh_cells_c_ {
    struct types_opts {
      enum options {
        meas_result_list_eutra,
        meas_result_list_utra,
        meas_result_list_geran,
        meas_results_cdma2000,
        // ...
        meas_result_neigh_cell_list_nr_r15,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts, true, 1> types;

    // choice methods
    meas_result_neigh_cells_c_() = default;
    meas_result_neigh_cells_c_(const meas_result_neigh_cells_c_& other);
    meas_result_neigh_cells_c_& operator=(const meas_result_neigh_cells_c_& other);
    ~meas_result_neigh_cells_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    meas_result_list_eutra_l& meas_result_list_eutra()
    {
      assert_choice_type("measResultListEUTRA", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_list_eutra_l>();
    }
    meas_result_list_utra_l& meas_result_list_utra()
    {
      assert_choice_type("measResultListUTRA", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_list_utra_l>();
    }
    meas_result_list_geran_l& meas_result_list_geran()
    {
      assert_choice_type("measResultListGERAN", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_list_geran_l>();
    }
    meas_results_cdma2000_s& meas_results_cdma2000()
    {
      assert_choice_type("measResultsCDMA2000", type_.to_string(), "measResultNeighCells");
      return c.get<meas_results_cdma2000_s>();
    }
    meas_result_cell_list_nr_r15_l& meas_result_neigh_cell_list_nr_r15()
    {
      assert_choice_type("measResultNeighCellListNR-r15", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_cell_list_nr_r15_l>();
    }
    const meas_result_list_eutra_l& meas_result_list_eutra() const
    {
      assert_choice_type("measResultListEUTRA", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_list_eutra_l>();
    }
    const meas_result_list_utra_l& meas_result_list_utra() const
    {
      assert_choice_type("measResultListUTRA", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_list_utra_l>();
    }
    const meas_result_list_geran_l& meas_result_list_geran() const
    {
      assert_choice_type("measResultListGERAN", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_list_geran_l>();
    }
    const meas_results_cdma2000_s& meas_results_cdma2000() const
    {
      assert_choice_type("measResultsCDMA2000", type_.to_string(), "measResultNeighCells");
      return c.get<meas_results_cdma2000_s>();
    }
    const meas_result_cell_list_nr_r15_l& meas_result_neigh_cell_list_nr_r15() const
    {
      assert_choice_type("measResultNeighCellListNR-r15", type_.to_string(), "measResultNeighCells");
      return c.get<meas_result_cell_list_nr_r15_l>();
    }
    meas_result_list_eutra_l& set_meas_result_list_eutra()
    {
      set(types::meas_result_list_eutra);
      return c.get<meas_result_list_eutra_l>();
    }
    meas_result_list_utra_l& set_meas_result_list_utra()
    {
      set(types::meas_result_list_utra);
      return c.get<meas_result_list_utra_l>();
    }
    meas_result_list_geran_l& set_meas_result_list_geran()
    {
      set(types::meas_result_list_geran);
      return c.get<meas_result_list_geran_l>();
    }
    meas_results_cdma2000_s& set_meas_results_cdma2000()
    {
      set(types::meas_results_cdma2000);
      return c.get<meas_results_cdma2000_s>();
    }
    meas_result_cell_list_nr_r15_l& set_meas_result_neigh_cell_list_nr_r15()
    {
      set(types::meas_result_neigh_cell_list_nr_r15);
      return c.get<meas_result_cell_list_nr_r15_l>();
    }

  private:
    types type_;
    choice_buffer_t<MAX8(sizeof(meas_result_cell_list_nr_r15_l),
                         sizeof(meas_result_list_eutra_l),
                         sizeof(meas_result_list_geran_l),
                         sizeof(meas_result_list_utra_l),
                         sizeof(meas_results_cdma2000_s),
                         0,
                         0,
                         0)>
        c;

    void destroy_();
  };
  struct meas_result_pcell_v1310_s_ {
    // member variables
    uint8_t rs_sinr_result_r13 = 0;
  };

  // member variables
  bool                       ext                             = false;
  bool                       meas_result_neigh_cells_present = false;
  uint8_t                    meas_id                         = 1;
  meas_result_pcell_s_       meas_result_pcell;
  meas_result_neigh_cells_c_ meas_result_neigh_cells;
  // ...
  // group 0
  bool                                meas_result_for_ecid_r9_present = false;
  copy_ptr<meas_result_for_ecid_r9_s> meas_result_for_ecid_r9;
  // group 1
  bool                                       location_info_r10_present              = false;
  bool                                       meas_result_serv_freq_list_r10_present = false;
  copy_ptr<location_info_r10_s>              location_info_r10;
  copy_ptr<meas_result_serv_freq_list_r10_l> meas_result_serv_freq_list_r10;
  // group 2
  bool                                    meas_id_v1250_present               = false;
  bool                                    meas_result_pcell_v1250_present     = false;
  bool                                    meas_result_csi_rs_list_r12_present = false;
  uint8_t                                 meas_id_v1250                       = 33;
  int8_t                                  meas_result_pcell_v1250             = -30;
  copy_ptr<meas_result_csi_rs_list_r12_l> meas_result_csi_rs_list_r12;
  // group 3
  bool                                           meas_result_for_rssi_r13_present           = false;
  bool                                           meas_result_serv_freq_list_ext_r13_present = false;
  bool                                           meas_result_sstd_r13_present               = false;
  bool                                           meas_result_pcell_v1310_present            = false;
  bool                                           ul_pdcp_delay_result_list_r13_present      = false;
  bool                                           meas_result_list_wlan_r13_present          = false;
  copy_ptr<meas_result_for_rssi_r13_s>           meas_result_for_rssi_r13;
  copy_ptr<meas_result_serv_freq_list_ext_r13_l> meas_result_serv_freq_list_ext_r13;
  copy_ptr<meas_result_sstd_r13_s>               meas_result_sstd_r13;
  copy_ptr<meas_result_pcell_v1310_s_>           meas_result_pcell_v1310;
  copy_ptr<ul_pdcp_delay_result_list_r13_l>      ul_pdcp_delay_result_list_r13;
  copy_ptr<meas_result_list_wlan_r13_l>          meas_result_list_wlan_r13;
  // group 4
  bool   meas_result_pcell_v1360_present = false;
  int8_t meas_result_pcell_v1360         = -17;
  // group 5
  bool                                  meas_result_list_cbr_r14_present  = false;
  bool                                  meas_result_list_wlan_r14_present = false;
  copy_ptr<meas_result_list_cbr_r14_l>  meas_result_list_cbr_r14;
  copy_ptr<meas_result_list_wlan_r14_l> meas_result_list_wlan_r14;
  // group 6
  bool                                          meas_result_serv_freq_list_nr_r15_present = false;
  bool                                          meas_result_cell_list_sftd_r15_present    = false;
  copy_ptr<meas_result_serv_freq_list_nr_r15_l> meas_result_serv_freq_list_nr_r15;
  copy_ptr<meas_result_cell_list_sftd_r15_l>    meas_result_cell_list_sftd_r15;
  // group 7
  bool                                      log_meas_result_list_bt_r15_present   = false;
  bool                                      log_meas_result_list_wlan_r15_present = false;
  bool                                      meas_result_sensing_r15_present       = false;
  bool                                      height_ue_r15_present                 = false;
  copy_ptr<log_meas_result_list_bt_r15_l>   log_meas_result_list_bt_r15;
  copy_ptr<log_meas_result_list_wlan_r15_l> log_meas_result_list_wlan_r15;
  copy_ptr<meas_result_sensing_r15_s>       meas_result_sensing_r15;
  int16_t                                   height_ue_r15 = -400;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasurementReport-v8a0-IEs ::= SEQUENCE
struct meas_report_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ProximityIndication-v930-IEs ::= SEQUENCE
struct proximity_ind_v930_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLF-Report-r9 ::= SEQUENCE
struct rlf_report_r9_s {
  struct meas_result_last_serv_cell_r9_s_ {
    // member variables
    bool    rsrq_result_r9_present = false;
    uint8_t rsrp_result_r9         = 0;
    uint8_t rsrq_result_r9         = 0;
  };
  struct meas_result_neigh_cells_r9_s_ {
    // member variables
    bool                            meas_result_list_eutra_r9_present = false;
    bool                            meas_result_list_utra_r9_present  = false;
    bool                            meas_result_list_geran_r9_present = false;
    bool                            meas_results_cdma2000_r9_present  = false;
    meas_result_list2_eutra_r9_l    meas_result_list_eutra_r9;
    meas_result_list2_utra_r9_l     meas_result_list_utra_r9;
    meas_result_list_geran_l        meas_result_list_geran_r9;
    meas_result_list2_cdma2000_r9_l meas_results_cdma2000_r9;
  };
  struct failed_pcell_id_r10_c_ {
    struct pci_arfcn_r10_s_ {
      // member variables
      uint16_t pci_r10          = 0;
      uint16_t carrier_freq_r10 = 0;
    };
    struct types_opts {
      enum options { cell_global_id_r10, pci_arfcn_r10, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    failed_pcell_id_r10_c_() = default;
    failed_pcell_id_r10_c_(const failed_pcell_id_r10_c_& other);
    failed_pcell_id_r10_c_& operator=(const failed_pcell_id_r10_c_& other);
    ~failed_pcell_id_r10_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cell_global_id_eutra_s& cell_global_id_r10()
    {
      assert_choice_type("cellGlobalId-r10", type_.to_string(), "failedPCellId-r10");
      return c.get<cell_global_id_eutra_s>();
    }
    pci_arfcn_r10_s_& pci_arfcn_r10()
    {
      assert_choice_type("pci-arfcn-r10", type_.to_string(), "failedPCellId-r10");
      return c.get<pci_arfcn_r10_s_>();
    }
    const cell_global_id_eutra_s& cell_global_id_r10() const
    {
      assert_choice_type("cellGlobalId-r10", type_.to_string(), "failedPCellId-r10");
      return c.get<cell_global_id_eutra_s>();
    }
    const pci_arfcn_r10_s_& pci_arfcn_r10() const
    {
      assert_choice_type("pci-arfcn-r10", type_.to_string(), "failedPCellId-r10");
      return c.get<pci_arfcn_r10_s_>();
    }
    cell_global_id_eutra_s& set_cell_global_id_r10()
    {
      set(types::cell_global_id_r10);
      return c.get<cell_global_id_eutra_s>();
    }
    pci_arfcn_r10_s_& set_pci_arfcn_r10()
    {
      set(types::pci_arfcn_r10);
      return c.get<pci_arfcn_r10_s_>();
    }

  private:
    types                                                                           type_;
    choice_buffer_t<MAX2(sizeof(cell_global_id_eutra_s), sizeof(pci_arfcn_r10_s_))> c;

    void destroy_();
  };
  struct conn_fail_type_r10_opts {
    enum options { rlf, hof, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<conn_fail_type_r10_opts> conn_fail_type_r10_e_;
  struct failed_pcell_id_v1090_s_ {
    // member variables
    uint32_t carrier_freq_v1090 = 65536;
  };
  struct basic_fields_r11_s_ {
    struct rlf_cause_r11_opts {
      enum options { t310_expiry, random_access_problem, rlc_max_num_retx, t312_expiry_r12, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<rlf_cause_r11_opts> rlf_cause_r11_e_;

    // member variables
    fixed_bitstring<16> c_rnti_r11;
    rlf_cause_r11_e_    rlf_cause_r11;
    uint32_t            time_since_fail_r11 = 0;
  };
  struct prev_utra_cell_id_r11_s_ {
    struct pci_r11_c_ {
      struct types_opts {
        enum options { fdd_r11, tdd_r11, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      pci_r11_c_() = default;
      pci_r11_c_(const pci_r11_c_& other);
      pci_r11_c_& operator=(const pci_r11_c_& other);
      ~pci_r11_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint16_t& fdd_r11()
      {
        assert_choice_type("fdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint16_t>();
      }
      uint8_t& tdd_r11()
      {
        assert_choice_type("tdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint8_t>();
      }
      const uint16_t& fdd_r11() const
      {
        assert_choice_type("fdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint16_t>();
      }
      const uint8_t& tdd_r11() const
      {
        assert_choice_type("tdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint8_t>();
      }
      uint16_t& set_fdd_r11()
      {
        set(types::fdd_r11);
        return c.get<uint16_t>();
      }
      uint8_t& set_tdd_r11()
      {
        set(types::tdd_r11);
        return c.get<uint8_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };

    // member variables
    bool                  cell_global_id_r11_present = false;
    uint16_t              carrier_freq_r11           = 0;
    pci_r11_c_            pci_r11;
    cell_global_id_utra_s cell_global_id_r11;
  };
  struct sel_utra_cell_id_r11_s_ {
    struct pci_r11_c_ {
      struct types_opts {
        enum options { fdd_r11, tdd_r11, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      pci_r11_c_() = default;
      pci_r11_c_(const pci_r11_c_& other);
      pci_r11_c_& operator=(const pci_r11_c_& other);
      ~pci_r11_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      uint16_t& fdd_r11()
      {
        assert_choice_type("fdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint16_t>();
      }
      uint8_t& tdd_r11()
      {
        assert_choice_type("tdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint8_t>();
      }
      const uint16_t& fdd_r11() const
      {
        assert_choice_type("fdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint16_t>();
      }
      const uint8_t& tdd_r11() const
      {
        assert_choice_type("tdd-r11", type_.to_string(), "physCellId-r11");
        return c.get<uint8_t>();
      }
      uint16_t& set_fdd_r11()
      {
        set(types::fdd_r11);
        return c.get<uint16_t>();
      }
      uint8_t& set_tdd_r11()
      {
        set(types::tdd_r11);
        return c.get<uint8_t>();
      }

    private:
      types              type_;
      choice_buffer_t<8> c;

      void destroy_();
    };

    // member variables
    uint16_t   carrier_freq_r11 = 0;
    pci_r11_c_ pci_r11;
  };
  struct failed_pcell_id_v1250_s_ {
    // member variables
    fixed_bitstring<16> tac_failed_pcell_r12;
  };

  // member variables
  bool                             ext                                = false;
  bool                             meas_result_neigh_cells_r9_present = false;
  meas_result_last_serv_cell_r9_s_ meas_result_last_serv_cell_r9;
  meas_result_neigh_cells_r9_s_    meas_result_neigh_cells_r9;
  // ...
  // group 0
  bool                             location_info_r10_present   = false;
  bool                             failed_pcell_id_r10_present = false;
  bool                             reest_cell_id_r10_present   = false;
  bool                             time_conn_fail_r10_present  = false;
  bool                             conn_fail_type_r10_present  = false;
  bool                             prev_pcell_id_r10_present   = false;
  copy_ptr<location_info_r10_s>    location_info_r10;
  copy_ptr<failed_pcell_id_r10_c_> failed_pcell_id_r10;
  copy_ptr<cell_global_id_eutra_s> reest_cell_id_r10;
  uint16_t                         time_conn_fail_r10 = 0;
  conn_fail_type_r10_e_            conn_fail_type_r10;
  copy_ptr<cell_global_id_eutra_s> prev_pcell_id_r10;
  // group 1
  bool                               failed_pcell_id_v1090_present = false;
  copy_ptr<failed_pcell_id_v1090_s_> failed_pcell_id_v1090;
  // group 2
  bool                               basic_fields_r11_present      = false;
  bool                               prev_utra_cell_id_r11_present = false;
  bool                               sel_utra_cell_id_r11_present  = false;
  copy_ptr<basic_fields_r11_s_>      basic_fields_r11;
  copy_ptr<prev_utra_cell_id_r11_s_> prev_utra_cell_id_r11;
  copy_ptr<sel_utra_cell_id_r11_s_>  sel_utra_cell_id_r11;
  // group 3
  bool                                      failed_pcell_id_v1250_present            = false;
  bool                                      meas_result_last_serv_cell_v1250_present = false;
  bool                                      last_serv_cell_rsrq_type_r12_present     = false;
  bool                                      meas_result_list_eutra_v1250_present     = false;
  copy_ptr<failed_pcell_id_v1250_s_>        failed_pcell_id_v1250;
  int8_t                                    meas_result_last_serv_cell_v1250 = -30;
  copy_ptr<rsrq_type_r12_s>                 last_serv_cell_rsrq_type_r12;
  copy_ptr<meas_result_list2_eutra_v1250_l> meas_result_list_eutra_v1250;
  // group 4
  bool drb_established_with_qci_minus1_r13_present = false;
  // group 5
  bool   meas_result_last_serv_cell_v1360_present = false;
  int8_t meas_result_last_serv_cell_v1360         = -17;
  // group 6
  bool                                      log_meas_result_list_bt_r15_present   = false;
  bool                                      log_meas_result_list_wlan_r15_present = false;
  copy_ptr<log_meas_result_list_bt_r15_l>   log_meas_result_list_bt_r15;
  copy_ptr<log_meas_result_list_wlan_r15_l> log_meas_result_list_wlan_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfigurationComplete-v8a0-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_v8a0_ies_s {
  // member variables
  bool                                late_non_crit_ext_present = false;
  bool                                non_crit_ext_present      = false;
  dyn_octstring                       late_non_crit_ext;
  rrc_conn_recfg_complete_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete-v920-IEs ::= SEQUENCE
struct rrc_conn_reest_complete_v920_ies_s {
  // member variables
  bool                               rlf_info_available_r9_present = false;
  bool                               non_crit_ext_present          = false;
  rrc_conn_reest_complete_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResumeComplete-v1530-IEs ::= SEQUENCE
struct rrc_conn_resume_complete_v1530_ies_s {
  // member variables
  bool log_meas_available_bt_r15_present      = false;
  bool log_meas_available_wlan_r15_present    = false;
  bool idle_meas_available_r15_present        = false;
  bool flight_path_info_available_r15_present = false;
  bool non_crit_ext_present                   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-v8a0-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_v8a0_ies_s {
  // member variables
  bool                                late_non_crit_ext_present = false;
  bool                                non_crit_ext_present      = false;
  dyn_octstring                       late_non_crit_ext;
  rrc_conn_setup_complete_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RSTD-InterFreqInfoList-r10 ::= SEQUENCE (SIZE(1..maxRSTD-Freq-r10)) OF RSTD-InterFreqInfo-r10
typedef dyn_array<rstd_inter_freq_info_r10_s> rstd_inter_freq_info_list_r10_l;

// RegisteredMME ::= SEQUENCE
struct registered_mme_s {
  // member variables
  bool                plmn_id_present = false;
  plmn_id_s           plmn_id;
  fixed_bitstring<16> mmegi;
  fixed_bitstring<8>  mmec;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCGFailureInformation-v1310-IEs ::= SEQUENCE
struct scg_fail_info_v1310_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeComplete-v8a0-IEs ::= SEQUENCE
struct security_mode_complete_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeFailure-v8a0-IEs ::= SEQUENCE
struct security_mode_fail_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SidelinkUEInformation-v1310-IEs ::= SEQUENCE
struct sidelink_ue_info_v1310_ies_s {
  struct comm_tx_res_info_req_relay_r13_s_ {
    struct ue_type_r13_opts {
      enum options { relay_ue, remote_ue, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<ue_type_r13_opts> ue_type_r13_e_;

    // member variables
    bool                     comm_tx_res_req_relay_r13_present    = false;
    bool                     comm_tx_res_req_relay_uc_r13_present = false;
    sl_comm_tx_res_req_r12_s comm_tx_res_req_relay_r13;
    sl_comm_tx_res_req_r12_s comm_tx_res_req_relay_uc_r13;
    ue_type_r13_e_           ue_type_r13;
  };
  struct disc_tx_res_req_v1310_s_ {
    // member variables
    bool                                   carrier_freq_disc_tx_r13_present     = false;
    bool                                   disc_tx_res_req_add_freq_r13_present = false;
    uint8_t                                carrier_freq_disc_tx_r13             = 1;
    sl_disc_tx_res_req_per_freq_list_r13_l disc_tx_res_req_add_freq_r13;
  };

  // member variables
  bool                                    comm_tx_res_req_uc_r13_present             = false;
  bool                                    comm_tx_res_info_req_relay_r13_present     = false;
  bool                                    disc_tx_res_req_v1310_present              = false;
  bool                                    disc_tx_res_req_ps_r13_present             = false;
  bool                                    disc_rx_gap_req_r13_present                = false;
  bool                                    disc_tx_gap_req_r13_present                = false;
  bool                                    disc_sys_info_report_freq_list_r13_present = false;
  bool                                    non_crit_ext_present                       = false;
  sl_comm_tx_res_req_r12_s                comm_tx_res_req_uc_r13;
  comm_tx_res_info_req_relay_r13_s_       comm_tx_res_info_req_relay_r13;
  disc_tx_res_req_v1310_s_                disc_tx_res_req_v1310;
  sl_disc_tx_res_req_r13_s                disc_tx_res_req_ps_r13;
  sl_gap_request_r13_l                    disc_rx_gap_req_r13;
  sl_gap_request_r13_l                    disc_tx_gap_req_r13;
  sl_disc_sys_info_report_freq_list_r13_l disc_sys_info_report_freq_list_r13;
  sidelink_ue_info_v1430_ies_s            non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TDM-AssistanceInfo-r11 ::= CHOICE
struct tdm_assist_info_r11_c {
  struct drx_assist_info_r11_s_ {
    struct drx_cycle_len_r11_opts {
      enum options { sf40, sf64, sf80, sf128, sf160, sf256, spare2, spare1, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<drx_cycle_len_r11_opts> drx_cycle_len_r11_e_;
    struct drx_active_time_r11_opts {
      enum options { sf20, sf30, sf40, sf60, sf80, sf100, spare2, spare1, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<drx_active_time_r11_opts> drx_active_time_r11_e_;

    // member variables
    bool                   drx_offset_r11_present = false;
    drx_cycle_len_r11_e_   drx_cycle_len_r11;
    uint8_t                drx_offset_r11 = 0;
    drx_active_time_r11_e_ drx_active_time_r11;
  };
  struct types_opts {
    enum options { drx_assist_info_r11, idc_sf_pattern_list_r11, /*...*/ nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<types_opts, true> types;

  // choice methods
  tdm_assist_info_r11_c() = default;
  tdm_assist_info_r11_c(const tdm_assist_info_r11_c& other);
  tdm_assist_info_r11_c& operator=(const tdm_assist_info_r11_c& other);
  ~tdm_assist_info_r11_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  drx_assist_info_r11_s_& drx_assist_info_r11()
  {
    assert_choice_type("drx-AssistanceInfo-r11", type_.to_string(), "TDM-AssistanceInfo-r11");
    return c.get<drx_assist_info_r11_s_>();
  }
  idc_sf_pattern_list_r11_l& idc_sf_pattern_list_r11()
  {
    assert_choice_type("idc-SubframePatternList-r11", type_.to_string(), "TDM-AssistanceInfo-r11");
    return c.get<idc_sf_pattern_list_r11_l>();
  }
  const drx_assist_info_r11_s_& drx_assist_info_r11() const
  {
    assert_choice_type("drx-AssistanceInfo-r11", type_.to_string(), "TDM-AssistanceInfo-r11");
    return c.get<drx_assist_info_r11_s_>();
  }
  const idc_sf_pattern_list_r11_l& idc_sf_pattern_list_r11() const
  {
    assert_choice_type("idc-SubframePatternList-r11", type_.to_string(), "TDM-AssistanceInfo-r11");
    return c.get<idc_sf_pattern_list_r11_l>();
  }
  drx_assist_info_r11_s_& set_drx_assist_info_r11()
  {
    set(types::drx_assist_info_r11);
    return c.get<drx_assist_info_r11_s_>();
  }
  idc_sf_pattern_list_r11_l& set_idc_sf_pattern_list_r11()
  {
    set(types::idc_sf_pattern_list_r11);
    return c.get<idc_sf_pattern_list_r11_l>();
  }

private:
  types                                                                                    type_;
  choice_buffer_t<MAX2(sizeof(drx_assist_info_r11_s_), sizeof(idc_sf_pattern_list_r11_l))> c;

  void destroy_();
};

// UE-CapabilityRAT-ContainerList ::= SEQUENCE (SIZE (0..maxRAT-Capabilities)) OF UE-CapabilityRAT-Container
typedef dyn_array<ue_cap_rat_container_s> ue_cap_rat_container_list_l;

// UEAssistanceInformation-v1430-IEs ::= SEQUENCE
struct ueassist_info_v1430_ies_s {
  struct sps_assist_info_r14_s_ {
    // member variables
    bool                            traffic_pattern_info_list_sl_r14_present = false;
    bool                            traffic_pattern_info_list_ul_r14_present = false;
    traffic_pattern_info_list_r14_l traffic_pattern_info_list_sl_r14;
    traffic_pattern_info_list_r14_l traffic_pattern_info_list_ul_r14;
  };
  struct rlm_report_r14_s_ {
    struct rlm_event_r14_opts {
      enum options { early_out_of_sync, early_in_sync, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<rlm_event_r14_opts> rlm_event_r14_e_;
    struct excess_rep_mpdcch_r14_opts {
      enum options { excess_rep1, excess_rep2, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<excess_rep_mpdcch_r14_opts> excess_rep_mpdcch_r14_e_;

    // member variables
    bool                     excess_rep_mpdcch_r14_present = false;
    rlm_event_r14_e_         rlm_event_r14;
    excess_rep_mpdcch_r14_e_ excess_rep_mpdcch_r14;
  };

  // member variables
  bool                      bw_pref_r14_present             = false;
  bool                      sps_assist_info_r14_present     = false;
  bool                      rlm_report_r14_present          = false;
  bool                      delay_budget_report_r14_present = false;
  bool                      non_crit_ext_present            = false;
  bw_pref_r14_s             bw_pref_r14;
  sps_assist_info_r14_s_    sps_assist_info_r14;
  rlm_report_r14_s_         rlm_report_r14;
  delay_budget_report_r14_c delay_budget_report_r14;
  ueassist_info_v1450_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityInformation-v8a0-IEs ::= SEQUENCE
struct ue_cap_info_v8a0_ies_s {
  // member variables
  bool                    late_non_crit_ext_present = false;
  bool                    non_crit_ext_present      = false;
  dyn_octstring           late_non_crit_ext;
  ue_cap_info_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationResponse-v930-IEs ::= SEQUENCE
struct ue_info_resp_v930_ies_s {
  // member variables
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  dyn_octstring            late_non_crit_ext;
  ue_info_resp_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULHandoverPreparationTransfer-v8a0-IEs ::= SEQUENCE
struct ul_ho_prep_transfer_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULInformationTransfer-v8a0-IEs ::= SEQUENCE
struct ul_info_transfer_v8a0_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-Status-r13 ::= ENUMERATED
struct wlan_status_r13_opts {
  enum options { successful_association, fail_wlan_radio_link, fail_wlan_unavailable, fail_timeout, nulltype } value;

  std::string to_string() const;
};
typedef enumerated<wlan_status_r13_opts> wlan_status_r13_e;

// WLANConnectionStatusReport-v1430-IEs ::= SEQUENCE
struct wlan_conn_status_report_v1430_ies_s {
  // member variables
  bool                non_crit_ext_present = false;
  wlan_status_v1430_e wlan_status_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSFBParametersRequestCDMA2000-r8-IEs ::= SEQUENCE
struct csfb_params_request_cdma2000_r8_ies_s {
  // member variables
  bool                                    non_crit_ext_present = false;
  csfb_params_request_cdma2000_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CounterCheckResponse-r8-IEs ::= SEQUENCE
struct counter_check_resp_r8_ies_s {
  // member variables
  bool                          non_crit_ext_present = false;
  drb_count_info_list_l         drb_count_info_list;
  counter_check_resp_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FailedLogicalChannelInfo-r15 ::= SEQUENCE
struct failed_lc_ch_info_r15_s {
  struct failed_lc_ch_id_r15_s_ {
    struct cell_group_ind_r15_opts {
      enum options { mn, sn, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<cell_group_ind_r15_opts> cell_group_ind_r15_e_;

    // member variables
    bool                  lc_ch_id_r15_present     = false;
    bool                  lc_ch_id_ext_r15_present = false;
    cell_group_ind_r15_e_ cell_group_ind_r15;
    uint8_t               lc_ch_id_r15     = 1;
    uint8_t               lc_ch_id_ext_r15 = 32;
  };
  struct fail_type_opts {
    enum options { dupl, spare3, spare2, spare1, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<fail_type_opts> fail_type_e_;

  // member variables
  failed_lc_ch_id_r15_s_ failed_lc_ch_id_r15;
  fail_type_e_           fail_type;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InDeviceCoexIndication-r11-IEs ::= SEQUENCE
struct in_dev_coex_ind_r11_ies_s {
  // member variables
  bool                             affected_carrier_freq_list_r11_present = false;
  bool                             tdm_assist_info_r11_present            = false;
  bool                             late_non_crit_ext_present              = false;
  bool                             non_crit_ext_present                   = false;
  affected_carrier_freq_list_r11_l affected_carrier_freq_list_r11;
  tdm_assist_info_r11_c            tdm_assist_info_r11;
  dyn_octstring                    late_non_crit_ext;
  in_dev_coex_ind_v11d0_ies_s      non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqRSTDMeasurementIndication-r10-IEs ::= SEQUENCE
struct inter_freq_rstd_meas_ind_r10_ies_s {
  struct rstd_inter_freq_ind_r10_c_ {
    struct start_s_ {
      // member variables
      rstd_inter_freq_info_list_r10_l rstd_inter_freq_info_list_r10;
    };
    struct types_opts {
      enum options { start, stop, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    rstd_inter_freq_ind_r10_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    start_s_& start()
    {
      assert_choice_type("start", type_.to_string(), "rstd-InterFreqIndication-r10");
      return c;
    }
    const start_s_& start() const
    {
      assert_choice_type("start", type_.to_string(), "rstd-InterFreqIndication-r10");
      return c;
    }
    start_s_& set_start()
    {
      set(types::start);
      return c;
    }

  private:
    types    type_;
    start_s_ c;
  };

  // member variables
  bool                       late_non_crit_ext_present = false;
  bool                       non_crit_ext_present      = false;
  rstd_inter_freq_ind_r10_c_ rstd_inter_freq_ind_r10;
  dyn_octstring              late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMSCountingResponse-r10-IEs ::= SEQUENCE
struct mbms_count_resp_r10_ies_s {
  // member variables
  bool                  mbsfn_area_idx_r10_present  = false;
  bool                  count_resp_list_r10_present = false;
  bool                  late_non_crit_ext_present   = false;
  bool                  non_crit_ext_present        = false;
  uint8_t               mbsfn_area_idx_r10          = 0;
  count_resp_list_r10_l count_resp_list_r10;
  dyn_octstring         late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMSInterestIndication-r11-IEs ::= SEQUENCE
struct mbms_interest_ind_r11_ies_s {
  // member variables
  bool                          mbms_freq_list_r11_present = false;
  bool                          mbms_prio_r11_present      = false;
  bool                          late_non_crit_ext_present  = false;
  bool                          non_crit_ext_present       = false;
  carrier_freq_list_mbms_r11_l  mbms_freq_list_r11;
  dyn_octstring                 late_non_crit_ext;
  mbms_interest_ind_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasReportAppLayer-r15-IEs ::= SEQUENCE
struct meas_report_app_layer_r15_ies_s {
  struct service_type_opts {
    enum options { qoe, qoemtsi, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<service_type_opts> service_type_e_;

  // member variables
  bool            meas_report_app_layer_container_r15_present = false;
  bool            service_type_present                        = false;
  bool            non_crit_ext_present                        = false;
  dyn_octstring   meas_report_app_layer_container_r15;
  service_type_e_ service_type;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasurementReport-r8-IEs ::= SEQUENCE
struct meas_report_r8_ies_s {
  // member variables
  bool                   non_crit_ext_present = false;
  meas_results_s         meas_results;
  meas_report_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ProximityIndication-r9-IEs ::= SEQUENCE
struct proximity_ind_r9_ies_s {
  struct type_r9_opts {
    enum options { entering, leaving, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<type_r9_opts> type_r9_e_;
  struct carrier_freq_r9_c_ {
    struct types_opts {
      enum options { eutra_r9, utra_r9, /*...*/ eutra2_v9e0, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts, true, 1> types;

    // choice methods
    carrier_freq_r9_c_() = default;
    carrier_freq_r9_c_(const carrier_freq_r9_c_& other);
    carrier_freq_r9_c_& operator=(const carrier_freq_r9_c_& other);
    ~carrier_freq_r9_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t& eutra_r9()
    {
      assert_choice_type("eutra-r9", type_.to_string(), "carrierFreq-r9");
      return c.get<uint16_t>();
    }
    uint16_t& utra_r9()
    {
      assert_choice_type("utra-r9", type_.to_string(), "carrierFreq-r9");
      return c.get<uint16_t>();
    }
    uint32_t& eutra2_v9e0()
    {
      assert_choice_type("eutra2-v9e0", type_.to_string(), "carrierFreq-r9");
      return c.get<uint32_t>();
    }
    const uint16_t& eutra_r9() const
    {
      assert_choice_type("eutra-r9", type_.to_string(), "carrierFreq-r9");
      return c.get<uint16_t>();
    }
    const uint16_t& utra_r9() const
    {
      assert_choice_type("utra-r9", type_.to_string(), "carrierFreq-r9");
      return c.get<uint16_t>();
    }
    const uint32_t& eutra2_v9e0() const
    {
      assert_choice_type("eutra2-v9e0", type_.to_string(), "carrierFreq-r9");
      return c.get<uint32_t>();
    }
    uint16_t& set_eutra_r9()
    {
      set(types::eutra_r9);
      return c.get<uint16_t>();
    }
    uint16_t& set_utra_r9()
    {
      set(types::utra_r9);
      return c.get<uint16_t>();
    }
    uint32_t& set_eutra2_v9e0()
    {
      set(types::eutra2_v9e0);
      return c.get<uint32_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };

  // member variables
  bool                     non_crit_ext_present = false;
  type_r9_e_               type_r9;
  carrier_freq_r9_c_       carrier_freq_r9;
  proximity_ind_v930_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RNReconfigurationComplete-r10-IEs ::= SEQUENCE
struct rn_recfg_complete_r10_ies_s {
  // member variables
  bool          late_non_crit_ext_present = false;
  bool          non_crit_ext_present      = false;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfigurationComplete-r8-IEs ::= SEQUENCE
struct rrc_conn_recfg_complete_r8_ies_s {
  // member variables
  bool                               non_crit_ext_present = false;
  rrc_conn_recfg_complete_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete-r8-IEs ::= SEQUENCE
struct rrc_conn_reest_complete_r8_ies_s {
  // member variables
  bool                               non_crit_ext_present = false;
  rrc_conn_reest_complete_v920_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResumeComplete-r13-IEs ::= SEQUENCE
struct rrc_conn_resume_complete_r13_ies_s {
  struct mob_state_r13_opts {
    enum options { normal, medium, high, spare, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<mob_state_r13_opts> mob_state_r13_e_;

  // member variables
  bool                                 sel_plmn_id_r13_present                  = false;
  bool                                 ded_info_nas_r13_present                 = false;
  bool                                 rlf_info_available_r13_present           = false;
  bool                                 log_meas_available_r13_present           = false;
  bool                                 conn_est_fail_info_available_r13_present = false;
  bool                                 mob_state_r13_present                    = false;
  bool                                 mob_history_avail_r13_present            = false;
  bool                                 log_meas_available_mbsfn_r13_present     = false;
  bool                                 late_non_crit_ext_present                = false;
  bool                                 non_crit_ext_present                     = false;
  uint8_t                              sel_plmn_id_r13                          = 1;
  dyn_octstring                        ded_info_nas_r13;
  mob_state_r13_e_                     mob_state_r13;
  dyn_octstring                        late_non_crit_ext;
  rrc_conn_resume_complete_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete-r8-IEs ::= SEQUENCE
struct rrc_conn_setup_complete_r8_ies_s {
  // member variables
  bool                               registered_mme_present = false;
  bool                               non_crit_ext_present   = false;
  uint8_t                            sel_plmn_id            = 1;
  registered_mme_s                   registered_mme;
  dyn_octstring                      ded_info_nas;
  rrc_conn_setup_complete_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCGFailureInformation-r12-IEs ::= SEQUENCE
struct scg_fail_info_r12_ies_s {
  // member variables
  bool                      fail_report_scg_r12_present = false;
  bool                      non_crit_ext_present        = false;
  fail_report_scg_r12_s     fail_report_scg_r12;
  scg_fail_info_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCGFailureInformationNR-r15-IEs ::= SEQUENCE
struct scg_fail_info_nr_r15_ies_s {
  // member variables
  bool                     fail_report_scg_nr_r15_present = false;
  bool                     non_crit_ext_present           = false;
  fail_report_scg_nr_r15_s fail_report_scg_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeComplete-r8-IEs ::= SEQUENCE
struct security_mode_complete_r8_ies_s {
  // member variables
  bool                              non_crit_ext_present = false;
  security_mode_complete_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeFailure-r8-IEs ::= SEQUENCE
struct security_mode_fail_r8_ies_s {
  // member variables
  bool                          non_crit_ext_present = false;
  security_mode_fail_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SidelinkUEInformation-r12-IEs ::= SEQUENCE
struct sidelink_ue_info_r12_ies_s {
  // member variables
  bool                         comm_rx_interested_freq_r12_present = false;
  bool                         comm_tx_res_req_r12_present         = false;
  bool                         disc_rx_interest_r12_present        = false;
  bool                         disc_tx_res_req_r12_present         = false;
  bool                         late_non_crit_ext_present           = false;
  bool                         non_crit_ext_present                = false;
  uint32_t                     comm_rx_interested_freq_r12         = 0;
  sl_comm_tx_res_req_r12_s     comm_tx_res_req_r12;
  uint8_t                      disc_tx_res_req_r12 = 1;
  dyn_octstring                late_non_crit_ext;
  sidelink_ue_info_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEAssistanceInformation-r11-IEs ::= SEQUENCE
struct ueassist_info_r11_ies_s {
  struct pwr_pref_ind_r11_opts {
    enum options { normal, low_pwr_consumption, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<pwr_pref_ind_r11_opts> pwr_pref_ind_r11_e_;

  // member variables
  bool                      pwr_pref_ind_r11_present  = false;
  bool                      late_non_crit_ext_present = false;
  bool                      non_crit_ext_present      = false;
  pwr_pref_ind_r11_e_       pwr_pref_ind_r11;
  dyn_octstring             late_non_crit_ext;
  ueassist_info_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityInformation-r8-IEs ::= SEQUENCE
struct ue_cap_info_r8_ies_s {
  // member variables
  bool                        non_crit_ext_present = false;
  ue_cap_rat_container_list_l ue_cap_rat_container_list;
  ue_cap_info_v8a0_ies_s      non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationResponse-r9-IEs ::= SEQUENCE
struct ue_info_resp_r9_ies_s {
  struct rach_report_r9_s_ {
    // member variables
    uint8_t nof_preambs_sent_r9    = 1;
    bool    contention_detected_r9 = false;
  };

  // member variables
  bool                    rach_report_r9_present = false;
  bool                    rlf_report_r9_present  = false;
  bool                    non_crit_ext_present   = false;
  rach_report_r9_s_       rach_report_r9;
  rlf_report_r9_s         rlf_report_r9;
  ue_info_resp_v930_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULHandoverPreparationTransfer-r8-IEs ::= SEQUENCE
struct ul_ho_prep_transfer_r8_ies_s {
  // member variables
  bool                           meid_present         = false;
  bool                           non_crit_ext_present = false;
  cdma2000_type_e                cdma2000_type;
  fixed_bitstring<56>            meid;
  dyn_octstring                  ded_info;
  ul_ho_prep_transfer_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULInformationTransfer-r8-IEs ::= SEQUENCE
struct ul_info_transfer_r8_ies_s {
  struct ded_info_type_c_ {
    struct types_opts {
      enum options { ded_info_nas, ded_info_cdma2000_minus1_xrtt, ded_info_cdma2000_hrpd, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ded_info_type_c_() = default;
    ded_info_type_c_(const ded_info_type_c_& other);
    ded_info_type_c_& operator=(const ded_info_type_c_& other);
    ~ded_info_type_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dyn_octstring& ded_info_nas()
    {
      assert_choice_type("dedicatedInfoNAS", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ded_info_cdma2000_minus1_xrtt()
    {
      assert_choice_type("dedicatedInfoCDMA2000-1XRTT", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& ded_info_cdma2000_hrpd()
    {
      assert_choice_type("dedicatedInfoCDMA2000-HRPD", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_nas() const
    {
      assert_choice_type("dedicatedInfoNAS", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_cdma2000_minus1_xrtt() const
    {
      assert_choice_type("dedicatedInfoCDMA2000-1XRTT", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    const dyn_octstring& ded_info_cdma2000_hrpd() const
    {
      assert_choice_type("dedicatedInfoCDMA2000-HRPD", type_.to_string(), "dedicatedInfoType");
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_nas()
    {
      set(types::ded_info_nas);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_cdma2000_minus1_xrtt()
    {
      set(types::ded_info_cdma2000_minus1_xrtt);
      return c.get<dyn_octstring>();
    }
    dyn_octstring& set_ded_info_cdma2000_hrpd()
    {
      set(types::ded_info_cdma2000_hrpd);
      return c.get<dyn_octstring>();
    }

  private:
    types                                  type_;
    choice_buffer_t<sizeof(dyn_octstring)> c;

    void destroy_();
  };

  // member variables
  bool                        non_crit_ext_present = false;
  ded_info_type_c_            ded_info_type;
  ul_info_transfer_v8a0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULInformationTransferMRDC-r15-IEs ::= SEQUENCE
struct ul_info_transfer_mrdc_r15_ies_s {
  // member variables
  bool          ul_dcch_msg_nr_r15_present = false;
  bool          late_non_crit_ext_present  = false;
  bool          non_crit_ext_present       = false;
  dyn_octstring ul_dcch_msg_nr_r15;
  dyn_octstring late_non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLANConnectionStatusReport-r13-IEs ::= SEQUENCE
struct wlan_conn_status_report_r13_ies_s {
  // member variables
  bool                                late_non_crit_ext_present = false;
  bool                                non_crit_ext_present      = false;
  wlan_status_r13_e                   wlan_status_r13;
  dyn_octstring                       late_non_crit_ext;
  wlan_conn_status_report_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSFBParametersRequestCDMA2000 ::= SEQUENCE
struct csfb_params_request_cdma2000_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { csfb_params_request_cdma2000_r8, crit_exts_future, nulltype } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csfb_params_request_cdma2000_r8_ies_s& csfb_params_request_cdma2000_r8()
    {
      assert_choice_type("csfbParametersRequestCDMA2000-r8", type_.to_string(), "criticalExtensions");
      return c.get<csfb_params_request_cdma2000_r8_ies_s>();
    }
    const csfb_params_request_cdma2000_r8_ies_s& csfb_params_request_cdma2000_r8() const
    {
      assert_choice_type("csfbParametersRequestCDMA2000-r8", type_.to_string(), "criticalExtensions");
      return c.get<csfb_params_request_cdma2000_r8_ies_s>();
    }
    csfb_params_request_cdma2000_r8_ies_s& set_csfb_params_request_cdma2000_r8()
    {
      set(types::csfb_params_request_cdma2000_r8);
      return c.get<csfb_params_request_cdma2000_r8_ies_s>();
    }

  private:
    types                                                          type_;
    choice_buffer_t<sizeof(csfb_params_request_cdma2000_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CounterCheckResponse ::= SEQUENCE
struct counter_check_resp_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { counter_check_resp_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    counter_check_resp_r8_ies_s& counter_check_resp_r8()
    {
      assert_choice_type("counterCheckResponse-r8", type_.to_string(), "criticalExtensions");
      return c.get<counter_check_resp_r8_ies_s>();
    }
    const counter_check_resp_r8_ies_s& counter_check_resp_r8() const
    {
      assert_choice_type("counterCheckResponse-r8", type_.to_string(), "criticalExtensions");
      return c.get<counter_check_resp_r8_ies_s>();
    }
    counter_check_resp_r8_ies_s& set_counter_check_resp_r8()
    {
      set(types::counter_check_resp_r8);
      return c.get<counter_check_resp_r8_ies_s>();
    }

  private:
    types                                                type_;
    choice_buffer_t<sizeof(counter_check_resp_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FailureInformation-r15 ::= SEQUENCE
struct fail_info_r15_s {
  // member variables
  bool                    failed_lc_ch_info_r15_present = false;
  failed_lc_ch_info_r15_s failed_lc_ch_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InDeviceCoexIndication-r11 ::= SEQUENCE
struct in_dev_coex_ind_r11_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { in_dev_coex_ind_r11, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      in_dev_coex_ind_r11_ies_s& in_dev_coex_ind_r11()
      {
        assert_choice_type("inDeviceCoexIndication-r11", type_.to_string(), "c1");
        return c;
      }
      const in_dev_coex_ind_r11_ies_s& in_dev_coex_ind_r11() const
      {
        assert_choice_type("inDeviceCoexIndication-r11", type_.to_string(), "c1");
        return c;
      }
      in_dev_coex_ind_r11_ies_s& set_in_dev_coex_ind_r11()
      {
        set(types::in_dev_coex_ind_r11);
        return c;
      }

    private:
      types                     type_;
      in_dev_coex_ind_r11_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqRSTDMeasurementIndication-r10 ::= SEQUENCE
struct inter_freq_rstd_meas_ind_r10_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { inter_freq_rstd_meas_ind_r10, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      inter_freq_rstd_meas_ind_r10_ies_s& inter_freq_rstd_meas_ind_r10()
      {
        assert_choice_type("interFreqRSTDMeasurementIndication-r10", type_.to_string(), "c1");
        return c;
      }
      const inter_freq_rstd_meas_ind_r10_ies_s& inter_freq_rstd_meas_ind_r10() const
      {
        assert_choice_type("interFreqRSTDMeasurementIndication-r10", type_.to_string(), "c1");
        return c;
      }
      inter_freq_rstd_meas_ind_r10_ies_s& set_inter_freq_rstd_meas_ind_r10()
      {
        set(types::inter_freq_rstd_meas_ind_r10);
        return c;
      }

    private:
      types                              type_;
      inter_freq_rstd_meas_ind_r10_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMSCountingResponse-r10 ::= SEQUENCE
struct mbms_count_resp_r10_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { count_resp_r10, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      mbms_count_resp_r10_ies_s& count_resp_r10()
      {
        assert_choice_type("countingResponse-r10", type_.to_string(), "c1");
        return c;
      }
      const mbms_count_resp_r10_ies_s& count_resp_r10() const
      {
        assert_choice_type("countingResponse-r10", type_.to_string(), "c1");
        return c;
      }
      mbms_count_resp_r10_ies_s& set_count_resp_r10()
      {
        set(types::count_resp_r10);
        return c;
      }

    private:
      types                     type_;
      mbms_count_resp_r10_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMSInterestIndication-r11 ::= SEQUENCE
struct mbms_interest_ind_r11_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { interest_ind_r11, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      mbms_interest_ind_r11_ies_s& interest_ind_r11()
      {
        assert_choice_type("interestIndication-r11", type_.to_string(), "c1");
        return c;
      }
      const mbms_interest_ind_r11_ies_s& interest_ind_r11() const
      {
        assert_choice_type("interestIndication-r11", type_.to_string(), "c1");
        return c;
      }
      mbms_interest_ind_r11_ies_s& set_interest_ind_r11()
      {
        set(types::interest_ind_r11);
        return c;
      }

    private:
      types                       type_;
      mbms_interest_ind_r11_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasReportAppLayer-r15 ::= SEQUENCE
struct meas_report_app_layer_r15_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { meas_report_app_layer_r15, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    meas_report_app_layer_r15_ies_s& meas_report_app_layer_r15()
    {
      assert_choice_type("measReportAppLayer-r15", type_.to_string(), "criticalExtensions");
      return c.get<meas_report_app_layer_r15_ies_s>();
    }
    const meas_report_app_layer_r15_ies_s& meas_report_app_layer_r15() const
    {
      assert_choice_type("measReportAppLayer-r15", type_.to_string(), "criticalExtensions");
      return c.get<meas_report_app_layer_r15_ies_s>();
    }
    meas_report_app_layer_r15_ies_s& set_meas_report_app_layer_r15()
    {
      set(types::meas_report_app_layer_r15);
      return c.get<meas_report_app_layer_r15_ies_s>();
    }

  private:
    types                                                    type_;
    choice_buffer_t<sizeof(meas_report_app_layer_r15_ies_s)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasurementReport ::= SEQUENCE
struct meas_report_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { meas_report_r8, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      meas_report_r8_ies_s& meas_report_r8()
      {
        assert_choice_type("measurementReport-r8", type_.to_string(), "c1");
        return c;
      }
      const meas_report_r8_ies_s& meas_report_r8() const
      {
        assert_choice_type("measurementReport-r8", type_.to_string(), "c1");
        return c;
      }
      meas_report_r8_ies_s& set_meas_report_r8()
      {
        set(types::meas_report_r8);
        return c;
      }

    private:
      types                type_;
      meas_report_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ProximityIndication-r9 ::= SEQUENCE
struct proximity_ind_r9_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { proximity_ind_r9, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      proximity_ind_r9_ies_s& proximity_ind_r9()
      {
        assert_choice_type("proximityIndication-r9", type_.to_string(), "c1");
        return c;
      }
      const proximity_ind_r9_ies_s& proximity_ind_r9() const
      {
        assert_choice_type("proximityIndication-r9", type_.to_string(), "c1");
        return c;
      }
      proximity_ind_r9_ies_s& set_proximity_ind_r9()
      {
        set(types::proximity_ind_r9);
        return c;
      }

    private:
      types                  type_;
      proximity_ind_r9_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RNReconfigurationComplete-r10 ::= SEQUENCE
struct rn_recfg_complete_r10_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rn_recfg_complete_r10, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rn_recfg_complete_r10_ies_s& rn_recfg_complete_r10()
      {
        assert_choice_type("rnReconfigurationComplete-r10", type_.to_string(), "c1");
        return c;
      }
      const rn_recfg_complete_r10_ies_s& rn_recfg_complete_r10() const
      {
        assert_choice_type("rnReconfigurationComplete-r10", type_.to_string(), "c1");
        return c;
      }
      rn_recfg_complete_r10_ies_s& set_rn_recfg_complete_r10()
      {
        set(types::rn_recfg_complete_r10);
        return c;
      }

    private:
      types                       type_;
      rn_recfg_complete_r10_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReconfigurationComplete ::= SEQUENCE
struct rrc_conn_recfg_complete_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_conn_recfg_complete_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_recfg_complete_r8_ies_s& rrc_conn_recfg_complete_r8()
    {
      assert_choice_type("rrcConnectionReconfigurationComplete-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_recfg_complete_r8_ies_s>();
    }
    const rrc_conn_recfg_complete_r8_ies_s& rrc_conn_recfg_complete_r8() const
    {
      assert_choice_type("rrcConnectionReconfigurationComplete-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_recfg_complete_r8_ies_s>();
    }
    rrc_conn_recfg_complete_r8_ies_s& set_rrc_conn_recfg_complete_r8()
    {
      set(types::rrc_conn_recfg_complete_r8);
      return c.get<rrc_conn_recfg_complete_r8_ies_s>();
    }

  private:
    types                                                     type_;
    choice_buffer_t<sizeof(rrc_conn_recfg_complete_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionReestablishmentComplete ::= SEQUENCE
struct rrc_conn_reest_complete_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_conn_reest_complete_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_reest_complete_r8_ies_s& rrc_conn_reest_complete_r8()
    {
      assert_choice_type("rrcConnectionReestablishmentComplete-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_reest_complete_r8_ies_s>();
    }
    const rrc_conn_reest_complete_r8_ies_s& rrc_conn_reest_complete_r8() const
    {
      assert_choice_type("rrcConnectionReestablishmentComplete-r8", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_reest_complete_r8_ies_s>();
    }
    rrc_conn_reest_complete_r8_ies_s& set_rrc_conn_reest_complete_r8()
    {
      set(types::rrc_conn_reest_complete_r8);
      return c.get<rrc_conn_reest_complete_r8_ies_s>();
    }

  private:
    types                                                     type_;
    choice_buffer_t<sizeof(rrc_conn_reest_complete_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionResumeComplete-r13 ::= SEQUENCE
struct rrc_conn_resume_complete_r13_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { rrc_conn_resume_complete_r13, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rrc_conn_resume_complete_r13_ies_s& rrc_conn_resume_complete_r13()
    {
      assert_choice_type("rrcConnectionResumeComplete-r13", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_resume_complete_r13_ies_s>();
    }
    const rrc_conn_resume_complete_r13_ies_s& rrc_conn_resume_complete_r13() const
    {
      assert_choice_type("rrcConnectionResumeComplete-r13", type_.to_string(), "criticalExtensions");
      return c.get<rrc_conn_resume_complete_r13_ies_s>();
    }
    rrc_conn_resume_complete_r13_ies_s& set_rrc_conn_resume_complete_r13()
    {
      set(types::rrc_conn_resume_complete_r13);
      return c.get<rrc_conn_resume_complete_r13_ies_s>();
    }

  private:
    types                                                       type_;
    choice_buffer_t<sizeof(rrc_conn_resume_complete_r13_ies_s)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCConnectionSetupComplete ::= SEQUENCE
struct rrc_conn_setup_complete_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { rrc_conn_setup_complete_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      rrc_conn_setup_complete_r8_ies_s& rrc_conn_setup_complete_r8()
      {
        assert_choice_type("rrcConnectionSetupComplete-r8", type_.to_string(), "c1");
        return c;
      }
      const rrc_conn_setup_complete_r8_ies_s& rrc_conn_setup_complete_r8() const
      {
        assert_choice_type("rrcConnectionSetupComplete-r8", type_.to_string(), "c1");
        return c;
      }
      rrc_conn_setup_complete_r8_ies_s& set_rrc_conn_setup_complete_r8()
      {
        set(types::rrc_conn_setup_complete_r8);
        return c;
      }

    private:
      types                            type_;
      rrc_conn_setup_complete_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCGFailureInformation-r12 ::= SEQUENCE
struct scg_fail_info_r12_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { scg_fail_info_r12, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      scg_fail_info_r12_ies_s& scg_fail_info_r12()
      {
        assert_choice_type("scgFailureInformation-r12", type_.to_string(), "c1");
        return c;
      }
      const scg_fail_info_r12_ies_s& scg_fail_info_r12() const
      {
        assert_choice_type("scgFailureInformation-r12", type_.to_string(), "c1");
        return c;
      }
      scg_fail_info_r12_ies_s& set_scg_fail_info_r12()
      {
        set(types::scg_fail_info_r12);
        return c;
      }

    private:
      types                   type_;
      scg_fail_info_r12_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCGFailureInformationNR-r15 ::= SEQUENCE
struct scg_fail_info_nr_r15_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { scg_fail_info_nr_r15, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      scg_fail_info_nr_r15_ies_s& scg_fail_info_nr_r15()
      {
        assert_choice_type("scgFailureInformationNR-r15", type_.to_string(), "c1");
        return c;
      }
      const scg_fail_info_nr_r15_ies_s& scg_fail_info_nr_r15() const
      {
        assert_choice_type("scgFailureInformationNR-r15", type_.to_string(), "c1");
        return c;
      }
      scg_fail_info_nr_r15_ies_s& set_scg_fail_info_nr_r15()
      {
        set(types::scg_fail_info_nr_r15);
        return c;
      }

    private:
      types                      type_;
      scg_fail_info_nr_r15_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeComplete ::= SEQUENCE
struct security_mode_complete_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { security_mode_complete_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    security_mode_complete_r8_ies_s& security_mode_complete_r8()
    {
      assert_choice_type("securityModeComplete-r8", type_.to_string(), "criticalExtensions");
      return c.get<security_mode_complete_r8_ies_s>();
    }
    const security_mode_complete_r8_ies_s& security_mode_complete_r8() const
    {
      assert_choice_type("securityModeComplete-r8", type_.to_string(), "criticalExtensions");
      return c.get<security_mode_complete_r8_ies_s>();
    }
    security_mode_complete_r8_ies_s& set_security_mode_complete_r8()
    {
      set(types::security_mode_complete_r8);
      return c.get<security_mode_complete_r8_ies_s>();
    }

  private:
    types                                                    type_;
    choice_buffer_t<sizeof(security_mode_complete_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SecurityModeFailure ::= SEQUENCE
struct security_mode_fail_s {
  struct crit_exts_c_ {
    struct types_opts {
      enum options { security_mode_fail_r8, crit_exts_future, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    security_mode_fail_r8_ies_s& security_mode_fail_r8()
    {
      assert_choice_type("securityModeFailure-r8", type_.to_string(), "criticalExtensions");
      return c.get<security_mode_fail_r8_ies_s>();
    }
    const security_mode_fail_r8_ies_s& security_mode_fail_r8() const
    {
      assert_choice_type("securityModeFailure-r8", type_.to_string(), "criticalExtensions");
      return c.get<security_mode_fail_r8_ies_s>();
    }
    security_mode_fail_r8_ies_s& set_security_mode_fail_r8()
    {
      set(types::security_mode_fail_r8);
      return c.get<security_mode_fail_r8_ies_s>();
    }

  private:
    types                                                type_;
    choice_buffer_t<sizeof(security_mode_fail_r8_ies_s)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SidelinkUEInformation-r12 ::= SEQUENCE
struct sidelink_ue_info_r12_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { sidelink_ue_info_r12, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      sidelink_ue_info_r12_ies_s& sidelink_ue_info_r12()
      {
        assert_choice_type("sidelinkUEInformation-r12", type_.to_string(), "c1");
        return c;
      }
      const sidelink_ue_info_r12_ies_s& sidelink_ue_info_r12() const
      {
        assert_choice_type("sidelinkUEInformation-r12", type_.to_string(), "c1");
        return c;
      }
      sidelink_ue_info_r12_ies_s& set_sidelink_ue_info_r12()
      {
        set(types::sidelink_ue_info_r12);
        return c;
      }

    private:
      types                      type_;
      sidelink_ue_info_r12_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEAssistanceInformation-r11 ::= SEQUENCE
struct ueassist_info_r11_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ue_assist_info_r11, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ueassist_info_r11_ies_s& ue_assist_info_r11()
      {
        assert_choice_type("ueAssistanceInformation-r11", type_.to_string(), "c1");
        return c;
      }
      const ueassist_info_r11_ies_s& ue_assist_info_r11() const
      {
        assert_choice_type("ueAssistanceInformation-r11", type_.to_string(), "c1");
        return c;
      }
      ueassist_info_r11_ies_s& set_ue_assist_info_r11()
      {
        set(types::ue_assist_info_r11);
        return c;
      }

    private:
      types                   type_;
      ueassist_info_r11_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UECapabilityInformation ::= SEQUENCE
struct ue_cap_info_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ue_cap_info_r8, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ue_cap_info_r8_ies_s& ue_cap_info_r8()
      {
        assert_choice_type("ueCapabilityInformation-r8", type_.to_string(), "c1");
        return c;
      }
      const ue_cap_info_r8_ies_s& ue_cap_info_r8() const
      {
        assert_choice_type("ueCapabilityInformation-r8", type_.to_string(), "c1");
        return c;
      }
      ue_cap_info_r8_ies_s& set_ue_cap_info_r8()
      {
        set(types::ue_cap_info_r8);
        return c;
      }

    private:
      types                type_;
      ue_cap_info_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInformationResponse-r9 ::= SEQUENCE
struct ue_info_resp_r9_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ue_info_resp_r9, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ue_info_resp_r9_ies_s& ue_info_resp_r9()
      {
        assert_choice_type("ueInformationResponse-r9", type_.to_string(), "c1");
        return c;
      }
      const ue_info_resp_r9_ies_s& ue_info_resp_r9() const
      {
        assert_choice_type("ueInformationResponse-r9", type_.to_string(), "c1");
        return c;
      }
      ue_info_resp_r9_ies_s& set_ue_info_resp_r9()
      {
        set(types::ue_info_resp_r9);
        return c;
      }

    private:
      types                 type_;
      ue_info_resp_r9_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  uint8_t      rrc_transaction_id = 0;
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULHandoverPreparationTransfer ::= SEQUENCE
struct ul_ho_prep_transfer_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ul_ho_prep_transfer_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ul_ho_prep_transfer_r8_ies_s& ul_ho_prep_transfer_r8()
      {
        assert_choice_type("ulHandoverPreparationTransfer-r8", type_.to_string(), "c1");
        return c;
      }
      const ul_ho_prep_transfer_r8_ies_s& ul_ho_prep_transfer_r8() const
      {
        assert_choice_type("ulHandoverPreparationTransfer-r8", type_.to_string(), "c1");
        return c;
      }
      ul_ho_prep_transfer_r8_ies_s& set_ul_ho_prep_transfer_r8()
      {
        set(types::ul_ho_prep_transfer_r8);
        return c;
      }

    private:
      types                        type_;
      ul_ho_prep_transfer_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULInformationTransfer ::= SEQUENCE
struct ul_info_transfer_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ul_info_transfer_r8, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ul_info_transfer_r8_ies_s& ul_info_transfer_r8()
      {
        assert_choice_type("ulInformationTransfer-r8", type_.to_string(), "c1");
        return c;
      }
      const ul_info_transfer_r8_ies_s& ul_info_transfer_r8() const
      {
        assert_choice_type("ulInformationTransfer-r8", type_.to_string(), "c1");
        return c;
      }
      ul_info_transfer_r8_ies_s& set_ul_info_transfer_r8()
      {
        set(types::ul_info_transfer_r8);
        return c;
      }

    private:
      types                     type_;
      ul_info_transfer_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULInformationTransferMRDC-r15 ::= SEQUENCE
struct ul_info_transfer_mrdc_r15_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ul_info_transfer_mrdc_r15, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ul_info_transfer_mrdc_r15_ies_s& ul_info_transfer_mrdc_r15()
      {
        assert_choice_type("ulInformationTransferMRDC-r15", type_.to_string(), "c1");
        return c;
      }
      const ul_info_transfer_mrdc_r15_ies_s& ul_info_transfer_mrdc_r15() const
      {
        assert_choice_type("ulInformationTransferMRDC-r15", type_.to_string(), "c1");
        return c;
      }
      ul_info_transfer_mrdc_r15_ies_s& set_ul_info_transfer_mrdc_r15()
      {
        set(types::ul_info_transfer_mrdc_r15);
        return c;
      }

    private:
      types                           type_;
      ul_info_transfer_mrdc_r15_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLANConnectionStatusReport-r13 ::= SEQUENCE
struct wlan_conn_status_report_r13_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { wlan_conn_status_report_r13, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      wlan_conn_status_report_r13_ies_s& wlan_conn_status_report_r13()
      {
        assert_choice_type("wlanConnectionStatusReport-r13", type_.to_string(), "c1");
        return c;
      }
      const wlan_conn_status_report_r13_ies_s& wlan_conn_status_report_r13() const
      {
        assert_choice_type("wlanConnectionStatusReport-r13", type_.to_string(), "c1");
        return c;
      }
      wlan_conn_status_report_r13_ies_s& set_wlan_conn_status_report_r13()
      {
        set(types::wlan_conn_status_report_r13);
        return c;
      }

    private:
      types                             type_;
      wlan_conn_status_report_r13_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-DCCH-MessageType ::= CHOICE
struct ul_dcch_msg_type_c {
  struct c1_c_ {
    struct types_opts {
      enum options {
        csfb_params_request_cdma2000,
        meas_report,
        rrc_conn_recfg_complete,
        rrc_conn_reest_complete,
        rrc_conn_setup_complete,
        security_mode_complete,
        security_mode_fail,
        ue_cap_info,
        ul_ho_prep_transfer,
        ul_info_transfer,
        counter_check_resp,
        ue_info_resp_r9,
        proximity_ind_r9,
        rn_recfg_complete_r10,
        mbms_count_resp_r10,
        inter_freq_rstd_meas_ind_r10,
        nulltype
      } value;
      typedef uint16_t number_type;

      std::string to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    c1_c_() = default;
    c1_c_(const c1_c_& other);
    c1_c_& operator=(const c1_c_& other);
    ~c1_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    csfb_params_request_cdma2000_s& csfb_params_request_cdma2000()
    {
      assert_choice_type("csfbParametersRequestCDMA2000", type_.to_string(), "c1");
      return c.get<csfb_params_request_cdma2000_s>();
    }
    meas_report_s& meas_report()
    {
      assert_choice_type("measurementReport", type_.to_string(), "c1");
      return c.get<meas_report_s>();
    }
    rrc_conn_recfg_complete_s& rrc_conn_recfg_complete()
    {
      assert_choice_type("rrcConnectionReconfigurationComplete", type_.to_string(), "c1");
      return c.get<rrc_conn_recfg_complete_s>();
    }
    rrc_conn_reest_complete_s& rrc_conn_reest_complete()
    {
      assert_choice_type("rrcConnectionReestablishmentComplete", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_complete_s>();
    }
    rrc_conn_setup_complete_s& rrc_conn_setup_complete()
    {
      assert_choice_type("rrcConnectionSetupComplete", type_.to_string(), "c1");
      return c.get<rrc_conn_setup_complete_s>();
    }
    security_mode_complete_s& security_mode_complete()
    {
      assert_choice_type("securityModeComplete", type_.to_string(), "c1");
      return c.get<security_mode_complete_s>();
    }
    security_mode_fail_s& security_mode_fail()
    {
      assert_choice_type("securityModeFailure", type_.to_string(), "c1");
      return c.get<security_mode_fail_s>();
    }
    ue_cap_info_s& ue_cap_info()
    {
      assert_choice_type("ueCapabilityInformation", type_.to_string(), "c1");
      return c.get<ue_cap_info_s>();
    }
    ul_ho_prep_transfer_s& ul_ho_prep_transfer()
    {
      assert_choice_type("ulHandoverPreparationTransfer", type_.to_string(), "c1");
      return c.get<ul_ho_prep_transfer_s>();
    }
    ul_info_transfer_s& ul_info_transfer()
    {
      assert_choice_type("ulInformationTransfer", type_.to_string(), "c1");
      return c.get<ul_info_transfer_s>();
    }
    counter_check_resp_s& counter_check_resp()
    {
      assert_choice_type("counterCheckResponse", type_.to_string(), "c1");
      return c.get<counter_check_resp_s>();
    }
    ue_info_resp_r9_s& ue_info_resp_r9()
    {
      assert_choice_type("ueInformationResponse-r9", type_.to_string(), "c1");
      return c.get<ue_info_resp_r9_s>();
    }
    proximity_ind_r9_s& proximity_ind_r9()
    {
      assert_choice_type("proximityIndication-r9", type_.to_string(), "c1");
      return c.get<proximity_ind_r9_s>();
    }
    rn_recfg_complete_r10_s& rn_recfg_complete_r10()
    {
      assert_choice_type("rnReconfigurationComplete-r10", type_.to_string(), "c1");
      return c.get<rn_recfg_complete_r10_s>();
    }
    mbms_count_resp_r10_s& mbms_count_resp_r10()
    {
      assert_choice_type("mbmsCountingResponse-r10", type_.to_string(), "c1");
      return c.get<mbms_count_resp_r10_s>();
    }
    inter_freq_rstd_meas_ind_r10_s& inter_freq_rstd_meas_ind_r10()
    {
      assert_choice_type("interFreqRSTDMeasurementIndication-r10", type_.to_string(), "c1");
      return c.get<inter_freq_rstd_meas_ind_r10_s>();
    }
    const csfb_params_request_cdma2000_s& csfb_params_request_cdma2000() const
    {
      assert_choice_type("csfbParametersRequestCDMA2000", type_.to_string(), "c1");
      return c.get<csfb_params_request_cdma2000_s>();
    }
    const meas_report_s& meas_report() const
    {
      assert_choice_type("measurementReport", type_.to_string(), "c1");
      return c.get<meas_report_s>();
    }
    const rrc_conn_recfg_complete_s& rrc_conn_recfg_complete() const
    {
      assert_choice_type("rrcConnectionReconfigurationComplete", type_.to_string(), "c1");
      return c.get<rrc_conn_recfg_complete_s>();
    }
    const rrc_conn_reest_complete_s& rrc_conn_reest_complete() const
    {
      assert_choice_type("rrcConnectionReestablishmentComplete", type_.to_string(), "c1");
      return c.get<rrc_conn_reest_complete_s>();
    }
    const rrc_conn_setup_complete_s& rrc_conn_setup_complete() const
    {
      assert_choice_type("rrcConnectionSetupComplete", type_.to_string(), "c1");
      return c.get<rrc_conn_setup_complete_s>();
    }
    const security_mode_complete_s& security_mode_complete() const
    {
      assert_choice_type("securityModeComplete", type_.to_string(), "c1");
      return c.get<security_mode_complete_s>();
    }
    const security_mode_fail_s& security_mode_fail() const
    {
      assert_choice_type("securityModeFailure", type_.to_string(), "c1");
      return c.get<security_mode_fail_s>();
    }
    const ue_cap_info_s& ue_cap_info() const
    {
      assert_choice_type("ueCapabilityInformation", type_.to_string(), "c1");
      return c.get<ue_cap_info_s>();
    }
    const ul_ho_prep_transfer_s& ul_ho_prep_transfer() const
    {
      assert_choice_type("ulHandoverPreparationTransfer", type_.to_string(), "c1");
      return c.get<ul_ho_prep_transfer_s>();
    }
    const ul_info_transfer_s& ul_info_transfer() const
    {
      assert_choice_type("ulInformationTransfer", type_.to_string(), "c1");
      return c.get<ul_info_transfer_s>();
    }
    const counter_check_resp_s& counter_check_resp() const
    {
      assert_choice_type("counterCheckResponse", type_.to_string(), "c1");
      return c.get<counter_check_resp_s>();
    }
    const ue_info_resp_r9_s& ue_info_resp_r9() const
    {
      assert_choice_type("ueInformationResponse-r9", type_.to_string(), "c1");
      return c.get<ue_info_resp_r9_s>();
    }
    const proximity_ind_r9_s& proximity_ind_r9() const
    {
      assert_choice_type("proximityIndication-r9", type_.to_string(), "c1");
      return c.get<proximity_ind_r9_s>();
    }
    const rn_recfg_complete_r10_s& rn_recfg_complete_r10() const
    {
      assert_choice_type("rnReconfigurationComplete-r10", type_.to_string(), "c1");
      return c.get<rn_recfg_complete_r10_s>();
    }
    const mbms_count_resp_r10_s& mbms_count_resp_r10() const
    {
      assert_choice_type("mbmsCountingResponse-r10", type_.to_string(), "c1");
      return c.get<mbms_count_resp_r10_s>();
    }
    const inter_freq_rstd_meas_ind_r10_s& inter_freq_rstd_meas_ind_r10() const
    {
      assert_choice_type("interFreqRSTDMeasurementIndication-r10", type_.to_string(), "c1");
      return c.get<inter_freq_rstd_meas_ind_r10_s>();
    }
    csfb_params_request_cdma2000_s& set_csfb_params_request_cdma2000()
    {
      set(types::csfb_params_request_cdma2000);
      return c.get<csfb_params_request_cdma2000_s>();
    }
    meas_report_s& set_meas_report()
    {
      set(types::meas_report);
      return c.get<meas_report_s>();
    }
    rrc_conn_recfg_complete_s& set_rrc_conn_recfg_complete()
    {
      set(types::rrc_conn_recfg_complete);
      return c.get<rrc_conn_recfg_complete_s>();
    }
    rrc_conn_reest_complete_s& set_rrc_conn_reest_complete()
    {
      set(types::rrc_conn_reest_complete);
      return c.get<rrc_conn_reest_complete_s>();
    }
    rrc_conn_setup_complete_s& set_rrc_conn_setup_complete()
    {
      set(types::rrc_conn_setup_complete);
      return c.get<rrc_conn_setup_complete_s>();
    }
    security_mode_complete_s& set_security_mode_complete()
    {
      set(types::security_mode_complete);
      return c.get<security_mode_complete_s>();
    }
    security_mode_fail_s& set_security_mode_fail()
    {
      set(types::security_mode_fail);
      return c.get<security_mode_fail_s>();
    }
    ue_cap_info_s& set_ue_cap_info()
    {
      set(types::ue_cap_info);
      return c.get<ue_cap_info_s>();
    }
    ul_ho_prep_transfer_s& set_ul_ho_prep_transfer()
    {
      set(types::ul_ho_prep_transfer);
      return c.get<ul_ho_prep_transfer_s>();
    }
    ul_info_transfer_s& set_ul_info_transfer()
    {
      set(types::ul_info_transfer);
      return c.get<ul_info_transfer_s>();
    }
    counter_check_resp_s& set_counter_check_resp()
    {
      set(types::counter_check_resp);
      return c.get<counter_check_resp_s>();
    }
    ue_info_resp_r9_s& set_ue_info_resp_r9()
    {
      set(types::ue_info_resp_r9);
      return c.get<ue_info_resp_r9_s>();
    }
    proximity_ind_r9_s& set_proximity_ind_r9()
    {
      set(types::proximity_ind_r9);
      return c.get<proximity_ind_r9_s>();
    }
    rn_recfg_complete_r10_s& set_rn_recfg_complete_r10()
    {
      set(types::rn_recfg_complete_r10);
      return c.get<rn_recfg_complete_r10_s>();
    }
    mbms_count_resp_r10_s& set_mbms_count_resp_r10()
    {
      set(types::mbms_count_resp_r10);
      return c.get<mbms_count_resp_r10_s>();
    }
    inter_freq_rstd_meas_ind_r10_s& set_inter_freq_rstd_meas_ind_r10()
    {
      set(types::inter_freq_rstd_meas_ind_r10);
      return c.get<inter_freq_rstd_meas_ind_r10_s>();
    }

  private:
    types type_;
    choice_buffer_t<MAX16(sizeof(counter_check_resp_s),
                          sizeof(csfb_params_request_cdma2000_s),
                          sizeof(inter_freq_rstd_meas_ind_r10_s),
                          sizeof(mbms_count_resp_r10_s),
                          sizeof(meas_report_s),
                          sizeof(proximity_ind_r9_s),
                          sizeof(rn_recfg_complete_r10_s),
                          sizeof(rrc_conn_recfg_complete_s),
                          sizeof(rrc_conn_reest_complete_s),
                          sizeof(rrc_conn_setup_complete_s),
                          sizeof(security_mode_complete_s),
                          sizeof(security_mode_fail_s),
                          sizeof(ue_cap_info_s),
                          sizeof(ue_info_resp_r9_s),
                          sizeof(ul_ho_prep_transfer_s),
                          sizeof(ul_info_transfer_s))>
        c;

    void destroy_();
  };
  struct msg_class_ext_c_ {
    struct c2_c_ {
      struct types_opts {
        enum options {
          ue_assist_info_r11,
          in_dev_coex_ind_r11,
          mbms_interest_ind_r11,
          scg_fail_info_r12,
          sidelink_ue_info_r12,
          wlan_conn_status_report_r13,
          rrc_conn_resume_complete_r13,
          ul_info_transfer_mrdc_r15,
          scg_fail_info_nr_r15,
          meas_report_app_layer_r15,
          fail_info_r15,
          spare5,
          spare4,
          spare3,
          spare2,
          spare1,
          nulltype
        } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c2_c_() = default;
      c2_c_(const c2_c_& other);
      c2_c_& operator=(const c2_c_& other);
      ~c2_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ueassist_info_r11_s& ue_assist_info_r11()
      {
        assert_choice_type("ueAssistanceInformation-r11", type_.to_string(), "c2");
        return c.get<ueassist_info_r11_s>();
      }
      in_dev_coex_ind_r11_s& in_dev_coex_ind_r11()
      {
        assert_choice_type("inDeviceCoexIndication-r11", type_.to_string(), "c2");
        return c.get<in_dev_coex_ind_r11_s>();
      }
      mbms_interest_ind_r11_s& mbms_interest_ind_r11()
      {
        assert_choice_type("mbmsInterestIndication-r11", type_.to_string(), "c2");
        return c.get<mbms_interest_ind_r11_s>();
      }
      scg_fail_info_r12_s& scg_fail_info_r12()
      {
        assert_choice_type("scgFailureInformation-r12", type_.to_string(), "c2");
        return c.get<scg_fail_info_r12_s>();
      }
      sidelink_ue_info_r12_s& sidelink_ue_info_r12()
      {
        assert_choice_type("sidelinkUEInformation-r12", type_.to_string(), "c2");
        return c.get<sidelink_ue_info_r12_s>();
      }
      wlan_conn_status_report_r13_s& wlan_conn_status_report_r13()
      {
        assert_choice_type("wlanConnectionStatusReport-r13", type_.to_string(), "c2");
        return c.get<wlan_conn_status_report_r13_s>();
      }
      rrc_conn_resume_complete_r13_s& rrc_conn_resume_complete_r13()
      {
        assert_choice_type("rrcConnectionResumeComplete-r13", type_.to_string(), "c2");
        return c.get<rrc_conn_resume_complete_r13_s>();
      }
      ul_info_transfer_mrdc_r15_s& ul_info_transfer_mrdc_r15()
      {
        assert_choice_type("ulInformationTransferMRDC-r15", type_.to_string(), "c2");
        return c.get<ul_info_transfer_mrdc_r15_s>();
      }
      scg_fail_info_nr_r15_s& scg_fail_info_nr_r15()
      {
        assert_choice_type("scgFailureInformationNR-r15", type_.to_string(), "c2");
        return c.get<scg_fail_info_nr_r15_s>();
      }
      meas_report_app_layer_r15_s& meas_report_app_layer_r15()
      {
        assert_choice_type("measReportAppLayer-r15", type_.to_string(), "c2");
        return c.get<meas_report_app_layer_r15_s>();
      }
      fail_info_r15_s& fail_info_r15()
      {
        assert_choice_type("failureInformation-r15", type_.to_string(), "c2");
        return c.get<fail_info_r15_s>();
      }
      const ueassist_info_r11_s& ue_assist_info_r11() const
      {
        assert_choice_type("ueAssistanceInformation-r11", type_.to_string(), "c2");
        return c.get<ueassist_info_r11_s>();
      }
      const in_dev_coex_ind_r11_s& in_dev_coex_ind_r11() const
      {
        assert_choice_type("inDeviceCoexIndication-r11", type_.to_string(), "c2");
        return c.get<in_dev_coex_ind_r11_s>();
      }
      const mbms_interest_ind_r11_s& mbms_interest_ind_r11() const
      {
        assert_choice_type("mbmsInterestIndication-r11", type_.to_string(), "c2");
        return c.get<mbms_interest_ind_r11_s>();
      }
      const scg_fail_info_r12_s& scg_fail_info_r12() const
      {
        assert_choice_type("scgFailureInformation-r12", type_.to_string(), "c2");
        return c.get<scg_fail_info_r12_s>();
      }
      const sidelink_ue_info_r12_s& sidelink_ue_info_r12() const
      {
        assert_choice_type("sidelinkUEInformation-r12", type_.to_string(), "c2");
        return c.get<sidelink_ue_info_r12_s>();
      }
      const wlan_conn_status_report_r13_s& wlan_conn_status_report_r13() const
      {
        assert_choice_type("wlanConnectionStatusReport-r13", type_.to_string(), "c2");
        return c.get<wlan_conn_status_report_r13_s>();
      }
      const rrc_conn_resume_complete_r13_s& rrc_conn_resume_complete_r13() const
      {
        assert_choice_type("rrcConnectionResumeComplete-r13", type_.to_string(), "c2");
        return c.get<rrc_conn_resume_complete_r13_s>();
      }
      const ul_info_transfer_mrdc_r15_s& ul_info_transfer_mrdc_r15() const
      {
        assert_choice_type("ulInformationTransferMRDC-r15", type_.to_string(), "c2");
        return c.get<ul_info_transfer_mrdc_r15_s>();
      }
      const scg_fail_info_nr_r15_s& scg_fail_info_nr_r15() const
      {
        assert_choice_type("scgFailureInformationNR-r15", type_.to_string(), "c2");
        return c.get<scg_fail_info_nr_r15_s>();
      }
      const meas_report_app_layer_r15_s& meas_report_app_layer_r15() const
      {
        assert_choice_type("measReportAppLayer-r15", type_.to_string(), "c2");
        return c.get<meas_report_app_layer_r15_s>();
      }
      const fail_info_r15_s& fail_info_r15() const
      {
        assert_choice_type("failureInformation-r15", type_.to_string(), "c2");
        return c.get<fail_info_r15_s>();
      }
      ueassist_info_r11_s& set_ue_assist_info_r11()
      {
        set(types::ue_assist_info_r11);
        return c.get<ueassist_info_r11_s>();
      }
      in_dev_coex_ind_r11_s& set_in_dev_coex_ind_r11()
      {
        set(types::in_dev_coex_ind_r11);
        return c.get<in_dev_coex_ind_r11_s>();
      }
      mbms_interest_ind_r11_s& set_mbms_interest_ind_r11()
      {
        set(types::mbms_interest_ind_r11);
        return c.get<mbms_interest_ind_r11_s>();
      }
      scg_fail_info_r12_s& set_scg_fail_info_r12()
      {
        set(types::scg_fail_info_r12);
        return c.get<scg_fail_info_r12_s>();
      }
      sidelink_ue_info_r12_s& set_sidelink_ue_info_r12()
      {
        set(types::sidelink_ue_info_r12);
        return c.get<sidelink_ue_info_r12_s>();
      }
      wlan_conn_status_report_r13_s& set_wlan_conn_status_report_r13()
      {
        set(types::wlan_conn_status_report_r13);
        return c.get<wlan_conn_status_report_r13_s>();
      }
      rrc_conn_resume_complete_r13_s& set_rrc_conn_resume_complete_r13()
      {
        set(types::rrc_conn_resume_complete_r13);
        return c.get<rrc_conn_resume_complete_r13_s>();
      }
      ul_info_transfer_mrdc_r15_s& set_ul_info_transfer_mrdc_r15()
      {
        set(types::ul_info_transfer_mrdc_r15);
        return c.get<ul_info_transfer_mrdc_r15_s>();
      }
      scg_fail_info_nr_r15_s& set_scg_fail_info_nr_r15()
      {
        set(types::scg_fail_info_nr_r15);
        return c.get<scg_fail_info_nr_r15_s>();
      }
      meas_report_app_layer_r15_s& set_meas_report_app_layer_r15()
      {
        set(types::meas_report_app_layer_r15);
        return c.get<meas_report_app_layer_r15_s>();
      }
      fail_info_r15_s& set_fail_info_r15()
      {
        set(types::fail_info_r15);
        return c.get<fail_info_r15_s>();
      }

    private:
      types type_;
      choice_buffer_t<MAX16(sizeof(fail_info_r15_s),
                            sizeof(in_dev_coex_ind_r11_s),
                            sizeof(mbms_interest_ind_r11_s),
                            sizeof(meas_report_app_layer_r15_s),
                            sizeof(rrc_conn_resume_complete_r13_s),
                            sizeof(scg_fail_info_nr_r15_s),
                            sizeof(scg_fail_info_r12_s),
                            sizeof(sidelink_ue_info_r12_s),
                            sizeof(ueassist_info_r11_s),
                            sizeof(ul_info_transfer_mrdc_r15_s),
                            sizeof(wlan_conn_status_report_r13_s),
                            0,
                            0,
                            0,
                            0,
                            0)>
          c;

      void destroy_();
    };
    struct types_opts {
      enum options { c2, msg_class_ext_future_r11, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    msg_class_ext_c_() = default;
    msg_class_ext_c_(const msg_class_ext_c_& other);
    msg_class_ext_c_& operator=(const msg_class_ext_c_& other);
    ~msg_class_ext_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c2_c_& c2()
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    const c2_c_& c2() const
    {
      assert_choice_type("c2", type_.to_string(), "messageClassExtension");
      return c.get<c2_c_>();
    }
    c2_c_& set_c2()
    {
      set(types::c2);
      return c.get<c2_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c2_c_)> c;

    void destroy_();
  };
  struct types_opts {
    enum options { c1, msg_class_ext, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ul_dcch_msg_type_c() = default;
  ul_dcch_msg_type_c(const ul_dcch_msg_type_c& other);
  ul_dcch_msg_type_c& operator=(const ul_dcch_msg_type_c& other);
  ~ul_dcch_msg_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  c1_c_& c1()
  {
    assert_choice_type("c1", type_.to_string(), "UL-DCCH-MessageType");
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& msg_class_ext()
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "UL-DCCH-MessageType");
    return c.get<msg_class_ext_c_>();
  }
  const c1_c_& c1() const
  {
    assert_choice_type("c1", type_.to_string(), "UL-DCCH-MessageType");
    return c.get<c1_c_>();
  }
  const msg_class_ext_c_& msg_class_ext() const
  {
    assert_choice_type("messageClassExtension", type_.to_string(), "UL-DCCH-MessageType");
    return c.get<msg_class_ext_c_>();
  }
  c1_c_& set_c1()
  {
    set(types::c1);
    return c.get<c1_c_>();
  }
  msg_class_ext_c_& set_msg_class_ext()
  {
    set(types::msg_class_ext);
    return c.get<msg_class_ext_c_>();
  }

private:
  types                                                          type_;
  choice_buffer_t<MAX2(sizeof(c1_c_), sizeof(msg_class_ext_c_))> c;

  void destroy_();
};

// UL-DCCH-Message ::= SEQUENCE
struct ul_dcch_msg_s {
  // member variables
  ul_dcch_msg_type_c msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqBandInfo ::= SEQUENCE
struct inter_freq_band_info_s {
  // member variables
  bool inter_freq_need_for_gaps = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterRAT-BandInfo ::= SEQUENCE
struct inter_rat_band_info_s {
  // member variables
  bool inter_rat_need_for_gaps = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InterFreqBandList ::= SEQUENCE (SIZE (1..maxBands)) OF InterFreqBandInfo
typedef dyn_array<inter_freq_band_info_s> inter_freq_band_list_l;

// InterRAT-BandList ::= SEQUENCE (SIZE (1..maxBands)) OF InterRAT-BandInfo
typedef dyn_array<inter_rat_band_info_s> inter_rat_band_list_l;

// BandInfoEUTRA ::= SEQUENCE
struct band_info_eutra_s {
  // member variables
  bool                   inter_rat_band_list_present = false;
  inter_freq_band_list_l inter_freq_band_list;
  inter_rat_band_list_l  inter_rat_band_list;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationListEUTRA-r10 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandInfoEUTRA
typedef dyn_array<band_info_eutra_s> band_combination_list_eutra_r10_l;

// MIMO-CapabilityDL-r10 ::= ENUMERATED
struct mimo_cap_dl_r10_opts {
  enum options { two_layers, four_layers, eight_layers, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<mimo_cap_dl_r10_opts> mimo_cap_dl_r10_e;

// MIMO-CapabilityUL-r10 ::= ENUMERATED
struct mimo_cap_ul_r10_opts {
  enum options { two_layers, four_layers, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<mimo_cap_ul_r10_opts> mimo_cap_ul_r10_e;

// CA-MIMO-ParametersDL-r10 ::= SEQUENCE
struct ca_mimo_params_dl_r10_s {
  // member variables
  bool              supported_mimo_cap_dl_r10_present = false;
  ca_bw_class_r10_e ca_bw_class_dl_r10;
  mimo_cap_dl_r10_e supported_mimo_cap_dl_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CA-MIMO-ParametersUL-r10 ::= SEQUENCE
struct ca_mimo_params_ul_r10_s {
  // member variables
  bool              supported_mimo_cap_ul_r10_present = false;
  ca_bw_class_r10_e ca_bw_class_ul_r10;
  mimo_cap_ul_r10_e supported_mimo_cap_ul_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParametersDL-r10 ::= SEQUENCE (SIZE (1..maxBandwidthClass-r10)) OF CA-MIMO-ParametersDL-r10
typedef dyn_array<ca_mimo_params_dl_r10_s> band_params_dl_r10_l;

// BandParametersUL-r10 ::= SEQUENCE (SIZE (1..maxBandwidthClass-r10)) OF CA-MIMO-ParametersUL-r10
typedef dyn_array<ca_mimo_params_ul_r10_s> band_params_ul_r10_l;

// BandParameters-r10 ::= SEQUENCE
struct band_params_r10_s {
  // member variables
  bool                 band_params_ul_r10_present = false;
  bool                 band_params_dl_r10_present = false;
  uint8_t              band_eutra_r10             = 1;
  band_params_ul_r10_l band_params_ul_r10;
  band_params_dl_r10_l band_params_dl_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-r10 ::= SEQUENCE (SIZE (1..maxSimultaneousBands-r10)) OF BandParameters-r10
typedef dyn_array<band_params_r10_s> band_combination_params_r10_l;

// BandParameters-r11 ::= SEQUENCE
struct band_params_r11_s {
  struct supported_csi_proc_r11_opts {
    enum options { n1, n3, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<supported_csi_proc_r11_opts> supported_csi_proc_r11_e_;

  // member variables
  bool                      band_params_ul_r11_present     = false;
  bool                      band_params_dl_r11_present     = false;
  bool                      supported_csi_proc_r11_present = false;
  uint16_t                  band_eutra_r11                 = 1;
  band_params_ul_r10_l      band_params_ul_r11;
  band_params_dl_r10_l      band_params_dl_r11;
  supported_csi_proc_r11_e_ supported_csi_proc_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-r11 ::= SEQUENCE
struct band_combination_params_r11_s {
  typedef dyn_array<band_params_r11_s> band_param_list_r11_l_;

  // member variables
  bool                   ext                                      = false;
  bool                   supported_bw_combination_set_r11_present = false;
  bool                   multiple_timing_advance_r11_present      = false;
  bool                   simul_rx_tx_r11_present                  = false;
  band_param_list_r11_l_ band_param_list_r11;
  dyn_bitstring          supported_bw_combination_set_r11;
  band_info_eutra_s      band_info_eutra_r11;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IntraBandContiguousCC-Info-r12 ::= SEQUENCE
struct intra_band_contiguous_cc_info_r12_s {
  struct supported_csi_proc_r12_opts {
    enum options { n1, n3, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<supported_csi_proc_r12_opts> supported_csi_proc_r12_e_;

  // member variables
  bool                      four_layer_tm3_tm4_per_cc_r12_present = false;
  bool                      supported_mimo_cap_dl_r12_present     = false;
  bool                      supported_csi_proc_r12_present        = false;
  mimo_cap_dl_r10_e         supported_mimo_cap_dl_r12;
  supported_csi_proc_r12_e_ supported_csi_proc_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CA-MIMO-ParametersDL-r13 ::= SEQUENCE
struct ca_mimo_params_dl_r13_s {
  typedef dyn_array<intra_band_contiguous_cc_info_r12_s> intra_band_contiguous_cc_info_list_r13_l_;

  // member variables
  bool                                      supported_mimo_cap_dl_r13_present = false;
  bool                                      four_layer_tm3_tm4_r13_present    = false;
  ca_bw_class_r10_e                         ca_bw_class_dl_r13;
  mimo_cap_dl_r10_e                         supported_mimo_cap_dl_r13;
  intra_band_contiguous_cc_info_list_r13_l_ intra_band_contiguous_cc_info_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParametersDL-r13 ::= CA-MIMO-ParametersDL-r13
typedef ca_mimo_params_dl_r13_s band_params_dl_r13_s;

// BandParametersUL-r13 ::= CA-MIMO-ParametersUL-r10
typedef ca_mimo_params_ul_r10_s band_params_ul_r13_s;

// BandParameters-r13 ::= SEQUENCE
struct band_params_r13_s {
  struct supported_csi_proc_r13_opts {
    enum options { n1, n3, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<supported_csi_proc_r13_opts> supported_csi_proc_r13_e_;

  // member variables
  bool                      band_params_ul_r13_present     = false;
  bool                      band_params_dl_r13_present     = false;
  bool                      supported_csi_proc_r13_present = false;
  uint16_t                  band_eutra_r13                 = 1;
  band_params_ul_r13_s      band_params_ul_r13;
  band_params_dl_r13_s      band_params_dl_r13;
  supported_csi_proc_r13_e_ supported_csi_proc_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-r13 ::= SEQUENCE
struct band_combination_params_r13_s {
  typedef dyn_array<band_params_r13_s> band_param_list_r13_l_;
  struct dc_support_r13_s_ {
    struct supported_cell_grouping_r13_c_ {
      struct types_opts {
        enum options { three_entries_r13, four_entries_r13, five_entries_r13, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      supported_cell_grouping_r13_c_() = default;
      supported_cell_grouping_r13_c_(const supported_cell_grouping_r13_c_& other);
      supported_cell_grouping_r13_c_& operator=(const supported_cell_grouping_r13_c_& other);
      ~supported_cell_grouping_r13_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      fixed_bitstring<3>& three_entries_r13()
      {
        assert_choice_type("threeEntries-r13", type_.to_string(), "supportedCellGrouping-r13");
        return c.get<fixed_bitstring<3> >();
      }
      fixed_bitstring<7>& four_entries_r13()
      {
        assert_choice_type("fourEntries-r13", type_.to_string(), "supportedCellGrouping-r13");
        return c.get<fixed_bitstring<7> >();
      }
      fixed_bitstring<15>& five_entries_r13()
      {
        assert_choice_type("fiveEntries-r13", type_.to_string(), "supportedCellGrouping-r13");
        return c.get<fixed_bitstring<15> >();
      }
      const fixed_bitstring<3>& three_entries_r13() const
      {
        assert_choice_type("threeEntries-r13", type_.to_string(), "supportedCellGrouping-r13");
        return c.get<fixed_bitstring<3> >();
      }
      const fixed_bitstring<7>& four_entries_r13() const
      {
        assert_choice_type("fourEntries-r13", type_.to_string(), "supportedCellGrouping-r13");
        return c.get<fixed_bitstring<7> >();
      }
      const fixed_bitstring<15>& five_entries_r13() const
      {
        assert_choice_type("fiveEntries-r13", type_.to_string(), "supportedCellGrouping-r13");
        return c.get<fixed_bitstring<15> >();
      }
      fixed_bitstring<3>& set_three_entries_r13()
      {
        set(types::three_entries_r13);
        return c.get<fixed_bitstring<3> >();
      }
      fixed_bitstring<7>& set_four_entries_r13()
      {
        set(types::four_entries_r13);
        return c.get<fixed_bitstring<7> >();
      }
      fixed_bitstring<15>& set_five_entries_r13()
      {
        set(types::five_entries_r13);
        return c.get<fixed_bitstring<15> >();
      }

    private:
      types                                        type_;
      choice_buffer_t<sizeof(fixed_bitstring<15>)> c;

      void destroy_();
    };

    // member variables
    bool                           async_r13_present                   = false;
    bool                           supported_cell_grouping_r13_present = false;
    supported_cell_grouping_r13_c_ supported_cell_grouping_r13;
  };

  // member variables
  bool                   different_fallback_supported_r13_present  = false;
  bool                   supported_bw_combination_set_r13_present  = false;
  bool                   multiple_timing_advance_r13_present       = false;
  bool                   simul_rx_tx_r13_present                   = false;
  bool                   dc_support_r13_present                    = false;
  bool                   supported_naics_minus2_crs_ap_r13_present = false;
  bool                   comm_supported_bands_per_bc_r13_present   = false;
  band_param_list_r13_l_ band_param_list_r13;
  dyn_bitstring          supported_bw_combination_set_r13;
  band_info_eutra_s      band_info_eutra_r13;
  dc_support_r13_s_      dc_support_r13;
  dyn_bitstring          supported_naics_minus2_crs_ap_r13;
  dyn_bitstring          comm_supported_bands_per_bc_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1090 ::= SEQUENCE
struct band_params_v1090_s {
  // member variables
  bool     ext                      = false;
  bool     band_eutra_v1090_present = false;
  uint16_t band_eutra_v1090         = 65;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1090 ::= SEQUENCE (SIZE (1..maxSimultaneousBands-r10)) OF BandParameters-v1090
typedef dyn_array<band_params_v1090_s> band_combination_params_v1090_l;

// CA-MIMO-ParametersDL-v10i0 ::= SEQUENCE
struct ca_mimo_params_dl_v10i0_s {
  // member variables
  bool four_layer_tm3_tm4_r10_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v10i0 ::= SEQUENCE
struct band_params_v10i0_s {
  typedef dyn_array<ca_mimo_params_dl_v10i0_s> band_params_dl_v10i0_l_;

  // member variables
  band_params_dl_v10i0_l_ band_params_dl_v10i0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v10i0 ::= SEQUENCE
struct band_combination_params_v10i0_s {
  typedef dyn_array<band_params_v10i0_s> band_param_list_v10i0_l_;

  // member variables
  bool                     band_param_list_v10i0_present = false;
  band_param_list_v10i0_l_ band_param_list_v10i0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1130 ::= SEQUENCE
struct band_params_v1130_s {
  struct supported_csi_proc_r11_opts {
    enum options { n1, n3, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<supported_csi_proc_r11_opts> supported_csi_proc_r11_e_;

  // member variables
  supported_csi_proc_r11_e_ supported_csi_proc_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1130 ::= SEQUENCE
struct band_combination_params_v1130_s {
  typedef dyn_array<band_params_v1130_s> band_param_list_r11_l_;

  // member variables
  bool                   ext                                 = false;
  bool                   multiple_timing_advance_r11_present = false;
  bool                   simul_rx_tx_r11_present             = false;
  bool                   band_param_list_r11_present         = false;
  band_param_list_r11_l_ band_param_list_r11;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1250 ::= SEQUENCE
struct band_combination_params_v1250_s {
  struct dc_support_r12_s_ {
    struct supported_cell_grouping_r12_c_ {
      struct types_opts {
        enum options { three_entries_r12, four_entries_r12, five_entries_r12, nulltype } value;
        typedef uint8_t number_type;

        std::string to_string() const;
        uint8_t     to_number() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      supported_cell_grouping_r12_c_() = default;
      supported_cell_grouping_r12_c_(const supported_cell_grouping_r12_c_& other);
      supported_cell_grouping_r12_c_& operator=(const supported_cell_grouping_r12_c_& other);
      ~supported_cell_grouping_r12_c_() { destroy_(); }
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      fixed_bitstring<3>& three_entries_r12()
      {
        assert_choice_type("threeEntries-r12", type_.to_string(), "supportedCellGrouping-r12");
        return c.get<fixed_bitstring<3> >();
      }
      fixed_bitstring<7>& four_entries_r12()
      {
        assert_choice_type("fourEntries-r12", type_.to_string(), "supportedCellGrouping-r12");
        return c.get<fixed_bitstring<7> >();
      }
      fixed_bitstring<15>& five_entries_r12()
      {
        assert_choice_type("fiveEntries-r12", type_.to_string(), "supportedCellGrouping-r12");
        return c.get<fixed_bitstring<15> >();
      }
      const fixed_bitstring<3>& three_entries_r12() const
      {
        assert_choice_type("threeEntries-r12", type_.to_string(), "supportedCellGrouping-r12");
        return c.get<fixed_bitstring<3> >();
      }
      const fixed_bitstring<7>& four_entries_r12() const
      {
        assert_choice_type("fourEntries-r12", type_.to_string(), "supportedCellGrouping-r12");
        return c.get<fixed_bitstring<7> >();
      }
      const fixed_bitstring<15>& five_entries_r12() const
      {
        assert_choice_type("fiveEntries-r12", type_.to_string(), "supportedCellGrouping-r12");
        return c.get<fixed_bitstring<15> >();
      }
      fixed_bitstring<3>& set_three_entries_r12()
      {
        set(types::three_entries_r12);
        return c.get<fixed_bitstring<3> >();
      }
      fixed_bitstring<7>& set_four_entries_r12()
      {
        set(types::four_entries_r12);
        return c.get<fixed_bitstring<7> >();
      }
      fixed_bitstring<15>& set_five_entries_r12()
      {
        set(types::five_entries_r12);
        return c.get<fixed_bitstring<15> >();
      }

    private:
      types                                        type_;
      choice_buffer_t<sizeof(fixed_bitstring<15>)> c;

      void destroy_();
    };

    // member variables
    bool                           async_r12_present                   = false;
    bool                           supported_cell_grouping_r12_present = false;
    supported_cell_grouping_r12_c_ supported_cell_grouping_r12;
  };

  // member variables
  bool              ext                                       = false;
  bool              dc_support_r12_present                    = false;
  bool              supported_naics_minus2_crs_ap_r12_present = false;
  bool              comm_supported_bands_per_bc_r12_present   = false;
  dc_support_r12_s_ dc_support_r12;
  dyn_bitstring     supported_naics_minus2_crs_ap_r12;
  dyn_bitstring     comm_supported_bands_per_bc_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CA-MIMO-ParametersDL-v1270 ::= SEQUENCE
struct ca_mimo_params_dl_v1270_s {
  typedef dyn_array<intra_band_contiguous_cc_info_r12_s> intra_band_contiguous_cc_info_list_r12_l_;

  // member variables
  intra_band_contiguous_cc_info_list_r12_l_ intra_band_contiguous_cc_info_list_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1270 ::= SEQUENCE
struct band_params_v1270_s {
  typedef dyn_array<ca_mimo_params_dl_v1270_s> band_params_dl_v1270_l_;

  // member variables
  band_params_dl_v1270_l_ band_params_dl_v1270;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1270 ::= SEQUENCE
struct band_combination_params_v1270_s {
  typedef dyn_array<band_params_v1270_s> band_param_list_v1270_l_;

  // member variables
  bool                     band_param_list_v1270_present = false;
  band_param_list_v1270_l_ band_param_list_v1270;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-BeamformedCapabilities-r13 ::= SEQUENCE
struct mimo_beamformed_capabilities_r13_s {
  // member variables
  bool          n_max_list_r13_present = false;
  uint8_t       k_max_r13              = 1;
  dyn_bitstring n_max_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-BeamformedCapabilityList-r13 ::= SEQUENCE (SIZE (1..maxCSI-Proc-r11)) OF MIMO-BeamformedCapabilities-r13
typedef dyn_array<mimo_beamformed_capabilities_r13_s> mimo_beamformed_cap_list_r13_l;

// MIMO-NonPrecodedCapabilities-r13 ::= SEQUENCE
struct mimo_non_precoded_capabilities_r13_s {
  // member variables
  bool cfg1_r13_present = false;
  bool cfg2_r13_present = false;
  bool cfg3_r13_present = false;
  bool cfg4_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBCPerTM-r13 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_per_tm_r13_s {
  // member variables
  bool                                 non_precoded_r13_present = false;
  bool                                 beamformed_r13_present   = false;
  bool                                 dmrs_enhance_r13_present = false;
  mimo_non_precoded_capabilities_r13_s non_precoded_r13;
  mimo_beamformed_cap_list_r13_l       beamformed_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBC-r13 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_r13_s {
  // member variables
  bool                                  params_tm9_r13_present  = false;
  bool                                  params_tm10_r13_present = false;
  mimo_ca_params_per_bo_bc_per_tm_r13_s params_tm9_r13;
  mimo_ca_params_per_bo_bc_per_tm_r13_s params_tm10_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1320 ::= SEQUENCE
struct band_params_v1320_s {
  // member variables
  mimo_ca_params_per_bo_bc_r13_s band_params_dl_v1320;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1320 ::= SEQUENCE
struct band_combination_params_v1320_s {
  typedef dyn_array<band_params_v1320_s> band_param_list_v1320_l_;

  // member variables
  bool                     band_param_list_v1320_present         = false;
  bool                     add_rx_tx_performance_req_r13_present = false;
  band_param_list_v1320_l_ band_param_list_v1320;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1380 ::= SEQUENCE
struct band_params_v1380_s {
  // member variables
  bool    tx_ant_switch_dl_r13_present = false;
  bool    tx_ant_switch_ul_r13_present = false;
  uint8_t tx_ant_switch_dl_r13         = 1;
  uint8_t tx_ant_switch_ul_r13         = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1380 ::= SEQUENCE
struct band_combination_params_v1380_s {
  typedef dyn_array<band_params_v1380_s> band_param_list_v1380_l_;

  // member variables
  bool                     band_param_list_v1380_present = false;
  band_param_list_v1380_l_ band_param_list_v1380;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBCPerTM-v1430 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_per_tm_v1430_s {
  // member variables
  bool csi_report_np_r14_present       = false;
  bool csi_report_advanced_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBC-v1430 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_v1430_s {
  // member variables
  bool                                    params_tm9_v1430_present  = false;
  bool                                    params_tm10_v1430_present = false;
  mimo_ca_params_per_bo_bc_per_tm_v1430_s params_tm9_v1430;
  mimo_ca_params_per_bo_bc_per_tm_v1430_s params_tm10_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RetuningTimeInfo-r14 ::= SEQUENCE
struct retuning_time_info_r14_s {
  struct retuning_info_s_ {
    struct rf_retuning_time_dl_r14_opts {
      enum options {
        n0,
        n0dot5,
        n1,
        n1dot5,
        n2,
        n2dot5,
        n3,
        n3dot5,
        n4,
        n4dot5,
        n5,
        n5dot5,
        n6,
        n6dot5,
        n7,
        spare1,
        nulltype
      } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<rf_retuning_time_dl_r14_opts> rf_retuning_time_dl_r14_e_;
    struct rf_retuning_time_ul_r14_opts {
      enum options {
        n0,
        n0dot5,
        n1,
        n1dot5,
        n2,
        n2dot5,
        n3,
        n3dot5,
        n4,
        n4dot5,
        n5,
        n5dot5,
        n6,
        n6dot5,
        n7,
        spare1,
        nulltype
      } value;
      typedef float number_type;

      std::string to_string() const;
      float       to_number() const;
      std::string to_number_string() const;
    };
    typedef enumerated<rf_retuning_time_ul_r14_opts> rf_retuning_time_ul_r14_e_;

    // member variables
    bool                       rf_retuning_time_dl_r14_present = false;
    bool                       rf_retuning_time_ul_r14_present = false;
    rf_retuning_time_dl_r14_e_ rf_retuning_time_dl_r14;
    rf_retuning_time_ul_r14_e_ rf_retuning_time_ul_r14;
  };

  // member variables
  retuning_info_s_ retuning_info;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-256QAM-perCC-Info-r14 ::= SEQUENCE
struct ul_minus256_qam_per_cc_info_r14_s {
  // member variables
  bool ul_minus256_qam_per_cc_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1430 ::= SEQUENCE
struct band_params_v1430_s {
  typedef dyn_array<ul_minus256_qam_per_cc_info_r14_s> ul_minus256_qam_per_cc_info_list_r14_l_;
  typedef dyn_array<retuning_time_info_r14_s>          retuning_time_info_band_list_r14_l_;

  // member variables
  bool                                    band_params_dl_v1430_present                 = false;
  bool                                    ul_minus256_qam_r14_present                  = false;
  bool                                    ul_minus256_qam_per_cc_info_list_r14_present = false;
  bool                                    retuning_time_info_band_list_r14_present     = false;
  mimo_ca_params_per_bo_bc_v1430_s        band_params_dl_v1430;
  ul_minus256_qam_per_cc_info_list_r14_l_ ul_minus256_qam_per_cc_info_list_r14;
  retuning_time_info_band_list_r14_l_     retuning_time_info_band_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1430 ::= SEQUENCE
struct band_combination_params_v1430_s {
  typedef dyn_array<band_params_v1430_s> band_param_list_v1430_l_;

  // member variables
  bool                     band_param_list_v1430_present                      = false;
  bool                     v2x_supported_tx_band_comb_list_per_bc_r14_present = false;
  bool                     v2x_supported_rx_band_comb_list_per_bc_r14_present = false;
  band_param_list_v1430_l_ band_param_list_v1430;
  dyn_bitstring            v2x_supported_tx_band_comb_list_per_bc_r14;
  dyn_bitstring            v2x_supported_rx_band_comb_list_per_bc_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MUST-Parameters-r14 ::= SEQUENCE
struct must_params_r14_s {
  // member variables
  bool must_tm234_up_to2_tx_r14_present                     = false;
  bool must_tm89_up_to_one_interfering_layer_r14_present    = false;
  bool must_tm10_up_to_one_interfering_layer_r14_present    = false;
  bool must_tm89_up_to_three_interfering_layers_r14_present = false;
  bool must_tm10_up_to_three_interfering_layers_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1450 ::= SEQUENCE
struct band_params_v1450_s {
  // member variables
  bool              must_cap_per_band_r14_present = false;
  must_params_r14_s must_cap_per_band_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1450 ::= SEQUENCE
struct band_combination_params_v1450_s {
  typedef dyn_array<band_params_v1450_s> band_param_list_v1450_l_;

  // member variables
  bool                     band_param_list_v1450_present = false;
  band_param_list_v1450_l_ band_param_list_v1450;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBCPerTM-v1470 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_per_tm_v1470_s {
  struct csi_report_advanced_max_ports_r14_opts {
    enum options { n8, n12, n16, n20, n24, n28, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<csi_report_advanced_max_ports_r14_opts> csi_report_advanced_max_ports_r14_e_;

  // member variables
  bool                                 csi_report_advanced_max_ports_r14_present = false;
  csi_report_advanced_max_ports_r14_e_ csi_report_advanced_max_ports_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBC-v1470 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_v1470_s {
  // member variables
  mimo_ca_params_per_bo_bc_per_tm_v1470_s params_tm9_v1470;
  mimo_ca_params_per_bo_bc_per_tm_v1470_s params_tm10_v1470;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1470 ::= SEQUENCE
struct band_params_v1470_s {
  // member variables
  bool                             band_params_dl_v1470_present = false;
  mimo_ca_params_per_bo_bc_v1470_s band_params_dl_v1470;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1470 ::= SEQUENCE
struct band_combination_params_v1470_s {
  typedef dyn_array<band_params_v1470_s> band_param_list_v1470_l_;

  // member variables
  bool                     band_param_list_v1470_present = false;
  bool                     srs_max_simul_ccs_r14_present = false;
  band_param_list_v1470_l_ band_param_list_v1470;
  uint8_t                  srs_max_simul_ccs_r14 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-UL-CCs-r15 ::= SEQUENCE
struct dl_ul_ccs_r15_s {
  // member variables
  bool    max_num_dl_ccs_r15_present = false;
  bool    max_num_ul_ccs_r15_present = false;
  uint8_t max_num_dl_ccs_r15         = 1;
  uint8_t max_num_ul_ccs_r15         = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CA-MIMO-ParametersDL-r15 ::= SEQUENCE
struct ca_mimo_params_dl_r15_s {
  typedef dyn_array<intra_band_contiguous_cc_info_r12_s> intra_band_contiguous_cc_info_list_r15_l_;

  // member variables
  bool                                      supported_mimo_cap_dl_r15_present              = false;
  bool                                      four_layer_tm3_tm4_r15_present                 = false;
  bool                                      intra_band_contiguous_cc_info_list_r15_present = false;
  mimo_cap_dl_r10_e                         supported_mimo_cap_dl_r15;
  intra_band_contiguous_cc_info_list_r15_l_ intra_band_contiguous_cc_info_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CA-MIMO-ParametersUL-r15 ::= SEQUENCE
struct ca_mimo_params_ul_r15_s {
  // member variables
  bool              supported_mimo_cap_ul_r15_present = false;
  mimo_cap_ul_r10_e supported_mimo_cap_ul_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// STTI-SupportedCombinations-r15 ::= SEQUENCE
struct stti_supported_combinations_r15_s {
  typedef dyn_array<dl_ul_ccs_r15_s> combination_minus22_minus27_r15_l_;
  typedef dyn_array<dl_ul_ccs_r15_s> combination_minus77_minus22_r15_l_;
  typedef dyn_array<dl_ul_ccs_r15_s> combination_minus77_minus27_r15_l_;

  // member variables
  bool                               combination_minus22_r15_present         = false;
  bool                               combination_minus77_r15_present         = false;
  bool                               combination_minus27_r15_present         = false;
  bool                               combination_minus22_minus27_r15_present = false;
  bool                               combination_minus77_minus22_r15_present = false;
  bool                               combination_minus77_minus27_r15_present = false;
  dl_ul_ccs_r15_s                    combination_minus22_r15;
  dl_ul_ccs_r15_s                    combination_minus77_r15;
  dl_ul_ccs_r15_s                    combination_minus27_r15;
  combination_minus22_minus27_r15_l_ combination_minus22_minus27_r15;
  combination_minus77_minus22_r15_l_ combination_minus77_minus22_r15;
  combination_minus77_minus27_r15_l_ combination_minus77_minus27_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// STTI-SPT-BandParameters-r15 ::= SEQUENCE
struct stti_spt_band_params_r15_s {
  struct s_tti_supported_csi_proc_r15_opts {
    enum options { n1, n3, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<s_tti_supported_csi_proc_r15_opts> s_tti_supported_csi_proc_r15_e_;

  // member variables
  bool                              ext                                            = false;
  bool                              dl_minus1024_qam_slot_r15_present              = false;
  bool                              dl_minus1024_qam_subslot_ta_minus1_r15_present = false;
  bool                              dl_minus1024_qam_subslot_ta_minus2_r15_present = false;
  bool                              simul_tx_different_tx_dur_r15_present          = false;
  bool                              s_tti_ca_mimo_params_dl_r15_present            = false;
  bool                              s_tti_fd_mimo_coexistence_present              = false;
  bool                              s_tti_mimo_ca_params_per_bo_bcs_r15_present    = false;
  bool                              s_tti_mimo_ca_params_per_bo_bcs_v1530_present  = false;
  bool                              s_tti_supported_combinations_r15_present       = false;
  bool                              s_tti_supported_csi_proc_r15_present           = false;
  bool                              ul_minus256_qam_slot_r15_present               = false;
  bool                              ul_minus256_qam_subslot_r15_present            = false;
  ca_mimo_params_dl_r15_s           s_tti_ca_mimo_params_dl_r15;
  ca_mimo_params_ul_r15_s           s_tti_ca_mimo_params_ul_r15;
  mimo_ca_params_per_bo_bc_r13_s    s_tti_mimo_ca_params_per_bo_bcs_r15;
  mimo_ca_params_per_bo_bc_v1430_s  s_tti_mimo_ca_params_per_bo_bcs_v1530;
  stti_supported_combinations_r15_s s_tti_supported_combinations_r15;
  s_tti_supported_csi_proc_r15_e_   s_tti_supported_csi_proc_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParameters-v1530 ::= SEQUENCE
struct band_params_v1530_s {
  // member variables
  bool                       ue_tx_ant_sel_srs_minus1_t4_r_r15_present              = false;
  bool                       ue_tx_ant_sel_srs_minus2_t4_r_minus2_pairs_r15_present = false;
  bool                       ue_tx_ant_sel_srs_minus2_t4_r_minus3_pairs_r15_present = false;
  bool                       dl_minus1024_qam_r15_present                           = false;
  bool                       qcl_type_c_operation_r15_present                       = false;
  bool                       qcl_cri_based_csi_report_r15_present                   = false;
  bool                       stti_spt_band_params_r15_present                       = false;
  stti_spt_band_params_r15_s stti_spt_band_params_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SPT-Parameters-r15 ::= SEQUENCE
struct spt_params_r15_s {
  // member variables
  bool               frame_structure_type_spt_r15_present = false;
  bool               max_num_ccs_spt_r15_present          = false;
  fixed_bitstring<3> frame_structure_type_spt_r15;
  uint8_t            max_num_ccs_spt_r15 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1530 ::= SEQUENCE
struct band_combination_params_v1530_s {
  typedef dyn_array<band_params_v1530_s> band_param_list_v1530_l_;

  // member variables
  bool                     band_param_list_v1530_present = false;
  bool                     spt_params_r15_present        = false;
  band_param_list_v1530_l_ band_param_list_v1530;
  spt_params_r15_s         spt_params_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParametersExt-r10 ::= SEQUENCE
struct band_combination_params_ext_r10_s {
  // member variables
  bool          supported_bw_combination_set_r10_present = false;
  dyn_bitstring supported_bw_combination_set_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandListEUTRA ::= SEQUENCE (SIZE (1..maxBands)) OF BandInfoEUTRA
typedef dyn_array<band_info_eutra_s> band_list_eutra_l;

// V2X-BandwidthClass-r14 ::= ENUMERATED
struct v2x_bw_class_r14_opts {
  enum options { a, b, c, d, e, f, /*...*/ c1_v1530, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<v2x_bw_class_r14_opts, true, 1> v2x_bw_class_r14_e;

// V2X-BandwidthClassSL-r14 ::= SEQUENCE (SIZE (1..maxBandwidthClass-r10)) OF V2X-BandwidthClass-r14
typedef bounded_array<v2x_bw_class_r14_e, 16> v2x_bw_class_sl_r14_l;

// BandParametersRxSL-r14 ::= SEQUENCE
struct band_params_rx_sl_r14_s {
  // member variables
  bool                  v2x_high_reception_r14_present = false;
  v2x_bw_class_sl_r14_l v2x_bw_class_rx_sl_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandParametersTxSL-r14 ::= SEQUENCE
struct band_params_tx_sl_r14_s {
  // member variables
  bool                  v2x_e_nb_sched_r14_present = false;
  bool                  v2x_high_pwr_r14_present   = false;
  v2x_bw_class_sl_r14_l v2x_bw_class_tx_sl_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FeatureSetDL-PerCC-r15 ::= SEQUENCE
struct feature_set_dl_per_cc_r15_s {
  struct supported_csi_proc_r15_opts {
    enum options { n1, n3, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<supported_csi_proc_r15_opts> supported_csi_proc_r15_e_;

  // member variables
  bool                      four_layer_tm3_tm4_r15_present    = false;
  bool                      supported_mimo_cap_dl_r15_present = false;
  bool                      supported_csi_proc_r15_present    = false;
  mimo_cap_dl_r10_e         supported_mimo_cap_dl_r15;
  supported_csi_proc_r15_e_ supported_csi_proc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBCPerTM-r15 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_per_tm_r15_s {
  // member variables
  bool                                 non_precoded_r13_present        = false;
  bool                                 beamformed_r13_present          = false;
  bool                                 dmrs_enhance_r13_present        = false;
  bool                                 csi_report_np_r14_present       = false;
  bool                                 csi_report_advanced_r14_present = false;
  mimo_non_precoded_capabilities_r13_s non_precoded_r13;
  mimo_beamformed_cap_list_r13_l       beamformed_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-CA-ParametersPerBoBC-r15 ::= SEQUENCE
struct mimo_ca_params_per_bo_bc_r15_s {
  // member variables
  bool                                  params_tm9_r15_present  = false;
  bool                                  params_tm10_r15_present = false;
  mimo_ca_params_per_bo_bc_per_tm_r15_s params_tm9_r15;
  mimo_ca_params_per_bo_bc_per_tm_r15_s params_tm10_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FeatureSetDL-r15 ::= SEQUENCE
struct feature_set_dl_r15_s {
  typedef bounded_array<uint8_t, 32> feature_set_per_cc_list_dl_r15_l_;

  // member variables
  bool                              mimo_ca_params_per_bo_bc_r15_present = false;
  mimo_ca_params_per_bo_bc_r15_s    mimo_ca_params_per_bo_bc_r15;
  feature_set_per_cc_list_dl_r15_l_ feature_set_per_cc_list_dl_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FeatureSetUL-PerCC-r15 ::= SEQUENCE
struct feature_set_ul_per_cc_r15_s {
  // member variables
  bool              supported_mimo_cap_ul_r15_present = false;
  bool              ul_minus256_qam_r15_present       = false;
  mimo_cap_ul_r10_e supported_mimo_cap_ul_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FeatureSetUL-r15 ::= SEQUENCE
struct feature_set_ul_r15_s {
  typedef bounded_array<uint8_t, 32> feature_set_per_cc_list_ul_r15_l_;

  // member variables
  feature_set_per_cc_list_ul_r15_l_ feature_set_per_cc_list_ul_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FeatureSetsEUTRA-r15 ::= SEQUENCE
struct feature_sets_eutra_r15_s {
  typedef dyn_array<feature_set_dl_r15_s>        feature_sets_dl_r15_l_;
  typedef dyn_array<feature_set_dl_per_cc_r15_s> feature_sets_dl_per_cc_r15_l_;
  typedef dyn_array<feature_set_ul_r15_s>        feature_sets_ul_r15_l_;
  typedef dyn_array<feature_set_ul_per_cc_r15_s> feature_sets_ul_per_cc_r15_l_;

  // member variables
  bool                          ext                                = false;
  bool                          feature_sets_dl_r15_present        = false;
  bool                          feature_sets_dl_per_cc_r15_present = false;
  bool                          feature_sets_ul_r15_present        = false;
  bool                          feature_sets_ul_per_cc_r15_present = false;
  feature_sets_dl_r15_l_        feature_sets_dl_r15;
  feature_sets_dl_per_cc_r15_l_ feature_sets_dl_per_cc_r15;
  feature_sets_ul_r15_l_        feature_sets_ul_r15;
  feature_sets_ul_per_cc_r15_l_ feature_sets_ul_per_cc_r15;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqBandIndicatorListEUTRA-r12 ::= SEQUENCE (SIZE (1..maxBands)) OF INTEGER
typedef dyn_array<uint16_t> freq_band_ind_list_eutra_r12_l;

// SupportedBandList1XRTT ::= SEQUENCE (SIZE (1..maxCDMA-BandClass)) OF BandclassCDMA2000
typedef bounded_array<bandclass_cdma2000_e, 32> supported_band_list1_xrtt_l;

// IRAT-ParametersCDMA2000-1XRTT ::= SEQUENCE
struct irat_params_cdma2000_minus1_xrtt_s {
  struct tx_cfg1_xrtt_opts {
    enum options { single, dual, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<tx_cfg1_xrtt_opts> tx_cfg1_xrtt_e_;
  struct rx_cfg1_xrtt_opts {
    enum options { single, dual, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<rx_cfg1_xrtt_opts> rx_cfg1_xrtt_e_;

  // member variables
  supported_band_list1_xrtt_l supported_band_list1_xrtt;
  tx_cfg1_xrtt_e_             tx_cfg1_xrtt;
  rx_cfg1_xrtt_e_             rx_cfg1_xrtt;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandListHRPD ::= SEQUENCE (SIZE (1..maxCDMA-BandClass)) OF BandclassCDMA2000
typedef bounded_array<bandclass_cdma2000_e, 32> supported_band_list_hrpd_l;

// IRAT-ParametersCDMA2000-HRPD ::= SEQUENCE
struct irat_params_cdma2000_hrpd_s {
  struct tx_cfg_hrpd_opts {
    enum options { single, dual, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<tx_cfg_hrpd_opts> tx_cfg_hrpd_e_;
  struct rx_cfg_hrpd_opts {
    enum options { single, dual, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<rx_cfg_hrpd_opts> rx_cfg_hrpd_e_;

  // member variables
  supported_band_list_hrpd_l supported_band_list_hrpd;
  tx_cfg_hrpd_e_             tx_cfg_hrpd;
  rx_cfg_hrpd_e_             rx_cfg_hrpd;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandGERAN ::= ENUMERATED
struct supported_band_geran_opts {
  enum options {
    gsm450,
    gsm480,
    gsm710,
    gsm750,
    gsm810,
    gsm850,
    gsm900_p,
    gsm900_e,
    gsm900_r,
    gsm1800,
    gsm1900,
    spare5,
    spare4,
    spare3,
    spare2,
    spare1,
    // ...
    nulltype
  } value;

  std::string to_string() const;
};
typedef enumerated<supported_band_geran_opts, true> supported_band_geran_e;

// SupportedBandListGERAN ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandGERAN
typedef dyn_array<supported_band_geran_e> supported_band_list_geran_l;

// IRAT-ParametersGERAN ::= SEQUENCE
struct irat_params_geran_s {
  // member variables
  supported_band_list_geran_l supported_band_list_geran;
  bool                        inter_rat_ps_ho_to_geran = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandNR-r15 ::= SEQUENCE
struct supported_band_nr_r15_s {
  // member variables
  uint16_t band_nr_r15 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandListNR-r15 ::= SEQUENCE (SIZE (1..maxBandsNR-r15)) OF SupportedBandNR-r15
typedef dyn_array<supported_band_nr_r15_s> supported_band_list_nr_r15_l;

// IRAT-ParametersNR-r15 ::= SEQUENCE
struct irat_params_nr_r15_s {
  // member variables
  bool                         en_dc_r15_present                  = false;
  bool                         event_b2_r15_present               = false;
  bool                         supported_band_list_nr_r15_present = false;
  supported_band_list_nr_r15_l supported_band_list_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandUTRA-FDD ::= ENUMERATED
struct supported_band_utra_fdd_opts {
  enum options {
    band_i,
    band_ii,
    band_iii,
    band_iv,
    band_v,
    band_vi,
    band_vii,
    band_viii,
    band_ix,
    band_x,
    band_xi,
    band_xii,
    band_xiii,
    band_xiv,
    band_xv,
    band_xvi,
    // ...
    band_xvii_minus8a0,
    band_xviii_minus8a0,
    band_xix_minus8a0,
    band_xx_minus8a0,
    band_xxi_minus8a0,
    band_xxii_minus8a0,
    band_xxiii_minus8a0,
    band_xxiv_minus8a0,
    band_xxv_minus8a0,
    band_xxvi_minus8a0,
    band_xxvii_minus8a0,
    band_xxviii_minus8a0,
    band_xxix_minus8a0,
    band_xxx_minus8a0,
    band_xxxi_minus8a0,
    band_xxxii_minus8a0,
    nulltype
  } value;

  std::string to_string() const;
};
typedef enumerated<supported_band_utra_fdd_opts, true, 16> supported_band_utra_fdd_e;

// SupportedBandListUTRA-FDD ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandUTRA-FDD
typedef dyn_array<supported_band_utra_fdd_e> supported_band_list_utra_fdd_l;

// IRAT-ParametersUTRA-FDD ::= SEQUENCE
struct irat_params_utra_fdd_s {
  // member variables
  supported_band_list_utra_fdd_l supported_band_list_utra_fdd;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandUTRA-TDD128 ::= ENUMERATED
struct supported_band_utra_tdd128_opts {
  enum options { a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, /*...*/ nulltype } value;

  std::string to_string() const;
};
typedef enumerated<supported_band_utra_tdd128_opts, true> supported_band_utra_tdd128_e;

// SupportedBandListUTRA-TDD128 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandUTRA-TDD128
typedef dyn_array<supported_band_utra_tdd128_e> supported_band_list_utra_tdd128_l;

// IRAT-ParametersUTRA-TDD128 ::= SEQUENCE
struct irat_params_utra_tdd128_s {
  // member variables
  supported_band_list_utra_tdd128_l supported_band_list_utra_tdd128;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandUTRA-TDD384 ::= ENUMERATED
struct supported_band_utra_tdd384_opts {
  enum options { a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, /*...*/ nulltype } value;

  std::string to_string() const;
};
typedef enumerated<supported_band_utra_tdd384_opts, true> supported_band_utra_tdd384_e;

// SupportedBandListUTRA-TDD384 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandUTRA-TDD384
typedef dyn_array<supported_band_utra_tdd384_e> supported_band_list_utra_tdd384_l;

// IRAT-ParametersUTRA-TDD384 ::= SEQUENCE
struct irat_params_utra_tdd384_s {
  // member variables
  supported_band_list_utra_tdd384_l supported_band_list_utra_tdd384;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandUTRA-TDD768 ::= ENUMERATED
struct supported_band_utra_tdd768_opts {
  enum options { a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, /*...*/ nulltype } value;

  std::string to_string() const;
};
typedef enumerated<supported_band_utra_tdd768_opts, true> supported_band_utra_tdd768_e;

// SupportedBandListUTRA-TDD768 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandUTRA-TDD768
typedef dyn_array<supported_band_utra_tdd768_e> supported_band_list_utra_tdd768_l;

// IRAT-ParametersUTRA-TDD768 ::= SEQUENCE
struct irat_params_utra_tdd768_s {
  // member variables
  supported_band_list_utra_tdd768_l supported_band_list_utra_tdd768;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersWLAN-r13 ::= SEQUENCE
struct irat_params_wlan_r13_s {
  typedef bounded_array<wlan_band_ind_r13_e, 8> supported_band_list_wlan_r13_l_;

  // member variables
  bool                            supported_band_list_wlan_r13_present = false;
  supported_band_list_wlan_r13_l_ supported_band_list_wlan_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ProcessingTimelineSet-r15 ::= ENUMERATED
struct processing_timeline_set_r15_opts {
  enum options { set1, set2, nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<processing_timeline_set_r15_opts> processing_timeline_set_r15_e;

// SkipSubframeProcessing-r15 ::= SEQUENCE
struct skip_sf_processing_r15_s {
  // member variables
  bool    skip_processing_dl_slot_r15_present     = false;
  bool    skip_processing_dl_sub_slot_r15_present = false;
  bool    skip_processing_ul_slot_r15_present     = false;
  bool    skip_processing_ul_sub_slot_r15_present = false;
  uint8_t skip_processing_dl_slot_r15             = 0;
  uint8_t skip_processing_dl_sub_slot_r15         = 0;
  uint8_t skip_processing_ul_slot_r15             = 0;
  uint8_t skip_processing_ul_sub_slot_r15         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MAC-Parameters-v1530 ::= SEQUENCE
struct mac_params_v1530_s {
  typedef bounded_array<processing_timeline_set_r15_e, 3> min_proc_timeline_subslot_r15_l_;

  // member variables
  bool                             min_proc_timeline_subslot_r15_present = false;
  bool                             skip_sf_processing_r15_present        = false;
  bool                             early_data_up_r15_present             = false;
  bool                             dormant_scell_state_r15_present       = false;
  bool                             direct_scell_activation_r15_present   = false;
  bool                             direct_scell_hibernation_r15_present  = false;
  bool                             extended_lcid_dupl_r15_present        = false;
  bool                             sps_serving_cell_r15_present          = false;
  min_proc_timeline_subslot_r15_l_ min_proc_timeline_subslot_r15;
  skip_sf_processing_r15_s         skip_sf_processing_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-UE-BeamformedCapabilities-r13 ::= SEQUENCE
struct mimo_ue_beamformed_capabilities_r13_s {
  // member variables
  bool                           alt_codebook_r13_present = false;
  mimo_beamformed_cap_list_r13_l mimo_beamformed_capabilities_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-UE-ParametersPerTM-r13 ::= SEQUENCE
struct mimo_ue_params_per_tm_r13_s {
  // member variables
  bool                                  non_precoded_r13_present       = false;
  bool                                  beamformed_r13_present         = false;
  bool                                  ch_meas_restrict_r13_present   = false;
  bool                                  dmrs_enhance_r13_present       = false;
  bool                                  csi_rs_enhance_tdd_r13_present = false;
  mimo_non_precoded_capabilities_r13_s  non_precoded_r13;
  mimo_ue_beamformed_capabilities_r13_s beamformed_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-UE-Parameters-r13 ::= SEQUENCE
struct mimo_ue_params_r13_s {
  // member variables
  bool                        params_tm9_r13_present                 = false;
  bool                        params_tm10_r13_present                = false;
  bool                        srs_enhance_tdd_r13_present            = false;
  bool                        srs_enhance_r13_present                = false;
  bool                        interference_meas_restrict_r13_present = false;
  mimo_ue_params_per_tm_r13_s params_tm9_r13;
  mimo_ue_params_per_tm_r13_s params_tm10_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-UE-ParametersPerTM-v1430 ::= SEQUENCE
struct mimo_ue_params_per_tm_v1430_s {
  struct nzp_csi_rs_aperiodic_info_r14_s_ {
    struct n_max_res_r14_opts {
      enum options { ffs1, ffs2, ffs3, ffs4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<n_max_res_r14_opts> n_max_res_r14_e_;

    // member variables
    uint8_t          n_max_proc_r14 = 5;
    n_max_res_r14_e_ n_max_res_r14;
  };
  struct nzp_csi_rs_periodic_info_r14_s_ {
    struct n_max_res_r14_opts {
      enum options { ffs1, ffs2, ffs3, ffs4, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<n_max_res_r14_opts> n_max_res_r14_e_;

    // member variables
    n_max_res_r14_e_ n_max_res_r14;
  };

  // member variables
  bool                             nzp_csi_rs_aperiodic_info_r14_present = false;
  bool                             nzp_csi_rs_periodic_info_r14_present  = false;
  bool                             zp_csi_rs_aperiodic_info_r14_present  = false;
  bool                             ul_dmrs_enhance_r14_present           = false;
  bool                             density_reduction_np_r14_present      = false;
  bool                             density_reduction_bf_r14_present      = false;
  bool                             hybrid_csi_r14_present                = false;
  bool                             semi_ol_r14_present                   = false;
  bool                             csi_report_np_r14_present             = false;
  bool                             csi_report_advanced_r14_present       = false;
  nzp_csi_rs_aperiodic_info_r14_s_ nzp_csi_rs_aperiodic_info_r14;
  nzp_csi_rs_periodic_info_r14_s_  nzp_csi_rs_periodic_info_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-UE-Parameters-v1430 ::= SEQUENCE
struct mimo_ue_params_v1430_s {
  // member variables
  bool                          params_tm9_v1430_present  = false;
  bool                          params_tm10_v1430_present = false;
  mimo_ue_params_per_tm_v1430_s params_tm9_v1430;
  mimo_ue_params_per_tm_v1430_s params_tm10_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-UE-ParametersPerTM-v1470 ::= SEQUENCE
struct mimo_ue_params_per_tm_v1470_s {
  struct csi_report_advanced_max_ports_r14_opts {
    enum options { n8, n12, n16, n20, n24, n28, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<csi_report_advanced_max_ports_r14_opts> csi_report_advanced_max_ports_r14_e_;

  // member variables
  bool                                 csi_report_advanced_max_ports_r14_present = false;
  csi_report_advanced_max_ports_r14_e_ csi_report_advanced_max_ports_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MIMO-UE-Parameters-v1470 ::= SEQUENCE
struct mimo_ue_params_v1470_s {
  // member variables
  mimo_ue_params_per_tm_v1470_s params_tm9_v1470;
  mimo_ue_params_per_tm_v1470_s params_tm10_v1470;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters ::= SEQUENCE
struct meas_params_s {
  // member variables
  band_list_eutra_l band_list_eutra;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v1020 ::= SEQUENCE
struct meas_params_v1020_s {
  // member variables
  band_combination_list_eutra_r10_l band_combination_list_eutra_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NAICS-Capability-Entry-r12 ::= SEQUENCE
struct naics_cap_entry_r12_s {
  struct nof_aggregated_prb_r12_opts {
    enum options {
      n50,
      n75,
      n100,
      n125,
      n150,
      n175,
      n200,
      n225,
      n250,
      n275,
      n300,
      n350,
      n400,
      n450,
      n500,
      spare,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<nof_aggregated_prb_r12_opts> nof_aggregated_prb_r12_e_;

  // member variables
  bool                      ext                      = false;
  uint8_t                   nof_naics_capable_cc_r12 = 1;
  nof_aggregated_prb_r12_e_ nof_aggregated_prb_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NAICS-Capability-List-r12 ::= SEQUENCE (SIZE (1..maxNAICS-Entries-r12)) OF NAICS-Capability-Entry-r12
typedef dyn_array<naics_cap_entry_r12_s> naics_cap_list_r12_l;

// NonContiguousUL-RA-WithinCC-r10 ::= SEQUENCE
struct non_contiguous_ul_ra_within_cc_r10_s {
  // member variables
  bool non_contiguous_ul_ra_within_cc_info_r10_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NonContiguousUL-RA-WithinCC-List-r10 ::= SEQUENCE (SIZE (1..maxBands)) OF NonContiguousUL-RA-WithinCC-r10
typedef dyn_array<non_contiguous_ul_ra_within_cc_r10_s> non_contiguous_ul_ra_within_cc_list_r10_l;

// ROHC-ProfileSupportList-r15 ::= SEQUENCE
struct rohc_profile_support_list_r15_s {
  // member variables
  bool profile0x0001_r15 = false;
  bool profile0x0002_r15 = false;
  bool profile0x0003_r15 = false;
  bool profile0x0004_r15 = false;
  bool profile0x0006_r15 = false;
  bool profile0x0101_r15 = false;
  bool profile0x0102_r15 = false;
  bool profile0x0103_r15 = false;
  bool profile0x0104_r15 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCP-Parameters ::= SEQUENCE
struct pdcp_params_s {
  struct max_num_rohc_context_sessions_opts {
    enum options {
      cs2,
      cs4,
      cs8,
      cs12,
      cs16,
      cs24,
      cs32,
      cs48,
      cs64,
      cs128,
      cs256,
      cs512,
      cs1024,
      cs16384,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<max_num_rohc_context_sessions_opts> max_num_rohc_context_sessions_e_;

  // member variables
  bool                             ext                                   = false;
  bool                             max_num_rohc_context_sessions_present = false;
  rohc_profile_support_list_r15_s  supported_rohc_profiles;
  max_num_rohc_context_sessions_e_ max_num_rohc_context_sessions;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedOperatorDic-r15 ::= SEQUENCE
struct supported_operator_dic_r15_s {
  // member variables
  uint8_t   version_of_dictionary_r15 = 0;
  plmn_id_s associated_plmn_id_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedUDC-r15 ::= SEQUENCE
struct supported_udc_r15_s {
  // member variables
  bool                         supported_standard_dic_r15_present = false;
  bool                         supported_operator_dic_r15_present = false;
  supported_operator_dic_r15_s supported_operator_dic_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCP-Parameters-v1530 ::= SEQUENCE
struct pdcp_params_v1530_s {
  // member variables
  bool                supported_udc_r15_present = false;
  bool                pdcp_dupl_r15_present     = false;
  supported_udc_r15_s supported_udc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCP-ParametersNR-r15 ::= SEQUENCE
struct pdcp_params_nr_r15_s {
  struct rohc_context_max_sessions_r15_opts {
    enum options {
      cs2,
      cs4,
      cs8,
      cs12,
      cs16,
      cs24,
      cs32,
      cs48,
      cs64,
      cs128,
      cs256,
      cs512,
      cs1024,
      cs16384,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<rohc_context_max_sessions_r15_opts> rohc_context_max_sessions_r15_e_;
  struct rohc_profiles_ul_only_r15_s_ {
    // member variables
    bool profile0x0006_r15 = false;
  };

  // member variables
  bool                             rohc_context_max_sessions_r15_present         = false;
  bool                             rohc_context_continue_r15_present             = false;
  bool                             out_of_order_delivery_r15_present             = false;
  bool                             sn_size_lo_r15_present                        = false;
  bool                             ims_voice_over_nr_pdcp_mcg_bearer_r15_present = false;
  bool                             ims_voice_over_nr_pdcp_scg_bearer_r15_present = false;
  rohc_profile_support_list_r15_s  rohc_profiles_r15;
  rohc_context_max_sessions_r15_e_ rohc_context_max_sessions_r15;
  rohc_profiles_ul_only_r15_s_     rohc_profiles_ul_only_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1020 ::= SEQUENCE
struct phy_layer_params_v1020_s {
  // member variables
  bool                                      two_ant_ports_for_pucch_r10_present             = false;
  bool                                      tm9_with_minus8_tx_fdd_r10_present              = false;
  bool                                      pmi_disabling_r10_present                       = false;
  bool                                      cross_carrier_sched_r10_present                 = false;
  bool                                      simul_pucch_pusch_r10_present                   = false;
  bool                                      multi_cluster_pusch_within_cc_r10_present       = false;
  bool                                      non_contiguous_ul_ra_within_cc_list_r10_present = false;
  non_contiguous_ul_ra_within_cc_list_r10_l non_contiguous_ul_ra_within_cc_list_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1250 ::= SEQUENCE
struct phy_layer_params_v1250_s {
  // member variables
  bool                 e_harq_pattern_fdd_r12_present               = false;
  bool                 enhanced_minus4_tx_codebook_r12_present      = false;
  bool                 tdd_fdd_ca_pcell_duplex_r12_present          = false;
  bool                 phy_tdd_re_cfg_tdd_pcell_r12_present         = false;
  bool                 phy_tdd_re_cfg_fdd_pcell_r12_present         = false;
  bool                 pusch_feedback_mode_r12_present              = false;
  bool                 pusch_srs_pwr_ctrl_sf_set_r12_present        = false;
  bool                 csi_sf_set_r12_present                       = false;
  bool                 no_res_restrict_for_tti_bundling_r12_present = false;
  bool                 discovery_signals_in_deact_scell_r12_present = false;
  bool                 naics_cap_list_r12_present                   = false;
  fixed_bitstring<2>   tdd_fdd_ca_pcell_duplex_r12;
  naics_cap_list_r12_l naics_cap_list_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1320 ::= SEQUENCE
struct phy_layer_params_v1320_s {
  // member variables
  bool                 mimo_ue_params_r13_present = false;
  mimo_ue_params_r13_s mimo_ue_params_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1330 ::= SEQUENCE
struct phy_layer_params_v1330_s {
  // member variables
  bool    cch_interf_mitigation_ref_rec_type_a_r13_present = false;
  bool    cch_interf_mitigation_ref_rec_type_b_r13_present = false;
  bool    cch_interf_mitigation_max_num_ccs_r13_present    = false;
  bool    crs_interf_mitigation_tm1to_tm9_r13_present      = false;
  uint8_t cch_interf_mitigation_max_num_ccs_r13            = 1;
  uint8_t crs_interf_mitigation_tm1to_tm9_r13              = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FeMBMS-Unicast-Parameters-r14 ::= SEQUENCE
struct fe_mbms_unicast_params_r14_s {
  // member variables
  bool unicast_fembms_mixed_scell_r14_present = false;
  bool empty_unicast_region_r14_present       = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1430 ::= SEQUENCE
struct phy_layer_params_v1430_s {
  struct ce_pdsch_pusch_max_bw_r14_opts {
    enum options { bw5, bw20, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ce_pdsch_pusch_max_bw_r14_opts> ce_pdsch_pusch_max_bw_r14_e_;
  struct ce_retuning_symbols_r14_opts {
    enum options { n0, n1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ce_retuning_symbols_r14_opts> ce_retuning_symbols_r14_e_;

  // member variables
  bool                         ce_pusch_nb_max_tbs_r14_present        = false;
  bool                         ce_pdsch_pusch_max_bw_r14_present      = false;
  bool                         ce_harq_ack_bundling_r14_present       = false;
  bool                         ce_pdsch_ten_processes_r14_present     = false;
  bool                         ce_retuning_symbols_r14_present        = false;
  bool                         ce_pdsch_pusch_enhancement_r14_present = false;
  bool                         ce_sched_enhancement_r14_present       = false;
  bool                         ce_srs_enhancement_r14_present         = false;
  bool                         ce_pucch_enhancement_r14_present       = false;
  bool                         ce_closed_loop_tx_ant_sel_r14_present  = false;
  bool                         tdd_special_sf_r14_present             = false;
  bool                         tdd_tti_bundling_r14_present           = false;
  bool                         dmrs_less_up_pts_r14_present           = false;
  bool                         mimo_ue_params_v1430_present           = false;
  bool                         alternative_tbs_idx_r14_present        = false;
  bool                         fe_mbms_unicast_params_r14_present     = false;
  ce_pdsch_pusch_max_bw_r14_e_ ce_pdsch_pusch_max_bw_r14;
  ce_retuning_symbols_r14_e_   ce_retuning_symbols_r14;
  mimo_ue_params_v1430_s       mimo_ue_params_v1430;
  fe_mbms_unicast_params_r14_s fe_mbms_unicast_params_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1470 ::= SEQUENCE
struct phy_layer_params_v1470_s {
  // member variables
  bool                   mimo_ue_params_v1470_present     = false;
  bool                   srs_up_pts_minus6sym_r14_present = false;
  mimo_ue_params_v1470_s mimo_ue_params_v1470;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1530 ::= SEQUENCE
struct phy_layer_params_v1530_s {
  struct stti_spt_capabilities_r15_s_ {
    struct max_layers_slot_or_subslot_pusch_r15_opts {
      enum options { one_layer, two_layers, four_layers, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<max_layers_slot_or_subslot_pusch_r15_opts> max_layers_slot_or_subslot_pusch_r15_e_;
    struct sps_stti_r15_opts {
      enum options { slot, subslot, slot_and_subslot, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<sps_stti_r15_opts> sps_stti_r15_e_;

    // member variables
    bool                                    aperiodic_csi_report_stti_r15_present                 = false;
    bool                                    dmrs_based_spdcch_mbsfn_r15_present                   = false;
    bool                                    dmrs_based_spdcch_non_mbsfn_r15_present               = false;
    bool                                    dmrs_position_pattern_r15_present                     = false;
    bool                                    dmrs_sharing_subslot_pdsch_r15_present                = false;
    bool                                    dmrs_repeat_subslot_pdsch_r15_present                 = false;
    bool                                    epdcch_spt_different_cells_r15_present                = false;
    bool                                    epdcch_stti_different_cells_r15_present               = false;
    bool                                    max_layers_slot_or_subslot_pusch_r15_present          = false;
    bool                                    max_num_updated_csi_proc_spt_r15_present              = false;
    bool                                    max_num_updated_csi_proc_stti_comb77_r15_present      = false;
    bool                                    max_num_updated_csi_proc_stti_comb27_r15_present      = false;
    bool                                    max_num_updated_csi_proc_stti_comb22_set1_r15_present = false;
    bool                                    max_num_updated_csi_proc_stti_comb22_set2_r15_present = false;
    bool                                    mimo_ue_params_stti_r15_present                       = false;
    bool                                    mimo_ue_params_stti_v1530_present                     = false;
    bool                                    nof_blind_decodes_uss_r15_present                     = false;
    bool                                    pdsch_slot_subslot_pdsch_decoding_r15_present         = false;
    bool                                    pwr_uci_slot_pusch_present                            = false;
    bool                                    pwr_uci_subslot_pusch_present                         = false;
    bool                                    slot_pdsch_tx_div_tm9and10_present                    = false;
    bool                                    subslot_pdsch_tx_div_tm9and10_present                 = false;
    bool                                    spdcch_different_rs_types_r15_present                 = false;
    bool                                    srs_dci7_triggering_fs2_r15_present                   = false;
    bool                                    sps_cyclic_shift_r15_present                          = false;
    bool                                    spdcch_reuse_r15_present                              = false;
    bool                                    sps_stti_r15_present                                  = false;
    bool                                    tm8_slot_pdsch_r15_present                            = false;
    bool                                    tm9_slot_subslot_r15_present                          = false;
    bool                                    tm9_slot_subslot_mbsfn_r15_present                    = false;
    bool                                    tm10_slot_subslot_r15_present                         = false;
    bool                                    tm10_slot_subslot_mbsfn_r15_present                   = false;
    bool                                    tx_div_spucch_r15_present                             = false;
    bool                                    ul_async_harq_sharing_diff_tti_lens_r15_present       = false;
    max_layers_slot_or_subslot_pusch_r15_e_ max_layers_slot_or_subslot_pusch_r15;
    uint8_t                                 max_num_updated_csi_proc_spt_r15              = 5;
    uint8_t                                 max_num_updated_csi_proc_stti_comb77_r15      = 1;
    uint8_t                                 max_num_updated_csi_proc_stti_comb27_r15      = 1;
    uint8_t                                 max_num_updated_csi_proc_stti_comb22_set1_r15 = 1;
    uint8_t                                 max_num_updated_csi_proc_stti_comb22_set2_r15 = 1;
    mimo_ue_params_r13_s                    mimo_ue_params_stti_r15;
    mimo_ue_params_v1430_s                  mimo_ue_params_stti_v1530;
    uint8_t                                 nof_blind_decodes_uss_r15 = 4;
    sps_stti_r15_e_                         sps_stti_r15;
  };
  struct ce_capabilities_r15_s_ {
    // member variables
    bool ce_crs_intf_mitig_r15_present                 = false;
    bool ce_cqi_alternative_table_r15_present          = false;
    bool ce_pdsch_flex_start_prb_ce_mode_a_r15_present = false;
    bool ce_pdsch_flex_start_prb_ce_mode_b_r15_present = false;
    bool ce_pdsch_minus64_qam_r15_present              = false;
    bool ce_pusch_flex_start_prb_ce_mode_a_r15_present = false;
    bool ce_pusch_flex_start_prb_ce_mode_b_r15_present = false;
    bool ce_pusch_sub_prb_alloc_r15_present            = false;
    bool ce_ul_harq_ack_feedback_r15_present           = false;
  };
  struct urllc_capabilities_r15_s_ {
    // member variables
    bool    pdsch_rep_sf_r15_present                  = false;
    bool    pdsch_rep_slot_r15_present                = false;
    bool    pdsch_rep_subslot_r15_present             = false;
    bool    pusch_sps_multi_cfg_sf_r15_present        = false;
    bool    pusch_sps_max_cfg_sf_r15_present          = false;
    bool    pusch_sps_multi_cfg_slot_r15_present      = false;
    bool    pusch_sps_max_cfg_slot_r15_present        = false;
    bool    pusch_sps_multi_cfg_subslot_r15_present   = false;
    bool    pusch_sps_max_cfg_subslot_r15_present     = false;
    bool    pusch_sps_slot_rep_pcell_r15_present      = false;
    bool    pusch_sps_slot_rep_ps_cell_r15_present    = false;
    bool    pusch_sps_slot_rep_scell_r15_present      = false;
    bool    pusch_sps_sf_rep_pcell_r15_present        = false;
    bool    pusch_sps_sf_rep_ps_cell_r15_present      = false;
    bool    pusch_sps_sf_rep_scell_r15_present        = false;
    bool    pusch_sps_subslot_rep_pcell_r15_present   = false;
    bool    pusch_sps_subslot_rep_ps_cell_r15_present = false;
    bool    pusch_sps_subslot_rep_scell_r15_present   = false;
    bool    semi_static_cfi_r15_present               = false;
    bool    semi_static_cfi_pattern_r15_present       = false;
    uint8_t pusch_sps_multi_cfg_sf_r15                = 0;
    uint8_t pusch_sps_max_cfg_sf_r15                  = 0;
    uint8_t pusch_sps_multi_cfg_slot_r15              = 0;
    uint8_t pusch_sps_max_cfg_slot_r15                = 0;
    uint8_t pusch_sps_multi_cfg_subslot_r15           = 0;
    uint8_t pusch_sps_max_cfg_subslot_r15             = 0;
  };

  // member variables
  bool                         stti_spt_capabilities_r15_present          = false;
  bool                         ce_capabilities_r15_present                = false;
  bool                         short_cqi_for_scell_activation_r15_present = false;
  bool                         mimo_cbsr_advanced_csi_r15_present         = false;
  bool                         crs_intf_mitig_r15_present                 = false;
  bool                         ul_pwr_ctrl_enhance_r15_present            = false;
  bool                         urllc_capabilities_r15_present             = false;
  bool                         alt_mcs_table_r15_present                  = false;
  stti_spt_capabilities_r15_s_ stti_spt_capabilities_r15;
  ce_capabilities_r15_s_       ce_capabilities_r15;
  urllc_capabilities_r15_s_    urllc_capabilities_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandEUTRA ::= SEQUENCE
struct supported_band_eutra_s {
  // member variables
  uint8_t band_eutra  = 1;
  bool    half_duplex = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandListEUTRA ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandEUTRA
typedef dyn_array<supported_band_eutra_s> supported_band_list_eutra_l;

// RF-Parameters ::= SEQUENCE
struct rf_params_s {
  // member variables
  supported_band_list_eutra_l supported_band_list_eutra;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-r10 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-r10
typedef dyn_array<band_combination_params_r10_l> supported_band_combination_r10_l;

// RF-Parameters-v1020 ::= SEQUENCE
struct rf_params_v1020_s {
  // member variables
  supported_band_combination_r10_l supported_band_combination_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombinationExt-r10 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParametersExt-r10
typedef dyn_array<band_combination_params_ext_r10_s> supported_band_combination_ext_r10_l;

// RF-Parameters-v1060 ::= SEQUENCE
struct rf_params_v1060_s {
  // member variables
  supported_band_combination_ext_r10_l supported_band_combination_ext_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1090 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1090
typedef dyn_array<band_combination_params_v1090_l> supported_band_combination_v1090_l;

// RF-Parameters-v1090 ::= SEQUENCE
struct rf_params_v1090_s {
  // member variables
  bool                               supported_band_combination_v1090_present = false;
  supported_band_combination_v1090_l supported_band_combination_v1090;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v10i0 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v10i0
typedef dyn_array<band_combination_params_v10i0_s> supported_band_combination_v10i0_l;

// RF-Parameters-v10i0 ::= SEQUENCE
struct rf_params_v10i0_s {
  // member variables
  bool                               supported_band_combination_v10i0_present = false;
  supported_band_combination_v10i0_l supported_band_combination_v10i0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1130 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1130
typedef dyn_array<band_combination_params_v1130_s> supported_band_combination_v1130_l;

// RF-Parameters-v1130 ::= SEQUENCE
struct rf_params_v1130_s {
  // member variables
  bool                               supported_band_combination_v1130_present = false;
  supported_band_combination_v1130_l supported_band_combination_v1130;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombinationAdd-r11 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-r11
typedef dyn_array<band_combination_params_r11_s> supported_band_combination_add_r11_l;

// RF-Parameters-v1180 ::= SEQUENCE
struct rf_params_v1180_s {
  typedef dyn_array<uint16_t> requested_bands_r11_l_;

  // member variables
  bool                                 freq_band_retrieval_r11_present            = false;
  bool                                 requested_bands_r11_present                = false;
  bool                                 supported_band_combination_add_r11_present = false;
  requested_bands_r11_l_               requested_bands_r11;
  supported_band_combination_add_r11_l supported_band_combination_add_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombinationAdd-v11d0 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v10i0
typedef dyn_array<band_combination_params_v10i0_s> supported_band_combination_add_v11d0_l;

// RF-Parameters-v11d0 ::= SEQUENCE
struct rf_params_v11d0_s {
  // member variables
  bool                                   supported_band_combination_add_v11d0_present = false;
  supported_band_combination_add_v11d0_l supported_band_combination_add_v11d0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandEUTRA-v1250 ::= SEQUENCE
struct supported_band_eutra_v1250_s {
  // member variables
  bool dl_minus256_qam_r12_present = false;
  bool ul_minus64_qam_r12_present  = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1250 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1250
typedef dyn_array<band_combination_params_v1250_s> supported_band_combination_v1250_l;

// SupportedBandCombinationAdd-v1250 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1250
typedef dyn_array<band_combination_params_v1250_s> supported_band_combination_add_v1250_l;

// SupportedBandListEUTRA-v1250 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandEUTRA-v1250
typedef dyn_array<supported_band_eutra_v1250_s> supported_band_list_eutra_v1250_l;

// RF-Parameters-v1250 ::= SEQUENCE
struct rf_params_v1250_s {
  // member variables
  bool                                   supported_band_list_eutra_v1250_present      = false;
  bool                                   supported_band_combination_v1250_present     = false;
  bool                                   supported_band_combination_add_v1250_present = false;
  bool                                   freq_band_prio_adjustment_r12_present        = false;
  supported_band_list_eutra_v1250_l      supported_band_list_eutra_v1250;
  supported_band_combination_v1250_l     supported_band_combination_v1250;
  supported_band_combination_add_v1250_l supported_band_combination_add_v1250;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1270 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1270
typedef dyn_array<band_combination_params_v1270_s> supported_band_combination_v1270_l;

// SupportedBandCombinationAdd-v1270 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1270
typedef dyn_array<band_combination_params_v1270_s> supported_band_combination_add_v1270_l;

// RF-Parameters-v1270 ::= SEQUENCE
struct rf_params_v1270_s {
  // member variables
  bool                                   supported_band_combination_v1270_present     = false;
  bool                                   supported_band_combination_add_v1270_present = false;
  supported_band_combination_v1270_l     supported_band_combination_v1270;
  supported_band_combination_add_v1270_l supported_band_combination_add_v1270;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandEUTRA-v1310 ::= SEQUENCE
struct supported_band_eutra_v1310_s {
  // member variables
  bool ue_pwr_class_minus5_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombinationReduced-r13 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-r13
typedef dyn_array<band_combination_params_r13_s> supported_band_combination_reduced_r13_l;

// SupportedBandListEUTRA-v1310 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandEUTRA-v1310
typedef dyn_array<supported_band_eutra_v1310_s> supported_band_list_eutra_v1310_l;

// RF-Parameters-v1310 ::= SEQUENCE
struct rf_params_v1310_s {
  struct e_nb_requested_params_r13_s_ {
    // member variables
    bool    reduced_int_non_cont_comb_requested_r13_present = false;
    bool    requested_ccs_dl_r13_present                    = false;
    bool    requested_ccs_ul_r13_present                    = false;
    bool    skip_fallback_comb_requested_r13_present        = false;
    uint8_t requested_ccs_dl_r13                            = 2;
    uint8_t requested_ccs_ul_r13                            = 2;
  };

  // member variables
  bool                                     e_nb_requested_params_r13_present              = false;
  bool                                     maximum_ccs_retrieval_r13_present              = false;
  bool                                     skip_fallback_combinations_r13_present         = false;
  bool                                     reduced_int_non_cont_comb_r13_present          = false;
  bool                                     supported_band_list_eutra_v1310_present        = false;
  bool                                     supported_band_combination_reduced_r13_present = false;
  e_nb_requested_params_r13_s_             e_nb_requested_params_r13;
  supported_band_list_eutra_v1310_l        supported_band_list_eutra_v1310;
  supported_band_combination_reduced_r13_l supported_band_combination_reduced_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandEUTRA-v1320 ::= SEQUENCE
struct supported_band_eutra_v1320_s {
  struct ue_pwr_class_n_r13_opts {
    enum options { class1, class2, class4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ue_pwr_class_n_r13_opts> ue_pwr_class_n_r13_e_;

  // member variables
  bool                  intra_freq_ce_need_for_gaps_r13_present = false;
  bool                  ue_pwr_class_n_r13_present              = false;
  ue_pwr_class_n_r13_e_ ue_pwr_class_n_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1320 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1320
typedef dyn_array<band_combination_params_v1320_s> supported_band_combination_v1320_l;

// SupportedBandCombinationAdd-v1320 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1320
typedef dyn_array<band_combination_params_v1320_s> supported_band_combination_add_v1320_l;

// SupportedBandCombinationReduced-v1320 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-v1320
typedef dyn_array<band_combination_params_v1320_s> supported_band_combination_reduced_v1320_l;

// SupportedBandListEUTRA-v1320 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandEUTRA-v1320
typedef dyn_array<supported_band_eutra_v1320_s> supported_band_list_eutra_v1320_l;

// RF-Parameters-v1320 ::= SEQUENCE
struct rf_params_v1320_s {
  // member variables
  bool                                       supported_band_list_eutra_v1320_present          = false;
  bool                                       supported_band_combination_v1320_present         = false;
  bool                                       supported_band_combination_add_v1320_present     = false;
  bool                                       supported_band_combination_reduced_v1320_present = false;
  supported_band_list_eutra_v1320_l          supported_band_list_eutra_v1320;
  supported_band_combination_v1320_l         supported_band_combination_v1320;
  supported_band_combination_add_v1320_l     supported_band_combination_add_v1320;
  supported_band_combination_reduced_v1320_l supported_band_combination_reduced_v1320;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1380 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1380
typedef dyn_array<band_combination_params_v1380_s> supported_band_combination_v1380_l;

// SupportedBandCombinationAdd-v1380 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1380
typedef dyn_array<band_combination_params_v1380_s> supported_band_combination_add_v1380_l;

// SupportedBandCombinationReduced-v1380 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-v1380
typedef dyn_array<band_combination_params_v1380_s> supported_band_combination_reduced_v1380_l;

// RF-Parameters-v1380 ::= SEQUENCE
struct rf_params_v1380_s {
  // member variables
  bool                                       supported_band_combination_v1380_present         = false;
  bool                                       supported_band_combination_add_v1380_present     = false;
  bool                                       supported_band_combination_reduced_v1380_present = false;
  supported_band_combination_v1380_l         supported_band_combination_v1380;
  supported_band_combination_add_v1380_l     supported_band_combination_add_v1380;
  supported_band_combination_reduced_v1380_l supported_band_combination_reduced_v1380;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BandCombinationParameters-v1390 ::= SEQUENCE
struct band_combination_params_v1390_s {
  // member variables
  bool ue_ca_pwr_class_n_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1390 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1390
typedef dyn_array<band_combination_params_v1390_s> supported_band_combination_v1390_l;

// SupportedBandCombinationAdd-v1390 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1390
typedef dyn_array<band_combination_params_v1390_s> supported_band_combination_add_v1390_l;

// SupportedBandCombinationReduced-v1390 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-v1390
typedef dyn_array<band_combination_params_v1390_s> supported_band_combination_reduced_v1390_l;

// RF-Parameters-v1390 ::= SEQUENCE
struct rf_params_v1390_s {
  // member variables
  bool                                       supported_band_combination_v1390_present         = false;
  bool                                       supported_band_combination_add_v1390_present     = false;
  bool                                       supported_band_combination_reduced_v1390_present = false;
  supported_band_combination_v1390_l         supported_band_combination_v1390;
  supported_band_combination_add_v1390_l     supported_band_combination_add_v1390;
  supported_band_combination_reduced_v1390_l supported_band_combination_reduced_v1390;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1430 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1430
typedef dyn_array<band_combination_params_v1430_s> supported_band_combination_v1430_l;

// SupportedBandCombinationAdd-v1430 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1430
typedef dyn_array<band_combination_params_v1430_s> supported_band_combination_add_v1430_l;

// SupportedBandCombinationReduced-v1430 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-v1430
typedef dyn_array<band_combination_params_v1430_s> supported_band_combination_reduced_v1430_l;

// RF-Parameters-v1430 ::= SEQUENCE
struct rf_params_v1430_s {
  struct e_nb_requested_params_v1430_s_ {
    // member variables
    band_combination_list_r14_l requested_diff_fallback_comb_list_r14;
  };

  // member variables
  bool                                       supported_band_combination_v1430_present         = false;
  bool                                       supported_band_combination_add_v1430_present     = false;
  bool                                       supported_band_combination_reduced_v1430_present = false;
  bool                                       e_nb_requested_params_v1430_present              = false;
  bool                                       diff_fallback_comb_report_r14_present            = false;
  supported_band_combination_v1430_l         supported_band_combination_v1430;
  supported_band_combination_add_v1430_l     supported_band_combination_add_v1430;
  supported_band_combination_reduced_v1430_l supported_band_combination_reduced_v1430;
  e_nb_requested_params_v1430_s_             e_nb_requested_params_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1450 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1450
typedef dyn_array<band_combination_params_v1450_s> supported_band_combination_v1450_l;

// SupportedBandCombinationAdd-v1450 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1450
typedef dyn_array<band_combination_params_v1450_s> supported_band_combination_add_v1450_l;

// SupportedBandCombinationReduced-v1450 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-v1450
typedef dyn_array<band_combination_params_v1450_s> supported_band_combination_reduced_v1450_l;

// RF-Parameters-v1450 ::= SEQUENCE
struct rf_params_v1450_s {
  // member variables
  bool                                       supported_band_combination_v1450_present         = false;
  bool                                       supported_band_combination_add_v1450_present     = false;
  bool                                       supported_band_combination_reduced_v1450_present = false;
  supported_band_combination_v1450_l         supported_band_combination_v1450;
  supported_band_combination_add_v1450_l     supported_band_combination_add_v1450;
  supported_band_combination_reduced_v1450_l supported_band_combination_reduced_v1450;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1470 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1470
typedef dyn_array<band_combination_params_v1470_s> supported_band_combination_v1470_l;

// SupportedBandCombinationAdd-v1470 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1470
typedef dyn_array<band_combination_params_v1470_s> supported_band_combination_add_v1470_l;

// SupportedBandCombinationReduced-v1470 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-v1470
typedef dyn_array<band_combination_params_v1470_s> supported_band_combination_reduced_v1470_l;

// RF-Parameters-v1470 ::= SEQUENCE
struct rf_params_v1470_s {
  // member variables
  bool                                       supported_band_combination_v1470_present         = false;
  bool                                       supported_band_combination_add_v1470_present     = false;
  bool                                       supported_band_combination_reduced_v1470_present = false;
  supported_band_combination_v1470_l         supported_band_combination_v1470;
  supported_band_combination_add_v1470_l     supported_band_combination_add_v1470;
  supported_band_combination_reduced_v1470_l supported_band_combination_reduced_v1470;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandCombination-v1530 ::= SEQUENCE (SIZE (1..maxBandComb-r10)) OF BandCombinationParameters-v1530
typedef dyn_array<band_combination_params_v1530_s> supported_band_combination_v1530_l;

// SupportedBandCombinationAdd-v1530 ::= SEQUENCE (SIZE (1..maxBandComb-r11)) OF BandCombinationParameters-v1530
typedef dyn_array<band_combination_params_v1530_s> supported_band_combination_add_v1530_l;

// SupportedBandCombinationReduced-v1530 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF BandCombinationParameters-v1530
typedef dyn_array<band_combination_params_v1530_s> supported_band_combination_reduced_v1530_l;

// RF-Parameters-v1530 ::= SEQUENCE
struct rf_params_v1530_s {
  // member variables
  bool                                       s_tti_spt_supported_r15_present                  = false;
  bool                                       supported_band_combination_v1530_present         = false;
  bool                                       supported_band_combination_add_v1530_present     = false;
  bool                                       supported_band_combination_reduced_v1530_present = false;
  bool                                       pwr_class_minus14dbm_r15_present                 = false;
  supported_band_combination_v1530_l         supported_band_combination_v1530;
  supported_band_combination_add_v1530_l     supported_band_combination_add_v1530;
  supported_band_combination_reduced_v1530_l supported_band_combination_reduced_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandEUTRA-v9e0 ::= SEQUENCE
struct supported_band_eutra_v9e0_s {
  // member variables
  bool     band_eutra_v9e0_present = false;
  uint16_t band_eutra_v9e0         = 65;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandListEUTRA-v9e0 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandEUTRA-v9e0
typedef dyn_array<supported_band_eutra_v9e0_s> supported_band_list_eutra_v9e0_l;

// RF-Parameters-v9e0 ::= SEQUENCE
struct rf_params_v9e0_s {
  // member variables
  bool                             supported_band_list_eutra_v9e0_present = false;
  supported_band_list_eutra_v9e0_l supported_band_list_eutra_v9e0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandInfo-r12 ::= SEQUENCE
struct supported_band_info_r12_s {
  // member variables
  bool support_r12_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SupportedBandInfoList-r12 ::= SEQUENCE (SIZE (1..maxBands)) OF SupportedBandInfo-r12
typedef dyn_array<supported_band_info_r12_s> supported_band_info_list_r12_l;

// SL-Parameters-r12 ::= SEQUENCE
struct sl_params_r12_s {
  struct disc_supported_proc_r12_opts {
    enum options { n50, n400, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<disc_supported_proc_r12_opts> disc_supported_proc_r12_e_;

  // member variables
  bool                           comm_simul_tx_r12_present         = false;
  bool                           comm_supported_bands_r12_present  = false;
  bool                           disc_supported_bands_r12_present  = false;
  bool                           disc_sched_res_alloc_r12_present  = false;
  bool                           disc_ue_sel_res_alloc_r12_present = false;
  bool                           disc_slss_r12_present             = false;
  bool                           disc_supported_proc_r12_present   = false;
  freq_band_ind_list_eutra_r12_l comm_supported_bands_r12;
  supported_band_info_list_r12_l disc_supported_bands_r12;
  disc_supported_proc_r12_e_     disc_supported_proc_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// V2X-BandParameters-r14 ::= SEQUENCE
struct v2x_band_params_r14_s {
  // member variables
  bool                    band_params_tx_sl_r14_present = false;
  bool                    band_params_rx_sl_r14_present = false;
  uint16_t                v2x_freq_band_eutra_r14       = 1;
  band_params_tx_sl_r14_s band_params_tx_sl_r14;
  band_params_rx_sl_r14_s band_params_rx_sl_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// V2X-BandCombinationParameters-r14 ::= SEQUENCE (SIZE (1.. maxSimultaneousBands-r10)) OF V2X-BandParameters-r14
typedef dyn_array<v2x_band_params_r14_s> v2x_band_combination_params_r14_l;

// V2X-SupportedBandCombination-r14 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF V2X-BandCombinationParameters-r14
typedef dyn_array<v2x_band_combination_params_r14_l> v2x_supported_band_combination_r14_l;

// SL-Parameters-v1430 ::= SEQUENCE
struct sl_params_v1430_s {
  // member variables
  bool                                 zone_based_pool_sel_r14_present                 = false;
  bool                                 ue_autonomous_with_full_sensing_r14_present     = false;
  bool                                 ue_autonomous_with_partial_sensing_r14_present  = false;
  bool                                 sl_congestion_ctrl_r14_present                  = false;
  bool                                 v2x_tx_with_short_resv_interv_r14_present       = false;
  bool                                 v2x_num_tx_rx_timing_r14_present                = false;
  bool                                 v2x_non_adjacent_pscch_pssch_r14_present        = false;
  bool                                 slss_tx_rx_r14_present                          = false;
  bool                                 v2x_supported_band_combination_list_r14_present = false;
  uint8_t                              v2x_num_tx_rx_timing_r14                        = 1;
  v2x_supported_band_combination_r14_l v2x_supported_band_combination_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// V2X-BandParameters-v1530 ::= SEQUENCE
struct v2x_band_params_v1530_s {
  // member variables
  bool v2x_enhanced_high_reception_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// V2X-BandCombinationParameters-v1530 ::= SEQUENCE (SIZE (1.. maxSimultaneousBands-r10)) OF V2X-BandParameters-v1530
typedef dyn_array<v2x_band_params_v1530_s> v2x_band_combination_params_v1530_l;

// UE-CategorySL-r15 ::= SEQUENCE
struct ue_category_sl_r15_s {
  // member variables
  uint8_t ue_category_sl_c_tx_r15 = 1;
  uint8_t ue_category_sl_c_rx_r15 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// V2X-SupportedBandCombination-v1530 ::= SEQUENCE (SIZE (1..maxBandComb-r13)) OF V2X-BandCombinationParameters-v1530
typedef dyn_array<v2x_band_combination_params_v1530_l> v2x_supported_band_combination_v1530_l;

// SL-Parameters-v1530 ::= SEQUENCE
struct sl_params_v1530_s {
  struct slss_supported_tx_freq_r15_opts {
    enum options { single, multiple, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<slss_supported_tx_freq_r15_opts> slss_supported_tx_freq_r15_e_;

  // member variables
  bool                                   slss_supported_tx_freq_r15_present                = false;
  bool                                   sl_minus64_qam_tx_r15_present                     = false;
  bool                                   sl_tx_diversity_r15_present                       = false;
  bool                                   ue_category_sl_r15_present                        = false;
  bool                                   v2x_supported_band_combination_list_v1530_present = false;
  slss_supported_tx_freq_r15_e_          slss_supported_tx_freq_r15;
  ue_category_sl_r15_s                   ue_category_sl_r15;
  v2x_supported_band_combination_v1530_l v2x_supported_band_combination_list_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// N1SPUCCH-AN-PersistentList-r15 ::= SEQUENCE (SIZE (1..4)) OF INTEGER
typedef bounded_array<uint16_t, 4> n1_spucch_an_persistent_list_r15_l;

// SPS-ConfigDL-STTI-r15 ::= CHOICE
struct sps_cfg_dl_stti_r15_c {
  struct setup_s_ {
    struct semi_persist_sched_interv_dl_stti_r15_opts {
      enum options {
        s_tti1,
        s_tti2,
        s_tti3,
        s_tti4,
        s_tti6,
        s_tti8,
        s_tti12,
        s_tti16,
        s_tti20,
        s_tti40,
        s_tti60,
        s_tti80,
        s_tti120,
        s_tti240,
        spare2,
        spare1,
        nulltype
      } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<semi_persist_sched_interv_dl_stti_r15_opts> semi_persist_sched_interv_dl_stti_r15_e_;
    struct two_ant_port_activ_r15_c_ {
      struct setup_s_ {
        // member variables
        n1_spucch_an_persistent_list_r15_l n1_spucch_an_persistent_list_p1_r15;
      };
      typedef setup_e types;

      // choice methods
      two_ant_port_activ_r15_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      setup_s_& setup()
      {
        assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivated-r15");
        return c;
      }
      const setup_s_& setup() const
      {
        assert_choice_type("setup", type_.to_string(), "twoAntennaPortActivated-r15");
        return c;
      }
      setup_s_& set_setup()
      {
        set(types::setup);
        return c;
      }

    private:
      types    type_;
      setup_s_ c;
    };

    // member variables
    bool                                     ext                                 = false;
    bool                                     two_ant_port_activ_r15_present      = false;
    bool                                     tpc_pdcch_cfg_pucch_sps_r15_present = false;
    semi_persist_sched_interv_dl_stti_r15_e_ semi_persist_sched_interv_dl_stti_r15;
    uint8_t                                  nof_conf_sps_processes_stti_r15 = 1;
    two_ant_port_activ_r15_c_                two_ant_port_activ_r15;
    uint8_t                                  s_tti_start_time_dl_r15 = 0;
    tpc_pdcch_cfg_c                          tpc_pdcch_cfg_pucch_sps_r15;
    // ...
  };
  typedef setup_e types;

  // choice methods
  sps_cfg_dl_stti_r15_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  setup_s_& setup()
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigDL-STTI-r15");
    return c;
  }
  const setup_s_& setup() const
  {
    assert_choice_type("setup", type_.to_string(), "SPS-ConfigDL-STTI-r15");
    return c;
  }
  setup_s_& set_setup()
  {
    set(types::setup);
    return c;
  }

private:
  types    type_;
  setup_s_ c;
};

// NeighCellSI-AcquisitionParameters-v1530 ::= SEQUENCE
struct neigh_cell_si_acquisition_params_v1530_s {
  // member variables
  bool report_cgi_nr_en_dc_r15_present    = false;
  bool report_cgi_nr_no_en_dc_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LAA-Parameters-v1530 ::= SEQUENCE
struct laa_params_v1530_s {
  // member variables
  bool aul_r15_present             = false;
  bool laa_pusch_mode1_r15_present = false;
  bool laa_pusch_mode2_r15_present = false;
  bool laa_pusch_mode3_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v1530 ::= SEQUENCE
struct meas_params_v1530_s {
  // member variables
  bool qoe_meas_report_r15_present            = false;
  bool qoe_mtsi_meas_report_r15_present       = false;
  bool ca_idle_mode_meass_r15_present         = false;
  bool ca_idle_mode_validity_area_r15_present = false;
  bool height_meas_r15_present                = false;
  bool multiple_cells_meas_ext_r15_present    = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Other-Parameters-v1530 ::= SEQUENCE
struct other_params_v1530_s {
  // member variables
  bool assist_info_bit_for_lc_r15_present = false;
  bool time_ref_provision_r15_present     = false;
  bool flight_path_plan_r15_present       = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLC-Parameters-v1530 ::= SEQUENCE
struct rlc_params_v1530_s {
  // member variables
  bool flex_um_am_combinations_r15_present = false;
  bool rlc_am_ooo_delivery_r15_present     = false;
  bool rlc_um_ooo_delivery_r15_present     = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-BasedNetwPerfMeasParameters-v1530 ::= SEQUENCE
struct ue_based_netw_perf_meas_params_v1530_s {
  // member variables
  bool logged_meas_bt_r15_present   = false;
  bool logged_meas_wlan_r15_present = false;
  bool imm_meas_bt_r15_present      = false;
  bool imm_meas_wlan_r15_present    = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1530 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1530_s {
  // member variables
  bool                                     neigh_cell_si_acquisition_params_v1530_present = false;
  bool                                     reduced_cp_latency_r15_present                 = false;
  neigh_cell_si_acquisition_params_v1530_s neigh_cell_si_acquisition_params_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v1520 ::= SEQUENCE
struct meas_params_v1520_s {
  // member variables
  bool               meas_gap_patterns_v1520_present = false;
  fixed_bitstring<8> meas_gap_patterns_v1520;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1530-IEs ::= SEQUENCE
struct ue_eutra_cap_v1530_ies_s {
  // member variables
  bool                                     meas_params_v1530_present                      = false;
  bool                                     other_params_v1530_present                     = false;
  bool                                     neigh_cell_si_acquisition_params_v1530_present = false;
  bool                                     mac_params_v1530_present                       = false;
  bool                                     phy_layer_params_v1530_present                 = false;
  bool                                     rf_params_v1530_present                        = false;
  bool                                     pdcp_params_v1530_present                      = false;
  bool                                     ue_category_dl_v1530_present                   = false;
  bool                                     ue_based_netw_perf_meas_params_v1530_present   = false;
  bool                                     rlc_params_v1530_present                       = false;
  bool                                     sl_params_v1530_present                        = false;
  bool                                     extended_nof_drbs_r15_present                  = false;
  bool                                     reduced_cp_latency_r15_present                 = false;
  bool                                     laa_params_v1530_present                       = false;
  bool                                     ue_category_ul_v1530_present                   = false;
  bool                                     fdd_add_ue_eutra_capabilities_v1530_present    = false;
  bool                                     tdd_add_ue_eutra_capabilities_v1530_present    = false;
  bool                                     non_crit_ext_present                           = false;
  meas_params_v1530_s                      meas_params_v1530;
  other_params_v1530_s                     other_params_v1530;
  neigh_cell_si_acquisition_params_v1530_s neigh_cell_si_acquisition_params_v1530;
  mac_params_v1530_s                       mac_params_v1530;
  phy_layer_params_v1530_s                 phy_layer_params_v1530;
  rf_params_v1530_s                        rf_params_v1530;
  pdcp_params_v1530_s                      pdcp_params_v1530;
  uint8_t                                  ue_category_dl_v1530 = 22;
  ue_based_netw_perf_meas_params_v1530_s   ue_based_netw_perf_meas_params_v1530;
  rlc_params_v1530_s                       rlc_params_v1530;
  sl_params_v1530_s                        sl_params_v1530;
  laa_params_v1530_s                       laa_params_v1530;
  uint8_t                                  ue_category_ul_v1530 = 22;
  ue_eutra_cap_add_xdd_mode_v1530_s        fdd_add_ue_eutra_capabilities_v1530;
  ue_eutra_cap_add_xdd_mode_v1530_s        tdd_add_ue_eutra_capabilities_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1520-IEs ::= SEQUENCE
struct ue_eutra_cap_v1520_ies_s {
  // member variables
  bool                     non_crit_ext_present = false;
  meas_params_v1520_s      meas_params_v1520;
  ue_eutra_cap_v1530_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1510 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1510_s {
  // member variables
  bool                 pdcp_params_nr_r15_present = false;
  pdcp_params_nr_r15_s pdcp_params_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Other-Parameters-v1460 ::= SEQUENCE
struct other_params_v1460_s {
  // member variables
  bool non_csg_si_report_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1510-IEs ::= SEQUENCE
struct ue_eutra_cap_v1510_ies_s {
  // member variables
  bool                              irat_params_nr_r15_present                  = false;
  bool                              feature_sets_eutra_r15_present              = false;
  bool                              pdcp_params_nr_r15_present                  = false;
  bool                              fdd_add_ue_eutra_capabilities_v1510_present = false;
  bool                              tdd_add_ue_eutra_capabilities_v1510_present = false;
  bool                              non_crit_ext_present                        = false;
  irat_params_nr_r15_s              irat_params_nr_r15;
  feature_sets_eutra_r15_s          feature_sets_eutra_r15;
  pdcp_params_nr_r15_s              pdcp_params_nr_r15;
  ue_eutra_cap_add_xdd_mode_v1510_s fdd_add_ue_eutra_capabilities_v1510;
  ue_eutra_cap_add_xdd_mode_v1510_s tdd_add_ue_eutra_capabilities_v1510;
  ue_eutra_cap_v1520_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// OtherParameters-v1450 ::= SEQUENCE
struct other_params_v1450_s {
  // member variables
  bool overheat_ind_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1450 ::= SEQUENCE
struct phy_layer_params_v1450_s {
  // member variables
  bool ce_srs_enhancement_without_comb4_r14_present = false;
  bool crs_less_dw_pts_r14_present                  = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1460-IEs ::= SEQUENCE
struct ue_eutra_cap_v1460_ies_s {
  // member variables
  bool                     ue_category_dl_v1460_present = false;
  bool                     non_crit_ext_present         = false;
  uint8_t                  ue_category_dl_v1460         = 21;
  other_params_v1460_s     other_params_v1460;
  ue_eutra_cap_v1510_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LWA-Parameters-v1440 ::= SEQUENCE
struct lwa_params_v1440_s {
  // member variables
  bool lwa_rlc_um_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MAC-Parameters-v1440 ::= SEQUENCE
struct mac_params_v1440_s {
  // member variables
  bool rai_support_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MMTEL-Parameters-r14 ::= SEQUENCE
struct mmtel_params_r14_s {
  // member variables
  bool delay_budget_report_r14_present        = false;
  bool pusch_enhance_r14_present              = false;
  bool recommended_bit_rate_r14_present       = false;
  bool recommended_bit_rate_query_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1450-IEs ::= SEQUENCE
struct ue_eutra_cap_v1450_ies_s {
  // member variables
  bool                     phy_layer_params_v1450_present = false;
  bool                     rf_params_v1450_present        = false;
  bool                     ue_category_dl_v1450_present   = false;
  bool                     non_crit_ext_present           = false;
  phy_layer_params_v1450_s phy_layer_params_v1450;
  rf_params_v1450_s        rf_params_v1450;
  other_params_v1450_s     other_params_v1450;
  uint8_t                  ue_category_dl_v1450 = 20;
  ue_eutra_cap_v1460_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CE-Parameters-v1430 ::= SEQUENCE
struct ce_params_v1430_s {
  // member variables
  bool ce_switch_without_ho_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HighSpeedEnhParameters-r14 ::= SEQUENCE
struct high_speed_enh_params_r14_s {
  // member variables
  bool meas_enhance_r14_present  = false;
  bool demod_enhance_r14_present = false;
  bool prach_enhance_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LAA-Parameters-v1430 ::= SEQUENCE
struct laa_params_v1430_s {
  struct two_step_sched_timing_info_r14_opts {
    enum options { n_plus1, n_plus2, n_plus3, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<two_step_sched_timing_info_r14_opts> two_step_sched_timing_info_r14_e_;

  // member variables
  bool                              cross_carrier_sched_laa_ul_r14_present    = false;
  bool                              ul_laa_r14_present                        = false;
  bool                              two_step_sched_timing_info_r14_present    = false;
  bool                              uss_blind_decoding_adjustment_r14_present = false;
  bool                              uss_blind_decoding_reduction_r14_present  = false;
  bool                              out_of_seq_grant_handling_r14_present     = false;
  two_step_sched_timing_info_r14_e_ two_step_sched_timing_info_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LWA-Parameters-v1430 ::= SEQUENCE
struct lwa_params_v1430_s {
  // member variables
  bool     lwa_ho_without_wt_change_r14_present = false;
  bool     lwa_ul_r14_present                   = false;
  bool     wlan_periodic_meas_r14_present       = false;
  bool     wlan_report_any_wlan_r14_present     = false;
  bool     wlan_supported_data_rate_r14_present = false;
  uint16_t wlan_supported_data_rate_r14         = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LWIP-Parameters-v1430 ::= SEQUENCE
struct lwip_params_v1430_s {
  // member variables
  bool lwip_aggregation_dl_r14_present = false;
  bool lwip_aggregation_ul_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MAC-Parameters-v1430 ::= SEQUENCE
struct mac_params_v1430_s {
  // member variables
  bool short_sps_interv_fdd_r14_present = false;
  bool short_sps_interv_tdd_r14_present = false;
  bool skip_ul_dynamic_r14_present      = false;
  bool skip_ul_sps_r14_present          = false;
  bool multiple_ul_sps_r14_present      = false;
  bool data_inact_mon_r14_present       = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-Parameters-v1430 ::= SEQUENCE
struct mbms_params_v1430_s {
  // member variables
  bool fembms_ded_cell_r14_present                   = false;
  bool fembms_mixed_cell_r14_present                 = false;
  bool subcarrier_spacing_mbms_khz7dot5_r14_present  = false;
  bool subcarrier_spacing_mbms_khz1dot25_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v1430 ::= SEQUENCE
struct meas_params_v1430_s {
  // member variables
  bool ce_meass_r14_present                  = false;
  bool ncsg_r14_present                      = false;
  bool short_meas_gap_r14_present            = false;
  bool per_serving_cell_meas_gap_r14_present = false;
  bool non_uniform_gap_r14_present           = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MobilityParameters-r14 ::= SEQUENCE
struct mob_params_r14_s {
  // member variables
  bool make_before_break_r14_present = false;
  bool rach_less_r14_present         = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Other-Parameters-v1430 ::= SEQUENCE
struct other_params_v1430_s {
  // member variables
  bool bw_pref_ind_r14_present        = false;
  bool rlm_report_support_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCP-Parameters-v1430 ::= SEQUENCE
struct pdcp_params_v1430_s {
  struct supported_ul_only_rohc_profiles_r14_s_ {
    // member variables
    bool profile0x0006_r14 = false;
  };
  struct max_num_rohc_context_sessions_r14_opts {
    enum options {
      cs2,
      cs4,
      cs8,
      cs12,
      cs16,
      cs24,
      cs32,
      cs48,
      cs64,
      cs128,
      cs256,
      cs512,
      cs1024,
      cs16384,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<max_num_rohc_context_sessions_r14_opts> max_num_rohc_context_sessions_r14_e_;

  // member variables
  bool                                   max_num_rohc_context_sessions_r14_present = false;
  supported_ul_only_rohc_profiles_r14_s_ supported_ul_only_rohc_profiles_r14;
  max_num_rohc_context_sessions_r14_e_   max_num_rohc_context_sessions_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLC-Parameters-v1430 ::= SEQUENCE
struct rlc_params_v1430_s {
  // member variables
  bool extended_poll_byte_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-BasedNetwPerfMeasParameters-v1430 ::= SEQUENCE
struct ue_based_netw_perf_meas_params_v1430_s {
  // member variables
  bool location_report_r14_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1440-IEs ::= SEQUENCE
struct ue_eutra_cap_v1440_ies_s {
  // member variables
  bool                     non_crit_ext_present = false;
  lwa_params_v1440_s       lwa_params_v1440;
  mac_params_v1440_s       mac_params_v1440;
  ue_eutra_cap_v1450_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1430 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1430_s {
  // member variables
  bool                     phy_layer_params_v1430_present = false;
  bool                     mmtel_params_r14_present       = false;
  phy_layer_params_v1430_s phy_layer_params_v1430;
  mmtel_params_r14_s       mmtel_params_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-Parameters-v1470 ::= SEQUENCE
struct mbms_params_v1470_s {
  struct mbms_max_bw_r14_c_ {
    struct types_opts {
      enum options { implicit_value, explicit_value, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    mbms_max_bw_r14_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t& explicit_value()
    {
      assert_choice_type("explicitValue", type_.to_string(), "mbms-MaxBW-r14");
      return c;
    }
    const uint8_t& explicit_value() const
    {
      assert_choice_type("explicitValue", type_.to_string(), "mbms-MaxBW-r14");
      return c;
    }
    uint8_t& set_explicit_value()
    {
      set(types::explicit_value);
      return c;
    }

  private:
    types   type_;
    uint8_t c;
  };
  struct mbms_scaling_factor1dot25_r14_opts {
    enum options { n3, n6, n9, n12, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<mbms_scaling_factor1dot25_r14_opts> mbms_scaling_factor1dot25_r14_e_;
  struct mbms_scaling_factor7dot5_r14_opts {
    enum options { n1, n2, n3, n4, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<mbms_scaling_factor7dot5_r14_opts> mbms_scaling_factor7dot5_r14_e_;

  // member variables
  bool                             mbms_scaling_factor1dot25_r14_present = false;
  bool                             mbms_scaling_factor7dot5_r14_present  = false;
  mbms_max_bw_r14_c_               mbms_max_bw_r14;
  mbms_scaling_factor1dot25_r14_e_ mbms_scaling_factor1dot25_r14;
  mbms_scaling_factor7dot5_r14_e_  mbms_scaling_factor7dot5_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Other-Parameters-v1360 ::= SEQUENCE
struct other_params_v1360_s {
  // member variables
  bool in_dev_coex_ind_hardware_sharing_ind_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1430-IEs ::= SEQUENCE
struct ue_eutra_cap_v1430_ies_s {
  struct ue_category_ul_v1430_opts {
    enum options { n16, n17, n18, n19, n20, m2, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ue_category_ul_v1430_opts> ue_category_ul_v1430_e_;

  // member variables
  bool                                   ue_category_dl_v1430_present                 = false;
  bool                                   ue_category_ul_v1430_present                 = false;
  bool                                   ue_category_ul_v1430b_present                = false;
  bool                                   mac_params_v1430_present                     = false;
  bool                                   meas_params_v1430_present                    = false;
  bool                                   pdcp_params_v1430_present                    = false;
  bool                                   rf_params_v1430_present                      = false;
  bool                                   laa_params_v1430_present                     = false;
  bool                                   lwa_params_v1430_present                     = false;
  bool                                   lwip_params_v1430_present                    = false;
  bool                                   mmtel_params_r14_present                     = false;
  bool                                   mob_params_r14_present                       = false;
  bool                                   fdd_add_ue_eutra_capabilities_v1430_present  = false;
  bool                                   tdd_add_ue_eutra_capabilities_v1430_present  = false;
  bool                                   mbms_params_v1430_present                    = false;
  bool                                   sl_params_v1430_present                      = false;
  bool                                   ue_based_netw_perf_meas_params_v1430_present = false;
  bool                                   high_speed_enh_params_r14_present            = false;
  bool                                   non_crit_ext_present                         = false;
  phy_layer_params_v1430_s               phy_layer_params_v1430;
  ue_category_ul_v1430_e_                ue_category_ul_v1430;
  mac_params_v1430_s                     mac_params_v1430;
  meas_params_v1430_s                    meas_params_v1430;
  pdcp_params_v1430_s                    pdcp_params_v1430;
  rlc_params_v1430_s                     rlc_params_v1430;
  rf_params_v1430_s                      rf_params_v1430;
  laa_params_v1430_s                     laa_params_v1430;
  lwa_params_v1430_s                     lwa_params_v1430;
  lwip_params_v1430_s                    lwip_params_v1430;
  other_params_v1430_s                   other_params_v1430;
  mmtel_params_r14_s                     mmtel_params_r14;
  mob_params_r14_s                       mob_params_r14;
  ce_params_v1430_s                      ce_params_v1430;
  ue_eutra_cap_add_xdd_mode_v1430_s      fdd_add_ue_eutra_capabilities_v1430;
  ue_eutra_cap_add_xdd_mode_v1430_s      tdd_add_ue_eutra_capabilities_v1430;
  mbms_params_v1430_s                    mbms_params_v1430;
  sl_params_v1430_s                      sl_params_v1430;
  ue_based_netw_perf_meas_params_v1430_s ue_based_netw_perf_meas_params_v1430;
  high_speed_enh_params_r14_s            high_speed_enh_params_r14;
  ue_eutra_cap_v1440_ies_s               non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CE-Parameters-v1350 ::= SEQUENCE
struct ce_params_v1350_s {
  // member variables
  bool unicast_freq_hop_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1360-IEs ::= SEQUENCE
struct ue_eutra_cap_v1360_ies_s {
  // member variables
  bool                     other_params_v1360_present = false;
  bool                     non_crit_ext_present       = false;
  other_params_v1360_s     other_params_v1360;
  ue_eutra_cap_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1470-IEs ::= SEQUENCE
struct ue_eutra_cap_v1470_ies_s {
  // member variables
  bool                     mbms_params_v1470_present      = false;
  bool                     phy_layer_params_v1470_present = false;
  bool                     rf_params_v1470_present        = false;
  bool                     non_crit_ext_present           = false;
  mbms_params_v1470_s      mbms_params_v1470;
  phy_layer_params_v1470_s phy_layer_params_v1470;
  rf_params_v1470_s        rf_params_v1470;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CE-Parameters-v1380 ::= SEQUENCE
struct ce_params_v1380_s {
  // member variables
  bool tm6_ce_mode_a_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1350-IEs ::= SEQUENCE
struct ue_eutra_cap_v1350_ies_s {
  // member variables
  bool                     ue_category_dl_v1350_present = false;
  bool                     ue_category_ul_v1350_present = false;
  bool                     non_crit_ext_present         = false;
  ce_params_v1350_s        ce_params_v1350;
  ue_eutra_cap_v1360_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v13x0-IEs ::= SEQUENCE
struct ue_eutra_cap_v13x0_ies_s {
  // member variables
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  dyn_octstring            late_non_crit_ext;
  ue_eutra_cap_v1470_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CE-Parameters-v1370 ::= SEQUENCE
struct ce_params_v1370_s {
  // member variables
  bool tm9_ce_mode_a_r13_present = false;
  bool tm9_ce_mode_b_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCPTM-Parameters-r13 ::= SEQUENCE
struct scptm_params_r13_s {
  // member variables
  bool scptm_parallel_reception_r13_present = false;
  bool scptm_scell_r13_present              = false;
  bool scptm_non_serving_cell_r13_present   = false;
  bool scptm_async_dc_r13_present           = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1340-IEs ::= SEQUENCE
struct ue_eutra_cap_v1340_ies_s {
  // member variables
  bool                     ue_category_ul_v1340_present = false;
  bool                     non_crit_ext_present         = false;
  uint8_t                  ue_category_ul_v1340         = 15;
  ue_eutra_cap_v1350_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1390-IEs ::= SEQUENCE
struct ue_eutra_cap_v1390_ies_s {
  // member variables
  bool                     rf_params_v1390_present = false;
  bool                     non_crit_ext_present    = false;
  rf_params_v1390_s        rf_params_v1390;
  ue_eutra_cap_v13x0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1380 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1380_s {
  // member variables
  ce_params_v1380_s ce_params_v1380;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CE-Parameters-v1320 ::= SEQUENCE
struct ce_params_v1320_s {
  // member variables
  bool intra_freq_a3_ce_mode_a_r13_present = false;
  bool intra_freq_a3_ce_mode_b_r13_present = false;
  bool intra_freq_ho_ce_mode_a_r13_present = false;
  bool intra_freq_ho_ce_mode_b_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1310 ::= SEQUENCE
struct phy_layer_params_v1310_s {
  struct supported_blind_decoding_r13_s_ {
    // member variables
    bool    max_num_decoding_r13_present                     = false;
    bool    pdcch_candidate_reductions_r13_present           = false;
    bool    skip_monitoring_dci_format0_minus1_a_r13_present = false;
    uint8_t max_num_decoding_r13                             = 1;
  };

  // member variables
  bool                            aperiodic_csi_report_r13_present       = false;
  bool                            codebook_harq_ack_r13_present          = false;
  bool                            cross_carrier_sched_b5_c_r13_present   = false;
  bool                            fdd_harq_timing_tdd_r13_present        = false;
  bool                            max_num_updated_csi_proc_r13_present   = false;
  bool                            pucch_format4_r13_present              = false;
  bool                            pucch_format5_r13_present              = false;
  bool                            pucch_scell_r13_present                = false;
  bool                            spatial_bundling_harq_ack_r13_present  = false;
  bool                            supported_blind_decoding_r13_present   = false;
  bool                            uci_pusch_ext_r13_present              = false;
  bool                            crs_interf_mitigation_tm10_r13_present = false;
  bool                            pdsch_collision_handling_r13_present   = false;
  fixed_bitstring<2>              aperiodic_csi_report_r13;
  fixed_bitstring<2>              codebook_harq_ack_r13;
  uint8_t                         max_num_updated_csi_proc_r13 = 5;
  supported_blind_decoding_r13_s_ supported_blind_decoding_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1330-IEs ::= SEQUENCE
struct ue_eutra_cap_v1330_ies_s {
  // member variables
  bool                     ue_category_dl_v1330_present   = false;
  bool                     phy_layer_params_v1330_present = false;
  bool                     ue_ce_need_ul_gaps_r13_present = false;
  bool                     non_crit_ext_present           = false;
  uint8_t                  ue_category_dl_v1330           = 18;
  phy_layer_params_v1330_s phy_layer_params_v1330;
  ue_eutra_cap_v1340_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1380-IEs ::= SEQUENCE
struct ue_eutra_cap_v1380_ies_s {
  // member variables
  bool                              rf_params_v1380_present = false;
  bool                              non_crit_ext_present    = false;
  rf_params_v1380_s                 rf_params_v1380;
  ce_params_v1380_s                 ce_params_v1380;
  ue_eutra_cap_add_xdd_mode_v1380_s fdd_add_ue_eutra_capabilities_v1380;
  ue_eutra_cap_add_xdd_mode_v1380_s tdd_add_ue_eutra_capabilities_v1380;
  ue_eutra_cap_v1390_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1320 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1320_s {
  // member variables
  bool                     phy_layer_params_v1320_present = false;
  bool                     scptm_params_r13_present       = false;
  phy_layer_params_v1320_s phy_layer_params_v1320;
  scptm_params_r13_s       scptm_params_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1370 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1370_s {
  // member variables
  bool              ce_params_v1370_present = false;
  ce_params_v1370_s ce_params_v1370;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CE-Parameters-r13 ::= SEQUENCE
struct ce_params_r13_s {
  // member variables
  bool ce_mode_a_r13_present = false;
  bool ce_mode_b_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DC-Parameters-v1310 ::= SEQUENCE
struct dc_params_v1310_s {
  // member variables
  bool pdcp_transfer_split_ul_r13_present = false;
  bool ue_sstd_meas_r13_present           = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LAA-Parameters-r13 ::= SEQUENCE
struct laa_params_r13_s {
  // member variables
  bool cross_carrier_sched_laa_dl_r13_present = false;
  bool csi_rs_drs_rrm_meass_laa_r13_present   = false;
  bool dl_laa_r13_present                     = false;
  bool ending_dw_pts_r13_present              = false;
  bool second_slot_start_position_r13_present = false;
  bool tm9_laa_r13_present                    = false;
  bool tm10_laa_r13_present                   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LWA-Parameters-r13 ::= SEQUENCE
struct lwa_params_r13_s {
  // member variables
  bool               lwa_r13_present              = false;
  bool               lwa_split_bearer_r13_present = false;
  bool               wlan_mac_address_r13_present = false;
  bool               lwa_buffer_size_r13_present  = false;
  fixed_octstring<6> wlan_mac_address_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LWIP-Parameters-r13 ::= SEQUENCE
struct lwip_params_r13_s {
  // member variables
  bool lwip_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MAC-Parameters-v1310 ::= SEQUENCE
struct mac_params_v1310_s {
  // member variables
  bool extended_mac_len_field_r13_present = false;
  bool extended_long_drx_r13_present      = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v1310 ::= SEQUENCE
struct meas_params_v1310_s {
  // member variables
  bool rs_sinr_meas_r13_present                 = false;
  bool white_cell_list_r13_present              = false;
  bool extended_max_obj_id_r13_present          = false;
  bool ul_pdcp_delay_r13_present                = false;
  bool extended_freq_priorities_r13_present     = false;
  bool multi_band_info_report_r13_present       = false;
  bool rssi_and_ch_occupancy_report_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCP-Parameters-v1310 ::= SEQUENCE
struct pdcp_params_v1310_s {
  // member variables
  bool pdcp_sn_ext_minus18bits_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLC-Parameters-v1310 ::= SEQUENCE
struct rlc_params_v1310_s {
  // member variables
  bool extended_rlc_sn_so_field_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-Parameters-v1310 ::= SEQUENCE
struct sl_params_v1310_s {
  // member variables
  bool disc_sys_info_report_r13_present = false;
  bool comm_multiple_tx_r13_present     = false;
  bool disc_inter_freq_tx_r13_present   = false;
  bool disc_periodic_slss_r13_present   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1320-IEs ::= SEQUENCE
struct ue_eutra_cap_v1320_ies_s {
  // member variables
  bool                              ce_params_v1320_present                     = false;
  bool                              phy_layer_params_v1320_present              = false;
  bool                              rf_params_v1320_present                     = false;
  bool                              fdd_add_ue_eutra_capabilities_v1320_present = false;
  bool                              tdd_add_ue_eutra_capabilities_v1320_present = false;
  bool                              non_crit_ext_present                        = false;
  ce_params_v1320_s                 ce_params_v1320;
  phy_layer_params_v1320_s          phy_layer_params_v1320;
  rf_params_v1320_s                 rf_params_v1320;
  ue_eutra_cap_add_xdd_mode_v1320_s fdd_add_ue_eutra_capabilities_v1320;
  ue_eutra_cap_add_xdd_mode_v1320_s tdd_add_ue_eutra_capabilities_v1320;
  ue_eutra_cap_v1330_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1370-IEs ::= SEQUENCE
struct ue_eutra_cap_v1370_ies_s {
  // member variables
  bool                              ce_params_v1370_present                     = false;
  bool                              fdd_add_ue_eutra_capabilities_v1370_present = false;
  bool                              tdd_add_ue_eutra_capabilities_v1370_present = false;
  bool                              non_crit_ext_present                        = false;
  ce_params_v1370_s                 ce_params_v1370;
  ue_eutra_cap_add_xdd_mode_v1370_s fdd_add_ue_eutra_capabilities_v1370;
  ue_eutra_cap_add_xdd_mode_v1370_s tdd_add_ue_eutra_capabilities_v1370;
  ue_eutra_cap_v1380_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1310 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1310_s {
  // member variables
  bool                     phy_layer_params_v1310_present = false;
  phy_layer_params_v1310_s phy_layer_params_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-IW-Parameters-v1310 ::= SEQUENCE
struct wlan_iw_params_v1310_s {
  // member variables
  bool rclwi_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1280 ::= SEQUENCE
struct phy_layer_params_v1280_s {
  // member variables
  bool alternative_tbs_indices_r12_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RF-Parameters-v12b0 ::= SEQUENCE
struct rf_params_v12b0_s {
  // member variables
  bool max_layers_mimo_ind_r12_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v12x0-IEs ::= SEQUENCE
struct ue_eutra_cap_v12x0_ies_s {
  // member variables
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  dyn_octstring            late_non_crit_ext;
  ue_eutra_cap_v1370_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1310-IEs ::= SEQUENCE
struct ue_eutra_cap_v1310_ies_s {
  struct ue_category_dl_v1310_opts {
    enum options { n17, m1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ue_category_dl_v1310_opts> ue_category_dl_v1310_e_;
  struct ue_category_ul_v1310_opts {
    enum options { n14, m1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ue_category_ul_v1310_opts> ue_category_ul_v1310_e_;

  // member variables
  bool                              ue_category_dl_v1310_present                = false;
  bool                              ue_category_ul_v1310_present                = false;
  bool                              mac_params_v1310_present                    = false;
  bool                              phy_layer_params_v1310_present              = false;
  bool                              rf_params_v1310_present                     = false;
  bool                              meas_params_v1310_present                   = false;
  bool                              dc_params_v1310_present                     = false;
  bool                              sl_params_v1310_present                     = false;
  bool                              scptm_params_r13_present                    = false;
  bool                              ce_params_r13_present                       = false;
  bool                              laa_params_r13_present                      = false;
  bool                              lwa_params_r13_present                      = false;
  bool                              fdd_add_ue_eutra_capabilities_v1310_present = false;
  bool                              tdd_add_ue_eutra_capabilities_v1310_present = false;
  bool                              non_crit_ext_present                        = false;
  ue_category_dl_v1310_e_           ue_category_dl_v1310;
  ue_category_ul_v1310_e_           ue_category_ul_v1310;
  pdcp_params_v1310_s               pdcp_params_v1310;
  rlc_params_v1310_s                rlc_params_v1310;
  mac_params_v1310_s                mac_params_v1310;
  phy_layer_params_v1310_s          phy_layer_params_v1310;
  rf_params_v1310_s                 rf_params_v1310;
  meas_params_v1310_s               meas_params_v1310;
  dc_params_v1310_s                 dc_params_v1310;
  sl_params_v1310_s                 sl_params_v1310;
  scptm_params_r13_s                scptm_params_r13;
  ce_params_r13_s                   ce_params_r13;
  irat_params_wlan_r13_s            inter_rat_params_wlan_r13;
  laa_params_r13_s                  laa_params_r13;
  lwa_params_r13_s                  lwa_params_r13;
  wlan_iw_params_v1310_s            wlan_iw_params_v1310;
  lwip_params_r13_s                 lwip_params_r13;
  ue_eutra_cap_add_xdd_mode_v1310_s fdd_add_ue_eutra_capabilities_v1310;
  ue_eutra_cap_add_xdd_mode_v1310_s tdd_add_ue_eutra_capabilities_v1310;
  ue_eutra_cap_v1320_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1280-IEs ::= SEQUENCE
struct ue_eutra_cap_v1280_ies_s {
  // member variables
  bool                     phy_layer_params_v1280_present = false;
  bool                     non_crit_ext_present           = false;
  phy_layer_params_v1280_s phy_layer_params_v1280;
  ue_eutra_cap_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v12b0-IEs ::= SEQUENCE
struct ue_eutra_cap_v12b0_ies_s {
  // member variables
  bool                     rf_params_v12b0_present = false;
  bool                     non_crit_ext_present    = false;
  rf_params_v12b0_s        rf_params_v12b0;
  ue_eutra_cap_v12x0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v1250 ::= SEQUENCE
struct meas_params_v1250_s {
  // member variables
  bool timer_t312_r12_present                    = false;
  bool alternative_time_to_trigger_r12_present   = false;
  bool inc_mon_eutra_r12_present                 = false;
  bool inc_mon_utra_r12_present                  = false;
  bool extended_max_meas_id_r12_present          = false;
  bool extended_rsrq_lower_range_r12_present     = false;
  bool rsrq_on_all_symbols_r12_present           = false;
  bool crs_discovery_signals_meas_r12_present    = false;
  bool csi_rs_discovery_signals_meas_r12_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Other-Parameters-v11d0 ::= SEQUENCE
struct other_params_v11d0_s {
  // member variables
  bool in_dev_coex_ind_ul_ca_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RF-Parameters-v10j0 ::= SEQUENCE
struct rf_params_v10j0_s {
  // member variables
  bool multi_ns_pmax_r10_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v11x0-IEs ::= SEQUENCE
struct ue_eutra_cap_v11x0_ies_s {
  // member variables
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  dyn_octstring            late_non_crit_ext;
  ue_eutra_cap_v12b0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1270-IEs ::= SEQUENCE
struct ue_eutra_cap_v1270_ies_s {
  // member variables
  bool                     rf_params_v1270_present = false;
  bool                     non_crit_ext_present    = false;
  rf_params_v1270_s        rf_params_v1270;
  ue_eutra_cap_v1280_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DC-Parameters-r12 ::= SEQUENCE
struct dc_params_r12_s {
  // member variables
  bool drb_type_split_r12_present = false;
  bool drb_type_scg_r12_present   = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MAC-Parameters-r12 ::= SEQUENCE
struct mac_params_r12_s {
  // member variables
  bool lc_ch_sr_prohibit_timer_r12_present = false;
  bool long_drx_cmd_r12_present            = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-Parameters-v1250 ::= SEQUENCE
struct mbms_params_v1250_s {
  // member variables
  bool mbms_async_dc_r12_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLC-Parameters-r12 ::= SEQUENCE
struct rlc_params_r12_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-BasedNetwPerfMeasParameters-v1250 ::= SEQUENCE
struct ue_based_netw_perf_meas_params_v1250_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v10j0-IEs ::= SEQUENCE
struct ue_eutra_cap_v10j0_ies_s {
  // member variables
  bool              rf_params_v10j0_present = false;
  bool              non_crit_ext_present    = false;
  rf_params_v10j0_s rf_params_v10j0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v11d0-IEs ::= SEQUENCE
struct ue_eutra_cap_v11d0_ies_s {
  // member variables
  bool                     rf_params_v11d0_present    = false;
  bool                     other_params_v11d0_present = false;
  bool                     non_crit_ext_present       = false;
  rf_params_v11d0_s        rf_params_v11d0;
  other_params_v11d0_s     other_params_v11d0;
  ue_eutra_cap_v11x0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1260-IEs ::= SEQUENCE
struct ue_eutra_cap_v1260_ies_s {
  // member variables
  bool                     ue_category_dl_v1260_present = false;
  bool                     non_crit_ext_present         = false;
  uint8_t                  ue_category_dl_v1260         = 15;
  ue_eutra_cap_v1270_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1250 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1250_s {
  // member variables
  bool                     phy_layer_params_v1250_present = false;
  bool                     meas_params_v1250_present      = false;
  phy_layer_params_v1250_s phy_layer_params_v1250;
  meas_params_v1250_s      meas_params_v1250;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WLAN-IW-Parameters-r12 ::= SEQUENCE
struct wlan_iw_params_r12_s {
  // member variables
  bool wlan_iw_ran_rules_r12_present      = false;
  bool wlan_iw_andsf_policies_r12_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBMS-Parameters-r11 ::= SEQUENCE
struct mbms_params_r11_s {
  // member variables
  bool mbms_scell_r11_present            = false;
  bool mbms_non_serving_cell_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v11a0 ::= SEQUENCE
struct meas_params_v11a0_s {
  // member variables
  bool benefits_from_interruption_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RF-Parameters-v10f0 ::= SEQUENCE
struct rf_params_v10f0_s {
  // member variables
  bool                modified_mpr_behavior_r10_present = false;
  fixed_bitstring<32> modified_mpr_behavior_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v10i0-IEs ::= SEQUENCE
struct ue_eutra_cap_v10i0_ies_s {
  // member variables
  bool                     rf_params_v10i0_present   = false;
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  rf_params_v10i0_s        rf_params_v10i0;
  dyn_octstring            late_non_crit_ext;
  ue_eutra_cap_v11d0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1250-IEs ::= SEQUENCE
struct ue_eutra_cap_v1250_ies_s {
  // member variables
  bool                                   phy_layer_params_v1250_present               = false;
  bool                                   rf_params_v1250_present                      = false;
  bool                                   rlc_params_r12_present                       = false;
  bool                                   ue_based_netw_perf_meas_params_v1250_present = false;
  bool                                   ue_category_dl_r12_present                   = false;
  bool                                   ue_category_ul_r12_present                   = false;
  bool                                   wlan_iw_params_r12_present                   = false;
  bool                                   meas_params_v1250_present                    = false;
  bool                                   dc_params_r12_present                        = false;
  bool                                   mbms_params_v1250_present                    = false;
  bool                                   mac_params_r12_present                       = false;
  bool                                   fdd_add_ue_eutra_capabilities_v1250_present  = false;
  bool                                   tdd_add_ue_eutra_capabilities_v1250_present  = false;
  bool                                   sl_params_r12_present                        = false;
  bool                                   non_crit_ext_present                         = false;
  phy_layer_params_v1250_s               phy_layer_params_v1250;
  rf_params_v1250_s                      rf_params_v1250;
  rlc_params_r12_s                       rlc_params_r12;
  ue_based_netw_perf_meas_params_v1250_s ue_based_netw_perf_meas_params_v1250;
  uint8_t                                ue_category_dl_r12 = 0;
  uint8_t                                ue_category_ul_r12 = 0;
  wlan_iw_params_r12_s                   wlan_iw_params_r12;
  meas_params_v1250_s                    meas_params_v1250;
  dc_params_r12_s                        dc_params_r12;
  mbms_params_v1250_s                    mbms_params_v1250;
  mac_params_r12_s                       mac_params_r12;
  ue_eutra_cap_add_xdd_mode_v1250_s      fdd_add_ue_eutra_capabilities_v1250;
  ue_eutra_cap_add_xdd_mode_v1250_s      tdd_add_ue_eutra_capabilities_v1250;
  sl_params_r12_s                        sl_params_r12;
  ue_eutra_cap_v1260_ies_s               non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// OTDOA-PositioningCapabilities-r10 ::= SEQUENCE
struct otdoa_positioning_capabilities_r10_s {
  // member variables
  bool inter_freq_rstd_meas_r10_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v10f0-IEs ::= SEQUENCE
struct ue_eutra_cap_v10f0_ies_s {
  // member variables
  bool                     rf_params_v10f0_present = false;
  bool                     non_crit_ext_present    = false;
  rf_params_v10f0_s        rf_params_v10f0;
  ue_eutra_cap_v10i0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v11a0-IEs ::= SEQUENCE
struct ue_eutra_cap_v11a0_ies_s {
  // member variables
  bool                     ue_category_v11a0_present = false;
  bool                     meas_params_v11a0_present = false;
  bool                     non_crit_ext_present      = false;
  uint8_t                  ue_category_v11a0         = 11;
  meas_params_v11a0_s      meas_params_v11a0;
  ue_eutra_cap_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1180 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1180_s {
  // member variables
  mbms_params_r11_s mbms_params_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersUTRA-v9h0 ::= SEQUENCE
struct irat_params_utra_v9h0_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasParameters-v1130 ::= SEQUENCE
struct meas_params_v1130_s {
  // member variables
  bool rsrq_meas_wideband_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Other-Parameters-r11 ::= SEQUENCE
struct other_params_r11_s {
  // member variables
  bool in_dev_coex_ind_r11_present          = false;
  bool pwr_pref_ind_r11_present             = false;
  bool ue_rx_tx_time_diff_meass_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1130 ::= SEQUENCE
struct phy_layer_params_v1130_s {
  // member variables
  bool crs_interf_handl_r11_present         = false;
  bool e_pdcch_r11_present                  = false;
  bool multi_ack_csi_report_r11_present     = false;
  bool ss_cch_interf_handl_r11_present      = false;
  bool tdd_special_sf_r11_present           = false;
  bool tx_div_pucch1b_ch_select_r11_present = false;
  bool ul_co_mp_r11_present                 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v1170 ::= SEQUENCE
struct phy_layer_params_v1170_s {
  // member variables
  bool               inter_band_tdd_ca_with_different_cfg_r11_present = false;
  fixed_bitstring<2> inter_band_tdd_ca_with_different_cfg_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v10c0-IEs ::= SEQUENCE
struct ue_eutra_cap_v10c0_ies_s {
  // member variables
  bool                                 otdoa_positioning_capabilities_r10_present = false;
  bool                                 non_crit_ext_present                       = false;
  otdoa_positioning_capabilities_r10_s otdoa_positioning_capabilities_r10;
  ue_eutra_cap_v10f0_ies_s             non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1180-IEs ::= SEQUENCE
struct ue_eutra_cap_v1180_ies_s {
  // member variables
  bool                              rf_params_v1180_present                     = false;
  bool                              mbms_params_r11_present                     = false;
  bool                              fdd_add_ue_eutra_capabilities_v1180_present = false;
  bool                              tdd_add_ue_eutra_capabilities_v1180_present = false;
  bool                              non_crit_ext_present                        = false;
  rf_params_v1180_s                 rf_params_v1180;
  mbms_params_r11_s                 mbms_params_r11;
  ue_eutra_cap_add_xdd_mode_v1180_s fdd_add_ue_eutra_capabilities_v1180;
  ue_eutra_cap_add_xdd_mode_v1180_s tdd_add_ue_eutra_capabilities_v1180;
  ue_eutra_cap_v11a0_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersCDMA2000-v1130 ::= SEQUENCE
struct irat_params_cdma2000_v1130_s {
  // member variables
  bool cdma2000_nw_sharing_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCP-Parameters-v1130 ::= SEQUENCE
struct pdcp_params_v1130_s {
  // member variables
  bool pdcp_sn_ext_r11_present                   = false;
  bool support_rohc_context_continue_r11_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1170-IEs ::= SEQUENCE
struct ue_eutra_cap_v1170_ies_s {
  // member variables
  bool                     phy_layer_params_v1170_present = false;
  bool                     ue_category_v1170_present      = false;
  bool                     non_crit_ext_present           = false;
  phy_layer_params_v1170_s phy_layer_params_v1170;
  uint8_t                  ue_category_v1170 = 9;
  ue_eutra_cap_v1180_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v9h0-IEs ::= SEQUENCE
struct ue_eutra_cap_v9h0_ies_s {
  // member variables
  bool                     inter_rat_params_utra_v9h0_present = false;
  bool                     late_non_crit_ext_present          = false;
  bool                     non_crit_ext_present               = false;
  irat_params_utra_v9h0_s  inter_rat_params_utra_v9h0;
  dyn_octstring            late_non_crit_ext;
  ue_eutra_cap_v10c0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1130 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1130_s {
  // member variables
  bool                     ext                            = false;
  bool                     phy_layer_params_v1130_present = false;
  bool                     meas_params_v1130_present      = false;
  bool                     other_params_r11_present       = false;
  phy_layer_params_v1130_s phy_layer_params_v1130;
  meas_params_v1130_s      meas_params_v1130;
  other_params_r11_s       other_params_r11;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersCDMA2000-1XRTT-v1020 ::= SEQUENCE
struct irat_params_cdma2000_minus1_xrtt_v1020_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersUTRA-TDD-v1020 ::= SEQUENCE
struct irat_params_utra_tdd_v1020_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v9d0 ::= SEQUENCE
struct phy_layer_params_v9d0_s {
  // member variables
  bool tm5_fdd_r9_present = false;
  bool tm5_tdd_r9_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1130-IEs ::= SEQUENCE
struct ue_eutra_cap_v1130_ies_s {
  // member variables
  bool                              phy_layer_params_v1130_present              = false;
  bool                              fdd_add_ue_eutra_capabilities_v1130_present = false;
  bool                              tdd_add_ue_eutra_capabilities_v1130_present = false;
  bool                              non_crit_ext_present                        = false;
  pdcp_params_v1130_s               pdcp_params_v1130;
  phy_layer_params_v1130_s          phy_layer_params_v1130;
  rf_params_v1130_s                 rf_params_v1130;
  meas_params_v1130_s               meas_params_v1130;
  irat_params_cdma2000_v1130_s      inter_rat_params_cdma2000_v1130;
  other_params_r11_s                other_params_r11;
  ue_eutra_cap_add_xdd_mode_v1130_s fdd_add_ue_eutra_capabilities_v1130;
  ue_eutra_cap_add_xdd_mode_v1130_s tdd_add_ue_eutra_capabilities_v1130;
  ue_eutra_cap_v1170_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v9e0-IEs ::= SEQUENCE
struct ue_eutra_cap_v9e0_ies_s {
  // member variables
  bool                    rf_params_v9e0_present = false;
  bool                    non_crit_ext_present   = false;
  rf_params_v9e0_s        rf_params_v9e0;
  ue_eutra_cap_v9h0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersCDMA2000-1XRTT-v920 ::= SEQUENCE
struct irat_params_cdma2000_minus1_xrtt_v920_s {
  // member variables
  bool e_csfb_conc_ps_mob1_xrtt_r9_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersUTRA-v920 ::= SEQUENCE
struct irat_params_utra_v920_s {
  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersUTRA-v9c0 ::= SEQUENCE
struct irat_params_utra_v9c0_s {
  // member variables
  bool voice_over_ps_hs_utra_fdd_r9_present             = false;
  bool voice_over_ps_hs_utra_tdd128_r9_present          = false;
  bool srvcc_from_utra_fdd_to_utra_fdd_r9_present       = false;
  bool srvcc_from_utra_fdd_to_geran_r9_present          = false;
  bool srvcc_from_utra_tdd128_to_utra_tdd128_r9_present = false;
  bool srvcc_from_utra_tdd128_to_geran_r9_present       = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighCellSI-AcquisitionParameters-r9 ::= SEQUENCE
struct neigh_cell_si_acquisition_params_r9_s {
  // member variables
  bool intra_freq_si_acquisition_for_ho_r9_present = false;
  bool inter_freq_si_acquisition_for_ho_r9_present = false;
  bool utran_si_acquisition_for_ho_r9_present      = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters ::= SEQUENCE
struct phy_layer_params_s {
  // member variables
  bool ue_tx_ant_sel_supported        = false;
  bool ue_specific_ref_sigs_supported = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1090-IEs ::= SEQUENCE
struct ue_eutra_cap_v1090_ies_s {
  // member variables
  bool                     rf_params_v1090_present = false;
  bool                     non_crit_ext_present    = false;
  rf_params_v1090_s        rf_params_v1090;
  ue_eutra_cap_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v9d0-IEs ::= SEQUENCE
struct ue_eutra_cap_v9d0_ies_s {
  // member variables
  bool                    phy_layer_params_v9d0_present = false;
  bool                    non_crit_ext_present          = false;
  phy_layer_params_v9d0_s phy_layer_params_v9d0;
  ue_eutra_cap_v9e0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-v1060 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_v1060_s {
  // member variables
  bool                                     ext                                     = false;
  bool                                     phy_layer_params_v1060_present          = false;
  bool                                     feature_group_ind_rel10_v1060_present   = false;
  bool                                     inter_rat_params_cdma2000_v1060_present = false;
  bool                                     inter_rat_params_utra_tdd_v1060_present = false;
  phy_layer_params_v1020_s                 phy_layer_params_v1060;
  fixed_bitstring<32>                      feature_group_ind_rel10_v1060;
  irat_params_cdma2000_minus1_xrtt_v1020_s inter_rat_params_cdma2000_v1060;
  irat_params_utra_tdd_v1020_s             inter_rat_params_utra_tdd_v1060;
  // ...
  // group 0
  bool                                           otdoa_positioning_capabilities_r10_present = false;
  copy_ptr<otdoa_positioning_capabilities_r10_s> otdoa_positioning_capabilities_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-BasedNetwPerfMeasParameters-r10 ::= SEQUENCE
struct ue_based_netw_perf_meas_params_r10_s {
  // member variables
  bool logged_meass_idle_r10_present        = false;
  bool standalone_gnss_location_r10_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1060-IEs ::= SEQUENCE
struct ue_eutra_cap_v1060_ies_s {
  // member variables
  bool                              fdd_add_ue_eutra_capabilities_v1060_present = false;
  bool                              tdd_add_ue_eutra_capabilities_v1060_present = false;
  bool                              rf_params_v1060_present                     = false;
  bool                              non_crit_ext_present                        = false;
  ue_eutra_cap_add_xdd_mode_v1060_s fdd_add_ue_eutra_capabilities_v1060;
  ue_eutra_cap_add_xdd_mode_v1060_s tdd_add_ue_eutra_capabilities_v1060;
  rf_params_v1060_s                 rf_params_v1060;
  ue_eutra_cap_v1090_ies_s          non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v9c0-IEs ::= SEQUENCE
struct ue_eutra_cap_v9c0_ies_s {
  // member variables
  bool                    inter_rat_params_utra_v9c0_present = false;
  bool                    non_crit_ext_present               = false;
  irat_params_utra_v9c0_s inter_rat_params_utra_v9c0;
  ue_eutra_cap_v9d0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-CapabilityAddXDD-Mode-r9 ::= SEQUENCE
struct ue_eutra_cap_add_xdd_mode_r9_s {
  // member variables
  bool                                    ext                                         = false;
  bool                                    phy_layer_params_r9_present                 = false;
  bool                                    feature_group_inds_r9_present               = false;
  bool                                    feature_group_ind_rel9_add_r9_present       = false;
  bool                                    inter_rat_params_geran_r9_present           = false;
  bool                                    inter_rat_params_utra_r9_present            = false;
  bool                                    inter_rat_params_cdma2000_r9_present        = false;
  bool                                    neigh_cell_si_acquisition_params_r9_present = false;
  phy_layer_params_s                      phy_layer_params_r9;
  fixed_bitstring<32>                     feature_group_inds_r9;
  fixed_bitstring<32>                     feature_group_ind_rel9_add_r9;
  irat_params_geran_s                     inter_rat_params_geran_r9;
  irat_params_utra_v920_s                 inter_rat_params_utra_r9;
  irat_params_cdma2000_minus1_xrtt_v920_s inter_rat_params_cdma2000_r9;
  neigh_cell_si_acquisition_params_r9_s   neigh_cell_si_acquisition_params_r9;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v1020-IEs ::= SEQUENCE
struct ue_eutra_cap_v1020_ies_s {
  // member variables
  bool                                     ue_category_v1020_present                  = false;
  bool                                     phy_layer_params_v1020_present             = false;
  bool                                     rf_params_v1020_present                    = false;
  bool                                     meas_params_v1020_present                  = false;
  bool                                     feature_group_ind_rel10_r10_present        = false;
  bool                                     inter_rat_params_cdma2000_v1020_present    = false;
  bool                                     ue_based_netw_perf_meas_params_r10_present = false;
  bool                                     inter_rat_params_utra_tdd_v1020_present    = false;
  bool                                     non_crit_ext_present                       = false;
  uint8_t                                  ue_category_v1020                          = 6;
  phy_layer_params_v1020_s                 phy_layer_params_v1020;
  rf_params_v1020_s                        rf_params_v1020;
  meas_params_v1020_s                      meas_params_v1020;
  fixed_bitstring<32>                      feature_group_ind_rel10_r10;
  irat_params_cdma2000_minus1_xrtt_v1020_s inter_rat_params_cdma2000_v1020;
  ue_based_netw_perf_meas_params_r10_s     ue_based_netw_perf_meas_params_r10;
  irat_params_utra_tdd_v1020_s             inter_rat_params_utra_tdd_v1020;
  ue_eutra_cap_v1060_ies_s                 non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v9a0-IEs ::= SEQUENCE
struct ue_eutra_cap_v9a0_ies_s {
  // member variables
  bool                           feature_group_ind_rel9_add_r9_present    = false;
  bool                           fdd_add_ue_eutra_capabilities_r9_present = false;
  bool                           tdd_add_ue_eutra_capabilities_r9_present = false;
  bool                           non_crit_ext_present                     = false;
  fixed_bitstring<32>            feature_group_ind_rel9_add_r9;
  ue_eutra_cap_add_xdd_mode_r9_s fdd_add_ue_eutra_capabilities_r9;
  ue_eutra_cap_add_xdd_mode_r9_s tdd_add_ue_eutra_capabilities_r9;
  ue_eutra_cap_v9c0_ies_s        non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSG-ProximityIndicationParameters-r9 ::= SEQUENCE
struct csg_proximity_ind_params_r9_s {
  // member variables
  bool intra_freq_proximity_ind_r9_present = false;
  bool inter_freq_proximity_ind_r9_present = false;
  bool utran_proximity_ind_r9_present      = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IRAT-ParametersGERAN-v920 ::= SEQUENCE
struct irat_params_geran_v920_s {
  // member variables
  bool dtm_r9_present                 = false;
  bool e_redirection_geran_r9_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PhyLayerParameters-v920 ::= SEQUENCE
struct phy_layer_params_v920_s {
  // member variables
  bool enhanced_dual_layer_fdd_r9_present = false;
  bool enhanced_dual_layer_tdd_r9_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SON-Parameters-r9 ::= SEQUENCE
struct son_params_r9_s {
  // member variables
  bool rach_report_r9_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability-v940-IEs ::= SEQUENCE
struct ue_eutra_cap_v940_ies_s {
  // member variables
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  dyn_octstring            late_non_crit_ext;
  ue_eutra_cap_v1020_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AccessStratumRelease ::= ENUMERATED
struct access_stratum_release_opts {
  enum options { rel8, rel9, rel10, rel11, rel12, rel13, rel14, rel15, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<access_stratum_release_opts, true> access_stratum_release_e;

// UE-EUTRA-Capability-v920-IEs ::= SEQUENCE
struct ue_eutra_cap_v920_ies_s {
  // member variables
  bool                                    inter_rat_params_utra_v920_present     = false;
  bool                                    inter_rat_params_cdma2000_v920_present = false;
  bool                                    dev_type_r9_present                    = false;
  bool                                    non_crit_ext_present                   = false;
  phy_layer_params_v920_s                 phy_layer_params_v920;
  irat_params_geran_v920_s                inter_rat_params_geran_v920;
  irat_params_utra_v920_s                 inter_rat_params_utra_v920;
  irat_params_cdma2000_minus1_xrtt_v920_s inter_rat_params_cdma2000_v920;
  csg_proximity_ind_params_r9_s           csg_proximity_ind_params_r9;
  neigh_cell_si_acquisition_params_r9_s   neigh_cell_si_acquisition_params_r9;
  son_params_r9_s                         son_params_r9;
  ue_eutra_cap_v940_ies_s                 non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-EUTRA-Capability ::= SEQUENCE
struct ue_eutra_cap_s {
  struct inter_rat_params_s_ {
    // member variables
    bool                               utra_fdd_present             = false;
    bool                               utra_tdd128_present          = false;
    bool                               utra_tdd384_present          = false;
    bool                               utra_tdd768_present          = false;
    bool                               geran_present                = false;
    bool                               cdma2000_hrpd_present        = false;
    bool                               cdma2000_minus1x_rtt_present = false;
    irat_params_utra_fdd_s             utra_fdd;
    irat_params_utra_tdd128_s          utra_tdd128;
    irat_params_utra_tdd384_s          utra_tdd384;
    irat_params_utra_tdd768_s          utra_tdd768;
    irat_params_geran_s                geran;
    irat_params_cdma2000_hrpd_s        cdma2000_hrpd;
    irat_params_cdma2000_minus1_xrtt_s cdma2000_minus1x_rtt;
  };

  // member variables
  bool                     feature_group_inds_present = false;
  bool                     non_crit_ext_present       = false;
  access_stratum_release_e access_stratum_release;
  uint8_t                  ue_category = 1;
  pdcp_params_s            pdcp_params;
  phy_layer_params_s       phy_layer_params;
  rf_params_s              rf_params;
  meas_params_s            meas_params;
  fixed_bitstring<32>      feature_group_inds;
  inter_rat_params_s_      inter_rat_params;
  ue_eutra_cap_v920_ies_s  non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-Config-r12-IEs ::= SEQUENCE
struct scg_cfg_r12_ies_s {
  // member variables
  bool                   scg_radio_cfg_r12_present = false;
  bool                   non_crit_ext_present      = false;
  scg_cfg_part_scg_r12_s scg_radio_cfg_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-ConfigNR-r15 ::= SEQUENCE
struct as_cfg_nr_r15_s {
  // member variables
  bool          source_rb_cfg_nr_r15_present       = false;
  bool          source_rb_cfg_sn_nr_r15_present    = false;
  bool          source_other_cfg_sn_nr_r15_present = false;
  dyn_octstring source_rb_cfg_nr_r15;
  dyn_octstring source_rb_cfg_sn_nr_r15;
  dyn_octstring source_other_cfg_sn_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-Config-r12 ::= SEQUENCE
struct scg_cfg_r12_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { scg_cfg_r12, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      scg_cfg_r12_ies_s& scg_cfg_r12()
      {
        assert_choice_type("scg-Config-r12", type_.to_string(), "c1");
        return c;
      }
      const scg_cfg_r12_ies_s& scg_cfg_r12() const
      {
        assert_choice_type("scg-Config-r12", type_.to_string(), "c1");
        return c;
      }
      scg_cfg_r12_ies_s& set_scg_cfg_r12()
      {
        set(types::scg_cfg_r12);
        return c;
      }

    private:
      types             type_;
      scg_cfg_r12_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Config ::= SEQUENCE
struct as_cfg_s {
  // member variables
  bool                     ext = false;
  meas_cfg_s               source_meas_cfg;
  rr_cfg_ded_s             source_rr_cfg;
  security_algorithm_cfg_s source_security_algorithm_cfg;
  fixed_bitstring<16>      source_ue_id;
  mib_s                    source_mib;
  sib_type1_s              source_sib_type1;
  sib_type2_s              source_sib_type2;
  ant_info_common_s        ant_info_common;
  uint16_t                 source_dl_carrier_freq = 0;
  // ...
  // group 0
  bool                     source_sib_type1_ext_present = false;
  dyn_octstring            source_sib_type1_ext;
  copy_ptr<other_cfg_r9_s> source_other_cfg_r9;
  // group 1
  bool                                  source_scell_cfg_list_r10_present = false;
  copy_ptr<scell_to_add_mod_list_r10_l> source_scell_cfg_list_r10;
  // group 2
  bool                    source_cfg_scg_r12_present = false;
  copy_ptr<scg_cfg_r12_s> source_cfg_scg_r12;
  // group 3
  bool                      as_cfg_nr_r15_present = false;
  copy_ptr<as_cfg_nr_r15_s> as_cfg_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Config-v10j0 ::= SEQUENCE
struct as_cfg_v10j0_s {
  // member variables
  bool                 ant_info_ded_pcell_v10i0_present = false;
  ant_info_ded_v10i0_s ant_info_ded_pcell_v10i0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Config-v1250 ::= SEQUENCE
struct as_cfg_v1250_s {
  // member variables
  bool                   source_wlan_offload_cfg_r12_present = false;
  bool                   source_sl_comm_cfg_r12_present      = false;
  bool                   source_sl_disc_cfg_r12_present      = false;
  wlan_offload_cfg_r12_s source_wlan_offload_cfg_r12;
  sl_comm_cfg_r12_s      source_sl_comm_cfg_r12;
  sl_disc_cfg_r12_s      source_sl_disc_cfg_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Config-v1320 ::= SEQUENCE
struct as_cfg_v1320_s {
  // member variables
  bool                            source_scell_cfg_list_r13_present = false;
  bool                            source_rclwi_cfg_r13_present      = false;
  scell_to_add_mod_list_ext_r13_l source_scell_cfg_list_r13;
  rclwi_cfg_r13_c                 source_rclwi_cfg_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Config-v1430 ::= SEQUENCE
struct as_cfg_v1430_s {
  // member variables
  bool                        source_sl_v2x_comm_cfg_r14_present  = false;
  bool                        source_lwa_cfg_r14_present          = false;
  bool                        source_wlan_meas_result_r14_present = false;
  sl_v2x_cfg_ded_r14_s        source_sl_v2x_comm_cfg_r14;
  lwa_cfg_r13_s               source_lwa_cfg_r14;
  meas_result_list_wlan_r13_l source_wlan_meas_result_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Config-v9e0 ::= SEQUENCE
struct as_cfg_v9e0_s {
  // member variables
  uint32_t source_dl_carrier_freq_v9e0 = 65536;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalReestabInfo ::= SEQUENCE
struct add_reestab_info_s {
  // member variables
  fixed_bitstring<28>  cell_id;
  fixed_bitstring<256> key_e_node_b_star;
  fixed_bitstring<16>  short_mac_i;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalReestabInfoList ::= SEQUENCE (SIZE (1..maxReestabInfo)) OF AdditionalReestabInfo
typedef dyn_array<add_reestab_info_s> add_reestab_info_list_l;

// ReestablishmentInfo ::= SEQUENCE
struct reest_info_s {
  // member variables
  bool                    ext                           = false;
  bool                    add_reestab_info_list_present = false;
  uint16_t                source_pci                    = 0;
  fixed_bitstring<16>     target_cell_short_mac_i;
  add_reestab_info_list_l add_reestab_info_list;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Context ::= SEQUENCE
struct as_context_s {
  // member variables
  bool         reest_info_present = false;
  reest_info_s reest_info;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Context-v1130 ::= SEQUENCE
struct as_context_v1130_s {
  // member variables
  bool          ext                           = false;
  bool          idc_ind_r11_present           = false;
  bool          mbms_interest_ind_r11_present = false;
  bool          pwr_pref_ind_r11_present      = false;
  dyn_octstring idc_ind_r11;
  dyn_octstring mbms_interest_ind_r11;
  dyn_octstring pwr_pref_ind_r11;
  // ...
  // group 0
  bool          sidelink_ue_info_r12_present = false;
  dyn_octstring sidelink_ue_info_r12;
  // group 1
  bool          source_context_en_dc_r15_present = false;
  dyn_octstring source_context_en_dc_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AS-Context-v1320 ::= SEQUENCE
struct as_context_v1320_s {
  // member variables
  bool          wlan_conn_status_report_r13_present = false;
  dyn_octstring wlan_conn_status_report_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CSI-RS-TriggeredList-r12 ::= SEQUENCE (SIZE (1..maxCSI-RS-Meas-r12)) OF INTEGER
typedef dyn_array<uint8_t> csi_rs_triggered_list_r12_l;

// CandidateCellInfo-r10 ::= SEQUENCE
struct candidate_cell_info_r10_s {
  // member variables
  bool     ext                     = false;
  bool     rsrp_result_r10_present = false;
  bool     rsrq_result_r10_present = false;
  uint16_t pci_r10                 = 0;
  uint16_t dl_carrier_freq_r10     = 0;
  uint8_t  rsrp_result_r10         = 0;
  uint8_t  rsrq_result_r10         = 0;
  // ...
  // group 0
  bool     dl_carrier_freq_v1090_present = false;
  uint32_t dl_carrier_freq_v1090         = 65536;
  // group 1
  bool   rsrq_result_v1250_present = false;
  int8_t rsrq_result_v1250         = -30;
  // group 2
  bool    rs_sinr_result_r13_present = false;
  uint8_t rs_sinr_result_r13         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CandidateCellInfoList-r10 ::= SEQUENCE (SIZE (1..maxFreq)) OF CandidateCellInfo-r10
typedef dyn_array<candidate_cell_info_r10_s> candidate_cell_info_list_r10_l;

// Cell-ToAddMod-r12 ::= SEQUENCE
struct cell_to_add_mod_r12_s {
  struct cell_identif_r12_s_ {
    // member variables
    uint16_t pci_r12             = 0;
    uint32_t dl_carrier_freq_r12 = 0;
  };
  struct meas_result_cell_to_add_r12_s_ {
    // member variables
    uint8_t rsrp_result_r12 = 0;
    uint8_t rsrq_result_r12 = 0;
  };
  struct meas_result_cell_to_add_v1310_s_ {
    // member variables
    uint8_t rs_sinr_result_r13 = 0;
  };

  // member variables
  bool                           ext                                 = false;
  bool                           cell_identif_r12_present            = false;
  bool                           meas_result_cell_to_add_r12_present = false;
  uint8_t                        s_cell_idx_r12                      = 1;
  cell_identif_r12_s_            cell_identif_r12;
  meas_result_cell_to_add_r12_s_ meas_result_cell_to_add_r12;
  // ...
  // group 0
  bool                                       s_cell_idx_r13_present                = false;
  bool                                       meas_result_cell_to_add_v1310_present = false;
  uint8_t                                    s_cell_idx_r13                        = 1;
  copy_ptr<meas_result_cell_to_add_v1310_s_> meas_result_cell_to_add_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SSB-IndexList-r15 ::= SEQUENCE (SIZE (1..maxRS-Index-r15)) OF INTEGER
typedef dyn_array<uint8_t> ssb_idx_list_r15_l;

struct cells_triggered_list_item_c_ {
  struct pci_utra_c_ {
    struct types_opts {
      enum options { fdd, tdd, nulltype } value;

      std::string to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    pci_utra_c_() = default;
    pci_utra_c_(const pci_utra_c_& other);
    pci_utra_c_& operator=(const pci_utra_c_& other);
    ~pci_utra_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t& fdd()
    {
      assert_choice_type("fdd", type_.to_string(), "physCellIdUTRA");
      return c.get<uint16_t>();
    }
    uint8_t& tdd()
    {
      assert_choice_type("tdd", type_.to_string(), "physCellIdUTRA");
      return c.get<uint8_t>();
    }
    const uint16_t& fdd() const
    {
      assert_choice_type("fdd", type_.to_string(), "physCellIdUTRA");
      return c.get<uint16_t>();
    }
    const uint8_t& tdd() const
    {
      assert_choice_type("tdd", type_.to_string(), "physCellIdUTRA");
      return c.get<uint8_t>();
    }
    uint16_t& set_fdd()
    {
      set(types::fdd);
      return c.get<uint16_t>();
    }
    uint8_t& set_tdd()
    {
      set(types::tdd);
      return c.get<uint8_t>();
    }

  private:
    types              type_;
    choice_buffer_t<8> c;

    void destroy_();
  };
  struct pci_geran_s_ {
    // member variables
    carrier_freq_geran_s carrier_freq;
    pci_geran_s          pci;
  };
  struct pci_nr_r15_s_ {
    // member variables
    bool               rs_idx_list_r15_present = false;
    uint32_t           carrier_freq            = 0;
    uint16_t           pci                     = 0;
    ssb_idx_list_r15_l rs_idx_list_r15;
  };
  struct types_opts {
    enum options { pci_eutra, pci_utra, pci_geran, pci_cdma2000, wlan_ids_r13, pci_nr_r15, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  cells_triggered_list_item_c_() = default;
  cells_triggered_list_item_c_(const cells_triggered_list_item_c_& other);
  cells_triggered_list_item_c_& operator=(const cells_triggered_list_item_c_& other);
  ~cells_triggered_list_item_c_() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& pci_eutra()
  {
    assert_choice_type("physCellIdEUTRA", type_.to_string(), "CellsTriggeredList-item");
    return c.get<uint16_t>();
  }
  pci_utra_c_& pci_utra()
  {
    assert_choice_type("physCellIdUTRA", type_.to_string(), "CellsTriggeredList-item");
    return c.get<pci_utra_c_>();
  }
  pci_geran_s_& pci_geran()
  {
    assert_choice_type("physCellIdGERAN", type_.to_string(), "CellsTriggeredList-item");
    return c.get<pci_geran_s_>();
  }
  uint16_t& pci_cdma2000()
  {
    assert_choice_type("physCellIdCDMA2000", type_.to_string(), "CellsTriggeredList-item");
    return c.get<uint16_t>();
  }
  wlan_ids_r12_s& wlan_ids_r13()
  {
    assert_choice_type("wlan-Identifiers-r13", type_.to_string(), "CellsTriggeredList-item");
    return c.get<wlan_ids_r12_s>();
  }
  pci_nr_r15_s_& pci_nr_r15()
  {
    assert_choice_type("physCellIdNR-r15", type_.to_string(), "CellsTriggeredList-item");
    return c.get<pci_nr_r15_s_>();
  }
  const uint16_t& pci_eutra() const
  {
    assert_choice_type("physCellIdEUTRA", type_.to_string(), "CellsTriggeredList-item");
    return c.get<uint16_t>();
  }
  const pci_utra_c_& pci_utra() const
  {
    assert_choice_type("physCellIdUTRA", type_.to_string(), "CellsTriggeredList-item");
    return c.get<pci_utra_c_>();
  }
  const pci_geran_s_& pci_geran() const
  {
    assert_choice_type("physCellIdGERAN", type_.to_string(), "CellsTriggeredList-item");
    return c.get<pci_geran_s_>();
  }
  const uint16_t& pci_cdma2000() const
  {
    assert_choice_type("physCellIdCDMA2000", type_.to_string(), "CellsTriggeredList-item");
    return c.get<uint16_t>();
  }
  const wlan_ids_r12_s& wlan_ids_r13() const
  {
    assert_choice_type("wlan-Identifiers-r13", type_.to_string(), "CellsTriggeredList-item");
    return c.get<wlan_ids_r12_s>();
  }
  const pci_nr_r15_s_& pci_nr_r15() const
  {
    assert_choice_type("physCellIdNR-r15", type_.to_string(), "CellsTriggeredList-item");
    return c.get<pci_nr_r15_s_>();
  }
  uint16_t& set_pci_eutra()
  {
    set(types::pci_eutra);
    return c.get<uint16_t>();
  }
  pci_utra_c_& set_pci_utra()
  {
    set(types::pci_utra);
    return c.get<pci_utra_c_>();
  }
  pci_geran_s_& set_pci_geran()
  {
    set(types::pci_geran);
    return c.get<pci_geran_s_>();
  }
  uint16_t& set_pci_cdma2000()
  {
    set(types::pci_cdma2000);
    return c.get<uint16_t>();
  }
  wlan_ids_r12_s& set_wlan_ids_r13()
  {
    set(types::wlan_ids_r13);
    return c.get<wlan_ids_r12_s>();
  }
  pci_nr_r15_s_& set_pci_nr_r15()
  {
    set(types::pci_nr_r15);
    return c.get<pci_nr_r15_s_>();
  }

private:
  types                                                                                                           type_;
  choice_buffer_t<MAX4(sizeof(pci_geran_s_), sizeof(pci_nr_r15_s_), sizeof(pci_utra_c_), sizeof(wlan_ids_r12_s))> c;

  void destroy_();
};

// CellsTriggeredList ::= SEQUENCE (SIZE (1..maxCellMeas)) OF CellsTriggeredList-item
typedef dyn_array<cells_triggered_list_item_c_> cells_triggered_list_l;

// DRB-InfoSCG-r12 ::= SEQUENCE
struct drb_info_scg_r12_s {
  struct drb_type_r12_opts {
    enum options { split, scg, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<drb_type_r12_opts> drb_type_r12_e_;

  // member variables
  bool            ext                       = false;
  bool            eps_bearer_id_r12_present = false;
  bool            drb_type_r12_present      = false;
  uint8_t         eps_bearer_id_r12         = 0;
  uint8_t         drb_id_r12                = 1;
  drb_type_r12_e_ drb_type_r12;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-InfoListSCG-r12 ::= SEQUENCE (SIZE (1..maxDRB)) OF DRB-InfoSCG-r12
typedef dyn_array<drb_info_scg_r12_s> drb_info_list_scg_r12_l;

// DRB-InfoListSCG-r15 ::= SEQUENCE (SIZE (1..maxDRB-r15)) OF DRB-InfoSCG-r12
typedef dyn_array<drb_info_scg_r12_s> drb_info_list_scg_r15_l;

// HandoverCommand-r8-IEs ::= SEQUENCE
struct ho_cmd_r8_ies_s {
  // member variables
  bool          non_crit_ext_present = false;
  dyn_octstring ho_cmd_msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverCommand ::= SEQUENCE
struct ho_cmd_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ho_cmd_r8, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ho_cmd_r8_ies_s& ho_cmd_r8()
      {
        assert_choice_type("handoverCommand-r8", type_.to_string(), "c1");
        return c;
      }
      const ho_cmd_r8_ies_s& ho_cmd_r8() const
      {
        assert_choice_type("handoverCommand-r8", type_.to_string(), "c1");
        return c;
      }
      ho_cmd_r8_ies_s& set_ho_cmd_r8()
      {
        set(types::ho_cmd_r8);
        return c;
      }

    private:
      types           type_;
      ho_cmd_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v1430-IEs ::= SEQUENCE
struct ho_prep_info_v1430_ies_s {
  // member variables
  bool           as_cfg_v1430_present              = false;
  bool           make_before_break_req_r14_present = false;
  bool           non_crit_ext_present              = false;
  as_cfg_v1430_s as_cfg_v1430;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v1320-IEs ::= SEQUENCE
struct ho_prep_info_v1320_ies_s {
  // member variables
  bool                     as_cfg_v1320_present     = false;
  bool                     as_context_v1320_present = false;
  bool                     non_crit_ext_present     = false;
  as_cfg_v1320_s           as_cfg_v1320;
  as_context_v1320_s       as_context_v1320;
  ho_prep_info_v1430_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v1250-IEs ::= SEQUENCE
struct ho_prep_info_v1250_ies_s {
  // member variables
  bool                     ue_supported_earfcn_r12_present = false;
  bool                     as_cfg_v1250_present            = false;
  bool                     non_crit_ext_present            = false;
  uint32_t                 ue_supported_earfcn_r12         = 0;
  as_cfg_v1250_s           as_cfg_v1250;
  ho_prep_info_v1320_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v10j0-IEs ::= SEQUENCE
struct ho_prep_info_v10j0_ies_s {
  // member variables
  bool           as_cfg_v10j0_present = false;
  bool           non_crit_ext_present = false;
  as_cfg_v10j0_s as_cfg_v10j0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v1130-IEs ::= SEQUENCE
struct ho_prep_info_v1130_ies_s {
  // member variables
  bool                     as_context_v1130_present = false;
  bool                     non_crit_ext_present     = false;
  as_context_v1130_s       as_context_v1130;
  ho_prep_info_v1250_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v9e0-IEs ::= SEQUENCE
struct ho_prep_info_v9e0_ies_s {
  // member variables
  bool                     as_cfg_v9e0_present  = false;
  bool                     non_crit_ext_present = false;
  as_cfg_v9e0_s            as_cfg_v9e0;
  ho_prep_info_v1130_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v9j0-IEs ::= SEQUENCE
struct ho_prep_info_v9j0_ies_s {
  // member variables
  bool                     late_non_crit_ext_present = false;
  bool                     non_crit_ext_present      = false;
  dyn_octstring            late_non_crit_ext;
  ho_prep_info_v10j0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v9d0-IEs ::= SEQUENCE
struct ho_prep_info_v9d0_ies_s {
  // member variables
  bool                    late_non_crit_ext_present = false;
  bool                    non_crit_ext_present      = false;
  dyn_octstring           late_non_crit_ext;
  ho_prep_info_v9e0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v920-IEs ::= SEQUENCE
struct ho_prep_info_v920_ies_s {
  struct ue_cfg_release_r9_opts {
    enum options { rel9, rel10, rel11, rel12, v10j0, v11e0, v1280, rel13, /*...*/ rel14, rel15, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<ue_cfg_release_r9_opts, true, 2> ue_cfg_release_r9_e_;

  // member variables
  bool                    ue_cfg_release_r9_present = false;
  bool                    non_crit_ext_present      = false;
  ue_cfg_release_r9_e_    ue_cfg_release_r9;
  ho_prep_info_v9d0_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRM-Config ::= SEQUENCE
struct rrm_cfg_s {
  struct ue_inactive_time_opts {
    enum options {
      s1,
      s2,
      s3,
      s5,
      s7,
      s10,
      s15,
      s20,
      s25,
      s30,
      s40,
      s50,
      min1,
      min1s20c,
      min1s40,
      min2,
      min2s30,
      min3,
      min3s30,
      min4,
      min5,
      min6,
      min7,
      min8,
      min9,
      min10,
      min12,
      min14,
      min17,
      min20,
      min24,
      min28,
      min33,
      min38,
      min44,
      min50,
      hr1,
      hr1min30,
      hr2,
      hr2min30,
      hr3,
      hr3min30,
      hr4,
      hr5,
      hr6,
      hr8,
      hr10,
      hr13,
      hr16,
      hr20,
      day1,
      day1hr12,
      day2,
      day2hr12,
      day3,
      day4,
      day5,
      day7,
      day10,
      day14,
      day19,
      day24,
      day30,
      day_more_than30,
      nulltype
    } value;

    std::string to_string() const;
  };
  typedef enumerated<ue_inactive_time_opts> ue_inactive_time_e_;

  // member variables
  bool                ext                      = false;
  bool                ue_inactive_time_present = false;
  ue_inactive_time_e_ ue_inactive_time;
  // ...
  // group 0
  bool                                     candidate_cell_info_list_r10_present = false;
  copy_ptr<candidate_cell_info_list_r10_l> candidate_cell_info_list_r10;
  // group 1
  bool                                          candidate_cell_info_list_nr_r15_present = false;
  copy_ptr<meas_result_serv_freq_list_nr_r15_l> candidate_cell_info_list_nr_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-r8-IEs ::= SEQUENCE
struct ho_prep_info_r8_ies_s {
  // member variables
  bool                        as_cfg_present       = false;
  bool                        rrm_cfg_present      = false;
  bool                        as_context_present   = false;
  bool                        non_crit_ext_present = false;
  ue_cap_rat_container_list_l ue_radio_access_cap_info;
  as_cfg_s                    as_cfg;
  rrm_cfg_s                   rrm_cfg;
  as_context_s                as_context;
  ho_prep_info_v920_ies_s     non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation ::= SEQUENCE
struct ho_prep_info_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { ho_prep_info_r8, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ho_prep_info_r8_ies_s& ho_prep_info_r8()
      {
        assert_choice_type("handoverPreparationInformation-r8", type_.to_string(), "c1");
        return c;
      }
      const ho_prep_info_r8_ies_s& ho_prep_info_r8() const
      {
        assert_choice_type("handoverPreparationInformation-r8", type_.to_string(), "c1");
        return c;
      }
      ho_prep_info_r8_ies_s& set_ho_prep_info_r8()
      {
        set(types::ho_prep_info_r8);
        return c;
      }

    private:
      types                 type_;
      ho_prep_info_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HandoverPreparationInformation-v1530-IEs ::= SEQUENCE
struct ho_prep_info_v1530_ies_s {
  // member variables
  bool                      ran_notif_area_info_r15_present = false;
  bool                      non_crit_ext_present            = false;
  ran_notif_area_info_r15_c ran_notif_area_info_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LogMeasInfoList2-r10 ::= SEQUENCE (SIZE (1..maxLogMeas-r10)) OF LogMeasInfo-r10
typedef dyn_array<log_meas_info_r10_s> log_meas_info_list2_r10_l;

// TDD-ConfigSL-r12 ::= SEQUENCE
struct tdd_cfg_sl_r12_s {
  struct sf_assign_sl_r12_opts {
    enum options { none, sa0, sa1, sa2, sa3, sa4, sa5, sa6, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<sf_assign_sl_r12_opts> sf_assign_sl_r12_e_;

  // member variables
  sf_assign_sl_r12_e_ sf_assign_sl_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MasterInformationBlock-SL ::= SEQUENCE
struct mib_sl_s {
  struct sl_bw_r12_opts {
    enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sl_bw_r12_opts> sl_bw_r12_e_;

  // member variables
  sl_bw_r12_e_        sl_bw_r12;
  tdd_cfg_sl_r12_s    tdd_cfg_sl_r12;
  fixed_bitstring<10> direct_frame_num_r12;
  uint8_t             direct_sf_num_r12 = 0;
  bool                in_coverage_r12   = false;
  fixed_bitstring<19> reserved_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MasterInformationBlock-SL-V2X-r14 ::= SEQUENCE
struct mib_sl_v2x_r14_s {
  struct sl_bw_r14_opts {
    enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sl_bw_r14_opts> sl_bw_r14_e_;

  // member variables
  sl_bw_r14_e_        sl_bw_r14;
  tdd_cfg_sl_r12_s    tdd_cfg_sl_r14;
  fixed_bitstring<10> direct_frame_num_r14;
  uint8_t             direct_sf_num_r14 = 0;
  bool                in_coverage_r14   = false;
  fixed_bitstring<27> reserved_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultRSSI-SCG-r13 ::= SEQUENCE
struct meas_result_rssi_scg_r13_s {
  // member variables
  uint8_t                    serv_cell_id_r13 = 0;
  meas_result_for_rssi_r13_s meas_result_for_rssi_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultListRSSI-SCG-r13 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF MeasResultRSSI-SCG-r13
typedef dyn_array<meas_result_rssi_scg_r13_s> meas_result_list_rssi_scg_r13_l;

// MeasResultServCellSCG-r12 ::= SEQUENCE
struct meas_result_serv_cell_scg_r12_s {
  struct meas_result_scell_r12_s_ {
    // member variables
    uint8_t rsrp_result_scell_r12 = 0;
    uint8_t rsrq_result_scell_r12 = 0;
  };
  struct meas_result_scell_v1310_s_ {
    // member variables
    uint8_t rs_sinr_result_scell_r13 = 0;
  };

  // member variables
  bool                     ext              = false;
  uint8_t                  serv_cell_id_r12 = 0;
  meas_result_scell_r12_s_ meas_result_scell_r12;
  // ...
  // group 0
  bool                                 serv_cell_id_r13_present        = false;
  bool                                 meas_result_scell_v1310_present = false;
  uint8_t                              serv_cell_id_r13                = 0;
  copy_ptr<meas_result_scell_v1310_s_> meas_result_scell_v1310;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasResultServCellListSCG-Ext-r13 ::= SEQUENCE (SIZE (1..maxServCell-r13)) OF MeasResultServCellSCG-r12
typedef dyn_array<meas_result_serv_cell_scg_r12_s> meas_result_serv_cell_list_scg_ext_r13_l;

// MeasResultServCellListSCG-r12 ::= SEQUENCE (SIZE (1..maxServCell-r10)) OF MeasResultServCellSCG-r12
typedef dyn_array<meas_result_serv_cell_scg_r12_s> meas_result_serv_cell_list_scg_r12_l;

// SBCCH-SL-BCH-MessageType ::= MasterInformationBlock-SL
typedef mib_sl_s sbcch_sl_bch_msg_type_s;

// SBCCH-SL-BCH-Message ::= SEQUENCE
struct sbcch_sl_bch_msg_s {
  // member variables
  sbcch_sl_bch_msg_type_s msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SBCCH-SL-BCH-MessageType-V2X-r14 ::= MasterInformationBlock-SL-V2X-r14
typedef mib_sl_v2x_r14_s sbcch_sl_bch_msg_type_v2x_r14_s;

// SBCCH-SL-BCH-Message-V2X-r14 ::= SEQUENCE
struct sbcch_sl_bch_msg_v2x_r14_s {
  // member variables
  sbcch_sl_bch_msg_type_v2x_r14_s msg;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-ConfigInfo-v1530-IEs ::= SEQUENCE
struct scg_cfg_info_v1530_ies_s {
  // member variables
  bool                      drb_to_add_mod_list_scg_r15_present = false;
  bool                      drb_to_release_list_scg_r15_present = false;
  bool                      non_crit_ext_present                = false;
  drb_info_list_scg_r15_l   drb_to_add_mod_list_scg_r15;
  drb_to_release_list_r15_l drb_to_release_list_scg_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-ConfigInfo-v1430-IEs ::= SEQUENCE
struct scg_cfg_info_v1430_ies_s {
  // member variables
  bool                           make_before_break_scg_req_r14_present = false;
  bool                           meas_gap_cfg_per_cc_list_present      = false;
  bool                           non_crit_ext_present                  = false;
  meas_gap_cfg_per_cc_list_r14_c meas_gap_cfg_per_cc_list;
  scg_cfg_info_v1530_ies_s       non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-ConfigInfo-v1330-IEs ::= SEQUENCE
struct scg_cfg_info_v1330_ies_s {
  // member variables
  bool                            meas_result_list_rssi_scg_r13_present = false;
  bool                            non_crit_ext_present                  = false;
  meas_result_list_rssi_scg_r13_l meas_result_list_rssi_scg_r13;
  scg_cfg_info_v1430_ies_s        non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddModListSCG-Ext-r13 ::= SEQUENCE (SIZE (1..maxSCell-r13)) OF Cell-ToAddMod-r12
typedef dyn_array<cell_to_add_mod_r12_s> scell_to_add_mod_list_scg_ext_r13_l;

// SCG-ConfigInfo-v1310-IEs ::= SEQUENCE
struct scg_cfg_info_v1310_ies_s {
  // member variables
  bool                                     meas_result_sstd_r13_present                   = false;
  bool                                     s_cell_to_add_mod_list_mcg_ext_r13_present     = false;
  bool                                     meas_result_serv_cell_list_scg_ext_r13_present = false;
  bool                                     s_cell_to_add_mod_list_scg_ext_r13_present     = false;
  bool                                     s_cell_to_release_list_scg_ext_r13_present     = false;
  bool                                     non_crit_ext_present                           = false;
  meas_result_sstd_r13_s                   meas_result_sstd_r13;
  scell_to_add_mod_list_ext_r13_l          s_cell_to_add_mod_list_mcg_ext_r13;
  meas_result_serv_cell_list_scg_ext_r13_l meas_result_serv_cell_list_scg_ext_r13;
  scell_to_add_mod_list_scg_ext_r13_l      s_cell_to_add_mod_list_scg_ext_r13;
  scell_to_release_list_ext_r13_l          s_cell_to_release_list_scg_ext_r13;
  scg_cfg_info_v1330_ies_s                 non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-ConfigRestrictInfo-r12 ::= SEQUENCE
struct scg_cfg_restrict_info_r12_s {
  // member variables
  uint8_t max_sch_tb_bits_dl_r12 = 1;
  uint8_t max_sch_tb_bits_ul_r12 = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCellToAddModListSCG-r12 ::= SEQUENCE (SIZE (1..maxSCell-r10)) OF Cell-ToAddMod-r12
typedef dyn_array<cell_to_add_mod_r12_s> scell_to_add_mod_list_scg_r12_l;

// SCG-ConfigInfo-r12-IEs ::= SEQUENCE
struct scg_cfg_info_r12_ies_s {
  // member variables
  bool                                 rr_cfg_ded_mcg_r12_present                 = false;
  bool                                 s_cell_to_add_mod_list_mcg_r12_present     = false;
  bool                                 meas_gap_cfg_r12_present                   = false;
  bool                                 pwr_coordination_info_r12_present          = false;
  bool                                 scg_radio_cfg_r12_present                  = false;
  bool                                 eutra_cap_info_r12_present                 = false;
  bool                                 scg_cfg_restrict_info_r12_present          = false;
  bool                                 mbms_interest_ind_r12_present              = false;
  bool                                 meas_result_serv_cell_list_scg_r12_present = false;
  bool                                 drb_to_add_mod_list_scg_r12_present        = false;
  bool                                 drb_to_release_list_scg_r12_present        = false;
  bool                                 s_cell_to_add_mod_list_scg_r12_present     = false;
  bool                                 s_cell_to_release_list_scg_r12_present     = false;
  bool                                 p_max_r12_present                          = false;
  bool                                 non_crit_ext_present                       = false;
  rr_cfg_ded_s                         rr_cfg_ded_mcg_r12;
  scell_to_add_mod_list_r10_l          s_cell_to_add_mod_list_mcg_r12;
  meas_gap_cfg_c                       meas_gap_cfg_r12;
  pwr_coordination_info_r12_s          pwr_coordination_info_r12;
  scg_cfg_part_scg_r12_s               scg_radio_cfg_r12;
  dyn_octstring                        eutra_cap_info_r12;
  scg_cfg_restrict_info_r12_s          scg_cfg_restrict_info_r12;
  dyn_octstring                        mbms_interest_ind_r12;
  meas_result_serv_cell_list_scg_r12_l meas_result_serv_cell_list_scg_r12;
  drb_info_list_scg_r12_l              drb_to_add_mod_list_scg_r12;
  drb_to_release_list_l                drb_to_release_list_scg_r12;
  scell_to_add_mod_list_scg_r12_l      s_cell_to_add_mod_list_scg_r12;
  scell_to_release_list_r10_l          s_cell_to_release_list_scg_r12;
  int8_t                               p_max_r12 = -30;
  scg_cfg_info_v1310_ies_s             non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCG-ConfigInfo-r12 ::= SEQUENCE
struct scg_cfg_info_r12_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options { scg_cfg_info_r12, spare7, spare6, spare5, spare4, spare3, spare2, spare1, nulltype } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      scg_cfg_info_r12_ies_s& scg_cfg_info_r12()
      {
        assert_choice_type("scg-ConfigInfo-r12", type_.to_string(), "c1");
        return c;
      }
      const scg_cfg_info_r12_ies_s& scg_cfg_info_r12() const
      {
        assert_choice_type("scg-ConfigInfo-r12", type_.to_string(), "c1");
        return c;
      }
      scg_cfg_info_r12_ies_s& set_scg_cfg_info_r12()
      {
        set(types::scg_cfg_info_r12);
        return c;
      }

    private:
      types                  type_;
      scg_cfg_info_r12_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PPPP-TxPreconfigIndex-r14 ::= SEQUENCE
struct sl_pppp_tx_precfg_idx_r14_s {
  typedef bounded_array<uint8_t, 16> tx_cfg_idx_list_r14_l_;

  // member variables
  uint8_t                prio_thres_r14         = 1;
  uint8_t                default_tx_cfg_idx_r14 = 0;
  uint8_t                cbr_cfg_idx_r14        = 0;
  tx_cfg_idx_list_r14_l_ tx_cfg_idx_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CBR-PPPP-TxPreconfigList-r14 ::= SEQUENCE (SIZE (1..8)) OF SL-PPPP-TxPreconfigIndex-r14
typedef dyn_array<sl_pppp_tx_precfg_idx_r14_s> sl_cbr_pppp_tx_precfg_list_r14_l;

// SL-PPPP-TxPreconfigIndex-v1530 ::= SEQUENCE
struct sl_pppp_tx_precfg_idx_v1530_s {
  typedef dyn_array<mcs_pssch_range_r15_s> mcs_pssch_range_r15_l_;

  // member variables
  bool                   mcs_pssch_range_r15_present = false;
  mcs_pssch_range_r15_l_ mcs_pssch_range_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-CBR-PPPP-TxPreconfigList-v1530 ::= SEQUENCE (SIZE (1..8)) OF SL-PPPP-TxPreconfigIndex-v1530
typedef dyn_array<sl_pppp_tx_precfg_idx_v1530_s> sl_cbr_pppp_tx_precfg_list_v1530_l;

// SL-CBR-PreconfigTxConfigList-r14 ::= SEQUENCE
struct sl_cbr_precfg_tx_cfg_list_r14_s {
  typedef dyn_array<sl_cbr_levels_cfg_r14_l>   cbr_range_common_cfg_list_r14_l_;
  typedef dyn_array<sl_cbr_pssch_tx_cfg_r14_s> sl_cbr_pssch_tx_cfg_list_r14_l_;

  // member variables
  cbr_range_common_cfg_list_r14_l_ cbr_range_common_cfg_list_r14;
  sl_cbr_pssch_tx_cfg_list_r14_l_  sl_cbr_pssch_tx_cfg_list_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigCommPool-r12 ::= SEQUENCE
struct sl_precfg_comm_pool_r12_s {
  // member variables
  bool                  ext = false;
  sl_cp_len_r12_e       sc_cp_len_r12;
  sl_period_comm_r12_e  sc_period_r12;
  sl_tf_res_cfg_r12_s   sc_tf_res_cfg_r12;
  int8_t                sc_tx_params_r12 = -126;
  sl_cp_len_r12_e       data_cp_len_r12;
  sl_tf_res_cfg_r12_s   data_tf_res_cfg_r12;
  sl_hop_cfg_comm_r12_s data_hop_cfg_r12;
  int8_t                data_tx_params_r12 = -126;
  dyn_bitstring         trpt_subset_r12;
  // ...
  // group 0
  bool                         prio_list_r13_present = false;
  copy_ptr<sl_prio_list_r13_l> prio_list_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigCommPoolList4-r12 ::= SEQUENCE (SIZE (1..maxSL-TxPool-r12)) OF SL-PreconfigCommPool-r12
typedef dyn_array<sl_precfg_comm_pool_r12_s> sl_precfg_comm_pool_list4_r12_l;

// SL-PreconfigCommRxPoolList-r13 ::= SEQUENCE (SIZE (1..maxSL-CommRxPoolPreconf-v1310)) OF SL-PreconfigCommPool-r12
typedef dyn_array<sl_precfg_comm_pool_r12_s> sl_precfg_comm_rx_pool_list_r13_l;

// SL-PreconfigCommTxPoolList-r13 ::= SEQUENCE (SIZE (1..maxSL-CommTxPoolPreconf-v1310)) OF SL-PreconfigCommPool-r12
typedef dyn_array<sl_precfg_comm_pool_r12_s> sl_precfg_comm_tx_pool_list_r13_l;

// SL-PreconfigDiscPool-r13 ::= SEQUENCE
struct sl_precfg_disc_pool_r13_s {
  struct disc_period_r13_opts {
    enum options {
      rf4,
      rf6,
      rf7,
      rf8,
      rf12,
      rf14,
      rf16,
      rf24,
      rf28,
      rf32,
      rf64,
      rf128,
      rf256,
      rf512,
      rf1024,
      spare,
      nulltype
    } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<disc_period_r13_opts> disc_period_r13_e_;
  struct tx_params_r13_s_ {
    struct tx_probability_r13_opts {
      enum options { p25, p50, p75, p100, nulltype } value;
      typedef uint8_t number_type;

      std::string to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<tx_probability_r13_opts> tx_probability_r13_e_;

    // member variables
    int8_t                tx_params_general_r13 = -126;
    tx_probability_r13_e_ tx_probability_r13;
  };

  // member variables
  bool                ext                   = false;
  bool                tx_params_r13_present = false;
  sl_cp_len_r12_e     cp_len_r13;
  disc_period_r13_e_  disc_period_r13;
  uint8_t             num_retx_r13   = 0;
  uint8_t             num_repeat_r13 = 1;
  sl_tf_res_cfg_r12_s tf_res_cfg_r13;
  tx_params_r13_s_    tx_params_r13;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigDiscRxPoolList-r13 ::= SEQUENCE (SIZE (1..maxSL-DiscRxPoolPreconf-r13)) OF SL-PreconfigDiscPool-r13
typedef dyn_array<sl_precfg_disc_pool_r13_s> sl_precfg_disc_rx_pool_list_r13_l;

// SL-PreconfigDiscTxPoolList-r13 ::= SEQUENCE (SIZE (1..maxSL-DiscTxPoolPreconf-r13)) OF SL-PreconfigDiscPool-r13
typedef dyn_array<sl_precfg_disc_pool_r13_s> sl_precfg_disc_tx_pool_list_r13_l;

// SL-PreconfigGeneral-r12 ::= SEQUENCE
struct sl_precfg_general_r12_s {
  struct rohc_profiles_r12_s_ {
    // member variables
    bool profile0x0001_r12 = false;
    bool profile0x0002_r12 = false;
    bool profile0x0004_r12 = false;
    bool profile0x0006_r12 = false;
    bool profile0x0101_r12 = false;
    bool profile0x0102_r12 = false;
    bool profile0x0104_r12 = false;
  };
  struct sl_bw_r12_opts {
    enum options { n6, n15, n25, n50, n75, n100, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sl_bw_r12_opts> sl_bw_r12_e_;

  // member variables
  bool                 ext = false;
  rohc_profiles_r12_s_ rohc_profiles_r12;
  uint32_t             carrier_freq_r12      = 0;
  int8_t               max_tx_pwr_r12        = -30;
  uint8_t              add_spec_emission_r12 = 1;
  sl_bw_r12_e_         sl_bw_r12;
  tdd_cfg_sl_r12_s     tdd_cfg_sl_r12;
  fixed_bitstring<19>  reserved_r12;
  // ...
  // group 0
  bool     add_spec_emission_v1440_present = false;
  uint16_t add_spec_emission_v1440         = 33;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigRelay-r13 ::= SEQUENCE
struct sl_precfg_relay_r13_s {
  // member variables
  resel_info_relay_r13_s resel_info_oo_c_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigSync-r12 ::= SEQUENCE
struct sl_precfg_sync_r12_s {
  struct sync_ref_min_hyst_r12_opts {
    enum options { db0, db3, db6, db9, db12, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sync_ref_min_hyst_r12_opts> sync_ref_min_hyst_r12_e_;
  struct sync_ref_diff_hyst_r12_opts {
    enum options { db0, db3, db6, db9, db12, dbinf, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sync_ref_diff_hyst_r12_opts> sync_ref_diff_hyst_r12_e_;

  // member variables
  bool                      ext = false;
  sl_cp_len_r12_e           sync_cp_len_r12;
  uint8_t                   sync_offset_ind1_r12    = 0;
  uint8_t                   sync_offset_ind2_r12    = 0;
  int8_t                    sync_tx_params_r12      = -126;
  uint8_t                   sync_tx_thresh_oo_c_r12 = 0;
  filt_coef_e               filt_coef_r12;
  sync_ref_min_hyst_r12_e_  sync_ref_min_hyst_r12;
  sync_ref_diff_hyst_r12_e_ sync_ref_diff_hyst_r12;
  // ...
  // group 0
  bool sync_tx_periodic_r13_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-PreconfigCommPool-r14 ::= SEQUENCE
struct sl_v2x_precfg_comm_pool_r14_s {
  struct size_subch_r14_opts {
    enum options {
      n4,
      n5,
      n6,
      n8,
      n9,
      n10,
      n12,
      n15,
      n16,
      n18,
      n20,
      n25,
      n30,
      n48,
      n50,
      n72,
      n75,
      n96,
      n100,
      spare13,
      spare12,
      spare11,
      spare10,
      spare9,
      spare8,
      spare7,
      spare6,
      spare5,
      spare4,
      spare3,
      spare2,
      spare1,
      nulltype
    } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<size_subch_r14_opts> size_subch_r14_e_;
  struct num_subch_r14_opts {
    enum options { n1, n3, n5, n8, n10, n15, n20, spare1, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<num_subch_r14_opts> num_subch_r14_e_;

  // member variables
  bool                                     ext                                    = false;
  bool                                     sl_offset_ind_r14_present              = false;
  bool                                     start_rb_pscch_pool_r14_present        = false;
  bool                                     zone_id_r14_present                    = false;
  bool                                     thresh_s_rssi_cbr_r14_present          = false;
  bool                                     cbr_pssch_tx_cfg_list_r14_present      = false;
  bool                                     res_sel_cfg_p2_x_r14_present           = false;
  bool                                     sync_allowed_r14_present               = false;
  bool                                     restrict_res_reserv_period_r14_present = false;
  sl_offset_ind_r12_c                      sl_offset_ind_r14;
  sf_bitmap_sl_r14_c                       sl_sf_r14;
  bool                                     adjacency_pscch_pssch_r14 = false;
  size_subch_r14_e_                        size_subch_r14;
  num_subch_r14_e_                         num_subch_r14;
  uint8_t                                  start_rb_subch_r14      = 0;
  uint8_t                                  start_rb_pscch_pool_r14 = 0;
  int8_t                                   data_tx_params_r14      = -126;
  uint8_t                                  zone_id_r14             = 0;
  uint8_t                                  thresh_s_rssi_cbr_r14   = 0;
  sl_cbr_pppp_tx_precfg_list_r14_l         cbr_pssch_tx_cfg_list_r14;
  sl_p2_x_res_sel_cfg_r14_s                res_sel_cfg_p2_x_r14;
  sl_sync_allowed_r14_s                    sync_allowed_r14;
  sl_restrict_res_reserv_period_list_r14_l restrict_res_reserv_period_r14;
  // ...
  // group 0
  bool                                         sl_min_t2_value_list_r15_present    = false;
  bool                                         cbr_pssch_tx_cfg_list_v1530_present = false;
  copy_ptr<sl_min_t2_value_list_r15_l>         sl_min_t2_value_list_r15;
  copy_ptr<sl_cbr_pppp_tx_precfg_list_v1530_l> cbr_pssch_tx_cfg_list_v1530;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigV2X-RxPoolList-r14 ::= SEQUENCE (SIZE (1..maxSL-V2X-RxPoolPreconf-r14)) OF SL-V2X-PreconfigCommPool-r14
typedef dyn_array<sl_v2x_precfg_comm_pool_r14_s> sl_precfg_v2x_rx_pool_list_r14_l;

// SL-V2X-SyncOffsetIndicators-r14 ::= SEQUENCE
struct sl_v2x_sync_offset_inds_r14_s {
  // member variables
  bool    sync_offset_ind3_r14_present = false;
  uint8_t sync_offset_ind1_r14         = 0;
  uint8_t sync_offset_ind2_r14         = 0;
  uint8_t sync_offset_ind3_r14         = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigV2X-Sync-r14 ::= SEQUENCE
struct sl_precfg_v2x_sync_r14_s {
  struct sync_ref_min_hyst_r14_opts {
    enum options { db0, db3, db6, db9, db12, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sync_ref_min_hyst_r14_opts> sync_ref_min_hyst_r14_e_;
  struct sync_ref_diff_hyst_r14_opts {
    enum options { db0, db3, db6, db9, db12, dbinf, nulltype } value;
    typedef uint8_t number_type;

    std::string to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<sync_ref_diff_hyst_r14_opts> sync_ref_diff_hyst_r14_e_;

  // member variables
  bool                          ext = false;
  sl_v2x_sync_offset_inds_r14_s sync_offset_inds_r14;
  int8_t                        sync_tx_params_r14      = -126;
  uint8_t                       sync_tx_thresh_oo_c_r14 = 0;
  filt_coef_e                   filt_coef_r14;
  sync_ref_min_hyst_r14_e_      sync_ref_min_hyst_r14;
  sync_ref_diff_hyst_r14_e_     sync_ref_diff_hyst_r14;
  // ...
  // group 0
  bool slss_tx_disabled_r15_present = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-PreconfigV2X-TxPoolList-r14 ::= SEQUENCE (SIZE (1..maxSL-V2X-TxPoolPreconf-r14)) OF SL-V2X-PreconfigCommPool-r14
typedef dyn_array<sl_v2x_precfg_comm_pool_r14_s> sl_precfg_v2x_tx_pool_list_r14_l;

// SL-Preconfiguration-r12 ::= SEQUENCE
struct sl_precfg_r12_s {
  struct precfg_comm_v1310_s_ {
    // member variables
    bool                              comm_tx_pool_list_r13_present = false;
    sl_precfg_comm_rx_pool_list_r13_l comm_rx_pool_list_r13;
    sl_precfg_comm_tx_pool_list_r13_l comm_tx_pool_list_r13;
  };
  struct precfg_disc_r13_s_ {
    // member variables
    bool                              disc_tx_pool_list_r13_present = false;
    sl_precfg_disc_rx_pool_list_r13_l disc_rx_pool_list_r13;
    sl_precfg_disc_tx_pool_list_r13_l disc_tx_pool_list_r13;
  };

  // member variables
  bool                            ext = false;
  sl_precfg_general_r12_s         precfg_general_r12;
  sl_precfg_sync_r12_s            precfg_sync_r12;
  sl_precfg_comm_pool_list4_r12_l precfg_comm_r12;
  // ...
  // group 0
  bool                            precfg_comm_v1310_present = false;
  bool                            precfg_disc_r13_present   = false;
  bool                            precfg_relay_r13_present  = false;
  copy_ptr<precfg_comm_v1310_s_>  precfg_comm_v1310;
  copy_ptr<precfg_disc_r13_s_>    precfg_disc_r13;
  copy_ptr<sl_precfg_relay_r13_s> precfg_relay_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-PreconfigFreqInfo-r14 ::= SEQUENCE
struct sl_v2x_precfg_freq_info_r14_s {
  struct sync_prio_r14_opts {
    enum options { gnss, enb, nulltype } value;

    std::string to_string() const;
  };
  typedef enumerated<sync_prio_r14_opts> sync_prio_r14_e_;

  // member variables
  bool                              ext                                    = false;
  bool                              v2x_comm_precfg_sync_r14_present       = false;
  bool                              v2x_res_sel_cfg_r14_present            = false;
  bool                              zone_cfg_r14_present                   = false;
  bool                              thres_sl_tx_prioritization_r14_present = false;
  bool                              offset_dfn_r14_present                 = false;
  sl_precfg_general_r12_s           v2x_comm_precfg_general_r14;
  sl_precfg_v2x_sync_r14_s          v2x_comm_precfg_sync_r14;
  sl_precfg_v2x_rx_pool_list_r14_l  v2x_comm_rx_pool_list_r14;
  sl_precfg_v2x_tx_pool_list_r14_l  v2x_comm_tx_pool_list_r14;
  sl_precfg_v2x_tx_pool_list_r14_l  p2x_comm_tx_pool_list_r14;
  sl_comm_tx_pool_sensing_cfg_r14_s v2x_res_sel_cfg_r14;
  sl_zone_cfg_r14_s                 zone_cfg_r14;
  sync_prio_r14_e_                  sync_prio_r14;
  uint8_t                           thres_sl_tx_prioritization_r14 = 1;
  uint16_t                          offset_dfn_r14                 = 0;
  // ...
  // group 0
  bool                                     v2x_freq_sel_cfg_list_r15_present = false;
  copy_ptr<sl_v2x_freq_sel_cfg_list_r15_l> v2x_freq_sel_cfg_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SL-V2X-PreconfigFreqList-r14 ::= SEQUENCE (SIZE (1..maxFreqV2X-r14)) OF SL-V2X-PreconfigFreqInfo-r14
typedef dyn_array<sl_v2x_precfg_freq_info_r14_s> sl_v2x_precfg_freq_list_r14_l;

// SL-V2X-TxProfile-r15 ::= ENUMERATED
struct sl_v2x_tx_profile_r15_opts {
  enum options { rel14, rel15, spare6, spare5, spare4, spare3, spare2, spare1, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  std::string to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<sl_v2x_tx_profile_r15_opts, true> sl_v2x_tx_profile_r15_e;

// SL-V2X-TxProfileList-r15 ::= SEQUENCE (SIZE (1..256)) OF SL-V2X-TxProfile-r15
typedef dyn_array<sl_v2x_tx_profile_r15_e> sl_v2x_tx_profile_list_r15_l;

// SL-V2X-Preconfiguration-r14 ::= SEQUENCE
struct sl_v2x_precfg_r14_s {
  // member variables
  bool                                  ext                                  = false;
  bool                                  anchor_carrier_freq_list_r14_present = false;
  bool                                  cbr_precfg_list_r14_present          = false;
  sl_v2x_precfg_freq_list_r14_l         v2x_precfg_freq_list_r14;
  sl_anchor_carrier_freq_list_v2x_r14_l anchor_carrier_freq_list_r14;
  sl_cbr_precfg_tx_cfg_list_r14_s       cbr_precfg_list_r14;
  // ...
  // group 0
  bool                                   v2x_packet_dupl_cfg_r15_present = false;
  bool                                   sync_freq_list_r15_present      = false;
  bool                                   slss_tx_multi_freq_r15_present  = false;
  bool                                   v2x_tx_profile_list_r15_present = false;
  copy_ptr<sl_v2x_packet_dupl_cfg_r15_s> v2x_packet_dupl_cfg_r15;
  copy_ptr<sl_v2x_sync_freq_list_r15_l>  sync_freq_list_r15;
  copy_ptr<sl_v2x_tx_profile_list_r15_l> v2x_tx_profile_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEPagingCoverageInformation-r13-IEs ::= SEQUENCE
struct ue_paging_coverage_info_r13_ies_s {
  // member variables
  bool     mpdcch_num_repeat_r13_present = false;
  bool     non_crit_ext_present          = false;
  uint16_t mpdcch_num_repeat_r13         = 1;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEPagingCoverageInformation ::= SEQUENCE
struct ue_paging_coverage_info_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options {
          ue_paging_coverage_info_r13,
          spare7,
          spare6,
          spare5,
          spare4,
          spare3,
          spare2,
          spare1,
          nulltype
        } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ue_paging_coverage_info_r13_ies_s& ue_paging_coverage_info_r13()
      {
        assert_choice_type("uePagingCoverageInformation-r13", type_.to_string(), "c1");
        return c;
      }
      const ue_paging_coverage_info_r13_ies_s& ue_paging_coverage_info_r13() const
      {
        assert_choice_type("uePagingCoverageInformation-r13", type_.to_string(), "c1");
        return c;
      }
      ue_paging_coverage_info_r13_ies_s& set_ue_paging_coverage_info_r13()
      {
        set(types::ue_paging_coverage_info_r13);
        return c;
      }

    private:
      types                             type_;
      ue_paging_coverage_info_r13_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UERadioAccessCapabilityInformation-r8-IEs ::= SEQUENCE
struct ue_radio_access_cap_info_r8_ies_s {
  // member variables
  bool          non_crit_ext_present = false;
  dyn_octstring ue_radio_access_cap_info;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UERadioAccessCapabilityInformation ::= SEQUENCE
struct ue_radio_access_cap_info_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options {
          ue_radio_access_cap_info_r8,
          spare7,
          spare6,
          spare5,
          spare4,
          spare3,
          spare2,
          spare1,
          nulltype
        } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ue_radio_access_cap_info_r8_ies_s& ue_radio_access_cap_info_r8()
      {
        assert_choice_type("ueRadioAccessCapabilityInformation-r8", type_.to_string(), "c1");
        return c;
      }
      const ue_radio_access_cap_info_r8_ies_s& ue_radio_access_cap_info_r8() const
      {
        assert_choice_type("ueRadioAccessCapabilityInformation-r8", type_.to_string(), "c1");
        return c;
      }
      ue_radio_access_cap_info_r8_ies_s& set_ue_radio_access_cap_info_r8()
      {
        set(types::ue_radio_access_cap_info_r8);
        return c;
      }

    private:
      types                             type_;
      ue_radio_access_cap_info_r8_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UERadioPagingInformation-v1310-IEs ::= SEQUENCE
struct ue_radio_paging_info_v1310_ies_s {
  typedef dyn_array<uint16_t> supported_band_list_eutra_for_paging_r13_l_;

  // member variables
  bool                                        supported_band_list_eutra_for_paging_r13_present = false;
  bool                                        non_crit_ext_present                             = false;
  supported_band_list_eutra_for_paging_r13_l_ supported_band_list_eutra_for_paging_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UERadioPagingInformation-r12-IEs ::= SEQUENCE
struct ue_radio_paging_info_r12_ies_s {
  // member variables
  bool                             non_crit_ext_present = false;
  dyn_octstring                    ue_radio_paging_info_r12;
  ue_radio_paging_info_v1310_ies_s non_crit_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UERadioPagingInformation ::= SEQUENCE
struct ue_radio_paging_info_s {
  struct crit_exts_c_ {
    struct c1_c_ {
      struct types_opts {
        enum options {
          ue_radio_paging_info_r12,
          spare7,
          spare6,
          spare5,
          spare4,
          spare3,
          spare2,
          spare1,
          nulltype
        } value;

        std::string to_string() const;
      };
      typedef enumerated<types_opts> types;

      // choice methods
      c1_c_() = default;
      void        set(types::options e = types::nulltype);
      types       type() const { return type_; }
      SRSASN_CODE pack(bit_ref& bref) const;
      SRSASN_CODE unpack(bit_ref& bref);
      void        to_json(json_writer& j) const;
      // getters
      ue_radio_paging_info_r12_ies_s& ue_radio_paging_info_r12()
      {
        assert_choice_type("ueRadioPagingInformation-r12", type_.to_string(), "c1");
        return c;
      }
      const ue_radio_paging_info_r12_ies_s& ue_radio_paging_info_r12() const
      {
        assert_choice_type("ueRadioPagingInformation-r12", type_.to_string(), "c1");
        return c;
      }
      ue_radio_paging_info_r12_ies_s& set_ue_radio_paging_info_r12()
      {
        set(types::ue_radio_paging_info_r12);
        return c;
      }

    private:
      types                          type_;
      ue_radio_paging_info_r12_ies_s c;
    };
    typedef c1_or_crit_ext_e types;

    // choice methods
    crit_exts_c_() = default;
    crit_exts_c_(const crit_exts_c_& other);
    crit_exts_c_& operator=(const crit_exts_c_& other);
    ~crit_exts_c_() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    c1_c_& c1()
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    const c1_c_& c1() const
    {
      assert_choice_type("c1", type_.to_string(), "criticalExtensions");
      return c.get<c1_c_>();
    }
    c1_c_& set_c1()
    {
      set(types::c1);
      return c.get<c1_c_>();
    }

  private:
    types                          type_;
    choice_buffer_t<sizeof(c1_c_)> c;

    void destroy_();
  };

  // member variables
  crit_exts_c_ crit_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarConnEstFailReport-r11 ::= SEQUENCE
struct var_conn_est_fail_report_r11_s {
  // member variables
  conn_est_fail_report_r11_s conn_est_fail_report_r11;
  plmn_id_s                  plmn_id_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarLogMeasConfig-r10 ::= SEQUENCE
struct var_log_meas_cfg_r10_s {
  // member variables
  bool                 area_cfg_r10_present = false;
  area_cfg_r10_c       area_cfg_r10;
  logging_dur_r10_e    logging_dur_r10;
  logging_interv_r10_e logging_interv_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarLogMeasConfig-r11 ::= SEQUENCE
struct var_log_meas_cfg_r11_s {
  // member variables
  bool                 area_cfg_r10_present   = false;
  bool                 area_cfg_v1130_present = false;
  area_cfg_r10_c       area_cfg_r10;
  area_cfg_v1130_s     area_cfg_v1130;
  logging_dur_r10_e    logging_dur_r10;
  logging_interv_r10_e logging_interv_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarLogMeasConfig-r12 ::= SEQUENCE
struct var_log_meas_cfg_r12_s {
  // member variables
  bool                         area_cfg_r10_present               = false;
  bool                         area_cfg_v1130_present             = false;
  bool                         target_mbsfn_area_list_r12_present = false;
  area_cfg_r10_c               area_cfg_r10;
  area_cfg_v1130_s             area_cfg_v1130;
  logging_dur_r10_e            logging_dur_r10;
  logging_interv_r10_e         logging_interv_r10;
  target_mbsfn_area_list_r12_l target_mbsfn_area_list_r12;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarLogMeasConfig-r15 ::= SEQUENCE
struct var_log_meas_cfg_r15_s {
  // member variables
  bool                         area_cfg_r10_present               = false;
  bool                         area_cfg_v1130_present             = false;
  bool                         target_mbsfn_area_list_r12_present = false;
  bool                         bt_name_list_r15_present           = false;
  bool                         wlan_name_list_r15_present         = false;
  area_cfg_r10_c               area_cfg_r10;
  area_cfg_v1130_s             area_cfg_v1130;
  logging_dur_r10_e            logging_dur_r10;
  logging_interv_r10_e         logging_interv_r10;
  target_mbsfn_area_list_r12_l target_mbsfn_area_list_r12;
  bt_name_list_r15_l           bt_name_list_r15;
  wlan_name_list_r15_l         wlan_name_list_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarLogMeasReport-r10 ::= SEQUENCE
struct var_log_meas_report_r10_s {
  // member variables
  trace_ref_r10_s           trace_ref_r10;
  fixed_octstring<2>        trace_recording_session_ref_r10;
  fixed_octstring<1>        tce_id_r10;
  plmn_id_s                 plmn_id_r10;
  fixed_bitstring<48>       absolute_time_info_r10;
  log_meas_info_list2_r10_l log_meas_info_list_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarLogMeasReport-r11 ::= SEQUENCE
struct var_log_meas_report_r11_s {
  // member variables
  trace_ref_r10_s           trace_ref_r10;
  fixed_octstring<2>        trace_recording_session_ref_r10;
  fixed_octstring<1>        tce_id_r10;
  plmn_id_list3_r11_l       plmn_id_list_r11;
  fixed_bitstring<48>       absolute_time_info_r10;
  log_meas_info_list2_r10_l log_meas_info_list_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarMeasConfig ::= SEQUENCE
struct var_meas_cfg_s {
  struct speed_state_pars_c_ {
    struct setup_s_ {
      // member variables
      mob_state_params_s          mob_state_params;
      speed_state_scale_factors_s time_to_trigger_sf;
    };
    typedef setup_e types;

    // choice methods
    speed_state_pars_c_() = default;
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(bit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    setup_s_& setup()
    {
      assert_choice_type("setup", type_.to_string(), "speedStatePars");
      return c;
    }
    const setup_s_& setup() const
    {
      assert_choice_type("setup", type_.to_string(), "speedStatePars");
      return c;
    }
    setup_s_& set_setup()
    {
      set(types::setup);
      return c;
    }

  private:
    types    type_;
    setup_s_ c;
  };

  // member variables
  bool                                meas_id_list_present            = false;
  bool                                meas_id_list_ext_r12_present    = false;
  bool                                meas_id_list_v1310_present      = false;
  bool                                meas_id_list_ext_v1310_present  = false;
  bool                                meas_obj_list_present           = false;
  bool                                meas_obj_list_ext_r13_present   = false;
  bool                                meas_obj_list_v9i0_present      = false;
  bool                                report_cfg_list_present         = false;
  bool                                quant_cfg_present               = false;
  bool                                meas_scale_factor_r12_present   = false;
  bool                                s_measure_present               = false;
  bool                                speed_state_pars_present        = false;
  bool                                allow_interruptions_r11_present = false;
  meas_id_to_add_mod_list_l           meas_id_list;
  meas_id_to_add_mod_list_ext_r12_l   meas_id_list_ext_r12;
  meas_id_to_add_mod_list_v1310_l     meas_id_list_v1310;
  meas_id_to_add_mod_list_ext_v1310_l meas_id_list_ext_v1310;
  meas_obj_to_add_mod_list_l          meas_obj_list;
  meas_obj_to_add_mod_list_ext_r13_l  meas_obj_list_ext_r13;
  meas_obj_to_add_mod_list_v9e0_l     meas_obj_list_v9i0;
  report_cfg_to_add_mod_list_l        report_cfg_list;
  quant_cfg_s                         quant_cfg;
  meas_scale_factor_r12_e             meas_scale_factor_r12;
  int16_t                             s_measure = -140;
  speed_state_pars_c_                 speed_state_pars;
  bool                                allow_interruptions_r11 = false;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarMeasIdleConfig-r15 ::= SEQUENCE
struct var_meas_idle_cfg_r15_s {
  struct meas_idle_dur_r15_opts {
    enum options { sec10, sec30, sec60, sec120, sec180, sec240, sec300, nulltype } value;
    typedef uint16_t number_type;

    std::string to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<meas_idle_dur_r15_opts> meas_idle_dur_r15_e_;

  // member variables
  bool                     meas_idle_carrier_list_eutra_r15_present = false;
  eutra_carrier_list_r15_l meas_idle_carrier_list_eutra_r15;
  meas_idle_dur_r15_e_     meas_idle_dur_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarMeasIdleReport-r15 ::= SEQUENCE
struct var_meas_idle_report_r15_s {
  // member variables
  meas_result_list_idle_r15_l meas_report_idle_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarMeasReport ::= SEQUENCE
struct var_meas_report_s {
  // member variables
  bool                        meas_id_v1250_present             = false;
  bool                        cells_triggered_list_present      = false;
  bool                        csi_rs_triggered_list_r12_present = false;
  bool                        pools_triggered_list_r14_present  = false;
  uint8_t                     meas_id                           = 1;
  uint8_t                     meas_id_v1250                     = 33;
  cells_triggered_list_l      cells_triggered_list;
  csi_rs_triggered_list_r12_l csi_rs_triggered_list_r12;
  tx_res_pool_meas_list_r14_l pools_triggered_list_r14;
  int64_t                     nof_reports_sent = 0;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarMeasReportList ::= SEQUENCE (SIZE (1..maxMeasId)) OF VarMeasReport
typedef dyn_array<var_meas_report_s> var_meas_report_list_l;

// VarMeasReportList-r12 ::= SEQUENCE (SIZE (1..maxMeasId-r12)) OF VarMeasReport
typedef dyn_array<var_meas_report_s> var_meas_report_list_r12_l;

// VarMobilityHistoryReport-r12 ::= VisitedCellInfoList-r12
typedef visited_cell_info_list_r12_l var_mob_history_report_r12_l;

// VarRLF-Report-r10 ::= SEQUENCE
struct var_rlf_report_r10_s {
  // member variables
  rlf_report_r9_s rlf_report_r10;
  plmn_id_s       plmn_id_r10;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarRLF-Report-r11 ::= SEQUENCE
struct var_rlf_report_r11_s {
  // member variables
  rlf_report_r9_s     rlf_report_r10;
  plmn_id_list3_r11_l plmn_id_list_r11;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarShortINACTIVE-MAC-Input-r15 ::= SEQUENCE
struct var_short_inactive_mac_input_r15_s {
  // member variables
  fixed_bitstring<28> cell_id_r15;
  uint16_t            pci_r15 = 0;
  fixed_bitstring<16> c_rnti_r15;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarShortMAC-Input ::= SEQUENCE
struct var_short_mac_input_s {
  // member variables
  fixed_bitstring<28> cell_id;
  uint16_t            pci = 0;
  fixed_bitstring<16> c_rnti;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarShortMAC-Input-NB-r13 ::= VarShortMAC-Input
typedef var_short_mac_input_s var_short_mac_input_nb_r13_s;

// VarShortResumeMAC-Input-r13 ::= SEQUENCE
struct var_short_resume_mac_input_r13_s {
  // member variables
  fixed_bitstring<28> cell_id_r13;
  uint16_t            pci_r13 = 0;
  fixed_bitstring<16> c_rnti_r13;
  fixed_bitstring<1>  resume_discriminator_r13;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarShortResumeMAC-Input-NB-r13 ::= VarShortResumeMAC-Input-r13
typedef var_short_resume_mac_input_r13_s var_short_resume_mac_input_nb_r13_s;

// VarWLAN-MobilityConfig ::= SEQUENCE
struct var_wlan_mob_cfg_s {
  // member variables
  bool                   wlan_mob_set_r13_present         = false;
  bool                   success_report_requested_present = false;
  bool                   wlan_suspend_cfg_r14_present     = false;
  wlan_id_list_r13_l     wlan_mob_set_r13;
  wlan_suspend_cfg_r14_s wlan_suspend_cfg_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VarWLAN-Status-r13 ::= SEQUENCE
struct var_wlan_status_r13_s {
  // member variables
  bool                status_r14_present = false;
  wlan_status_r13_e   status_r13;
  wlan_status_v1430_e status_r14;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(bit_ref& bref);
  void        to_json(json_writer& j) const;
};

} // namespace rrc
} // namespace asn1

#endif // SRSASN1_RRC_H
